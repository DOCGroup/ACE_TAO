// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:314


#include "IFR_BasicC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */


#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BasicC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_PrimitiveKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5072), 
  ACE_NTOHL (0x696d6974), 
  ACE_NTOHL (0x6976654b), 
  ACE_NTOHL (0x696e643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/PrimitiveKind:1.0
  14,
  ACE_NTOHL (0x5072696d), 
  ACE_NTOHL (0x69746976), 
  ACE_NTOHL (0x654b696e), 
  ACE_NTOHL (0x64000000),  // name = PrimitiveKind
  22, // member count
  8,
  ACE_NTOHL (0x706b5f6e), 
  ACE_NTOHL (0x756c6c00),  // name = pk_null
  8,
  ACE_NTOHL (0x706b5f76), 
  ACE_NTOHL (0x6f696400),  // name = pk_void
  9,
  ACE_NTOHL (0x706b5f73), 
  ACE_NTOHL (0x686f7274), 
  ACE_NTOHL (0x0),  // name = pk_short
  8,
  ACE_NTOHL (0x706b5f6c), 
  ACE_NTOHL (0x6f6e6700),  // name = pk_long
  10,
  ACE_NTOHL (0x706b5f75), 
  ACE_NTOHL (0x73686f72), 
  ACE_NTOHL (0x74000000),  // name = pk_ushort
  9,
  ACE_NTOHL (0x706b5f75), 
  ACE_NTOHL (0x6c6f6e67), 
  ACE_NTOHL (0x0),  // name = pk_ulong
  9,
  ACE_NTOHL (0x706b5f66), 
  ACE_NTOHL (0x6c6f6174), 
  ACE_NTOHL (0x0),  // name = pk_float
  10,
  ACE_NTOHL (0x706b5f64), 
  ACE_NTOHL (0x6f75626c), 
  ACE_NTOHL (0x65000000),  // name = pk_double
  11,
  ACE_NTOHL (0x706b5f62), 
  ACE_NTOHL (0x6f6f6c65), 
  ACE_NTOHL (0x616e0000),  // name = pk_boolean
  8,
  ACE_NTOHL (0x706b5f63), 
  ACE_NTOHL (0x68617200),  // name = pk_char
  9,
  ACE_NTOHL (0x706b5f6f), 
  ACE_NTOHL (0x63746574), 
  ACE_NTOHL (0x0),  // name = pk_octet
  7,
  ACE_NTOHL (0x706b5f61), 
  ACE_NTOHL (0x6e790000),  // name = pk_any
  12,
  ACE_NTOHL (0x706b5f54), 
  ACE_NTOHL (0x79706543), 
  ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
  13,
  ACE_NTOHL (0x706b5f50), 
  ACE_NTOHL (0x72696e63), 
  ACE_NTOHL (0x6970616c), 
  ACE_NTOHL (0x0),  // name = pk_Principal
  10,
  ACE_NTOHL (0x706b5f73), 
  ACE_NTOHL (0x7472696e), 
  ACE_NTOHL (0x67000000),  // name = pk_string
  10,
  ACE_NTOHL (0x706b5f6f), 
  ACE_NTOHL (0x626a7265), 
  ACE_NTOHL (0x66000000),  // name = pk_objref
  12,
  ACE_NTOHL (0x706b5f6c), 
  ACE_NTOHL (0x6f6e676c), 
  ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
  13,
  ACE_NTOHL (0x706b5f75), 
  ACE_NTOHL (0x6c6f6e67), 
  ACE_NTOHL (0x6c6f6e67), 
  ACE_NTOHL (0x0),  // name = pk_ulonglong
  14,
  ACE_NTOHL (0x706b5f6c), 
  ACE_NTOHL (0x6f6e6764), 
  ACE_NTOHL (0x6f75626c), 
  ACE_NTOHL (0x65000000),  // name = pk_longdouble
  9,
  ACE_NTOHL (0x706b5f77), 
  ACE_NTOHL (0x63686172), 
  ACE_NTOHL (0x0),  // name = pk_wchar
  11,
  ACE_NTOHL (0x706b5f77), 
  ACE_NTOHL (0x73747269), 
  ACE_NTOHL (0x6e670000),  // name = pk_wstring
  14,
  ACE_NTOHL (0x706b5f76), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x5f626173), 
  ACE_NTOHL (0x65000000),  // name = pk_value_base
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_PrimitiveKind (
    CORBA::tk_enum,
    sizeof (_oc_CORBA_PrimitiveKind),
    (char *) &_oc_CORBA_PrimitiveKind,
    0,
    sizeof (CORBA::PrimitiveKind)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PrimitiveKind,
    &_tc_TAO_tc_CORBA_PrimitiveKind
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::Repository::_tao_class_id = 0;

CORBA::Repository_ptr
CORBA::tao_Repository_life::tao_duplicate (
    Repository_ptr p
  )
{
  return Repository::_duplicate (p);
}

void
CORBA::tao_Repository_life::tao_release (
    Repository_ptr p
  )
{
  CORBA::release (p);
}

CORBA::Repository_ptr
CORBA::tao_Repository_life::tao_nil (
    void
  )
{
  return Repository::_nil ();
}

CORBA::Boolean
CORBA::tao_Repository_life::tao_marshal (
    Repository_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::Repository_ptr
CORBA::tao_Repository_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Repository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_Repository_cast::tao_upcast (
    void *src
  )
{
  Repository **tmp =
    ACE_static_cast (Repository **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::Repository,
        CORBA::tao_Repository_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::Repository,
        CORBA::tao_Repository_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::Repository, \
        CORBA::tao_Repository_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::Repository, \
        CORBA::tao_Repository_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_lookup_id : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_lookup_id (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Contained_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_lookup_id (const TAO_ClientRequestInfo_CORBA_Repository_lookup_id &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_lookup_id &);
    const char * search_id_;
    
    ::CORBA::Contained_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_lookup_id::TAO_ClientRequestInfo_CORBA_Repository_lookup_id (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_id
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      search_id_ (search_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= search_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_lookup_id::result (::CORBA::Contained_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::TypeCode_ptr tc
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode (const TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode &);
    CORBA::TypeCode_ptr tc_;
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::TypeCode_ptr tc
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      tc_ (tc)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= tc_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_get_primitive : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_get_primitive (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::PrimitiveKind & kind
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::PrimitiveDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_get_primitive (const TAO_ClientRequestInfo_CORBA_Repository_get_primitive &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_get_primitive &);
    const CORBA::PrimitiveKind & kind_;
    
    ::CORBA::PrimitiveDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_get_primitive::TAO_ClientRequestInfo_CORBA_Repository_get_primitive (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::PrimitiveKind & kind
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      kind_ (kind)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->kind_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_get_primitive::result (::CORBA::PrimitiveDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_create_string : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_string (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::StringDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_create_string (const TAO_ClientRequestInfo_CORBA_Repository_create_string &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_string &);
    const CORBA::ULong & bound_;
    
    ::CORBA::StringDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_create_string::TAO_ClientRequestInfo_CORBA_Repository_create_string (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_string::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_string::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_create_string::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_create_string::result (::CORBA::StringDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_create_wstring : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_wstring (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::WstringDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_create_wstring (const TAO_ClientRequestInfo_CORBA_Repository_create_wstring &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_wstring &);
    const CORBA::ULong & bound_;
    
    ::CORBA::WstringDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_create_wstring::TAO_ClientRequestInfo_CORBA_Repository_create_wstring (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_create_wstring::result (::CORBA::WstringDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_create_sequence : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_sequence (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound,
      CORBA::IDLType_ptr element_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::SequenceDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_create_sequence (const TAO_ClientRequestInfo_CORBA_Repository_create_sequence &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_sequence &);
    const CORBA::ULong & bound_;
    CORBA::IDLType_ptr element_type_;
    
    ::CORBA::SequenceDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_create_sequence::TAO_ClientRequestInfo_CORBA_Repository_create_sequence (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound,
      CORBA::IDLType_ptr element_type
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      bound_ (bound),
      element_type_ (element_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->element_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_create_sequence::result (::CORBA::SequenceDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_create_array : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_array (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & length,
      CORBA::IDLType_ptr element_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ArrayDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_create_array (const TAO_ClientRequestInfo_CORBA_Repository_create_array &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_array &);
    const CORBA::ULong & length_;
    CORBA::IDLType_ptr element_type_;
    
    ::CORBA::ArrayDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_create_array::TAO_ClientRequestInfo_CORBA_Repository_create_array (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & length,
      CORBA::IDLType_ptr element_type
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      length_ (length),
      element_type_ (element_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_array::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= length_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->element_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_array::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_create_array::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_create_array::result (::CORBA::ArrayDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Repository_create_fixed : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Repository_create_fixed (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UShort & digits,
      const CORBA::Short & scale
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::FixedDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Repository_create_fixed (const TAO_ClientRequestInfo_CORBA_Repository_create_fixed &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Repository_create_fixed &);
    const CORBA::UShort & digits_;
    const CORBA::Short & scale_;
    
    ::CORBA::FixedDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_Repository_create_fixed::TAO_ClientRequestInfo_CORBA_Repository_create_fixed (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UShort & digits,
      const CORBA::Short & scale
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      digits_ (digits),
      scale_ (scale)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= digits_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= scale_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Repository_create_fixed::result (::CORBA::FixedDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_Repository_Proxy_Impl::_TAO_Repository_Proxy_Impl (void)
{}

CORBA::_TAO_Repository_Remote_Proxy_Impl::_TAO_Repository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::Contained_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::lookup_id (
    CORBA::Object *_collocated_tao_target_,
    const char * search_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Contained_var _tao_retval (CORBA::Contained::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_id",
      9,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_lookup_id _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          search_id
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << search_id)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::Contained_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::get_canonical_typecode (
    CORBA::Object *_collocated_tao_target_,
    CORBA::TypeCode_ptr tc
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_canonical_typecode",
      22,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_get_canonical_typecode _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          tc
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << tc)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::PrimitiveDef_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::get_primitive (
    CORBA::Object *_collocated_tao_target_,
    CORBA::PrimitiveKind kind
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::PrimitiveDef_var _tao_retval (CORBA::PrimitiveDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primitive",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_get_primitive _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          kind
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << kind)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::PrimitiveDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::StringDef_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::create_string (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StringDef_var _tao_retval (CORBA::StringDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_string _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          bound
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << bound)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::StringDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::WstringDef_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::create_wstring (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::WstringDef_var _tao_retval (CORBA::WstringDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring",
      14,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_wstring _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          bound
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << bound)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::WstringDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::SequenceDef_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::create_sequence (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::SequenceDef_var _tao_retval (CORBA::SequenceDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence",
      15,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_sequence _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          bound,
          element_type
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << bound) &&
                  (_tao_out << element_type)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::SequenceDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ArrayDef_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::create_array (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong length,
    CORBA::IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ArrayDef_var _tao_retval (CORBA::ArrayDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array",
      12,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_array _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          length,
          element_type
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << length) &&
                  (_tao_out << element_type)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ArrayDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::FixedDef_ptr CORBA::_TAO_Repository_Remote_Proxy_Impl::create_fixed (
    CORBA::Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Short scale
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::FixedDef_var _tao_retval (
      CORBA::tao_FixedDef_life::tao_nil ()
    );
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed",
      12,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Repository_create_fixed _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          digits,
          scale
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << digits) &&
                  (_tao_out << scale)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::FixedDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_Repository_Proxy_Broker::_TAO_Repository_Proxy_Broker (void)
{
}

CORBA::_TAO_Repository_Proxy_Broker::~_TAO_Repository_Proxy_Broker (void)
{
}

CORBA::_TAO_Repository_Proxy_Broker * (*CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_Repository_Remote_Proxy_Broker *
CORBA::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_Repository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_Repository_Remote_Proxy_Broker::_TAO_Repository_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_Repository_Remote_Proxy_Broker::~_TAO_Repository_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_Repository_Proxy_Impl&
CORBA::_TAO_Repository_Remote_Proxy_Broker::select_proxy (
    ::CORBA::Repository *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::Repository::Repository (int collocated)
{
  this->CORBA_Repository_setup_collocation (collocated);
}

void
CORBA::Repository::CORBA_Repository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Repository_Proxy_Broker_ =
      ::CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Repository_Proxy_Broker_ =
      ::CORBA::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker ();
  
  this->CORBA_Container_setup_collocation (collocated);
}

CORBA::Repository::~Repository (void)
{}

void 
CORBA::Repository::_tao_any_destructor (void *_tao_void_pointer)
{
  Repository *tmp = ACE_static_cast (Repository *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::Repository_ptr
CORBA::Repository::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Repository::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/Repository:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Repository::_nil ());
      
      if (is_a == 0)
        {
          return Repository::_nil ();
        }
    }
  
  return Repository::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::Repository_ptr 
CORBA::Repository::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Repository::_nil ();
    }
  
  Repository_ptr default_proxy = Repository::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::Repository (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          Repository::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::Repository (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Repository::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::Repository (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Repository::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Repository_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Repository::_tao_class_id
                )
            )
        );
}

CORBA::Repository_ptr
CORBA::Repository::_duplicate (Repository_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::Repository::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::Repository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, Repository)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

CORBA::Boolean
CORBA::Repository::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::Contained_ptr CORBA::Repository::lookup_id (
    const char * search_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.lookup_id (
      this,
      search_id
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::Repository::get_canonical_typecode (
    CORBA::TypeCode_ptr tc
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_canonical_typecode (
      this,
      tc
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::PrimitiveDef_ptr CORBA::Repository::get_primitive (
    CORBA::PrimitiveKind kind
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_primitive (
      this,
      kind
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::StringDef_ptr CORBA::Repository::create_string (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_string (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::WstringDef_ptr CORBA::Repository::create_wstring (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_wstring (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::SequenceDef_ptr CORBA::Repository::create_sequence (
    CORBA::ULong bound,
    CORBA::IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_sequence (
      this,
      bound,
      element_type
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ArrayDef_ptr CORBA::Repository::create_array (
    CORBA::ULong length,
    CORBA::IDLType_ptr element_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_array (
      this,
      length,
      element_type
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::FixedDef_ptr CORBA::Repository::create_fixed (
    CORBA::UShort digits,
    CORBA::Short scale
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_Repository_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_Repository_Proxy_Impl &proxy = 
    this->the_TAO_Repository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_fixed (
      this,
      digits,
      scale
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Repository[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5265), 
  ACE_NTOHL (0x706f7369), 
  ACE_NTOHL (0x746f7279), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Repository:1.0
    11,
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72790000),  // name = Repository
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_Repository (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_Repository),
    (char *) &_oc_CORBA_Repository,
    0,
    sizeof (CORBA::Repository)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Repository,
    &_tc_TAO_tc_CORBA_Repository
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ModuleDef::_tao_class_id = 0;

CORBA::ModuleDef_ptr
CORBA::tao_ModuleDef_life::tao_duplicate (
    ModuleDef_ptr p
  )
{
  return ModuleDef::_duplicate (p);
}

void
CORBA::tao_ModuleDef_life::tao_release (
    ModuleDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ModuleDef_ptr
CORBA::tao_ModuleDef_life::tao_nil (
    void
  )
{
  return ModuleDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ModuleDef_life::tao_marshal (
    ModuleDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ModuleDef_ptr
CORBA::tao_ModuleDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ModuleDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ModuleDef_cast::tao_upcast (
    void *src
  )
{
  ModuleDef **tmp =
    ACE_static_cast (ModuleDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ModuleDef,
        CORBA::tao_ModuleDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ModuleDef,
        CORBA::tao_ModuleDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ModuleDef, \
        CORBA::tao_ModuleDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ModuleDef, \
        CORBA::tao_ModuleDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ModuleDef_Proxy_Impl::_TAO_ModuleDef_Proxy_Impl (void)
{}

CORBA::_TAO_ModuleDef_Remote_Proxy_Impl::_TAO_ModuleDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ModuleDef_Proxy_Broker::_TAO_ModuleDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ModuleDef_Proxy_Broker::~_TAO_ModuleDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ModuleDef_Proxy_Broker * (*CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ModuleDef_Remote_Proxy_Broker *
CORBA::_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ModuleDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ModuleDef_Remote_Proxy_Broker::_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ModuleDef_Remote_Proxy_Broker::~_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ModuleDef_Proxy_Impl&
CORBA::_TAO_ModuleDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ModuleDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ModuleDef::ModuleDef (int collocated)
{
  this->CORBA_ModuleDef_setup_collocation (collocated);
}

void
CORBA::ModuleDef::CORBA_ModuleDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ModuleDef_Proxy_Broker_ =
      ::CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ModuleDef_Proxy_Broker_ =
      ::CORBA::_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker ();
  
  this->CORBA_Container_setup_collocation (collocated);
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::ModuleDef::~ModuleDef (void)
{}

void 
CORBA::ModuleDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ModuleDef *tmp = ACE_static_cast (ModuleDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ModuleDef_ptr
CORBA::ModuleDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ModuleDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ModuleDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ModuleDef::_nil ());
      
      if (is_a == 0)
        {
          return ModuleDef::_nil ();
        }
    }
  
  return ModuleDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ModuleDef_ptr 
CORBA::ModuleDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ModuleDef::_nil ();
    }
  
  ModuleDef_ptr default_proxy = ModuleDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ModuleDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ModuleDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ModuleDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ModuleDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ModuleDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ModuleDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ModuleDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ModuleDef::_tao_class_id
                )
            )
        );
}

CORBA::ModuleDef_ptr
CORBA::ModuleDef::_duplicate (ModuleDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ModuleDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ModuleDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ModuleDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

CORBA::Boolean
CORBA::ModuleDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ModuleDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4d6f), 
  ACE_NTOHL (0x64756c65), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ModuleDef:1.0
    10,
  ACE_NTOHL (0x4d6f6475), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x66000000),  // name = ModuleDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ModuleDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ModuleDef),
    (char *) &_oc_CORBA_ModuleDef,
    0,
    sizeof (CORBA::ModuleDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ModuleDef,
    &_tc_TAO_tc_CORBA_ModuleDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ModuleDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4d6f), 
  ACE_NTOHL (0x64756c65), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ModuleDescription:1.0
    18,
  ACE_NTOHL (0x4d6f6475), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = ModuleDescription
  4, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ModuleDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ModuleDescription),
    (char *) &_oc_CORBA_ModuleDescription,
    0,
    sizeof (CORBA::ModuleDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ModuleDescription,
    &_tc_TAO_tc_CORBA_ModuleDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::ModuleDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ModuleDescription *tmp = ACE_static_cast (ModuleDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::ModuleDescription
    >;

template class
  TAO_Out_T<
      CORBA::ModuleDescription,
      CORBA::ModuleDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::ModuleDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::ModuleDescription, \
      CORBA::ModuleDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ConstantDef::_tao_class_id = 0;

CORBA::ConstantDef_ptr
CORBA::tao_ConstantDef_life::tao_duplicate (
    ConstantDef_ptr p
  )
{
  return ConstantDef::_duplicate (p);
}

void
CORBA::tao_ConstantDef_life::tao_release (
    ConstantDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ConstantDef_ptr
CORBA::tao_ConstantDef_life::tao_nil (
    void
  )
{
  return ConstantDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ConstantDef_life::tao_marshal (
    ConstantDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ConstantDef_ptr
CORBA::tao_ConstantDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ConstantDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ConstantDef_cast::tao_upcast (
    void *src
  )
{
  ConstantDef **tmp =
    ACE_static_cast (ConstantDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ConstantDef,
        CORBA::tao_ConstantDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ConstantDef,
        CORBA::tao_ConstantDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ConstantDef, \
        CORBA::tao_ConstantDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ConstantDef, \
        CORBA::tao_ConstantDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ConstantDef_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ConstantDef_type_get (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::TAO_ClientRequestInfo_CORBA_ConstantDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ConstantDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set &);
    CORBA::IDLType_ptr type_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ConstantDef_value_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Any * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ConstantDef_value_get (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_get &);
    
    ::CORBA::Any * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::TAO_ClientRequestInfo_CORBA_ConstantDef_value_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ConstantDef_value_get::result (CORBA::Any * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ConstantDef_value_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Any & value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ConstantDef_value_set (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ConstantDef_value_set &);
    const CORBA::Any & value_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::TAO_ClientRequestInfo_CORBA_ConstantDef_value_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Any & value
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ConstantDef_value_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ConstantDef_Proxy_Impl::_TAO_ConstantDef_Proxy_Impl (void)
{}

CORBA::_TAO_ConstantDef_Remote_Proxy_Impl::_TAO_ConstantDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_ConstantDef_Remote_Proxy_Impl::type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_ConstantDef_Remote_Proxy_Impl::type_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ConstantDef_Remote_Proxy_Impl::type_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << type_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Any * CORBA::_TAO_ConstantDef_Remote_Proxy_Impl::value (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Any_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::Any *tmp;
    ACE_NEW_RETURN (tmp, CORBA::Any, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_value",
      10,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_value_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::Any * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ConstantDef_Remote_Proxy_Impl::value (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::Any & value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_value",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ConstantDef_value_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          value
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << value)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ConstantDef_Proxy_Broker::_TAO_ConstantDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ConstantDef_Proxy_Broker::~_TAO_ConstantDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ConstantDef_Proxy_Broker * (*CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ConstantDef_Remote_Proxy_Broker *
CORBA::_TAO_ConstantDef_Remote_Proxy_Broker::the_TAO_ConstantDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ConstantDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ConstantDef_Remote_Proxy_Broker::_TAO_ConstantDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ConstantDef_Remote_Proxy_Broker::~_TAO_ConstantDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ConstantDef_Proxy_Impl&
CORBA::_TAO_ConstantDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ConstantDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ConstantDef::ConstantDef (int collocated)
{
  this->CORBA_ConstantDef_setup_collocation (collocated);
}

void
CORBA::ConstantDef::CORBA_ConstantDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ConstantDef_Proxy_Broker_ =
      ::CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ConstantDef_Proxy_Broker_ =
      ::CORBA::_TAO_ConstantDef_Remote_Proxy_Broker::the_TAO_ConstantDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::ConstantDef::~ConstantDef (void)
{}

void 
CORBA::ConstantDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ConstantDef *tmp = ACE_static_cast (ConstantDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ConstantDef_ptr
CORBA::ConstantDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ConstantDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ConstantDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ConstantDef::_nil ());
      
      if (is_a == 0)
        {
          return ConstantDef::_nil ();
        }
    }
  
  return ConstantDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ConstantDef_ptr 
CORBA::ConstantDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ConstantDef::_nil ();
    }
  
  ConstantDef_ptr default_proxy = ConstantDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ConstantDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ConstantDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ConstantDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ConstantDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ConstantDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ConstantDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ConstantDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ConstantDef::_tao_class_id
                )
            )
        );
}

CORBA::ConstantDef_ptr
CORBA::ConstantDef::_duplicate (ConstantDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ConstantDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ConstantDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ConstantDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

CORBA::Boolean
CORBA::ConstantDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::ConstantDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ConstantDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ConstantDef_Proxy_Impl &proxy = 
    this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::ConstantDef::type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ConstantDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ConstantDef_Proxy_Impl &proxy = 
    this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ConstantDef::type_def (
    CORBA::IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ConstantDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ConstantDef_Proxy_Impl &proxy = 
    this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.type_def (
      this,
      type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::Any * CORBA::ConstantDef::value (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ConstantDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ConstantDef_Proxy_Impl &proxy = 
    this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.value (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ConstantDef::value (
    const CORBA::Any & value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ConstantDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ConstantDef_Proxy_Impl &proxy = 
    this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.value (
      this,
      value
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ConstantDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e737461), 
  ACE_NTOHL (0x6e744465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ConstantDef:1.0
    12,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x74616e74), 
  ACE_NTOHL (0x44656600),  // name = ConstantDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ConstantDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ConstantDef),
    (char *) &_oc_CORBA_ConstantDef,
    0,
    sizeof (CORBA::ConstantDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConstantDef,
    &_tc_TAO_tc_CORBA_ConstantDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ConstantDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e737461), 
  ACE_NTOHL (0x6e744465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ConstantDescription:1.0
    20,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x74616e74), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
  6, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
    CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ConstantDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ConstantDescription),
    (char *) &_oc_CORBA_ConstantDescription,
    0,
    sizeof (CORBA::ConstantDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConstantDescription,
    &_tc_TAO_tc_CORBA_ConstantDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::ConstantDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ConstantDescription *tmp = ACE_static_cast (ConstantDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::ConstantDescription
    >;

template class
  TAO_Out_T<
      CORBA::ConstantDescription,
      CORBA::ConstantDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::ConstantDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::ConstantDescription, \
      CORBA::ConstantDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::StructDef::_tao_class_id = 0;

CORBA::StructDef_ptr
CORBA::tao_StructDef_life::tao_duplicate (
    StructDef_ptr p
  )
{
  return StructDef::_duplicate (p);
}

void
CORBA::tao_StructDef_life::tao_release (
    StructDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::StructDef_ptr
CORBA::tao_StructDef_life::tao_nil (
    void
  )
{
  return StructDef::_nil ();
}

CORBA::Boolean
CORBA::tao_StructDef_life::tao_marshal (
    StructDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::StructDef_ptr
CORBA::tao_StructDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return StructDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_StructDef_cast::tao_upcast (
    void *src
  )
{
  StructDef **tmp =
    ACE_static_cast (StructDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::StructDef,
        CORBA::tao_StructDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::StructDef,
        CORBA::tao_StructDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::StructDef, \
        CORBA::tao_StructDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::StructDef, \
        CORBA::tao_StructDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_StructDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StructDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::StructMemberSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_StructDef_members_get (const TAO_ClientRequestInfo_CORBA_StructDef_members_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_StructDef_members_get &);
    
    ::CORBA::StructMemberSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_StructDef_members_get::TAO_ClientRequestInfo_CORBA_StructDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StructDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StructDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_StructDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_StructDef_members_get::result (::CORBA::StructMemberSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_StructDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StructDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_StructDef_members_set (const TAO_ClientRequestInfo_CORBA_StructDef_members_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_StructDef_members_set &);
    const CORBA::StructMemberSeq & members_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_StructDef_members_set::TAO_ClientRequestInfo_CORBA_StructDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StructDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StructDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_StructDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_StructDef_Proxy_Impl::_TAO_StructDef_Proxy_Impl (void)
{}

CORBA::_TAO_StructDef_Remote_Proxy_Impl::_TAO_StructDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::StructMemberSeq * CORBA::_TAO_StructDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StructMemberSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::StructMemberSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::StructMemberSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StructDef_members_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::StructMemberSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_StructDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StructDef_members_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << members)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_StructDef_Proxy_Broker::_TAO_StructDef_Proxy_Broker (void)
{
}

CORBA::_TAO_StructDef_Proxy_Broker::~_TAO_StructDef_Proxy_Broker (void)
{
}

CORBA::_TAO_StructDef_Proxy_Broker * (*CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_StructDef_Remote_Proxy_Broker *
CORBA::_TAO_StructDef_Remote_Proxy_Broker::the_TAO_StructDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_StructDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_StructDef_Remote_Proxy_Broker::_TAO_StructDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_StructDef_Remote_Proxy_Broker::~_TAO_StructDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_StructDef_Proxy_Impl&
CORBA::_TAO_StructDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::StructDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::StructDef::StructDef (int collocated)
{
  this->CORBA_StructDef_setup_collocation (collocated);
}

void
CORBA::StructDef::CORBA_StructDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_StructDef_Proxy_Broker_ =
      ::CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_StructDef_Proxy_Broker_ =
      ::CORBA::_TAO_StructDef_Remote_Proxy_Broker::the_TAO_StructDef_Remote_Proxy_Broker ();
  
  this->CORBA_TypedefDef_setup_collocation (collocated);
  this->CORBA_Container_setup_collocation (collocated);
}

CORBA::StructDef::~StructDef (void)
{}

void 
CORBA::StructDef::_tao_any_destructor (void *_tao_void_pointer)
{
  StructDef *tmp = ACE_static_cast (StructDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::StructDef_ptr
CORBA::StructDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return StructDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/StructDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (StructDef::_nil ());
      
      if (is_a == 0)
        {
          return StructDef::_nil ();
        }
    }
  
  return StructDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::StructDef_ptr 
CORBA::StructDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return StructDef::_nil ();
    }
  
  StructDef_ptr default_proxy = StructDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::StructDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          StructDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::StructDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              StructDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::StructDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              StructDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          StructDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &StructDef::_tao_class_id
                )
            )
        );
}

CORBA::StructDef_ptr
CORBA::StructDef::_duplicate (StructDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::StructDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/StructDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::StructDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, StructDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::TypedefDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::TypedefDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

CORBA::Boolean
CORBA::StructDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::StructMemberSeq * CORBA::StructDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_StructDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_StructDef_Proxy_Impl &proxy = 
    this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::StructDef::members (
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_StructDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_StructDef_Proxy_Impl &proxy = 
    this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_StructDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5374), 
  ACE_NTOHL (0x72756374), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StructDef:1.0
    10,
  ACE_NTOHL (0x53747275), 
  ACE_NTOHL (0x63744465), 
  ACE_NTOHL (0x66000000),  // name = StructDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_StructDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_StructDef),
    (char *) &_oc_CORBA_StructDef,
    0,
    sizeof (CORBA::StructDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_StructDef,
    &_tc_TAO_tc_CORBA_StructDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::UnionDef::_tao_class_id = 0;

CORBA::UnionDef_ptr
CORBA::tao_UnionDef_life::tao_duplicate (
    UnionDef_ptr p
  )
{
  return UnionDef::_duplicate (p);
}

void
CORBA::tao_UnionDef_life::tao_release (
    UnionDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::UnionDef_ptr
CORBA::tao_UnionDef_life::tao_nil (
    void
  )
{
  return UnionDef::_nil ();
}

CORBA::Boolean
CORBA::tao_UnionDef_life::tao_marshal (
    UnionDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::UnionDef_ptr
CORBA::tao_UnionDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return UnionDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_UnionDef_cast::tao_upcast (
    void *src
  )
{
  UnionDef **tmp =
    ACE_static_cast (UnionDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::UnionDef,
        CORBA::tao_UnionDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::UnionDef,
        CORBA::tao_UnionDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::UnionDef, \
        CORBA::tao_UnionDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::UnionDef, \
        CORBA::tao_UnionDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr discriminator_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set &);
    CORBA::IDLType_ptr discriminator_type_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr discriminator_type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      discriminator_type_def_ (discriminator_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->discriminator_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_UnionDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::UnionMemberSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_UnionDef_members_get (const TAO_ClientRequestInfo_CORBA_UnionDef_members_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_members_get &);
    
    ::CORBA::UnionMemberSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_UnionDef_members_get::TAO_ClientRequestInfo_CORBA_UnionDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_UnionDef_members_get::result (::CORBA::UnionMemberSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_UnionDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_UnionDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UnionMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_UnionDef_members_set (const TAO_ClientRequestInfo_CORBA_UnionDef_members_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_UnionDef_members_set &);
    const CORBA::UnionMemberSeq & members_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_UnionDef_members_set::TAO_ClientRequestInfo_CORBA_UnionDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UnionMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_UnionDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_UnionDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_UnionDef_Proxy_Impl::_TAO_UnionDef_Proxy_Impl (void)
{}

CORBA::_TAO_UnionDef_Remote_Proxy_Impl::_TAO_UnionDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_UnionDef_Remote_Proxy_Impl::discriminator_type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type",
      23,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type_def",
      27,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr discriminator_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_discriminator_type_def",
      27,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_discriminator_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          discriminator_type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << discriminator_type_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::UnionMemberSeq * CORBA::_TAO_UnionDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UnionMemberSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::UnionMemberSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::UnionMemberSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_members_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::UnionMemberSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_UnionDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::UnionMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_UnionDef_members_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << members)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_UnionDef_Proxy_Broker::_TAO_UnionDef_Proxy_Broker (void)
{
}

CORBA::_TAO_UnionDef_Proxy_Broker::~_TAO_UnionDef_Proxy_Broker (void)
{
}

CORBA::_TAO_UnionDef_Proxy_Broker * (*CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_UnionDef_Remote_Proxy_Broker *
CORBA::_TAO_UnionDef_Remote_Proxy_Broker::the_TAO_UnionDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_UnionDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_UnionDef_Remote_Proxy_Broker::_TAO_UnionDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_UnionDef_Remote_Proxy_Broker::~_TAO_UnionDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_UnionDef_Proxy_Impl&
CORBA::_TAO_UnionDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::UnionDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::UnionDef::UnionDef (int collocated)
{
  this->CORBA_UnionDef_setup_collocation (collocated);
}

void
CORBA::UnionDef::CORBA_UnionDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_UnionDef_Proxy_Broker_ =
      ::CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_UnionDef_Proxy_Broker_ =
      ::CORBA::_TAO_UnionDef_Remote_Proxy_Broker::the_TAO_UnionDef_Remote_Proxy_Broker ();
  
  this->CORBA_TypedefDef_setup_collocation (collocated);
  this->CORBA_Container_setup_collocation (collocated);
}

CORBA::UnionDef::~UnionDef (void)
{}

void 
CORBA::UnionDef::_tao_any_destructor (void *_tao_void_pointer)
{
  UnionDef *tmp = ACE_static_cast (UnionDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::UnionDef_ptr
CORBA::UnionDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return UnionDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/UnionDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (UnionDef::_nil ());
      
      if (is_a == 0)
        {
          return UnionDef::_nil ();
        }
    }
  
  return UnionDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::UnionDef_ptr 
CORBA::UnionDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return UnionDef::_nil ();
    }
  
  UnionDef_ptr default_proxy = UnionDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::UnionDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          UnionDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::UnionDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              UnionDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::UnionDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              UnionDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          UnionDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &UnionDef::_tao_class_id
                )
            )
        );
}

CORBA::UnionDef_ptr
CORBA::UnionDef::_duplicate (UnionDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::UnionDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/UnionDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::UnionDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, UnionDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::TypedefDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::TypedefDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

CORBA::Boolean
CORBA::UnionDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::UnionDef::discriminator_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_UnionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_UnionDef_Proxy_Impl &proxy = 
    this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.discriminator_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::UnionDef::discriminator_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_UnionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_UnionDef_Proxy_Impl &proxy = 
    this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.discriminator_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::UnionDef::discriminator_type_def (
    CORBA::IDLType_ptr discriminator_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_UnionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_UnionDef_Proxy_Impl &proxy = 
    this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.discriminator_type_def (
      this,
      discriminator_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::UnionMemberSeq * CORBA::UnionDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_UnionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_UnionDef_Proxy_Impl &proxy = 
    this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::UnionDef::members (
    const CORBA::UnionMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_UnionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_UnionDef_Proxy_Impl &proxy = 
    this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_UnionDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f556e), 
  ACE_NTOHL (0x696f6e44), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/UnionDef:1.0
    9,
  ACE_NTOHL (0x556e696f), 
  ACE_NTOHL (0x6e446566), 
  ACE_NTOHL (0x0),  // name = UnionDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_UnionDef),
    (char *) &_oc_CORBA_UnionDef,
    0,
    sizeof (CORBA::UnionDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UnionDef,
    &_tc_TAO_tc_CORBA_UnionDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::EnumDef::_tao_class_id = 0;

CORBA::EnumDef_ptr
CORBA::tao_EnumDef_life::tao_duplicate (
    EnumDef_ptr p
  )
{
  return EnumDef::_duplicate (p);
}

void
CORBA::tao_EnumDef_life::tao_release (
    EnumDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::EnumDef_ptr
CORBA::tao_EnumDef_life::tao_nil (
    void
  )
{
  return EnumDef::_nil ();
}

CORBA::Boolean
CORBA::tao_EnumDef_life::tao_marshal (
    EnumDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::EnumDef_ptr
CORBA::tao_EnumDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return EnumDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_EnumDef_cast::tao_upcast (
    void *src
  )
{
  EnumDef **tmp =
    ACE_static_cast (EnumDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::EnumDef,
        CORBA::tao_EnumDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::EnumDef,
        CORBA::tao_EnumDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::EnumDef, \
        CORBA::tao_EnumDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::EnumDef, \
        CORBA::tao_EnumDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_EnumDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_EnumDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::EnumMemberSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_EnumDef_members_get (const TAO_ClientRequestInfo_CORBA_EnumDef_members_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_EnumDef_members_get &);
    
    ::CORBA::EnumMemberSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_EnumDef_members_get::TAO_ClientRequestInfo_CORBA_EnumDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_EnumDef_members_get::result (::CORBA::EnumMemberSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_EnumDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_EnumDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::EnumMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_EnumDef_members_set (const TAO_ClientRequestInfo_CORBA_EnumDef_members_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_EnumDef_members_set &);
    const CORBA::EnumMemberSeq & members_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_EnumDef_members_set::TAO_ClientRequestInfo_CORBA_EnumDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::EnumMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_EnumDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_EnumDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_EnumDef_Proxy_Impl::_TAO_EnumDef_Proxy_Impl (void)
{}

CORBA::_TAO_EnumDef_Remote_Proxy_Impl::_TAO_EnumDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::EnumMemberSeq * CORBA::_TAO_EnumDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::EnumMemberSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::EnumMemberSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::EnumMemberSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_EnumDef_members_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::EnumMemberSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_EnumDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::EnumMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_EnumDef_members_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << members)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_EnumDef_Proxy_Broker::_TAO_EnumDef_Proxy_Broker (void)
{
}

CORBA::_TAO_EnumDef_Proxy_Broker::~_TAO_EnumDef_Proxy_Broker (void)
{
}

CORBA::_TAO_EnumDef_Proxy_Broker * (*CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_EnumDef_Remote_Proxy_Broker *
CORBA::_TAO_EnumDef_Remote_Proxy_Broker::the_TAO_EnumDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_EnumDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_EnumDef_Remote_Proxy_Broker::_TAO_EnumDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_EnumDef_Remote_Proxy_Broker::~_TAO_EnumDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_EnumDef_Proxy_Impl&
CORBA::_TAO_EnumDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::EnumDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::EnumDef::EnumDef (int collocated)
{
  this->CORBA_EnumDef_setup_collocation (collocated);
}

void
CORBA::EnumDef::CORBA_EnumDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EnumDef_Proxy_Broker_ =
      ::CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EnumDef_Proxy_Broker_ =
      ::CORBA::_TAO_EnumDef_Remote_Proxy_Broker::the_TAO_EnumDef_Remote_Proxy_Broker ();
  
  this->CORBA_TypedefDef_setup_collocation (collocated);
}

CORBA::EnumDef::~EnumDef (void)
{}

void 
CORBA::EnumDef::_tao_any_destructor (void *_tao_void_pointer)
{
  EnumDef *tmp = ACE_static_cast (EnumDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::EnumDef_ptr
CORBA::EnumDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return EnumDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/EnumDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (EnumDef::_nil ());
      
      if (is_a == 0)
        {
          return EnumDef::_nil ();
        }
    }
  
  return EnumDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::EnumDef_ptr 
CORBA::EnumDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return EnumDef::_nil ();
    }
  
  EnumDef_ptr default_proxy = EnumDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::EnumDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          EnumDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::EnumDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              EnumDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::EnumDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              EnumDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          EnumDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &EnumDef::_tao_class_id
                )
            )
        );
}

CORBA::EnumDef_ptr
CORBA::EnumDef::_duplicate (EnumDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::EnumDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/EnumDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::EnumDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, EnumDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::TypedefDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::TypedefDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

CORBA::Boolean
CORBA::EnumDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::EnumMemberSeq * CORBA::EnumDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_EnumDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_EnumDef_Proxy_Impl &proxy = 
    this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::EnumDef::members (
    const CORBA::EnumMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_EnumDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_EnumDef_Proxy_Impl &proxy = 
    this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_EnumDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f456e), 
  ACE_NTOHL (0x756d4465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/EnumDef:1.0
    8,
  ACE_NTOHL (0x456e756d), 
  ACE_NTOHL (0x44656600),  // name = EnumDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_EnumDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_EnumDef),
    (char *) &_oc_CORBA_EnumDef,
    0,
    sizeof (CORBA::EnumDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EnumDef,
    &_tc_TAO_tc_CORBA_EnumDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::AliasDef::_tao_class_id = 0;

CORBA::AliasDef_ptr
CORBA::tao_AliasDef_life::tao_duplicate (
    AliasDef_ptr p
  )
{
  return AliasDef::_duplicate (p);
}

void
CORBA::tao_AliasDef_life::tao_release (
    AliasDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::AliasDef_ptr
CORBA::tao_AliasDef_life::tao_nil (
    void
  )
{
  return AliasDef::_nil ();
}

CORBA::Boolean
CORBA::tao_AliasDef_life::tao_marshal (
    AliasDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::AliasDef_ptr
CORBA::tao_AliasDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return AliasDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_AliasDef_cast::tao_upcast (
    void *src
  )
{
  AliasDef **tmp =
    ACE_static_cast (AliasDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::AliasDef,
        CORBA::tao_AliasDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::AliasDef,
        CORBA::tao_AliasDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::AliasDef, \
        CORBA::tao_AliasDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::AliasDef, \
        CORBA::tao_AliasDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set &);
    CORBA::IDLType_ptr original_type_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->original_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_AliasDef_Proxy_Impl::_TAO_AliasDef_Proxy_Impl (void)
{}

CORBA::_TAO_AliasDef_Remote_Proxy_Impl::_TAO_AliasDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AliasDef_original_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          original_type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << original_type_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_AliasDef_Proxy_Broker::_TAO_AliasDef_Proxy_Broker (void)
{
}

CORBA::_TAO_AliasDef_Proxy_Broker::~_TAO_AliasDef_Proxy_Broker (void)
{
}

CORBA::_TAO_AliasDef_Proxy_Broker * (*CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_AliasDef_Remote_Proxy_Broker *
CORBA::_TAO_AliasDef_Remote_Proxy_Broker::the_TAO_AliasDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_AliasDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_AliasDef_Remote_Proxy_Broker::_TAO_AliasDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_AliasDef_Remote_Proxy_Broker::~_TAO_AliasDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_AliasDef_Proxy_Impl&
CORBA::_TAO_AliasDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::AliasDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::AliasDef::AliasDef (int collocated)
{
  this->CORBA_AliasDef_setup_collocation (collocated);
}

void
CORBA::AliasDef::CORBA_AliasDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_AliasDef_Proxy_Broker_ =
      ::CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_AliasDef_Proxy_Broker_ =
      ::CORBA::_TAO_AliasDef_Remote_Proxy_Broker::the_TAO_AliasDef_Remote_Proxy_Broker ();
  
  this->CORBA_TypedefDef_setup_collocation (collocated);
}

CORBA::AliasDef::~AliasDef (void)
{}

void 
CORBA::AliasDef::_tao_any_destructor (void *_tao_void_pointer)
{
  AliasDef *tmp = ACE_static_cast (AliasDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::AliasDef_ptr
CORBA::AliasDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return AliasDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/AliasDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (AliasDef::_nil ());
      
      if (is_a == 0)
        {
          return AliasDef::_nil ();
        }
    }
  
  return AliasDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::AliasDef_ptr 
CORBA::AliasDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return AliasDef::_nil ();
    }
  
  AliasDef_ptr default_proxy = AliasDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::AliasDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          AliasDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::AliasDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              AliasDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::AliasDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              AliasDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          AliasDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &AliasDef::_tao_class_id
                )
            )
        );
}

CORBA::AliasDef_ptr
CORBA::AliasDef::_duplicate (AliasDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::AliasDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/AliasDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::AliasDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, AliasDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::TypedefDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::TypedefDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

CORBA::Boolean
CORBA::AliasDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::AliasDef::original_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AliasDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AliasDef_Proxy_Impl &proxy = 
    this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.original_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::AliasDef::original_type_def (
    CORBA::IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AliasDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AliasDef_Proxy_Impl &proxy = 
    this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.original_type_def (
      this,
      original_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_AliasDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f416c), 
  ACE_NTOHL (0x69617344), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AliasDef:1.0
    9,
  ACE_NTOHL (0x416c6961), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x0),  // name = AliasDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_AliasDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_AliasDef),
    (char *) &_oc_CORBA_AliasDef,
    0,
    sizeof (CORBA::AliasDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AliasDef,
    &_tc_TAO_tc_CORBA_AliasDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::NativeDef::_tao_class_id = 0;

CORBA::NativeDef_ptr
CORBA::tao_NativeDef_life::tao_duplicate (
    NativeDef_ptr p
  )
{
  return NativeDef::_duplicate (p);
}

void
CORBA::tao_NativeDef_life::tao_release (
    NativeDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::NativeDef_ptr
CORBA::tao_NativeDef_life::tao_nil (
    void
  )
{
  return NativeDef::_nil ();
}

CORBA::Boolean
CORBA::tao_NativeDef_life::tao_marshal (
    NativeDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::NativeDef_ptr
CORBA::tao_NativeDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return NativeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_NativeDef_cast::tao_upcast (
    void *src
  )
{
  NativeDef **tmp =
    ACE_static_cast (NativeDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::NativeDef,
        CORBA::tao_NativeDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::NativeDef,
        CORBA::tao_NativeDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::NativeDef, \
        CORBA::tao_NativeDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::NativeDef, \
        CORBA::tao_NativeDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_NativeDef_Proxy_Impl::_TAO_NativeDef_Proxy_Impl (void)
{}

CORBA::_TAO_NativeDef_Remote_Proxy_Impl::_TAO_NativeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_NativeDef_Proxy_Broker::_TAO_NativeDef_Proxy_Broker (void)
{
}

CORBA::_TAO_NativeDef_Proxy_Broker::~_TAO_NativeDef_Proxy_Broker (void)
{
}

CORBA::_TAO_NativeDef_Proxy_Broker * (*CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_NativeDef_Remote_Proxy_Broker *
CORBA::_TAO_NativeDef_Remote_Proxy_Broker::the_TAO_NativeDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_NativeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_NativeDef_Remote_Proxy_Broker::_TAO_NativeDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_NativeDef_Remote_Proxy_Broker::~_TAO_NativeDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_NativeDef_Proxy_Impl&
CORBA::_TAO_NativeDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::NativeDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::NativeDef::NativeDef (int collocated)
{
  this->CORBA_NativeDef_setup_collocation (collocated);
}

void
CORBA::NativeDef::CORBA_NativeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_NativeDef_Proxy_Broker_ =
      ::CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_NativeDef_Proxy_Broker_ =
      ::CORBA::_TAO_NativeDef_Remote_Proxy_Broker::the_TAO_NativeDef_Remote_Proxy_Broker ();
  
  this->CORBA_TypedefDef_setup_collocation (collocated);
}

CORBA::NativeDef::~NativeDef (void)
{}

void 
CORBA::NativeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  NativeDef *tmp = ACE_static_cast (NativeDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::NativeDef_ptr
CORBA::NativeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return NativeDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/NativeDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (NativeDef::_nil ());
      
      if (is_a == 0)
        {
          return NativeDef::_nil ();
        }
    }
  
  return NativeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::NativeDef_ptr 
CORBA::NativeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return NativeDef::_nil ();
    }
  
  NativeDef_ptr default_proxy = NativeDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::NativeDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          NativeDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::NativeDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              NativeDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::NativeDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              NativeDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          NativeDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &NativeDef::_tao_class_id
                )
            )
        );
}

CORBA::NativeDef_ptr
CORBA::NativeDef::_duplicate (NativeDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::NativeDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/NativeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::NativeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, NativeDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::TypedefDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::TypedefDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/NativeDef:1.0";
}

CORBA::Boolean
CORBA::NativeDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_NativeDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4e61), 
  ACE_NTOHL (0x74697665), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/NativeDef:1.0
    10,
  ACE_NTOHL (0x4e617469), 
  ACE_NTOHL (0x76654465), 
  ACE_NTOHL (0x66000000),  // name = NativeDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_NativeDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_NativeDef),
    (char *) &_oc_CORBA_NativeDef,
    0,
    sizeof (CORBA::NativeDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NativeDef,
    &_tc_TAO_tc_CORBA_NativeDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::PrimitiveDef::_tao_class_id = 0;

CORBA::PrimitiveDef_ptr
CORBA::tao_PrimitiveDef_life::tao_duplicate (
    PrimitiveDef_ptr p
  )
{
  return PrimitiveDef::_duplicate (p);
}

void
CORBA::tao_PrimitiveDef_life::tao_release (
    PrimitiveDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::PrimitiveDef_ptr
CORBA::tao_PrimitiveDef_life::tao_nil (
    void
  )
{
  return PrimitiveDef::_nil ();
}

CORBA::Boolean
CORBA::tao_PrimitiveDef_life::tao_marshal (
    PrimitiveDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::PrimitiveDef_ptr
CORBA::tao_PrimitiveDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PrimitiveDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_PrimitiveDef_cast::tao_upcast (
    void *src
  )
{
  PrimitiveDef **tmp =
    ACE_static_cast (PrimitiveDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::PrimitiveDef,
        CORBA::tao_PrimitiveDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::PrimitiveDef,
        CORBA::tao_PrimitiveDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::PrimitiveDef, \
        CORBA::tao_PrimitiveDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::PrimitiveDef, \
        CORBA::tao_PrimitiveDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::PrimitiveKind result);
    
  private:
    TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get (const TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get &);
    
    ::CORBA::PrimitiveKind _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get::result (::CORBA::PrimitiveKind result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_PrimitiveDef_Proxy_Impl::_TAO_PrimitiveDef_Proxy_Impl (void)
{}

CORBA::_TAO_PrimitiveDef_Remote_Proxy_Impl::_TAO_PrimitiveDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::PrimitiveKind CORBA::_TAO_PrimitiveDef_Remote_Proxy_Impl::kind (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::PrimitiveKind _tao_retval = (CORBA::PrimitiveKind)0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_kind",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_PrimitiveDef_kind_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::PrimitiveKind _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_PrimitiveDef_Proxy_Broker::_TAO_PrimitiveDef_Proxy_Broker (void)
{
}

CORBA::_TAO_PrimitiveDef_Proxy_Broker::~_TAO_PrimitiveDef_Proxy_Broker (void)
{
}

CORBA::_TAO_PrimitiveDef_Proxy_Broker * (*CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker *
CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker::the_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker::_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker::~_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_PrimitiveDef_Proxy_Impl&
CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::PrimitiveDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::PrimitiveDef::PrimitiveDef (int collocated)
{
  this->CORBA_PrimitiveDef_setup_collocation (collocated);
}

void
CORBA::PrimitiveDef::CORBA_PrimitiveDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
      ::CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
      ::CORBA::_TAO_PrimitiveDef_Remote_Proxy_Broker::the_TAO_PrimitiveDef_Remote_Proxy_Broker ();
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::PrimitiveDef::~PrimitiveDef (void)
{}

void 
CORBA::PrimitiveDef::_tao_any_destructor (void *_tao_void_pointer)
{
  PrimitiveDef *tmp = ACE_static_cast (PrimitiveDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::PrimitiveDef_ptr
CORBA::PrimitiveDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return PrimitiveDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/PrimitiveDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (PrimitiveDef::_nil ());
      
      if (is_a == 0)
        {
          return PrimitiveDef::_nil ();
        }
    }
  
  return PrimitiveDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::PrimitiveDef_ptr 
CORBA::PrimitiveDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return PrimitiveDef::_nil ();
    }
  
  PrimitiveDef_ptr default_proxy = PrimitiveDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::PrimitiveDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          PrimitiveDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::PrimitiveDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              PrimitiveDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::PrimitiveDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              PrimitiveDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          PrimitiveDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &PrimitiveDef::_tao_class_id
                )
            )
        );
}

CORBA::PrimitiveDef_ptr
CORBA::PrimitiveDef::_duplicate (PrimitiveDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::PrimitiveDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::PrimitiveDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, PrimitiveDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

CORBA::Boolean
CORBA::PrimitiveDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::PrimitiveKind CORBA::PrimitiveDef::kind (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_PrimitiveDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_PrimitiveDef_Proxy_Impl &proxy = 
    this->the_TAO_PrimitiveDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::PrimitiveKind)0);
  
  return proxy.kind (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_PrimitiveDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5072), 
  ACE_NTOHL (0x696d6974), 
  ACE_NTOHL (0x69766544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/PrimitiveDef:1.0
    13,
  ACE_NTOHL (0x5072696d), 
  ACE_NTOHL (0x69746976), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x0),  // name = PrimitiveDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_PrimitiveDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_PrimitiveDef),
    (char *) &_oc_CORBA_PrimitiveDef,
    0,
    sizeof (CORBA::PrimitiveDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PrimitiveDef,
    &_tc_TAO_tc_CORBA_PrimitiveDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::StringDef::_tao_class_id = 0;

CORBA::StringDef_ptr
CORBA::tao_StringDef_life::tao_duplicate (
    StringDef_ptr p
  )
{
  return StringDef::_duplicate (p);
}

void
CORBA::tao_StringDef_life::tao_release (
    StringDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::StringDef_ptr
CORBA::tao_StringDef_life::tao_nil (
    void
  )
{
  return StringDef::_nil ();
}

CORBA::Boolean
CORBA::tao_StringDef_life::tao_marshal (
    StringDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::StringDef_ptr
CORBA::tao_StringDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return StringDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_StringDef_cast::tao_upcast (
    void *src
  )
{
  StringDef **tmp =
    ACE_static_cast (StringDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::StringDef,
        CORBA::tao_StringDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::StringDef,
        CORBA::tao_StringDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::StringDef, \
        CORBA::tao_StringDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::StringDef, \
        CORBA::tao_StringDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_StringDef_bound_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StringDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ULong result);
    
  private:
    TAO_ClientRequestInfo_CORBA_StringDef_bound_get (const TAO_ClientRequestInfo_CORBA_StringDef_bound_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_StringDef_bound_get &);
    
    ::CORBA::ULong _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_StringDef_bound_get::TAO_ClientRequestInfo_CORBA_StringDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_StringDef_bound_get::result (CORBA::ULong result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_StringDef_bound_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_StringDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_StringDef_bound_set (const TAO_ClientRequestInfo_CORBA_StringDef_bound_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_StringDef_bound_set &);
    const CORBA::ULong & bound_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_StringDef_bound_set::TAO_ClientRequestInfo_CORBA_StringDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_StringDef_bound_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_StringDef_bound_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_StringDef_Proxy_Impl::_TAO_StringDef_Proxy_Impl (void)
{}

CORBA::_TAO_StringDef_Remote_Proxy_Impl::_TAO_StringDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::ULong CORBA::_TAO_StringDef_Remote_Proxy_Impl::bound (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StringDef_bound_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::ULong _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_StringDef_Remote_Proxy_Impl::bound (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_StringDef_bound_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          bound
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << bound)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_StringDef_Proxy_Broker::_TAO_StringDef_Proxy_Broker (void)
{
}

CORBA::_TAO_StringDef_Proxy_Broker::~_TAO_StringDef_Proxy_Broker (void)
{
}

CORBA::_TAO_StringDef_Proxy_Broker * (*CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_StringDef_Remote_Proxy_Broker *
CORBA::_TAO_StringDef_Remote_Proxy_Broker::the_TAO_StringDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_StringDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_StringDef_Remote_Proxy_Broker::_TAO_StringDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_StringDef_Remote_Proxy_Broker::~_TAO_StringDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_StringDef_Proxy_Impl&
CORBA::_TAO_StringDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::StringDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::StringDef::StringDef (int collocated)
{
  this->CORBA_StringDef_setup_collocation (collocated);
}

void
CORBA::StringDef::CORBA_StringDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_StringDef_Proxy_Broker_ =
      ::CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_StringDef_Proxy_Broker_ =
      ::CORBA::_TAO_StringDef_Remote_Proxy_Broker::the_TAO_StringDef_Remote_Proxy_Broker ();
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::StringDef::~StringDef (void)
{}

void 
CORBA::StringDef::_tao_any_destructor (void *_tao_void_pointer)
{
  StringDef *tmp = ACE_static_cast (StringDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::StringDef_ptr
CORBA::StringDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return StringDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/StringDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (StringDef::_nil ());
      
      if (is_a == 0)
        {
          return StringDef::_nil ();
        }
    }
  
  return StringDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::StringDef_ptr 
CORBA::StringDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return StringDef::_nil ();
    }
  
  StringDef_ptr default_proxy = StringDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::StringDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          StringDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::StringDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              StringDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::StringDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              StringDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          StringDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &StringDef::_tao_class_id
                )
            )
        );
}

CORBA::StringDef_ptr
CORBA::StringDef::_duplicate (StringDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::StringDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/StringDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::StringDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, StringDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

CORBA::Boolean
CORBA::StringDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::ULong CORBA::StringDef::bound (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_StringDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_StringDef_Proxy_Impl &proxy = 
    this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.bound (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::StringDef::bound (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_StringDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_StringDef_Proxy_Impl &proxy = 
    this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.bound (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_StringDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5374), 
  ACE_NTOHL (0x72696e67), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StringDef:1.0
    10,
  ACE_NTOHL (0x53747269), 
  ACE_NTOHL (0x6e674465), 
  ACE_NTOHL (0x66000000),  // name = StringDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_StringDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_StringDef),
    (char *) &_oc_CORBA_StringDef,
    0,
    sizeof (CORBA::StringDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_StringDef,
    &_tc_TAO_tc_CORBA_StringDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::WstringDef::_tao_class_id = 0;

CORBA::WstringDef_ptr
CORBA::tao_WstringDef_life::tao_duplicate (
    WstringDef_ptr p
  )
{
  return WstringDef::_duplicate (p);
}

void
CORBA::tao_WstringDef_life::tao_release (
    WstringDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::WstringDef_ptr
CORBA::tao_WstringDef_life::tao_nil (
    void
  )
{
  return WstringDef::_nil ();
}

CORBA::Boolean
CORBA::tao_WstringDef_life::tao_marshal (
    WstringDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::WstringDef_ptr
CORBA::tao_WstringDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return WstringDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_WstringDef_cast::tao_upcast (
    void *src
  )
{
  WstringDef **tmp =
    ACE_static_cast (WstringDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::WstringDef,
        CORBA::tao_WstringDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::WstringDef,
        CORBA::tao_WstringDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::WstringDef, \
        CORBA::tao_WstringDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::WstringDef, \
        CORBA::tao_WstringDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_WstringDef_bound_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ULong result);
    
  private:
    TAO_ClientRequestInfo_CORBA_WstringDef_bound_get (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_get &);
    
    ::CORBA::ULong _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::TAO_ClientRequestInfo_CORBA_WstringDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_WstringDef_bound_get::result (CORBA::ULong result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_WstringDef_bound_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_WstringDef_bound_set (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_WstringDef_bound_set &);
    const CORBA::ULong & bound_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::TAO_ClientRequestInfo_CORBA_WstringDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_WstringDef_bound_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_WstringDef_Proxy_Impl::_TAO_WstringDef_Proxy_Impl (void)
{}

CORBA::_TAO_WstringDef_Remote_Proxy_Impl::_TAO_WstringDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::ULong CORBA::_TAO_WstringDef_Remote_Proxy_Impl::bound (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_WstringDef_bound_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::ULong _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_WstringDef_Remote_Proxy_Impl::bound (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_WstringDef_bound_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          bound
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << bound)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_WstringDef_Proxy_Broker::_TAO_WstringDef_Proxy_Broker (void)
{
}

CORBA::_TAO_WstringDef_Proxy_Broker::~_TAO_WstringDef_Proxy_Broker (void)
{
}

CORBA::_TAO_WstringDef_Proxy_Broker * (*CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_WstringDef_Remote_Proxy_Broker *
CORBA::_TAO_WstringDef_Remote_Proxy_Broker::the_TAO_WstringDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_WstringDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_WstringDef_Remote_Proxy_Broker::_TAO_WstringDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_WstringDef_Remote_Proxy_Broker::~_TAO_WstringDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_WstringDef_Proxy_Impl&
CORBA::_TAO_WstringDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::WstringDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::WstringDef::WstringDef (int collocated)
{
  this->CORBA_WstringDef_setup_collocation (collocated);
}

void
CORBA::WstringDef::CORBA_WstringDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_WstringDef_Proxy_Broker_ =
      ::CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_WstringDef_Proxy_Broker_ =
      ::CORBA::_TAO_WstringDef_Remote_Proxy_Broker::the_TAO_WstringDef_Remote_Proxy_Broker ();
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::WstringDef::~WstringDef (void)
{}

void 
CORBA::WstringDef::_tao_any_destructor (void *_tao_void_pointer)
{
  WstringDef *tmp = ACE_static_cast (WstringDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::WstringDef_ptr
CORBA::WstringDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return WstringDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/WstringDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (WstringDef::_nil ());
      
      if (is_a == 0)
        {
          return WstringDef::_nil ();
        }
    }
  
  return WstringDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::WstringDef_ptr 
CORBA::WstringDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return WstringDef::_nil ();
    }
  
  WstringDef_ptr default_proxy = WstringDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::WstringDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          WstringDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::WstringDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              WstringDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::WstringDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              WstringDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          WstringDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &WstringDef::_tao_class_id
                )
            )
        );
}

CORBA::WstringDef_ptr
CORBA::WstringDef::_duplicate (WstringDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::WstringDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/WstringDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::WstringDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, WstringDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

CORBA::Boolean
CORBA::WstringDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::ULong CORBA::WstringDef::bound (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_WstringDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_WstringDef_Proxy_Impl &proxy = 
    this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.bound (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::WstringDef::bound (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_WstringDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_WstringDef_Proxy_Impl &proxy = 
    this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.bound (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_WstringDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5773), 
  ACE_NTOHL (0x7472696e), 
  ACE_NTOHL (0x67446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/WstringDef:1.0
    11,
  ACE_NTOHL (0x57737472), 
  ACE_NTOHL (0x696e6744), 
  ACE_NTOHL (0x65660000),  // name = WstringDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_WstringDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_WstringDef),
    (char *) &_oc_CORBA_WstringDef,
    0,
    sizeof (CORBA::WstringDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_WstringDef,
    &_tc_TAO_tc_CORBA_WstringDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::SequenceDef::_tao_class_id = 0;

CORBA::SequenceDef_ptr
CORBA::tao_SequenceDef_life::tao_duplicate (
    SequenceDef_ptr p
  )
{
  return SequenceDef::_duplicate (p);
}

void
CORBA::tao_SequenceDef_life::tao_release (
    SequenceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::SequenceDef_ptr
CORBA::tao_SequenceDef_life::tao_nil (
    void
  )
{
  return SequenceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_SequenceDef_life::tao_marshal (
    SequenceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::SequenceDef_ptr
CORBA::tao_SequenceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return SequenceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_SequenceDef_cast::tao_upcast (
    void *src
  )
{
  SequenceDef **tmp =
    ACE_static_cast (SequenceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::SequenceDef,
        CORBA::tao_SequenceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::SequenceDef,
        CORBA::tao_SequenceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::SequenceDef, \
        CORBA::tao_SequenceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::SequenceDef, \
        CORBA::tao_SequenceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ULong result);
    
  private:
    TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get &);
    
    ::CORBA::ULong _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get::result (CORBA::ULong result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set &);
    const CORBA::ULong & bound_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & bound
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      bound_ (bound)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= bound_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr element_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set &);
    CORBA::IDLType_ptr element_type_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr element_type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->element_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_SequenceDef_Proxy_Impl::_TAO_SequenceDef_Proxy_Impl (void)
{}

CORBA::_TAO_SequenceDef_Remote_Proxy_Impl::_TAO_SequenceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::ULong CORBA::_TAO_SequenceDef_Remote_Proxy_Impl::bound (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_bound_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::ULong _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_SequenceDef_Remote_Proxy_Impl::bound (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_bound_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          bound
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << bound)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_SequenceDef_Remote_Proxy_Impl::element_type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_SequenceDef_element_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          element_type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << element_type_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_SequenceDef_Proxy_Broker::_TAO_SequenceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_SequenceDef_Proxy_Broker::~_TAO_SequenceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_SequenceDef_Proxy_Broker * (*CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_SequenceDef_Remote_Proxy_Broker *
CORBA::_TAO_SequenceDef_Remote_Proxy_Broker::the_TAO_SequenceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_SequenceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_SequenceDef_Remote_Proxy_Broker::_TAO_SequenceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_SequenceDef_Remote_Proxy_Broker::~_TAO_SequenceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_SequenceDef_Proxy_Impl&
CORBA::_TAO_SequenceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::SequenceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::SequenceDef::SequenceDef (int collocated)
{
  this->CORBA_SequenceDef_setup_collocation (collocated);
}

void
CORBA::SequenceDef::CORBA_SequenceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_SequenceDef_Proxy_Broker_ =
      ::CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_SequenceDef_Proxy_Broker_ =
      ::CORBA::_TAO_SequenceDef_Remote_Proxy_Broker::the_TAO_SequenceDef_Remote_Proxy_Broker ();
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::SequenceDef::~SequenceDef (void)
{}

void 
CORBA::SequenceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  SequenceDef *tmp = ACE_static_cast (SequenceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::SequenceDef_ptr
CORBA::SequenceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return SequenceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/SequenceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (SequenceDef::_nil ());
      
      if (is_a == 0)
        {
          return SequenceDef::_nil ();
        }
    }
  
  return SequenceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::SequenceDef_ptr 
CORBA::SequenceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return SequenceDef::_nil ();
    }
  
  SequenceDef_ptr default_proxy = SequenceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::SequenceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          SequenceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::SequenceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              SequenceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::SequenceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              SequenceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          SequenceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &SequenceDef::_tao_class_id
                )
            )
        );
}

CORBA::SequenceDef_ptr
CORBA::SequenceDef::_duplicate (SequenceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::SequenceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::SequenceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, SequenceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

CORBA::Boolean
CORBA::SequenceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::ULong CORBA::SequenceDef::bound (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_SequenceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_SequenceDef_Proxy_Impl &proxy = 
    this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.bound (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::SequenceDef::bound (
    CORBA::ULong bound
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_SequenceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_SequenceDef_Proxy_Impl &proxy = 
    this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.bound (
      this,
      bound
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::SequenceDef::element_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_SequenceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_SequenceDef_Proxy_Impl &proxy = 
    this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.element_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::SequenceDef::element_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_SequenceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_SequenceDef_Proxy_Impl &proxy = 
    this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.element_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::SequenceDef::element_type_def (
    CORBA::IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_SequenceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_SequenceDef_Proxy_Impl &proxy = 
    this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.element_type_def (
      this,
      element_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_SequenceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5365), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x63654465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/SequenceDef:1.0
    12,
  ACE_NTOHL (0x53657175), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x44656600),  // name = SequenceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_SequenceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_SequenceDef),
    (char *) &_oc_CORBA_SequenceDef,
    0,
    sizeof (CORBA::SequenceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_SequenceDef,
    &_tc_TAO_tc_CORBA_SequenceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ArrayDef::_tao_class_id = 0;

CORBA::ArrayDef_ptr
CORBA::tao_ArrayDef_life::tao_duplicate (
    ArrayDef_ptr p
  )
{
  return ArrayDef::_duplicate (p);
}

void
CORBA::tao_ArrayDef_life::tao_release (
    ArrayDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ArrayDef_ptr
CORBA::tao_ArrayDef_life::tao_nil (
    void
  )
{
  return ArrayDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ArrayDef_life::tao_marshal (
    ArrayDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ArrayDef_ptr
CORBA::tao_ArrayDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ArrayDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ArrayDef_cast::tao_upcast (
    void *src
  )
{
  ArrayDef **tmp =
    ACE_static_cast (ArrayDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ArrayDef,
        CORBA::tao_ArrayDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ArrayDef,
        CORBA::tao_ArrayDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ArrayDef, \
        CORBA::tao_ArrayDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ArrayDef, \
        CORBA::tao_ArrayDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ArrayDef_length_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ULong result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ArrayDef_length_get (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_get &);
    
    ::CORBA::ULong _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::TAO_ClientRequestInfo_CORBA_ArrayDef_length_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ArrayDef_length_get::result (CORBA::ULong result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ArrayDef_length_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & length
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ArrayDef_length_set (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_length_set &);
    const CORBA::ULong & length_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::TAO_ClientRequestInfo_CORBA_ArrayDef_length_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ULong & length
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      length_ (length)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= length_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ArrayDef_length_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr element_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set &);
    CORBA::IDLType_ptr element_type_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr element_type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->element_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ArrayDef_Proxy_Impl::_TAO_ArrayDef_Proxy_Impl (void)
{}

CORBA::_TAO_ArrayDef_Remote_Proxy_Impl::_TAO_ArrayDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::ULong CORBA::_TAO_ArrayDef_Remote_Proxy_Impl::length (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_length",
      11,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_length_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::ULong _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ArrayDef_Remote_Proxy_Impl::length (
    CORBA::Object *_collocated_tao_target_,
    CORBA::ULong length
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_length",
      11,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_length_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          length
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << length)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_ArrayDef_Remote_Proxy_Impl::element_type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ArrayDef_element_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          element_type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << element_type_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ArrayDef_Proxy_Broker::_TAO_ArrayDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ArrayDef_Proxy_Broker::~_TAO_ArrayDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ArrayDef_Proxy_Broker * (*CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ArrayDef_Remote_Proxy_Broker *
CORBA::_TAO_ArrayDef_Remote_Proxy_Broker::the_TAO_ArrayDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ArrayDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ArrayDef_Remote_Proxy_Broker::_TAO_ArrayDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ArrayDef_Remote_Proxy_Broker::~_TAO_ArrayDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ArrayDef_Proxy_Impl&
CORBA::_TAO_ArrayDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ArrayDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ArrayDef::ArrayDef (int collocated)
{
  this->CORBA_ArrayDef_setup_collocation (collocated);
}

void
CORBA::ArrayDef::CORBA_ArrayDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ArrayDef_Proxy_Broker_ =
      ::CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ArrayDef_Proxy_Broker_ =
      ::CORBA::_TAO_ArrayDef_Remote_Proxy_Broker::the_TAO_ArrayDef_Remote_Proxy_Broker ();
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::ArrayDef::~ArrayDef (void)
{}

void 
CORBA::ArrayDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ArrayDef *tmp = ACE_static_cast (ArrayDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ArrayDef_ptr
CORBA::ArrayDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ArrayDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ArrayDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ArrayDef::_nil ());
      
      if (is_a == 0)
        {
          return ArrayDef::_nil ();
        }
    }
  
  return ArrayDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ArrayDef_ptr 
CORBA::ArrayDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ArrayDef::_nil ();
    }
  
  ArrayDef_ptr default_proxy = ArrayDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ArrayDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ArrayDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ArrayDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ArrayDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ArrayDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ArrayDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ArrayDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ArrayDef::_tao_class_id
                )
            )
        );
}

CORBA::ArrayDef_ptr
CORBA::ArrayDef::_duplicate (ArrayDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ArrayDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ArrayDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ArrayDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

CORBA::Boolean
CORBA::ArrayDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::ULong CORBA::ArrayDef::length (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ArrayDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ArrayDef_Proxy_Impl &proxy = 
    this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.length (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ArrayDef::length (
    CORBA::ULong length
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ArrayDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ArrayDef_Proxy_Impl &proxy = 
    this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.length (
      this,
      length
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::ArrayDef::element_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ArrayDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ArrayDef_Proxy_Impl &proxy = 
    this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.element_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::ArrayDef::element_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ArrayDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ArrayDef_Proxy_Impl &proxy = 
    this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.element_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ArrayDef::element_type_def (
    CORBA::IDLType_ptr element_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ArrayDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ArrayDef_Proxy_Impl &proxy = 
    this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.element_type_def (
      this,
      element_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ArrayDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4172), 
  ACE_NTOHL (0x72617944), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ArrayDef:1.0
    9,
  ACE_NTOHL (0x41727261), 
  ACE_NTOHL (0x79446566), 
  ACE_NTOHL (0x0),  // name = ArrayDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ArrayDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ArrayDef),
    (char *) &_oc_CORBA_ArrayDef,
    0,
    sizeof (CORBA::ArrayDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ArrayDef,
    &_tc_TAO_tc_CORBA_ArrayDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ExceptionDef::_tao_class_id = 0;

CORBA::ExceptionDef_ptr
CORBA::tao_ExceptionDef_life::tao_duplicate (
    ExceptionDef_ptr p
  )
{
  return ExceptionDef::_duplicate (p);
}

void
CORBA::tao_ExceptionDef_life::tao_release (
    ExceptionDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ExceptionDef_ptr
CORBA::tao_ExceptionDef_life::tao_nil (
    void
  )
{
  return ExceptionDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ExceptionDef_life::tao_marshal (
    ExceptionDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ExceptionDef_ptr
CORBA::tao_ExceptionDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ExceptionDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ExceptionDef_cast::tao_upcast (
    void *src
  )
{
  ExceptionDef **tmp =
    ACE_static_cast (ExceptionDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ExceptionDef,
        CORBA::tao_ExceptionDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ExceptionDef,
        CORBA::tao_ExceptionDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ExceptionDef, \
        CORBA::tao_ExceptionDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ExceptionDef, \
        CORBA::tao_ExceptionDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get (const TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::StructMemberSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get &);
    
    ::CORBA::StructMemberSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get::result (::CORBA::StructMemberSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set &);
    const CORBA::StructMemberSeq & members_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ExceptionDef_Proxy_Impl::_TAO_ExceptionDef_Proxy_Impl (void)
{}

CORBA::_TAO_ExceptionDef_Remote_Proxy_Impl::_TAO_ExceptionDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_ExceptionDef_Remote_Proxy_Impl::type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExceptionDef_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::StructMemberSeq * CORBA::_TAO_ExceptionDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StructMemberSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::StructMemberSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::StructMemberSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExceptionDef_members_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::StructMemberSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ExceptionDef_Remote_Proxy_Impl::members (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExceptionDef_members_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << members)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ExceptionDef_Proxy_Broker::_TAO_ExceptionDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExceptionDef_Proxy_Broker::~_TAO_ExceptionDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExceptionDef_Proxy_Broker * (*CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker *
CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker::the_TAO_ExceptionDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker::_TAO_ExceptionDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker::~_TAO_ExceptionDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExceptionDef_Proxy_Impl&
CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ExceptionDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ExceptionDef::ExceptionDef (int collocated)
{
  this->CORBA_ExceptionDef_setup_collocation (collocated);
}

void
CORBA::ExceptionDef::CORBA_ExceptionDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExceptionDef_Proxy_Broker_ =
      ::CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExceptionDef_Proxy_Broker_ =
      ::CORBA::_TAO_ExceptionDef_Remote_Proxy_Broker::the_TAO_ExceptionDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
  this->CORBA_Container_setup_collocation (collocated);
}

CORBA::ExceptionDef::~ExceptionDef (void)
{}

void 
CORBA::ExceptionDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ExceptionDef *tmp = ACE_static_cast (ExceptionDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ExceptionDef_ptr
CORBA::ExceptionDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExceptionDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ExceptionDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ExceptionDef::_nil ());
      
      if (is_a == 0)
        {
          return ExceptionDef::_nil ();
        }
    }
  
  return ExceptionDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ExceptionDef_ptr 
CORBA::ExceptionDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExceptionDef::_nil ();
    }
  
  ExceptionDef_ptr default_proxy = ExceptionDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ExceptionDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ExceptionDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExceptionDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ExceptionDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExceptionDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ExceptionDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ExceptionDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ExceptionDef::_tao_class_id
                )
            )
        );
}

CORBA::ExceptionDef_ptr
CORBA::ExceptionDef::_duplicate (ExceptionDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ExceptionDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ExceptionDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ExceptionDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

CORBA::Boolean
CORBA::ExceptionDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::ExceptionDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExceptionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExceptionDef_Proxy_Impl &proxy = 
    this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::StructMemberSeq * CORBA::ExceptionDef::members (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExceptionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExceptionDef_Proxy_Impl &proxy = 
    this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.members (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ExceptionDef::members (
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExceptionDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExceptionDef_Proxy_Impl &proxy = 
    this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.members (
      this,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExceptionDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x63657074), 
  ACE_NTOHL (0x696f6e44), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDef:1.0
    13,
  ACE_NTOHL (0x45786365), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e446566), 
  ACE_NTOHL (0x0),  // name = ExceptionDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ExceptionDef),
    (char *) &_oc_CORBA_ExceptionDef,
    0,
    sizeof (CORBA::ExceptionDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExceptionDef,
    &_tc_TAO_tc_CORBA_ExceptionDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_EXCEPTIONDEFSEQ_CS_)
#define _CORBA_EXCEPTIONDEFSEQ_CS_

CORBA::ExceptionDefSeq::ExceptionDefSeq (void)
{}

CORBA::ExceptionDefSeq::ExceptionDefSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Object_Sequence<
        CORBA::ExceptionDef,
        CORBA::ExceptionDef_var,
        CORBA::tao_ExceptionDef_life,
        CORBA::tao_ExceptionDef_cast
      >
    (max)
{}

CORBA::ExceptionDefSeq::ExceptionDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ExceptionDef_ptr * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Object_Sequence<
        CORBA::ExceptionDef,
        CORBA::ExceptionDef_var,
        CORBA::tao_ExceptionDef_life,
        CORBA::tao_ExceptionDef_cast
      >
    (max, length, buffer, release)
{}

CORBA::ExceptionDefSeq::ExceptionDefSeq (
    const ExceptionDefSeq &seq
  )
  : TAO_Unbounded_Object_Sequence<
        CORBA::ExceptionDef,
        CORBA::ExceptionDef_var,
        CORBA::tao_ExceptionDef_life,
        CORBA::tao_ExceptionDef_cast
      >
    (seq)
{}

CORBA::ExceptionDefSeq::~ExceptionDefSeq (void)
{}

void CORBA::ExceptionDefSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  ExceptionDefSeq * tmp =
    ACE_static_cast (
        ExceptionDefSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Object_Manager<
      CORBA::ExceptionDef,
      CORBA::ExceptionDef_var,
      CORBA::tao_ExceptionDef_life
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
    TAO_Object_Manager< \
        CORBA::ExceptionDef, \
        CORBA::ExceptionDef_var, \
        CORBA::tao_ExceptionDef_life \
      >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_MngSeq_Var_T<
      CORBA::ExceptionDefSeq,
      TAO_Object_Manager<
          CORBA::ExceptionDef,
          CORBA::ExceptionDef_var,
          CORBA::tao_ExceptionDef_life
        >
    >;

template class
  TAO_MngSeq_Out_T<
      CORBA::ExceptionDefSeq,
      CORBA::ExceptionDefSeq_var,
      TAO_Object_Manager<
          CORBA::ExceptionDef,
          CORBA::ExceptionDef_var,
          CORBA::tao_ExceptionDef_life
        >
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
    TAO_MngSeq_Var_T< \
        CORBA::ExceptionDefSeq, \
        TAO_Object_Manager< \
            CORBA::ExceptionDef, \
            CORBA::ExceptionDef_var, \
            CORBA::tao_ExceptionDef_life \
          > \
      >

# pragma instantiate \
    TAO_MngSeq_Out_T< \
        CORBA::ExceptionDefSeq, \
        CORBA::ExceptionDefSeq_var, \
        TAO_Object_Manager< \
            CORBA::ExceptionDef, \
            CORBA::ExceptionDef_var, \
            CORBA::tao_ExceptionDef_life \
          > \
      >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_defn.cpp:284
  
  static const CORBA::Long _oc_CORBA_ExceptionDefSeq[] =
  {
        TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x63657074), 
    ACE_NTOHL (0x696f6e44), 
    ACE_NTOHL (0x65665365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExceptionDefSeq:1.0
        16,
    ACE_NTOHL (0x45786365), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e446566), 
    ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
        CORBA::tk_sequence, // typecode kind
    80, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x63657074), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65663a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDef:1.0
                13,
        ACE_NTOHL (0x45786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e446566), 
        ACE_NTOHL (0x0),  // name = ExceptionDef
        
      0U,

};
  
  static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDefSeq (
      CORBA::tk_alias,
      sizeof (_oc_CORBA_ExceptionDefSeq),
      (char *) &_oc_CORBA_ExceptionDefSeq,
      0,
      sizeof (CORBA::ExceptionDefSeq)
    );
  
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (CORBA)
  TAO_NAMESPACE_DEFINE (
      ::CORBA::TypeCode_ptr,
      _tc_ExceptionDefSeq,
      &_tc_TAO_tc_CORBA_ExceptionDefSeq
    )
  TAO_NAMESPACE_END
  
  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_defn.cpp:284
  
  static const CORBA::Long _oc_CORBA_AttributeMode[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4174), 
    ACE_NTOHL (0x74726962), 
    ACE_NTOHL (0x7574654d), 
    ACE_NTOHL (0x6f64653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
    14,
    ACE_NTOHL (0x41747472), 
    ACE_NTOHL (0x69627574), 
    ACE_NTOHL (0x654d6f64), 
    ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12,
    ACE_NTOHL (0x41545452), 
    ACE_NTOHL (0x5f4e4f52), 
    ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14,
    ACE_NTOHL (0x41545452), 
    ACE_NTOHL (0x5f524541), 
    ACE_NTOHL (0x444f4e4c), 
    ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
    };
  
  static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeMode (
      CORBA::tk_enum,
      sizeof (_oc_CORBA_AttributeMode),
      (char *) &_oc_CORBA_AttributeMode,
      0,
      sizeof (CORBA::AttributeMode)
    );
  
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (CORBA)
  TAO_NAMESPACE_DEFINE (
      ::CORBA::TypeCode_ptr,
      _tc_AttributeMode,
      &_tc_TAO_tc_CORBA_AttributeMode
    )
  TAO_NAMESPACE_END
  
  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_cs.cpp:57
  
  int CORBA::AttributeDef::_tao_class_id = 0;
  
  CORBA::AttributeDef_ptr
  CORBA::tao_AttributeDef_life::tao_duplicate (
      AttributeDef_ptr p
    )
  {
    return AttributeDef::_duplicate (p);
  }
  
  void
  CORBA::tao_AttributeDef_life::tao_release (
      AttributeDef_ptr p
    )
  {
    CORBA::release (p);
  }
  
  CORBA::AttributeDef_ptr
  CORBA::tao_AttributeDef_life::tao_nil (
      void
    )
  {
    return AttributeDef::_nil ();
  }
  
  CORBA::Boolean
  CORBA::tao_AttributeDef_life::tao_marshal (
      AttributeDef_ptr p,
      TAO_OutputCDR &cdr
    )
  {
    return p->marshal (cdr);
  }
  
  CORBA::AttributeDef_ptr
  CORBA::tao_AttributeDef_cast::tao_narrow (
      CORBA::Object *p
      ACE_ENV_ARG_DECL
    )
  {
    return AttributeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
  }
  
  CORBA::Object *
  CORBA::tao_AttributeDef_cast::tao_upcast (
      void *src
    )
  {
    AttributeDef **tmp =
      ACE_static_cast (AttributeDef **, src);
    return *tmp;
  }
  
#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
    template class
      TAO_Objref_Var_T<
          CORBA::AttributeDef,
          CORBA::tao_AttributeDef_life
        >;
    template class
      TAO_Objref_Out_T<
          CORBA::AttributeDef,
          CORBA::tao_AttributeDef_life
        >;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  # pragma instantiate \
      TAO_Objref_Var_T< \
          CORBA::AttributeDef, \
          CORBA::tao_AttributeDef_life \
        >
  # pragma instantiate \
      TAO_Objref_Out_T< \
          CORBA::AttributeDef, \
          CORBA::tao_AttributeDef_life \
        >
  #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
  
  // TAO_IDL - Generated from
  // be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:76
  
  class TAO_ClientRequestInfo_CORBA_AttributeDef_type_get : public TAO_ClientRequestInfo_i
  {
  public:
    TAO_ClientRequestInfo_CORBA_AttributeDef_type_get (
        TAO_GIOP_Invocation *_tao_invocation,
        CORBA::Object_ptr _tao_target
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

      virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
        ACE_THROW_SPEC ((CORBA::SystemException));
      
      virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
        ACE_THROW_SPEC ((CORBA::SystemException));
      
      virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
        ACE_THROW_SPEC ((CORBA::SystemException));

      void result (::CORBA::TypeCode_ptr result);
      
    private:
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_get (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_get &);
      void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_get &);
      
      ::CORBA::TypeCode_ptr _result;
    };
    
    // TAO_IDL - Generated from
    // be/be_visitor_operation/interceptors_cs.cpp:376
    
    TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::TAO_ClientRequestInfo_CORBA_AttributeDef_type_get (
        TAO_GIOP_Invocation *_tao_invocation,
        CORBA::Object_ptr _tao_target
        ACE_ENV_ARG_DECL_NOT_USED        
      )
          : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)  
  {}

Dynamic::ParameterList *
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the argument list on demand.
    Dynamic::ParameterList *parameter_list =
      TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return parameter_list;
  }
  
  Dynamic::ExceptionList *
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException))
  {
    // Generate the exception list on demand.
    Dynamic::ExceptionList *exception_list =
      TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);
    
    return exception_list;
  }

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_AttributeDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set &);
    CORBA::IDLType_ptr type_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::AttributeMode result);
    
  private:
    TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get &);
    
    ::CORBA::AttributeMode _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get::result (::CORBA::AttributeMode result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set &);
    const CORBA::AttributeMode & mode_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_AttributeDef_Proxy_Impl::_TAO_AttributeDef_Proxy_Impl (void)
{}

CORBA::_TAO_AttributeDef_Remote_Proxy_Impl::_TAO_AttributeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_AttributeDef_Remote_Proxy_Impl::type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_AttributeDef_Remote_Proxy_Impl::type_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_AttributeDef_Remote_Proxy_Impl::type_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << type_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::AttributeMode CORBA::_TAO_AttributeDef_Remote_Proxy_Impl::mode (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AttributeMode _tao_retval = (CORBA::AttributeMode)0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_mode_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::AttributeMode _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_AttributeDef_Remote_Proxy_Impl::mode (
    CORBA::Object *_collocated_tao_target_,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_AttributeDef_mode_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          mode
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << mode)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_AttributeDef_Proxy_Broker::_TAO_AttributeDef_Proxy_Broker (void)
{
}

CORBA::_TAO_AttributeDef_Proxy_Broker::~_TAO_AttributeDef_Proxy_Broker (void)
{
}

CORBA::_TAO_AttributeDef_Proxy_Broker * (*CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_AttributeDef_Remote_Proxy_Broker *
CORBA::_TAO_AttributeDef_Remote_Proxy_Broker::the_TAO_AttributeDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_AttributeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_AttributeDef_Remote_Proxy_Broker::_TAO_AttributeDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_AttributeDef_Remote_Proxy_Broker::~_TAO_AttributeDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_AttributeDef_Proxy_Impl&
CORBA::_TAO_AttributeDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::AttributeDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::AttributeDef::AttributeDef (int collocated)
{
  this->CORBA_AttributeDef_setup_collocation (collocated);
}

void
CORBA::AttributeDef::CORBA_AttributeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_AttributeDef_Proxy_Broker_ =
      ::CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_AttributeDef_Proxy_Broker_ =
      ::CORBA::_TAO_AttributeDef_Remote_Proxy_Broker::the_TAO_AttributeDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::AttributeDef::~AttributeDef (void)
{}

void 
CORBA::AttributeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  AttributeDef *tmp = ACE_static_cast (AttributeDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::AttributeDef_ptr
CORBA::AttributeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return AttributeDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/AttributeDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (AttributeDef::_nil ());
      
      if (is_a == 0)
        {
          return AttributeDef::_nil ();
        }
    }
  
  return AttributeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::AttributeDef_ptr 
CORBA::AttributeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return AttributeDef::_nil ();
    }
  
  AttributeDef_ptr default_proxy = AttributeDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::AttributeDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          AttributeDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::AttributeDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              AttributeDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::AttributeDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              AttributeDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          AttributeDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &AttributeDef::_tao_class_id
                )
            )
        );
}

CORBA::AttributeDef_ptr
CORBA::AttributeDef::_duplicate (AttributeDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::AttributeDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::AttributeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, AttributeDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

CORBA::Boolean
CORBA::AttributeDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::AttributeDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::AttributeDef::type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::AttributeDef::type_def (
    CORBA::IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.type_def (
      this,
      type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::AttributeMode CORBA::AttributeDef::mode (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::AttributeMode)0);
  
  return proxy.mode (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::AttributeDef::mode (
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_AttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_AttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.mode (
      this,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_AttributeDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4174), 
  ACE_NTOHL (0x74726962), 
  ACE_NTOHL (0x75746544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDef:1.0
    13,
  ACE_NTOHL (0x41747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x0),  // name = AttributeDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_AttributeDef),
    (char *) &_oc_CORBA_AttributeDef,
    0,
    sizeof (CORBA::AttributeDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AttributeDef,
    &_tc_TAO_tc_CORBA_AttributeDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_AttributeDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4174), 
  ACE_NTOHL (0x74726962), 
  ACE_NTOHL (0x75746544), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
    21,
  ACE_NTOHL (0x41747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = AttributeDescription
  6, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

  5,
  ACE_NTOHL (0x6d6f6465), 
  ACE_NTOHL (0x0),  // name = mode
    CORBA::tk_enum, // typecode kind
  104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4174), 
    ACE_NTOHL (0x74726962), 
    ACE_NTOHL (0x7574654d), 
    ACE_NTOHL (0x6f64653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
    14,
    ACE_NTOHL (0x41747472), 
    ACE_NTOHL (0x69627574), 
    ACE_NTOHL (0x654d6f64), 
    ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12,
    ACE_NTOHL (0x41545452), 
    ACE_NTOHL (0x5f4e4f52), 
    ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14,
    ACE_NTOHL (0x41545452), 
    ACE_NTOHL (0x5f524541), 
    ACE_NTOHL (0x444f4e4c), 
    ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
    
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_AttributeDescription),
    (char *) &_oc_CORBA_AttributeDescription,
    0,
    sizeof (CORBA::AttributeDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AttributeDescription,
    &_tc_TAO_tc_CORBA_AttributeDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::AttributeDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  AttributeDescription *tmp = ACE_static_cast (AttributeDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::AttributeDescription
    >;

template class
  TAO_Out_T<
      CORBA::AttributeDescription,
      CORBA::AttributeDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::AttributeDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::AttributeDescription, \
      CORBA::AttributeDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtAttributeDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x74417474), 
  ACE_NTOHL (0x72696275), 
  ACE_NTOHL (0x74654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDescription:1.0
    24,
  ACE_NTOHL (0x45787441), 
  ACE_NTOHL (0x74747269), 
  ACE_NTOHL (0x62757465), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ExtAttributeDescription
  8, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

  5,
  ACE_NTOHL (0x6d6f6465), 
  ACE_NTOHL (0x0),  // name = mode
    CORBA::tk_enum, // typecode kind
  104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4174), 
    ACE_NTOHL (0x74726962), 
    ACE_NTOHL (0x7574654d), 
    ACE_NTOHL (0x6f64653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
    14,
    ACE_NTOHL (0x41747472), 
    ACE_NTOHL (0x69627574), 
    ACE_NTOHL (0x654d6f64), 
    ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12,
    ACE_NTOHL (0x41545452), 
    ACE_NTOHL (0x5f4e4f52), 
    ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14,
    ACE_NTOHL (0x41545452), 
    ACE_NTOHL (0x5f524541), 
    ACE_NTOHL (0x444f4e4c), 
    ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
    
  15,
  ACE_NTOHL (0x6765745f), 
  ACE_NTOHL (0x65786365), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = get_exceptions
    CORBA::tk_alias, // typecode kind for typedefs
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x63446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
        18,
    ACE_NTOHL (0x45786344), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    196, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      180, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x63657074), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                21,
        ACE_NTOHL (0x45786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffd84, // negative offset (-636)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffdc8, // negative offset (-568)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffdb0, // negative offset (-592)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffe10, // negative offset (-496)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,


      0U,


  15,
  ACE_NTOHL (0x7075745f), 
  ACE_NTOHL (0x65786365), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = put_exceptions
    0xffffffff, // indirection
  0xfffffecc, // negative offset (-308)
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtAttributeDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ExtAttributeDescription),
    (char *) &_oc_CORBA_ExtAttributeDescription,
    0,
    sizeof (CORBA::ExtAttributeDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtAttributeDescription,
    &_tc_TAO_tc_CORBA_ExtAttributeDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::ExtAttributeDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtAttributeDescription *tmp = ACE_static_cast (ExtAttributeDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::ExtAttributeDescription
    >;

template class
  TAO_Out_T<
      CORBA::ExtAttributeDescription,
      CORBA::ExtAttributeDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::ExtAttributeDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::ExtAttributeDescription, \
      CORBA::ExtAttributeDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ExtAttributeDef::_tao_class_id = 0;

CORBA::ExtAttributeDef_ptr
CORBA::tao_ExtAttributeDef_life::tao_duplicate (
    ExtAttributeDef_ptr p
  )
{
  return ExtAttributeDef::_duplicate (p);
}

void
CORBA::tao_ExtAttributeDef_life::tao_release (
    ExtAttributeDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ExtAttributeDef_ptr
CORBA::tao_ExtAttributeDef_life::tao_nil (
    void
  )
{
  return ExtAttributeDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ExtAttributeDef_life::tao_marshal (
    ExtAttributeDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ExtAttributeDef_ptr
CORBA::tao_ExtAttributeDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ExtAttributeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ExtAttributeDef_cast::tao_upcast (
    void *src
  )
{
  ExtAttributeDef **tmp =
    ACE_static_cast (ExtAttributeDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ExtAttributeDef,
        CORBA::tao_ExtAttributeDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ExtAttributeDef,
        CORBA::tao_ExtAttributeDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ExtAttributeDef, \
        CORBA::tao_ExtAttributeDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ExtAttributeDef, \
        CORBA::tao_ExtAttributeDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExcDescriptionSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get &);
    
    ::CORBA::ExcDescriptionSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get::TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get::result (::CORBA::ExcDescriptionSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExcDescriptionSeq & get_exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set &);
    const CORBA::ExcDescriptionSeq & get_exceptions_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set::TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExcDescriptionSeq & get_exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      get_exceptions_ (get_exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->get_exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExcDescriptionSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get &);
    
    ::CORBA::ExcDescriptionSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get::TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get::result (::CORBA::ExcDescriptionSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExcDescriptionSeq & set_exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set &);
    const CORBA::ExcDescriptionSeq & set_exceptions_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set::TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExcDescriptionSeq & set_exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      set_exceptions_ (set_exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->set_exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExtAttributeDescription * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute &);
    
    ::CORBA::ExtAttributeDescription * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute::TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute::result (::CORBA::ExtAttributeDescription * result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ExtAttributeDef_Proxy_Impl::_TAO_ExtAttributeDef_Proxy_Impl (void)
{}

CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Impl::_TAO_ExtAttributeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExcDescriptionSeq * CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Impl::get_exceptions (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExcDescriptionSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ExcDescriptionSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ExcDescriptionSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_get_exceptions",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ExcDescriptionSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Impl::get_exceptions (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::ExcDescriptionSeq & get_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_get_exceptions",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtAttributeDef_get_exceptions_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          get_exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << get_exceptions)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExcDescriptionSeq * CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Impl::set_exceptions (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExcDescriptionSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ExcDescriptionSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ExcDescriptionSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_set_exceptions",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ExcDescriptionSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Impl::set_exceptions (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::ExcDescriptionSeq & set_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_set_exceptions",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtAttributeDef_set_exceptions_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          set_exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << set_exceptions)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExtAttributeDescription * CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Impl::describe_attribute (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExtAttributeDescription_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ExtAttributeDescription *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ExtAttributeDescription, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_attribute",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtAttributeDef_describe_attribute _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ExtAttributeDescription * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ExtAttributeDef_Proxy_Broker::_TAO_ExtAttributeDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAttributeDef_Proxy_Broker::~_TAO_ExtAttributeDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAttributeDef_Proxy_Broker * (*CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker *
CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker::the_TAO_ExtAttributeDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker::_TAO_ExtAttributeDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker::~_TAO_ExtAttributeDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAttributeDef_Proxy_Impl&
CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ExtAttributeDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ExtAttributeDef::ExtAttributeDef (int collocated)
{
  this->CORBA_ExtAttributeDef_setup_collocation (collocated);
}

void
CORBA::ExtAttributeDef::CORBA_ExtAttributeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExtAttributeDef_Proxy_Broker_ =
      ::CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExtAttributeDef_Proxy_Broker_ =
      ::CORBA::_TAO_ExtAttributeDef_Remote_Proxy_Broker::the_TAO_ExtAttributeDef_Remote_Proxy_Broker ();
  
  this->CORBA_AttributeDef_setup_collocation (collocated);
}

CORBA::ExtAttributeDef::~ExtAttributeDef (void)
{}

void 
CORBA::ExtAttributeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtAttributeDef *tmp = ACE_static_cast (ExtAttributeDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ExtAttributeDef_ptr
CORBA::ExtAttributeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtAttributeDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ExtAttributeDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ExtAttributeDef::_nil ());
      
      if (is_a == 0)
        {
          return ExtAttributeDef::_nil ();
        }
    }
  
  return ExtAttributeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ExtAttributeDef_ptr 
CORBA::ExtAttributeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtAttributeDef::_nil ();
    }
  
  ExtAttributeDef_ptr default_proxy = ExtAttributeDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ExtAttributeDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ExtAttributeDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtAttributeDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ExtAttributeDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtAttributeDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ExtAttributeDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ExtAttributeDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ExtAttributeDef::_tao_class_id
                )
            )
        );
}

CORBA::ExtAttributeDef_ptr
CORBA::ExtAttributeDef::_duplicate (ExtAttributeDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ExtAttributeDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtAttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ExtAttributeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ExtAttributeDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, AttributeDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::AttributeDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ExtAttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAttributeDef:1.0";
}

CORBA::Boolean
CORBA::ExtAttributeDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ExcDescriptionSeq * CORBA::ExtAttributeDef::get_exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExtAttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExtAttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtAttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_exceptions (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ExtAttributeDef::get_exceptions (
    const CORBA::ExcDescriptionSeq & get_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExtAttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExtAttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtAttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.get_exceptions (
      this,
      get_exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ExcDescriptionSeq * CORBA::ExtAttributeDef::set_exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExtAttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExtAttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtAttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.set_exceptions (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::ExtAttributeDef::set_exceptions (
    const CORBA::ExcDescriptionSeq & set_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExtAttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExtAttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtAttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_exceptions (
      this,
      set_exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ExtAttributeDescription * CORBA::ExtAttributeDef::describe_attribute (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_ExtAttributeDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_ExtAttributeDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtAttributeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_attribute (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtAttributeDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x74417474), 
  ACE_NTOHL (0x72696275), 
  ACE_NTOHL (0x74654465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDef:1.0
    16,
  ACE_NTOHL (0x45787441), 
  ACE_NTOHL (0x74747269), 
  ACE_NTOHL (0x62757465), 
  ACE_NTOHL (0x44656600),  // name = ExtAttributeDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtAttributeDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ExtAttributeDef),
    (char *) &_oc_CORBA_ExtAttributeDef,
    0,
    sizeof (CORBA::ExtAttributeDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtAttributeDef,
    &_tc_TAO_tc_CORBA_ExtAttributeDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_OperationMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4f70), 
  ACE_NTOHL (0x65726174), 
  ACE_NTOHL (0x696f6e4d), 
  ACE_NTOHL (0x6f64653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
  14,
  ACE_NTOHL (0x4f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e4d6f64), 
  ACE_NTOHL (0x65000000),  // name = OperationMode
  2, // member count
  10,
  ACE_NTOHL (0x4f505f4e), 
  ACE_NTOHL (0x4f524d41), 
  ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
  10,
  ACE_NTOHL (0x4f505f4f), 
  ACE_NTOHL (0x4e455741), 
  ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationMode (
    CORBA::tk_enum,
    sizeof (_oc_CORBA_OperationMode),
    (char *) &_oc_CORBA_OperationMode,
    0,
    sizeof (CORBA::OperationMode)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_OperationMode,
    &_tc_TAO_tc_CORBA_OperationMode
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ParameterDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5061), 
  ACE_NTOHL (0x72616d65), 
  ACE_NTOHL (0x74657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
    21,
  ACE_NTOHL (0x50617261), 
  ACE_NTOHL (0x6d657465), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ParameterDescription
  4, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

  9,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f646566), 
  ACE_NTOHL (0x0),  // name = type_def
    CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4944), 
    ACE_NTOHL (0x4c547970), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8,
    ACE_NTOHL (0x49444c54), 
    ACE_NTOHL (0x79706500),  // name = IDLType
    
  5,
  ACE_NTOHL (0x6d6f6465), 
  ACE_NTOHL (0x0),  // name = mode
    CORBA::tk_enum, // typecode kind
  116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5061), 
    ACE_NTOHL (0x72616d65), 
    ACE_NTOHL (0x7465724d), 
    ACE_NTOHL (0x6f64653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
    14,
    ACE_NTOHL (0x50617261), 
    ACE_NTOHL (0x6d657465), 
    ACE_NTOHL (0x724d6f64), 
    ACE_NTOHL (0x65000000),  // name = ParameterMode
    3, // member count
    9,
    ACE_NTOHL (0x50415241), 
    ACE_NTOHL (0x4d5f494e), 
    ACE_NTOHL (0x0),  // name = PARAM_IN
    10,
    ACE_NTOHL (0x50415241), 
    ACE_NTOHL (0x4d5f4f55), 
    ACE_NTOHL (0x54000000),  // name = PARAM_OUT
    12,
    ACE_NTOHL (0x50415241), 
    ACE_NTOHL (0x4d5f494e), 
    ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
    
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ParameterDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ParameterDescription),
    (char *) &_oc_CORBA_ParameterDescription,
    0,
    sizeof (CORBA::ParameterDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ParameterDescription,
    &_tc_TAO_tc_CORBA_ParameterDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::ParameterDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ParameterDescription *tmp = ACE_static_cast (ParameterDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::ParameterDescription
    >;

template class
  TAO_Out_T<
      CORBA::ParameterDescription,
      CORBA::ParameterDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::ParameterDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::ParameterDescription, \
      CORBA::ParameterDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_PARDESCRIPTIONSEQ_CS_)
#define _CORBA_PARDESCRIPTIONSEQ_CS_

CORBA::ParDescriptionSeq::ParDescriptionSeq (void)
{}

CORBA::ParDescriptionSeq::ParDescriptionSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        CORBA::ParameterDescription
      >
    (max)
{}

CORBA::ParDescriptionSeq::ParDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ParameterDescription * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        CORBA::ParameterDescription
      >
    (max, length, buffer, release)
{}

CORBA::ParDescriptionSeq::ParDescriptionSeq (
    const ParDescriptionSeq &seq
  )
  : TAO_Unbounded_Sequence<
        CORBA::ParameterDescription
      >
    (seq)
{}

CORBA::ParDescriptionSeq::~ParDescriptionSeq (void)
{}

void CORBA::ParDescriptionSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  ParDescriptionSeq * tmp =
    ACE_static_cast (
        ParDescriptionSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_VarSeq_Var_T<
      CORBA::ParDescriptionSeq,
      CORBA::ParameterDescription
    >;

template class
  TAO_Seq_Out_T<
      CORBA::ParDescriptionSeq,
      CORBA::ParDescriptionSeq_var,
      CORBA::ParameterDescription
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_VarSeq_Var_T< \
      ParDescriptionSeq, \
      CORBA::ParameterDescription \
    >

# pragma instantiate \
  TAO_Seq_Out_T< \
      ParDescriptionSeq, \
      ParDescriptionSeq_var, \
      CORBA::ParameterDescription \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ParDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5061), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
    18,
  ACE_NTOHL (0x50617244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e5365), 
  ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  416, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    400, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5061), 
      ACE_NTOHL (0x72616d65), 
      ACE_NTOHL (0x74657244), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
            21,
      ACE_NTOHL (0x50617261), 
      ACE_NTOHL (0x6d657465), 
      ACE_NTOHL (0x72446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = ParameterDescription
      4, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      5,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

      9,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x5f646566), 
      ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4944), 
        ACE_NTOHL (0x4c547970), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8,
        ACE_NTOHL (0x49444c54), 
        ACE_NTOHL (0x79706500),  // name = IDLType
        
      5,
      ACE_NTOHL (0x6d6f6465), 
      ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
      116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5061), 
        ACE_NTOHL (0x72616d65), 
        ACE_NTOHL (0x7465724d), 
        ACE_NTOHL (0x6f64653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
        14,
        ACE_NTOHL (0x50617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x724d6f64), 
        ACE_NTOHL (0x65000000),  // name = ParameterMode
        3, // member count
        9,
        ACE_NTOHL (0x50415241), 
        ACE_NTOHL (0x4d5f494e), 
        ACE_NTOHL (0x0),  // name = PARAM_IN
        10,
        ACE_NTOHL (0x50415241), 
        ACE_NTOHL (0x4d5f4f55), 
        ACE_NTOHL (0x54000000),  // name = PARAM_OUT
        12,
        ACE_NTOHL (0x50415241), 
        ACE_NTOHL (0x4d5f494e), 
        ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
        

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ParDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ParDescriptionSeq),
    (char *) &_oc_CORBA_ParDescriptionSeq,
    0,
    sizeof (CORBA::ParDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ParDescriptionSeq,
    &_tc_TAO_tc_CORBA_ParDescriptionSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ContextIdentifier[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746578), 
  ACE_NTOHL (0x74496465), 
  ACE_NTOHL (0x6e746966), 
  ACE_NTOHL (0x6965723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
    18,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x65787449), 
  ACE_NTOHL (0x64656e74), 
  ACE_NTOHL (0x69666965), 
  ACE_NTOHL (0x72000000),  // name = ContextIdentifier
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ContextIdentifier (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ContextIdentifier),
    (char *) &_oc_CORBA_ContextIdentifier,
    0,
    sizeof (CORBA::ContextIdentifier)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ContextIdentifier,
    &_tc_TAO_tc_CORBA_ContextIdentifier
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_CONTEXTIDSEQ_CS_)
#define _CORBA_CONTEXTIDSEQ_CS_

CORBA::ContextIdSeq::ContextIdSeq (void)
{}

CORBA::ContextIdSeq::ContextIdSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_String_Sequence
    (max)
{}

CORBA::ContextIdSeq::ContextIdSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    char * * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_String_Sequence
    (max, length, buffer, release)
{}

CORBA::ContextIdSeq::ContextIdSeq (
    const ContextIdSeq &seq
  )
  : TAO_Unbounded_String_Sequence
    (seq)
{}

CORBA::ContextIdSeq::~ContextIdSeq (void)
{}

void CORBA::ContextIdSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  ContextIdSeq * tmp =
    ACE_static_cast (
        ContextIdSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_MngSeq_Var_T<
      CORBA::ContextIdSeq,
      TAO_SeqElem_String_Manager
    >;

template class
  TAO_MngSeq_Out_T<
      CORBA::ContextIdSeq,
      CORBA::ContextIdSeq_var,
      TAO_SeqElem_String_Manager
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_MngSeq_Var_T< \
      CORBA::ContextIdSeq, \
      TAO_SeqElem_String_Manager \
    >

# pragma instantiate \
  TAO_MngSeq_Out_T< \
      CORBA::ContextIdSeq, \
      CORBA::ContextIdSeq_var, \
      TAO_SeqElem_String_Manager \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ContextIdSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746578), 
  ACE_NTOHL (0x74496453), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
    13,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x65787449), 
  ACE_NTOHL (0x64536571), 
  ACE_NTOHL (0x0),  // name = ContextIdSeq
    CORBA::tk_sequence, // typecode kind
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    148, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6e746578), 
      ACE_NTOHL (0x74496465), 
      ACE_NTOHL (0x6e746966), 
      ACE_NTOHL (0x6965723a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
            18,
      ACE_NTOHL (0x436f6e74), 
      ACE_NTOHL (0x65787449), 
      ACE_NTOHL (0x64656e74), 
      ACE_NTOHL (0x69666965), 
      ACE_NTOHL (0x72000000),  // name = ContextIdentifier
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ContextIdSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ContextIdSeq),
    (char *) &_oc_CORBA_ContextIdSeq,
    0,
    sizeof (CORBA::ContextIdSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ContextIdSeq,
    &_tc_TAO_tc_CORBA_ContextIdSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::OperationDef::_tao_class_id = 0;

CORBA::OperationDef_ptr
CORBA::tao_OperationDef_life::tao_duplicate (
    OperationDef_ptr p
  )
{
  return OperationDef::_duplicate (p);
}

void
CORBA::tao_OperationDef_life::tao_release (
    OperationDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::OperationDef_ptr
CORBA::tao_OperationDef_life::tao_nil (
    void
  )
{
  return OperationDef::_nil ();
}

CORBA::Boolean
CORBA::tao_OperationDef_life::tao_marshal (
    OperationDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::OperationDef_ptr
CORBA::tao_OperationDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return OperationDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_OperationDef_cast::tao_upcast (
    void *src
  )
{
  OperationDef **tmp =
    ACE_static_cast (OperationDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::OperationDef,
        CORBA::tao_OperationDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::OperationDef,
        CORBA::tao_OperationDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::OperationDef, \
        CORBA::tao_OperationDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::OperationDef, \
        CORBA::tao_OperationDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_result_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_result_get (const TAO_ClientRequestInfo_CORBA_OperationDef_result_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_result_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_result_get::TAO_ClientRequestInfo_CORBA_OperationDef_result_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_OperationDef_result_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr result_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set &);
    CORBA::IDLType_ptr result_def_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr result_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      result_def_ (result_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->result_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_params_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_params_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ParDescriptionSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_params_get (const TAO_ClientRequestInfo_CORBA_OperationDef_params_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_params_get &);
    
    ::CORBA::ParDescriptionSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_params_get::TAO_ClientRequestInfo_CORBA_OperationDef_params_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_OperationDef_params_get::result (::CORBA::ParDescriptionSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_params_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_params_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ParDescriptionSeq & params
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_params_set (const TAO_ClientRequestInfo_CORBA_OperationDef_params_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_params_set &);
    const CORBA::ParDescriptionSeq & params_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_params_set::TAO_ClientRequestInfo_CORBA_OperationDef_params_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ParDescriptionSeq & params
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      params_ (params)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_params_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_params_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_mode_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::OperationMode result);
    
  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_mode_get (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_get &);
    
    ::CORBA::OperationMode _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::TAO_ClientRequestInfo_CORBA_OperationDef_mode_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_OperationDef_mode_get::result (::CORBA::OperationMode result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_mode_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::OperationMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_mode_set (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_mode_set &);
    const CORBA::OperationMode & mode_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::TAO_ClientRequestInfo_CORBA_OperationDef_mode_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::OperationMode & mode
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_mode_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ContextIdSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get &);
    
    ::CORBA::ContextIdSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get::result (::CORBA::ContextIdSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set &);
    const CORBA::ContextIdSeq & contexts_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExceptionDefSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get &);
    
    ::CORBA::ExceptionDefSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get::result (::CORBA::ExceptionDefSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set &);
    const CORBA::ExceptionDefSeq & exceptions_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_OperationDef_Proxy_Impl::_TAO_OperationDef_Proxy_Impl (void)
{}

CORBA::_TAO_OperationDef_Remote_Proxy_Impl::_TAO_OperationDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_OperationDef_Remote_Proxy_Impl::result (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result",
      11,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_result_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_OperationDef_Remote_Proxy_Impl::result_def (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result_def",
      15,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_result_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::IDLType_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_OperationDef_Remote_Proxy_Impl::result_def (
    CORBA::Object *_collocated_tao_target_,
    CORBA::IDLType_ptr result_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_result_def",
      15,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_result_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          result_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << result_def)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ParDescriptionSeq * CORBA::_TAO_OperationDef_Remote_Proxy_Impl::params (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ParDescriptionSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ParDescriptionSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ParDescriptionSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_params",
      11,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_params_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ParDescriptionSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_OperationDef_Remote_Proxy_Impl::params (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::ParDescriptionSeq & params
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_params",
      11,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_params_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          params
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << params)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::OperationMode CORBA::_TAO_OperationDef_Remote_Proxy_Impl::mode (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::OperationMode _tao_retval = (CORBA::OperationMode)0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_mode_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::OperationMode _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_OperationDef_Remote_Proxy_Impl::mode (
    CORBA::Object *_collocated_tao_target_,
    CORBA::OperationMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_mode_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          mode
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << mode)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ContextIdSeq * CORBA::_TAO_OperationDef_Remote_Proxy_Impl::contexts (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ContextIdSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ContextIdSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ContextIdSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_contexts",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_contexts_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ContextIdSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_OperationDef_Remote_Proxy_Impl::contexts (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_contexts",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_contexts_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          contexts
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << contexts)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExceptionDefSeq * CORBA::_TAO_OperationDef_Remote_Proxy_Impl::exceptions (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExceptionDefSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ExceptionDefSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ExceptionDefSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_exceptions",
      15,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ExceptionDefSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_OperationDef_Remote_Proxy_Impl::exceptions (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_exceptions",
      15,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_OperationDef_exceptions_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << exceptions)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_OperationDef_Proxy_Broker::_TAO_OperationDef_Proxy_Broker (void)
{
}

CORBA::_TAO_OperationDef_Proxy_Broker::~_TAO_OperationDef_Proxy_Broker (void)
{
}

CORBA::_TAO_OperationDef_Proxy_Broker * (*CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_OperationDef_Remote_Proxy_Broker *
CORBA::_TAO_OperationDef_Remote_Proxy_Broker::the_TAO_OperationDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_OperationDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_OperationDef_Remote_Proxy_Broker::_TAO_OperationDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_OperationDef_Remote_Proxy_Broker::~_TAO_OperationDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_OperationDef_Proxy_Impl&
CORBA::_TAO_OperationDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::OperationDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::OperationDef::OperationDef (int collocated)
{
  this->CORBA_OperationDef_setup_collocation (collocated);
}

void
CORBA::OperationDef::CORBA_OperationDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_OperationDef_Proxy_Broker_ =
      ::CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_OperationDef_Proxy_Broker_ =
      ::CORBA::_TAO_OperationDef_Remote_Proxy_Broker::the_TAO_OperationDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::OperationDef::~OperationDef (void)
{}

void 
CORBA::OperationDef::_tao_any_destructor (void *_tao_void_pointer)
{
  OperationDef *tmp = ACE_static_cast (OperationDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::OperationDef_ptr
CORBA::OperationDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return OperationDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/OperationDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (OperationDef::_nil ());
      
      if (is_a == 0)
        {
          return OperationDef::_nil ();
        }
    }
  
  return OperationDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::OperationDef_ptr 
CORBA::OperationDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return OperationDef::_nil ();
    }
  
  OperationDef_ptr default_proxy = OperationDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::OperationDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          OperationDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::OperationDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              OperationDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::OperationDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              OperationDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          OperationDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &OperationDef::_tao_class_id
                )
            )
        );
}

CORBA::OperationDef_ptr
CORBA::OperationDef::_duplicate (OperationDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::OperationDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::OperationDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, OperationDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

CORBA::Boolean
CORBA::OperationDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::OperationDef::result (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.result (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::OperationDef::result_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.result_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::OperationDef::result_def (
    CORBA::IDLType_ptr result_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.result_def (
      this,
      result_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ParDescriptionSeq * CORBA::OperationDef::params (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.params (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::OperationDef::params (
    const CORBA::ParDescriptionSeq & params
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.params (
      this,
      params
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::OperationMode CORBA::OperationDef::mode (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::OperationMode)0);
  
  return proxy.mode (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::OperationDef::mode (
    CORBA::OperationMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.mode (
      this,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ContextIdSeq * CORBA::OperationDef::contexts (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.contexts (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::OperationDef::contexts (
    const CORBA::ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.contexts (
      this,
      contexts
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ExceptionDefSeq * CORBA::OperationDef::exceptions (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.exceptions (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::OperationDef::exceptions (
    const CORBA::ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_OperationDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_OperationDef_Proxy_Impl &proxy = 
    this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.exceptions (
      this,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_OperationDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4f70), 
  ACE_NTOHL (0x65726174), 
  ACE_NTOHL (0x696f6e44), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDef:1.0
    13,
  ACE_NTOHL (0x4f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e446566), 
  ACE_NTOHL (0x0),  // name = OperationDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_OperationDef),
    (char *) &_oc_CORBA_OperationDef,
    0,
    sizeof (CORBA::OperationDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_OperationDef,
    &_tc_TAO_tc_CORBA_OperationDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_OperationDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4f70), 
  ACE_NTOHL (0x65726174), 
  ACE_NTOHL (0x696f6e44), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
    21,
  ACE_NTOHL (0x4f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = OperationDescription
  9, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  7,
  ACE_NTOHL (0x72657375), 
  ACE_NTOHL (0x6c740000),  // name = result
    CORBA::tk_TypeCode,

  5,
  ACE_NTOHL (0x6d6f6465), 
  ACE_NTOHL (0x0),  // name = mode
    CORBA::tk_enum, // typecode kind
  100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
    36,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f70), 
    ACE_NTOHL (0x65726174), 
    ACE_NTOHL (0x696f6e4d), 
    ACE_NTOHL (0x6f64653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
    14,
    ACE_NTOHL (0x4f706572), 
    ACE_NTOHL (0x6174696f), 
    ACE_NTOHL (0x6e4d6f64), 
    ACE_NTOHL (0x65000000),  // name = OperationMode
    2, // member count
    10,
    ACE_NTOHL (0x4f505f4e), 
    ACE_NTOHL (0x4f524d41), 
    ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
    10,
    ACE_NTOHL (0x4f505f4f), 
    ACE_NTOHL (0x4e455741), 
    ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
    
  9,
  ACE_NTOHL (0x636f6e74), 
  ACE_NTOHL (0x65787473), 
  ACE_NTOHL (0x0),  // name = contexts
    CORBA::tk_alias, // typecode kind for typedefs
  168, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f436f), 
    ACE_NTOHL (0x6e746578), 
    ACE_NTOHL (0x74496453), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
        13,
    ACE_NTOHL (0x436f6e74), 
    ACE_NTOHL (0x65787449), 
    ACE_NTOHL (0x64536571), 
    ACE_NTOHL (0x0),  // name = ContextIdSeq
        CORBA::tk_sequence, // typecode kind
    96, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6e746578), 
        ACE_NTOHL (0x74496465), 
        ACE_NTOHL (0x6e746966), 
        ACE_NTOHL (0x6965723a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                18,
        ACE_NTOHL (0x436f6e74), 
        ACE_NTOHL (0x65787449), 
        ACE_NTOHL (0x64656e74), 
        ACE_NTOHL (0x69666965), 
        ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                0xffffffff, // indirection
        0xfffffdac, // negative offset (-596)

      0U,


  11,
  ACE_NTOHL (0x70617261), 
  ACE_NTOHL (0x6d657465), 
  ACE_NTOHL (0x72730000),  // name = parameters
    CORBA::tk_alias, // typecode kind for typedefs
  428, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5061), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
        18,
    ACE_NTOHL (0x50617244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    348, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      332, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5061), 
        ACE_NTOHL (0x72616d65), 
        ACE_NTOHL (0x74657244), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                21,
        ACE_NTOHL (0x50617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = ParameterDescription
        4, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffccc, // negative offset (-820)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        9,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f646566), 
        ACE_NTOHL (0x0),  // name = type_def
                CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4944), 
          ACE_NTOHL (0x4c547970), 
          ACE_NTOHL (0x653a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                    8,
          ACE_NTOHL (0x49444c54), 
          ACE_NTOHL (0x79706500),  // name = IDLType
          
        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5061), 
          ACE_NTOHL (0x72616d65), 
          ACE_NTOHL (0x7465724d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
          14,
          ACE_NTOHL (0x50617261), 
          ACE_NTOHL (0x6d657465), 
          ACE_NTOHL (0x724d6f64), 
          ACE_NTOHL (0x65000000),  // name = ParameterMode
          3, // member count
          9,
          ACE_NTOHL (0x50415241), 
          ACE_NTOHL (0x4d5f494e), 
          ACE_NTOHL (0x0),  // name = PARAM_IN
          10,
          ACE_NTOHL (0x50415241), 
          ACE_NTOHL (0x4d5f4f55), 
          ACE_NTOHL (0x54000000),  // name = PARAM_OUT
          12,
          ACE_NTOHL (0x50415241), 
          ACE_NTOHL (0x4d5f494e), 
          ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
          

      0U,


  11,
  ACE_NTOHL (0x65786365), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = exceptions
    CORBA::tk_alias, // typecode kind for typedefs
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x63446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
        18,
    ACE_NTOHL (0x45786344), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    196, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      180, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x63657074), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                21,
        ACE_NTOHL (0x45786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffb08, // negative offset (-1272)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffb4c, // negative offset (-1204)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffb34, // negative offset (-1228)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffb94, // negative offset (-1132)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,


      0U,


};

static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_OperationDescription),
    (char *) &_oc_CORBA_OperationDescription,
    0,
    sizeof (CORBA::OperationDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_OperationDescription,
    &_tc_TAO_tc_CORBA_OperationDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::OperationDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  OperationDescription *tmp = ACE_static_cast (OperationDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::OperationDescription
    >;

template class
  TAO_Out_T<
      CORBA::OperationDescription,
      CORBA::OperationDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::OperationDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::OperationDescription, \
      CORBA::OperationDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_REPOSITORYIDSEQ_CS_)
#define _CORBA_REPOSITORYIDSEQ_CS_

CORBA::RepositoryIdSeq::RepositoryIdSeq (void)
{}

CORBA::RepositoryIdSeq::RepositoryIdSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_String_Sequence
    (max)
{}

CORBA::RepositoryIdSeq::RepositoryIdSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    char * * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_String_Sequence
    (max, length, buffer, release)
{}

CORBA::RepositoryIdSeq::RepositoryIdSeq (
    const RepositoryIdSeq &seq
  )
  : TAO_Unbounded_String_Sequence
    (seq)
{}

CORBA::RepositoryIdSeq::~RepositoryIdSeq (void)
{}

void CORBA::RepositoryIdSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  RepositoryIdSeq * tmp =
    ACE_static_cast (
        RepositoryIdSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_MngSeq_Var_T<
      CORBA::RepositoryIdSeq,
      TAO_SeqElem_String_Manager
    >;

template class
  TAO_MngSeq_Out_T<
      CORBA::RepositoryIdSeq,
      CORBA::RepositoryIdSeq_var,
      TAO_SeqElem_String_Manager
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_MngSeq_Var_T< \
      CORBA::RepositoryIdSeq, \
      TAO_SeqElem_String_Manager \
    >

# pragma instantiate \
  TAO_MngSeq_Out_T< \
      CORBA::RepositoryIdSeq, \
      CORBA::RepositoryIdSeq_var, \
      TAO_SeqElem_String_Manager \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_RepositoryIdSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5265), 
  ACE_NTOHL (0x706f7369), 
  ACE_NTOHL (0x746f7279), 
  ACE_NTOHL (0x49645365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16,
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72794964), 
  ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryIdSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_RepositoryIdSeq),
    (char *) &_oc_CORBA_RepositoryIdSeq,
    0,
    sizeof (CORBA::RepositoryIdSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_RepositoryIdSeq,
    &_tc_TAO_tc_CORBA_RepositoryIdSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_OPDESCRIPTIONSEQ_CS_)
#define _CORBA_OPDESCRIPTIONSEQ_CS_

CORBA::OpDescriptionSeq::OpDescriptionSeq (void)
{}

CORBA::OpDescriptionSeq::OpDescriptionSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        CORBA::OperationDescription
      >
    (max)
{}

CORBA::OpDescriptionSeq::OpDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::OperationDescription * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        CORBA::OperationDescription
      >
    (max, length, buffer, release)
{}

CORBA::OpDescriptionSeq::OpDescriptionSeq (
    const OpDescriptionSeq &seq
  )
  : TAO_Unbounded_Sequence<
        CORBA::OperationDescription
      >
    (seq)
{}

CORBA::OpDescriptionSeq::~OpDescriptionSeq (void)
{}

void CORBA::OpDescriptionSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  OpDescriptionSeq * tmp =
    ACE_static_cast (
        OpDescriptionSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_VarSeq_Var_T<
      CORBA::OpDescriptionSeq,
      CORBA::OperationDescription
    >;

template class
  TAO_Seq_Out_T<
      CORBA::OpDescriptionSeq,
      CORBA::OpDescriptionSeq_var,
      CORBA::OperationDescription
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_VarSeq_Var_T< \
      OpDescriptionSeq, \
      CORBA::OperationDescription \
    >

# pragma instantiate \
  TAO_Seq_Out_T< \
      OpDescriptionSeq, \
      OpDescriptionSeq_var, \
      CORBA::OperationDescription \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_OpDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4f70), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17,
  ACE_NTOHL (0x4f704465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e536571), 
  ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  1468, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    1452, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4f70), 
      ACE_NTOHL (0x65726174), 
      ACE_NTOHL (0x696f6e44), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
            21,
      ACE_NTOHL (0x4f706572), 
      ACE_NTOHL (0x6174696f), 
      ACE_NTOHL (0x6e446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = OperationDescription
      9, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      7,
      ACE_NTOHL (0x72657375), 
      ACE_NTOHL (0x6c740000),  // name = result
            CORBA::tk_TypeCode,

      5,
      ACE_NTOHL (0x6d6f6465), 
      ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
      100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e4d), 
        ACE_NTOHL (0x6f64653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
        14,
        ACE_NTOHL (0x4f706572), 
        ACE_NTOHL (0x6174696f), 
        ACE_NTOHL (0x6e4d6f64), 
        ACE_NTOHL (0x65000000),  // name = OperationMode
        2, // member count
        10,
        ACE_NTOHL (0x4f505f4e), 
        ACE_NTOHL (0x4f524d41), 
        ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
        10,
        ACE_NTOHL (0x4f505f4f), 
        ACE_NTOHL (0x4e455741), 
        ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
        
      9,
      ACE_NTOHL (0x636f6e74), 
      ACE_NTOHL (0x65787473), 
      ACE_NTOHL (0x0),  // name = contexts
            CORBA::tk_alias, // typecode kind for typedefs
      168, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6e746578), 
        ACE_NTOHL (0x74496453), 
        ACE_NTOHL (0x65713a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
                13,
        ACE_NTOHL (0x436f6e74), 
        ACE_NTOHL (0x65787449), 
        ACE_NTOHL (0x64536571), 
        ACE_NTOHL (0x0),  // name = ContextIdSeq
                CORBA::tk_sequence, // typecode kind
        96, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_alias, // typecode kind for typedefs
          80, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f436f), 
            ACE_NTOHL (0x6e746578), 
            ACE_NTOHL (0x74496465), 
            ACE_NTOHL (0x6e746966), 
            ACE_NTOHL (0x6965723a), 
            ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                        18,
            ACE_NTOHL (0x436f6e74), 
            ACE_NTOHL (0x65787449), 
            ACE_NTOHL (0x64656e74), 
            ACE_NTOHL (0x69666965), 
            ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                        0xffffffff, // indirection
            0xfffffdac, // negative offset (-596)

          0U,


      11,
      ACE_NTOHL (0x70617261), 
      ACE_NTOHL (0x6d657465), 
      ACE_NTOHL (0x72730000),  // name = parameters
            CORBA::tk_alias, // typecode kind for typedefs
      428, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5061), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x5365713a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
                18,
        ACE_NTOHL (0x50617244), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e5365), 
        ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
                CORBA::tk_sequence, // typecode kind
        348, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          332, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f5061), 
            ACE_NTOHL (0x72616d65), 
            ACE_NTOHL (0x74657244), 
            ACE_NTOHL (0x65736372), 
            ACE_NTOHL (0x69707469), 
            ACE_NTOHL (0x6f6e3a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                        21,
            ACE_NTOHL (0x50617261), 
            ACE_NTOHL (0x6d657465), 
            ACE_NTOHL (0x72446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x0),  // name = ParameterDescription
            4, // member count
                        5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
                        0xffffffff, // indirection
            0xfffffccc, // negative offset (-820)
            5,
            ACE_NTOHL (0x74797065), 
            ACE_NTOHL (0x0),  // name = type
                        CORBA::tk_TypeCode,

            9,
            ACE_NTOHL (0x74797065), 
            ACE_NTOHL (0x5f646566), 
            ACE_NTOHL (0x0),  // name = type_def
                        CORBA::tk_objref, // typecode kind
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4944), 
              ACE_NTOHL (0x4c547970), 
              ACE_NTOHL (0x653a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                            8,
              ACE_NTOHL (0x49444c54), 
              ACE_NTOHL (0x79706500),  // name = IDLType
              
            5,
            ACE_NTOHL (0x6d6f6465), 
            ACE_NTOHL (0x0),  // name = mode
                        CORBA::tk_enum, // typecode kind
            116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
              36,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x7465724d), 
              ACE_NTOHL (0x6f64653a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
              14,
              ACE_NTOHL (0x50617261), 
              ACE_NTOHL (0x6d657465), 
              ACE_NTOHL (0x724d6f64), 
              ACE_NTOHL (0x65000000),  // name = ParameterMode
              3, // member count
              9,
              ACE_NTOHL (0x50415241), 
              ACE_NTOHL (0x4d5f494e), 
              ACE_NTOHL (0x0),  // name = PARAM_IN
              10,
              ACE_NTOHL (0x50415241), 
              ACE_NTOHL (0x4d5f4f55), 
              ACE_NTOHL (0x54000000),  // name = PARAM_OUT
              12,
              ACE_NTOHL (0x50415241), 
              ACE_NTOHL (0x4d5f494e), 
              ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
              

          0U,


      11,
      ACE_NTOHL (0x65786365), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e730000),  // name = exceptions
            CORBA::tk_alias, // typecode kind for typedefs
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x63446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x5365713a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                18,
        ACE_NTOHL (0x45786344), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e5365), 
        ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                CORBA::tk_sequence, // typecode kind
        196, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          180, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f4578), 
            ACE_NTOHL (0x63657074), 
            ACE_NTOHL (0x696f6e44), 
            ACE_NTOHL (0x65736372), 
            ACE_NTOHL (0x69707469), 
            ACE_NTOHL (0x6f6e3a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                        21,
            ACE_NTOHL (0x45786365), 
            ACE_NTOHL (0x7074696f), 
            ACE_NTOHL (0x6e446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
                        5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
                        0xffffffff, // indirection
            0xfffffb08, // negative offset (-1272)
            3,
            ACE_NTOHL (0x69640000),  // name = id
                        0xffffffff, // indirection
            0xfffffb4c, // negative offset (-1204)
            11,
            ACE_NTOHL (0x64656669), 
            ACE_NTOHL (0x6e65645f), 
            ACE_NTOHL (0x696e0000),  // name = defined_in
                        0xffffffff, // indirection
            0xfffffb34, // negative offset (-1228)
            8,
            ACE_NTOHL (0x76657273), 
            ACE_NTOHL (0x696f6e00),  // name = version
                        0xffffffff, // indirection
            0xfffffb94, // negative offset (-1132)
            5,
            ACE_NTOHL (0x74797065), 
            ACE_NTOHL (0x0),  // name = type
                        CORBA::tk_TypeCode,


          0U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_OpDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_OpDescriptionSeq),
    (char *) &_oc_CORBA_OpDescriptionSeq,
    0,
    sizeof (CORBA::OpDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_OpDescriptionSeq,
    &_tc_TAO_tc_CORBA_OpDescriptionSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define _CORBA_ATTRDESCRIPTIONSEQ_CS_

CORBA::AttrDescriptionSeq::AttrDescriptionSeq (void)
{}

CORBA::AttrDescriptionSeq::AttrDescriptionSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        CORBA::AttributeDescription
      >
    (max)
{}

CORBA::AttrDescriptionSeq::AttrDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::AttributeDescription * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        CORBA::AttributeDescription
      >
    (max, length, buffer, release)
{}

CORBA::AttrDescriptionSeq::AttrDescriptionSeq (
    const AttrDescriptionSeq &seq
  )
  : TAO_Unbounded_Sequence<
        CORBA::AttributeDescription
      >
    (seq)
{}

CORBA::AttrDescriptionSeq::~AttrDescriptionSeq (void)
{}

void CORBA::AttrDescriptionSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  AttrDescriptionSeq * tmp =
    ACE_static_cast (
        AttrDescriptionSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_VarSeq_Var_T<
      CORBA::AttrDescriptionSeq,
      CORBA::AttributeDescription
    >;

template class
  TAO_Seq_Out_T<
      CORBA::AttrDescriptionSeq,
      CORBA::AttrDescriptionSeq_var,
      CORBA::AttributeDescription
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_VarSeq_Var_T< \
      AttrDescriptionSeq, \
      CORBA::AttributeDescription \
    >

# pragma instantiate \
  TAO_Seq_Out_T< \
      AttrDescriptionSeq, \
      AttrDescriptionSeq_var, \
      CORBA::AttributeDescription \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_AttrDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4174), 
  ACE_NTOHL (0x74724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19,
  ACE_NTOHL (0x41747472), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  528, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    512, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4174), 
      ACE_NTOHL (0x74726962), 
      ACE_NTOHL (0x75746544), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
            21,
      ACE_NTOHL (0x41747472), 
      ACE_NTOHL (0x69627574), 
      ACE_NTOHL (0x65446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = AttributeDescription
      6, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      5,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

      5,
      ACE_NTOHL (0x6d6f6465), 
      ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
      104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x7574654d), 
        ACE_NTOHL (0x6f64653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
        14,
        ACE_NTOHL (0x41747472), 
        ACE_NTOHL (0x69627574), 
        ACE_NTOHL (0x654d6f64), 
        ACE_NTOHL (0x65000000),  // name = AttributeMode
        2, // member count
        12,
        ACE_NTOHL (0x41545452), 
        ACE_NTOHL (0x5f4e4f52), 
        ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
        14,
        ACE_NTOHL (0x41545452), 
        ACE_NTOHL (0x5f524541), 
        ACE_NTOHL (0x444f4e4c), 
        ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
        

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_AttrDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_AttrDescriptionSeq),
    (char *) &_oc_CORBA_AttrDescriptionSeq,
    0,
    sizeof (CORBA::AttrDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AttrDescriptionSeq,
    &_tc_TAO_tc_CORBA_AttrDescriptionSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_CORBA_EXTATTRDESCRIPTIONSEQ_CS_)
#define _CORBA_EXTATTRDESCRIPTIONSEQ_CS_

CORBA::ExtAttrDescriptionSeq::ExtAttrDescriptionSeq (void)
{}

CORBA::ExtAttrDescriptionSeq::ExtAttrDescriptionSeq (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        CORBA::ExtAttributeDescription
      >
    (max)
{}

CORBA::ExtAttrDescriptionSeq::ExtAttrDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ExtAttributeDescription * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        CORBA::ExtAttributeDescription
      >
    (max, length, buffer, release)
{}

CORBA::ExtAttrDescriptionSeq::ExtAttrDescriptionSeq (
    const ExtAttrDescriptionSeq &seq
  )
  : TAO_Unbounded_Sequence<
        CORBA::ExtAttributeDescription
      >
    (seq)
{}

CORBA::ExtAttrDescriptionSeq::~ExtAttrDescriptionSeq (void)
{}

void CORBA::ExtAttrDescriptionSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  ExtAttrDescriptionSeq * tmp =
    ACE_static_cast (
        ExtAttrDescriptionSeq *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_VarSeq_Var_T<
      CORBA::ExtAttrDescriptionSeq,
      CORBA::ExtAttributeDescription
    >;

template class
  TAO_Seq_Out_T<
      CORBA::ExtAttrDescriptionSeq,
      CORBA::ExtAttrDescriptionSeq_var,
      CORBA::ExtAttributeDescription
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_VarSeq_Var_T< \
      ExtAttrDescriptionSeq, \
      CORBA::ExtAttributeDescription \
    >

# pragma instantiate \
  TAO_Seq_Out_T< \
      ExtAttrDescriptionSeq, \
      ExtAttrDescriptionSeq_var, \
      CORBA::ExtAttributeDescription \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtAttrDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x74417474), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExtAttrDescriptionSeq:1.0
    22,
  ACE_NTOHL (0x45787441), 
  ACE_NTOHL (0x74747244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e5365), 
  ACE_NTOHL (0x71000000),  // name = ExtAttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  864, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    848, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      46,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4578), 
      ACE_NTOHL (0x74417474), 
      ACE_NTOHL (0x72696275), 
      ACE_NTOHL (0x74654465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e3a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDescription:1.0
            24,
      ACE_NTOHL (0x45787441), 
      ACE_NTOHL (0x74747269), 
      ACE_NTOHL (0x62757465), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = ExtAttributeDescription
      8, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      5,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

      5,
      ACE_NTOHL (0x6d6f6465), 
      ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
      104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
        36,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x7574654d), 
        ACE_NTOHL (0x6f64653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
        14,
        ACE_NTOHL (0x41747472), 
        ACE_NTOHL (0x69627574), 
        ACE_NTOHL (0x654d6f64), 
        ACE_NTOHL (0x65000000),  // name = AttributeMode
        2, // member count
        12,
        ACE_NTOHL (0x41545452), 
        ACE_NTOHL (0x5f4e4f52), 
        ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
        14,
        ACE_NTOHL (0x41545452), 
        ACE_NTOHL (0x5f524541), 
        ACE_NTOHL (0x444f4e4c), 
        ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
        
      15,
      ACE_NTOHL (0x6765745f), 
      ACE_NTOHL (0x65786365), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e730000),  // name = get_exceptions
            CORBA::tk_alias, // typecode kind for typedefs
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x63446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x5365713a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                18,
        ACE_NTOHL (0x45786344), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e5365), 
        ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                CORBA::tk_sequence, // typecode kind
        196, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          180, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f4578), 
            ACE_NTOHL (0x63657074), 
            ACE_NTOHL (0x696f6e44), 
            ACE_NTOHL (0x65736372), 
            ACE_NTOHL (0x69707469), 
            ACE_NTOHL (0x6f6e3a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                        21,
            ACE_NTOHL (0x45786365), 
            ACE_NTOHL (0x7074696f), 
            ACE_NTOHL (0x6e446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
                        5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
                        0xffffffff, // indirection
            0xfffffd84, // negative offset (-636)
            3,
            ACE_NTOHL (0x69640000),  // name = id
                        0xffffffff, // indirection
            0xfffffdc8, // negative offset (-568)
            11,
            ACE_NTOHL (0x64656669), 
            ACE_NTOHL (0x6e65645f), 
            ACE_NTOHL (0x696e0000),  // name = defined_in
                        0xffffffff, // indirection
            0xfffffdb0, // negative offset (-592)
            8,
            ACE_NTOHL (0x76657273), 
            ACE_NTOHL (0x696f6e00),  // name = version
                        0xffffffff, // indirection
            0xfffffe10, // negative offset (-496)
            5,
            ACE_NTOHL (0x74797065), 
            ACE_NTOHL (0x0),  // name = type
                        CORBA::tk_TypeCode,


          0U,


      15,
      ACE_NTOHL (0x7075745f), 
      ACE_NTOHL (0x65786365), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e730000),  // name = put_exceptions
            0xffffffff, // indirection
      0xfffffecc, // negative offset (-308)

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtAttrDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ExtAttrDescriptionSeq),
    (char *) &_oc_CORBA_ExtAttrDescriptionSeq,
    0,
    sizeof (CORBA::ExtAttrDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtAttrDescriptionSeq,
    &_tc_TAO_tc_CORBA_ExtAttrDescriptionSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::InterfaceDef::_tao_class_id = 0;

CORBA::InterfaceDef_ptr
CORBA::tao_InterfaceDef_life::tao_duplicate (
    InterfaceDef_ptr p
  )
{
  return InterfaceDef::_duplicate (p);
}

void
CORBA::tao_InterfaceDef_life::tao_release (
    InterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::InterfaceDef_ptr
CORBA::tao_InterfaceDef_life::tao_nil (
    void
  )
{
  return InterfaceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_InterfaceDef_life::tao_marshal (
    InterfaceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::InterfaceDef_ptr
CORBA::tao_InterfaceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return InterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_InterfaceDef_cast::tao_upcast (
    void *src
  )
{
  InterfaceDef **tmp =
    ACE_static_cast (InterfaceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::InterfaceDef,
        CORBA::tao_InterfaceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::InterfaceDef,
        CORBA::tao_InterfaceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::InterfaceDef, \
        CORBA::tao_InterfaceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::InterfaceDef, \
        CORBA::tao_InterfaceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDefSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get &);
    
    ::CORBA::InterfaceDefSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get::result (::CORBA::InterfaceDefSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set &);
    const CORBA::InterfaceDefSeq & base_interfaces_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * interface_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a (const TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a &);
    const char * interface_id_;
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * interface_id
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      interface_id_ (interface_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= interface_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDef::FullInterfaceDescription * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface (const TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface &);
    
    ::CORBA::InterfaceDef::FullInterfaceDescription * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface::result (::CORBA::InterfaceDef::FullInterfaceDescription * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::AttributeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr type_;
    const CORBA::AttributeMode & mode_;
    
    ::CORBA::AttributeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      type_ (type),
      mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute::result (::CORBA::AttributeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode & mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::OperationDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr result_;
    const CORBA::OperationMode & mode_;
    const CORBA::ParDescriptionSeq & params_;
    const CORBA::ExceptionDefSeq & exceptions_;
    const CORBA::ContextIdSeq & contexts_;
    
    ::CORBA::OperationDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode & mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      result_ (result),
      mode_ (mode),
      params_ (params),
      exceptions_ (exceptions),
      contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (8);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->result_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation::result (::CORBA::OperationDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_InterfaceDef_Proxy_Impl::_TAO_InterfaceDef_Proxy_Impl (void)
{}

CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::_TAO_InterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDefSeq * CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDefSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InterfaceDefSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InterfaceDefSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_interfaces",
      20,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::InterfaceDefSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
    CORBA::Object *_collocated_tao_target_,
    const CORBA::InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_interfaces",
      20,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_base_interfaces_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          base_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << base_interfaces)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK;

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::is_a (
    CORBA::Object *_collocated_tao_target_,
    const char * interface_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_is_a _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          interface_id
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << interface_id)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::Boolean _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDef::FullInterfaceDescription * CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::describe_interface (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef::FullInterfaceDescription_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InterfaceDef::FullInterfaceDescription *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InterfaceDef::FullInterfaceDescription, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_interface",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_describe_interface _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::InterfaceDef::FullInterfaceDescription * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::AttributeDef_ptr CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::create_attribute (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AttributeDef_var _tao_retval (CORBA::AttributeDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_create_attribute _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          type,
          mode
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << type) &&
                  (_tao_out << mode)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::AttributeDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::OperationDef_ptr CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl::create_operation (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::OperationDef_var _tao_retval (CORBA::OperationDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      8,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceDef_create_operation _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          result,
          mode,
          params,
          exceptions,
          contexts
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << result) &&
                  (_tao_out << mode) &&
                  (_tao_out << params) &&
                  (_tao_out << exceptions) &&
                  (_tao_out << contexts)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::OperationDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_InterfaceDef_Proxy_Broker::_TAO_InterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceDef_Proxy_Broker::~_TAO_InterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceDef_Proxy_Broker * (*CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker *
CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker::the_TAO_InterfaceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker::_TAO_InterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker::~_TAO_InterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceDef_Proxy_Impl&
CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::InterfaceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::InterfaceDef::InterfaceDef (int collocated)
{
  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void
CORBA::InterfaceDef::CORBA_InterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_InterfaceDef_Proxy_Broker_ =
      ::CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_InterfaceDef_Proxy_Broker_ =
      ::CORBA::_TAO_InterfaceDef_Remote_Proxy_Broker::the_TAO_InterfaceDef_Remote_Proxy_Broker ();
  
  this->CORBA_Container_setup_collocation (collocated);
  this->CORBA_Contained_setup_collocation (collocated);
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::InterfaceDef::~InterfaceDef (void)
{}

void 
CORBA::InterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceDef *tmp = ACE_static_cast (InterfaceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::InterfaceDef_ptr
CORBA::InterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return InterfaceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/InterfaceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (InterfaceDef::_nil ());
      
      if (is_a == 0)
        {
          return InterfaceDef::_nil ();
        }
    }
  
  return InterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::InterfaceDef_ptr 
CORBA::InterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return InterfaceDef::_nil ();
    }
  
  InterfaceDef_ptr default_proxy = InterfaceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::InterfaceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          InterfaceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::InterfaceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              InterfaceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::InterfaceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              InterfaceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          InterfaceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &InterfaceDef::_tao_class_id
                )
            )
        );
}

CORBA::InterfaceDef_ptr
CORBA::InterfaceDef::_duplicate (InterfaceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::InterfaceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::InterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

CORBA::Boolean
CORBA::InterfaceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDefSeq * CORBA::InterfaceDef::base_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceDef_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.base_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::InterfaceDef::base_interfaces (
    const CORBA::InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceDef_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.base_interfaces (
      this,
      base_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::InterfaceDef::is_a (
    const char * interface_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceDef_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_a (
      this,
      interface_id
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InterfaceDef_FullInterfaceDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  60,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65662f46), 
  ACE_NTOHL (0x756c6c49), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef/FullInterfaceDescription:1.0
    25,
  ACE_NTOHL (0x46756c6c), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = FullInterfaceDescription
  8, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e730000),  // name = operations
    CORBA::tk_alias, // typecode kind for typedefs
  1340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
        17,
    ACE_NTOHL (0x4f704465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    1260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1244, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
                21,
        ACE_NTOHL (0x4f706572), 
        ACE_NTOHL (0x6174696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffe14, // negative offset (-492)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffe58, // negative offset (-424)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffe40, // negative offset (-448)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffea0, // negative offset (-352)
        7,
        ACE_NTOHL (0x72657375), 
        ACE_NTOHL (0x6c740000),  // name = result
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572), 
          ACE_NTOHL (0x6174696f), 
          ACE_NTOHL (0x6e4d6f64), 
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e), 
          ACE_NTOHL (0x4f524d41), 
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f), 
          ACE_NTOHL (0x4e455741), 
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
          
        9,
        ACE_NTOHL (0x636f6e74), 
        ACE_NTOHL (0x65787473), 
        ACE_NTOHL (0x0),  // name = contexts
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
                    13,
          ACE_NTOHL (0x436f6e74), 
          ACE_NTOHL (0x65787449), 
          ACE_NTOHL (0x64536571), 
          ACE_NTOHL (0x0),  // name = ContextIdSeq
                    CORBA::tk_sequence, // typecode kind
          96, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            80, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f436f), 
              ACE_NTOHL (0x6e746578), 
              ACE_NTOHL (0x74496465), 
              ACE_NTOHL (0x6e746966), 
              ACE_NTOHL (0x6965723a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                            18,
              ACE_NTOHL (0x436f6e74), 
              ACE_NTOHL (0x65787449), 
              ACE_NTOHL (0x64656e74), 
              ACE_NTOHL (0x69666965), 
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                            0xffffffff, // indirection
              0xfffffc94, // negative offset (-876)

            0U,


        11,
        ACE_NTOHL (0x70617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72730000),  // name = parameters
                CORBA::tk_alias, // typecode kind for typedefs
        428, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x50617244), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          348, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            332, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                            21,
              ACE_NTOHL (0x50617261), 
              ACE_NTOHL (0x6d657465), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffffbb4, // negative offset (-1100)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                                8,
                ACE_NTOHL (0x49444c54), 
                ACE_NTOHL (0x79706500),  // name = IDLType
                
              5,
              ACE_NTOHL (0x6d6f6465), 
              ACE_NTOHL (0x0),  // name = mode
                            CORBA::tk_enum, // typecode kind
              116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f64653a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261), 
                ACE_NTOHL (0x6d657465), 
                ACE_NTOHL (0x724d6f64), 
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f4f55), 
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
                

            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
                CORBA::tk_alias, // typecode kind for typedefs
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x45786344), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          196, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            180, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                            21,
              ACE_NTOHL (0x45786365), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff9f0, // negative offset (-1552)
              3,
              ACE_NTOHL (0x69640000),  // name = id
                            0xffffffff, // indirection
              0xfffffa34, // negative offset (-1484)
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
                            0xffffffff, // indirection
              0xfffffa1c, // negative offset (-1508)
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
                            0xffffffff, // indirection
              0xfffffa7c, // negative offset (-1412)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,


            0U,



      0U,


  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
    CORBA::tk_alias, // typecode kind for typedefs
  404, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4174), 
    ACE_NTOHL (0x74724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
        19,
    ACE_NTOHL (0x41747472), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    320, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      304, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x75746544), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
                21,
        ACE_NTOHL (0x41747472), 
        ACE_NTOHL (0x69627574), 
        ACE_NTOHL (0x65446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff8bc, // negative offset (-1860)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff900, // negative offset (-1792)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff8e8, // negative offset (-1816)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff948, // negative offset (-1720)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472), 
          ACE_NTOHL (0x69627574), 
          ACE_NTOHL (0x654d6f64), 
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
          

      0U,


  16,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = base_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffff7d0, // negative offset (-2096)
      0U,


  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_InterfaceDef_FullInterfaceDescription),
    (char *) &_oc_CORBA_InterfaceDef_FullInterfaceDescription,
    0,
    sizeof (CORBA::InterfaceDef::FullInterfaceDescription)
  );

::CORBA::TypeCode_ptr CORBA::InterfaceDef::_tc_FullInterfaceDescription =
  &_tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription;

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::InterfaceDef::FullInterfaceDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  FullInterfaceDescription *tmp = ACE_static_cast (FullInterfaceDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::InterfaceDef::FullInterfaceDescription
    >;

template class
  TAO_Out_T<
      CORBA::InterfaceDef::FullInterfaceDescription,
      CORBA::InterfaceDef::FullInterfaceDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::InterfaceDef::FullInterfaceDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::InterfaceDef::FullInterfaceDescription, \
      CORBA::InterfaceDef::FullInterfaceDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDef::FullInterfaceDescription * CORBA::InterfaceDef::describe_interface (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceDef_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_interface (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::AttributeDef_ptr CORBA::InterfaceDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceDef_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_attribute (
      this,
      id,
      name,
      version,
      type,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::OperationDef_ptr CORBA::InterfaceDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceDef_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceDef_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_operation (
      this,
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InterfaceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
    13,
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x0),  // name = InterfaceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_InterfaceDef),
    (char *) &_oc_CORBA_InterfaceDef,
    0,
    sizeof (CORBA::InterfaceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InterfaceDef,
    &_tc_TAO_tc_CORBA_InterfaceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InterfaceDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDescription:1.0
    21,
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = InterfaceDescription
  5, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  16,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = base_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffffed0, // negative offset (-304)
      0U,


};

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_InterfaceDescription),
    (char *) &_oc_CORBA_InterfaceDescription,
    0,
    sizeof (CORBA::InterfaceDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InterfaceDescription,
    &_tc_TAO_tc_CORBA_InterfaceDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::InterfaceDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceDescription *tmp = ACE_static_cast (InterfaceDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::InterfaceDescription
    >;

template class
  TAO_Out_T<
      CORBA::InterfaceDescription,
      CORBA::InterfaceDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::InterfaceDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::InterfaceDescription, \
      CORBA::InterfaceDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::InterfaceAttrExtension::_tao_class_id = 0;

CORBA::InterfaceAttrExtension_ptr
CORBA::tao_InterfaceAttrExtension_life::tao_duplicate (
    InterfaceAttrExtension_ptr p
  )
{
  return InterfaceAttrExtension::_duplicate (p);
}

void
CORBA::tao_InterfaceAttrExtension_life::tao_release (
    InterfaceAttrExtension_ptr p
  )
{
  CORBA::release (p);
}

CORBA::InterfaceAttrExtension_ptr
CORBA::tao_InterfaceAttrExtension_life::tao_nil (
    void
  )
{
  return InterfaceAttrExtension::_nil ();
}

CORBA::Boolean
CORBA::tao_InterfaceAttrExtension_life::tao_marshal (
    InterfaceAttrExtension_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::InterfaceAttrExtension_ptr
CORBA::tao_InterfaceAttrExtension_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return InterfaceAttrExtension::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_InterfaceAttrExtension_cast::tao_upcast (
    void *src
  )
{
  InterfaceAttrExtension **tmp =
    ACE_static_cast (InterfaceAttrExtension **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::InterfaceAttrExtension,
        CORBA::tao_InterfaceAttrExtension_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::InterfaceAttrExtension,
        CORBA::tao_InterfaceAttrExtension_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::InterfaceAttrExtension, \
        CORBA::tao_InterfaceAttrExtension_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::InterfaceAttrExtension, \
        CORBA::tao_InterfaceAttrExtension_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface (const TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface &);
    
    ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface::TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface::result (::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode,
      const CORBA::ExceptionDefSeq & get_exceptions,
      const CORBA::ExceptionDefSeq & set_exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExtAttributeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute (const TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute &);
    void operator= (const TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr type_;
    const CORBA::AttributeMode & mode_;
    const CORBA::ExceptionDefSeq & get_exceptions_;
    const CORBA::ExceptionDefSeq & set_exceptions_;
    
    ::CORBA::ExtAttributeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute::TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode,
      const CORBA::ExceptionDefSeq & get_exceptions,
      const CORBA::ExceptionDefSeq & set_exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      type_ (type),
      mode_ (mode),
      get_exceptions_ (get_exceptions),
      set_exceptions_ (set_exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (7);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->get_exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->set_exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute::result (::CORBA::ExtAttributeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_InterfaceAttrExtension_Proxy_Impl::_TAO_InterfaceAttrExtension_Proxy_Impl (void)
{}

CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Impl::_TAO_InterfaceAttrExtension_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription * CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Impl::describe_ext_interface (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_ext_interface",
      22,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_describe_ext_interface _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExtAttributeDef_ptr CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Impl::create_ext_attribute (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    const CORBA::ExceptionDefSeq & get_exceptions,
    const CORBA::ExceptionDefSeq & set_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExtAttributeDef_var _tao_retval (CORBA::ExtAttributeDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_ext_attribute",
      20,
      7,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_InterfaceAttrExtension_create_ext_attribute _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          type,
          mode,
          get_exceptions,
          set_exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << type) &&
                  (_tao_out << mode) &&
                  (_tao_out << get_exceptions) &&
                  (_tao_out << set_exceptions)
                  ))
                {
                  TAO_OutputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                  TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  _tao_call.transport()->assign_translators (&_tao_in,0);
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_InputCDR::throw_stub_exception (errno ACE_ENV_ARG_PARAMETER); 
                      TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

                      
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ExtAttributeDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_InterfaceAttrExtension_Proxy_Broker::_TAO_InterfaceAttrExtension_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceAttrExtension_Proxy_Broker::~_TAO_InterfaceAttrExtension_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceAttrExtension_Proxy_Broker * (*CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker *
CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker::the_TAO_InterfaceAttrExtension_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker::~_TAO_InterfaceAttrExtension_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_InterfaceAttrExtension_Proxy_Impl&
CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker::select_proxy (
    ::CORBA::InterfaceAttrExtension *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::InterfaceAttrExtension::InterfaceAttrExtension (int collocated)
{
  this->CORBA_InterfaceAttrExtension_setup_collocation (collocated);
}

void
CORBA::InterfaceAttrExtension::CORBA_InterfaceAttrExtension_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_InterfaceAttrExtension_Proxy_Broker_ =
      ::CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_InterfaceAttrExtension_Proxy_Broker_ =
      ::CORBA::_TAO_InterfaceAttrExtension_Remote_Proxy_Broker::the_TAO_InterfaceAttrExtension_Remote_Proxy_Broker ();
}

CORBA::InterfaceAttrExtension::~InterfaceAttrExtension (void)
{}

void 
CORBA::InterfaceAttrExtension::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceAttrExtension *tmp = ACE_static_cast (InterfaceAttrExtension *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::InterfaceAttrExtension_ptr
CORBA::InterfaceAttrExtension::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return InterfaceAttrExtension::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (InterfaceAttrExtension::_nil ());
      
      if (is_a == 0)
        {
          return InterfaceAttrExtension::_nil ();
        }
    }
  
  return InterfaceAttrExtension::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::InterfaceAttrExtension_ptr 
CORBA::InterfaceAttrExtension::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return InterfaceAttrExtension::_nil ();
    }
  
  InterfaceAttrExtension_ptr default_proxy = InterfaceAttrExtension::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::InterfaceAttrExtension (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          InterfaceAttrExtension::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::InterfaceAttrExtension (
                  stub,
                  1,
                  obj->_servant ()
                ),
              InterfaceAttrExtension::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::InterfaceAttrExtension (
                  stub,
                  0,
                  obj->_servant ()
                ),
              InterfaceAttrExtension::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          InterfaceAttrExtension_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &InterfaceAttrExtension::_tao_class_id
                )
            )
        );
}

CORBA::InterfaceAttrExtension_ptr
CORBA::InterfaceAttrExtension::_duplicate (InterfaceAttrExtension_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::InterfaceAttrExtension::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::InterfaceAttrExtension::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceAttrExtension)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::InterfaceAttrExtension::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0";
}

CORBA::Boolean
CORBA::InterfaceAttrExtension::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  73,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636541), 
  ACE_NTOHL (0x74747245), 
  ACE_NTOHL (0x7874656e), 
  ACE_NTOHL (0x73696f6e), 
  ACE_NTOHL (0x2f457874), 
  ACE_NTOHL (0x46756c6c), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InterfaceAttrExtension/ExtFullInterfaceDescription:1.0
    28,
  ACE_NTOHL (0x45787446), 
  ACE_NTOHL (0x756c6c49), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ExtFullInterfaceDescription
  8, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e730000),  // name = operations
    CORBA::tk_alias, // typecode kind for typedefs
  1340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
        17,
    ACE_NTOHL (0x4f704465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    1260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1244, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
                21,
        ACE_NTOHL (0x4f706572), 
        ACE_NTOHL (0x6174696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffe14, // negative offset (-492)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffe58, // negative offset (-424)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffe40, // negative offset (-448)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffea0, // negative offset (-352)
        7,
        ACE_NTOHL (0x72657375), 
        ACE_NTOHL (0x6c740000),  // name = result
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572), 
          ACE_NTOHL (0x6174696f), 
          ACE_NTOHL (0x6e4d6f64), 
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e), 
          ACE_NTOHL (0x4f524d41), 
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f), 
          ACE_NTOHL (0x4e455741), 
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
          
        9,
        ACE_NTOHL (0x636f6e74), 
        ACE_NTOHL (0x65787473), 
        ACE_NTOHL (0x0),  // name = contexts
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
                    13,
          ACE_NTOHL (0x436f6e74), 
          ACE_NTOHL (0x65787449), 
          ACE_NTOHL (0x64536571), 
          ACE_NTOHL (0x0),  // name = ContextIdSeq
                    CORBA::tk_sequence, // typecode kind
          96, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            80, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f436f), 
              ACE_NTOHL (0x6e746578), 
              ACE_NTOHL (0x74496465), 
              ACE_NTOHL (0x6e746966), 
              ACE_NTOHL (0x6965723a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                            18,
              ACE_NTOHL (0x436f6e74), 
              ACE_NTOHL (0x65787449), 
              ACE_NTOHL (0x64656e74), 
              ACE_NTOHL (0x69666965), 
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                            0xffffffff, // indirection
              0xfffffc94, // negative offset (-876)

            0U,


        11,
        ACE_NTOHL (0x70617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72730000),  // name = parameters
                CORBA::tk_alias, // typecode kind for typedefs
        428, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x50617244), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          348, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            332, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                            21,
              ACE_NTOHL (0x50617261), 
              ACE_NTOHL (0x6d657465), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffffbb4, // negative offset (-1100)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                                8,
                ACE_NTOHL (0x49444c54), 
                ACE_NTOHL (0x79706500),  // name = IDLType
                
              5,
              ACE_NTOHL (0x6d6f6465), 
              ACE_NTOHL (0x0),  // name = mode
                            CORBA::tk_enum, // typecode kind
              116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f64653a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261), 
                ACE_NTOHL (0x6d657465), 
                ACE_NTOHL (0x724d6f64), 
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f4f55), 
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
                

            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
                CORBA::tk_alias, // typecode kind for typedefs
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x45786344), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          196, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            180, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                            21,
              ACE_NTOHL (0x45786365), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff9f0, // negative offset (-1552)
              3,
              ACE_NTOHL (0x69640000),  // name = id
                            0xffffffff, // indirection
              0xfffffa34, // negative offset (-1484)
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
                            0xffffffff, // indirection
              0xfffffa1c, // negative offset (-1508)
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
                            0xffffffff, // indirection
              0xfffffa7c, // negative offset (-1412)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,


            0U,



      0U,


  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
    CORBA::tk_alias, // typecode kind for typedefs
  468, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    44,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x74417474), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExtAttrDescriptionSeq:1.0
        22,
    ACE_NTOHL (0x45787441), 
    ACE_NTOHL (0x74747244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ExtAttrDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    380, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      364, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        46,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x74417474), 
        ACE_NTOHL (0x72696275), 
        ACE_NTOHL (0x74654465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDescription:1.0
                24,
        ACE_NTOHL (0x45787441), 
        ACE_NTOHL (0x74747269), 
        ACE_NTOHL (0x62757465), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ExtAttributeDescription
        8, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff8b4, // negative offset (-1868)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff8f8, // negative offset (-1800)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff8e0, // negative offset (-1824)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff940, // negative offset (-1728)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472), 
          ACE_NTOHL (0x69627574), 
          ACE_NTOHL (0x654d6f64), 
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
          
        15,
        ACE_NTOHL (0x6765745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = get_exceptions
                0xffffffff, // indirection
        0xfffffd18, // negative offset (-744)
        15,
        ACE_NTOHL (0x7075745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = put_exceptions
                0xffffffff, // indirection
        0xfffffcfc, // negative offset (-772)

      0U,


  16,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = base_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffff790, // negative offset (-2160)
      0U,


  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription),
    (char *) &_oc_CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription,
    0,
    sizeof (CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription)
  );

::CORBA::TypeCode_ptr CORBA::InterfaceAttrExtension::_tc_ExtFullInterfaceDescription =
  &_tc_TAO_tc_CORBA_InterfaceAttrExtension_ExtFullInterfaceDescription;

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtFullInterfaceDescription *tmp = ACE_static_cast (ExtFullInterfaceDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_type.cpp:292

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_Var_Var_T<
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription
    >;

template class
  TAO_Out_T<
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_Var_Var_T< \
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription \
    >

# pragma instantiate \
  TAO_Out_T< \
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription, \
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription * CORBA::InterfaceAttrExtension::describe_ext_interface (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceAttrExtension_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceAttrExtension_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceAttrExtension_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_ext_interface (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ExtAttributeDef_ptr CORBA::InterfaceAttrExtension::create_ext_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    const CORBA::ExceptionDefSeq & get_exceptions,
    const CORBA::ExceptionDefSeq & set_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  if (!this->is_evaluated ())
    {
      ACE_NESTED_CLASS (CORBA, Object)::tao_object_initialize (this);
      this->CORBA_InterfaceAttrExtension_setup_collocation (
          this->ACE_NESTED_CLASS (CORBA, Object)::_is_collocated ()
        );
    }
  
  _TAO_InterfaceAttrExtension_Proxy_Impl &proxy = 
    this->the_TAO_InterfaceAttrExtension_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_ext_attribute (
      this,
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      set_exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InterfaceAttrExtension[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636541), 
  ACE_NTOHL (0x74747245), 
  ACE_NTOHL (0x7874656e), 
  ACE_NTOHL (0x73696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InterfaceAttrExtension:1.0
    23,
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65417474), 
  ACE_NTOHL (0x72457874), 
  ACE_NTOHL (0x656e7369), 
  ACE_NTOHL (0x6f6e0000),  // name = InterfaceAttrExtension
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceAttrExtension (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_InterfaceAttrExtension),
    (char *) &_oc_CORBA_InterfaceAttrExtension,
    0,
    sizeof (CORBA::InterfaceAttrExtension)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InterfaceAttrExtension,
    &_tc_TAO_tc_CORBA_InterfaceAttrExtension
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ExtInterfaceDef::_tao_class_id = 0;

CORBA::ExtInterfaceDef_ptr
CORBA::tao_ExtInterfaceDef_life::tao_duplicate (
    ExtInterfaceDef_ptr p
  )
{
  return ExtInterfaceDef::_duplicate (p);
}

void
CORBA::tao_ExtInterfaceDef_life::tao_release (
    ExtInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ExtInterfaceDef_ptr
CORBA::tao_ExtInterfaceDef_life::tao_nil (
    void
  )
{
  return ExtInterfaceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ExtInterfaceDef_life::tao_marshal (
    ExtInterfaceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ExtInterfaceDef_ptr
CORBA::tao_ExtInterfaceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ExtInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ExtInterfaceDef_cast::tao_upcast (
    void *src
  )
{
  ExtInterfaceDef **tmp =
    ACE_static_cast (ExtInterfaceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ExtInterfaceDef,
        CORBA::tao_ExtInterfaceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ExtInterfaceDef,
        CORBA::tao_ExtInterfaceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ExtInterfaceDef, \
        CORBA::tao_ExtInterfaceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ExtInterfaceDef, \
        CORBA::tao_ExtInterfaceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ExtInterfaceDef_Proxy_Impl::_TAO_ExtInterfaceDef_Proxy_Impl (void)
{}

CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Impl::_TAO_ExtInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ExtInterfaceDef_Proxy_Broker::_TAO_ExtInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtInterfaceDef_Proxy_Broker::~_TAO_ExtInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtInterfaceDef_Proxy_Broker * (*CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker *
CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker::the_TAO_ExtInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker::_TAO_ExtInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker::~_TAO_ExtInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtInterfaceDef_Proxy_Impl&
CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ExtInterfaceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ExtInterfaceDef::ExtInterfaceDef (int collocated)
{
  this->CORBA_ExtInterfaceDef_setup_collocation (collocated);
}

void
CORBA::ExtInterfaceDef::CORBA_ExtInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExtInterfaceDef_Proxy_Broker_ =
      ::CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExtInterfaceDef_Proxy_Broker_ =
      ::CORBA::_TAO_ExtInterfaceDef_Remote_Proxy_Broker::the_TAO_ExtInterfaceDef_Remote_Proxy_Broker ();
  
  this->CORBA_InterfaceDef_setup_collocation (collocated);
  this->CORBA_InterfaceAttrExtension_setup_collocation (collocated);
}

CORBA::ExtInterfaceDef::~ExtInterfaceDef (void)
{}

void 
CORBA::ExtInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtInterfaceDef *tmp = ACE_static_cast (ExtInterfaceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ExtInterfaceDef_ptr
CORBA::ExtInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtInterfaceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ExtInterfaceDef::_nil ());
      
      if (is_a == 0)
        {
          return ExtInterfaceDef::_nil ();
        }
    }
  
  return ExtInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ExtInterfaceDef_ptr 
CORBA::ExtInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtInterfaceDef::_nil ();
    }
  
  ExtInterfaceDef_ptr default_proxy = ExtInterfaceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ExtInterfaceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ExtInterfaceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtInterfaceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ExtInterfaceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtInterfaceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ExtInterfaceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ExtInterfaceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ExtInterfaceDef::_tao_class_id
                )
            )
        );
}

CORBA::ExtInterfaceDef_ptr
CORBA::ExtInterfaceDef::_duplicate (ExtInterfaceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ExtInterfaceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ExtInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ExtInterfaceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceAttrExtension)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceAttrExtension_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ExtInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtInterfaceDef:1.0";
}

CORBA::Boolean
CORBA::ExtInterfaceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtInterfaceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63654465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtInterfaceDef:1.0
    16,
  ACE_NTOHL (0x45787449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x44656600),  // name = ExtInterfaceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtInterfaceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ExtInterfaceDef),
    (char *) &_oc_CORBA_ExtInterfaceDef,
    0,
    sizeof (CORBA::ExtInterfaceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtInterfaceDef,
    &_tc_TAO_tc_CORBA_ExtInterfaceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::AbstractInterfaceDef::_tao_class_id = 0;

CORBA::AbstractInterfaceDef_ptr
CORBA::tao_AbstractInterfaceDef_life::tao_duplicate (
    AbstractInterfaceDef_ptr p
  )
{
  return AbstractInterfaceDef::_duplicate (p);
}

void
CORBA::tao_AbstractInterfaceDef_life::tao_release (
    AbstractInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::AbstractInterfaceDef_ptr
CORBA::tao_AbstractInterfaceDef_life::tao_nil (
    void
  )
{
  return AbstractInterfaceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_AbstractInterfaceDef_life::tao_marshal (
    AbstractInterfaceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::AbstractInterfaceDef_ptr
CORBA::tao_AbstractInterfaceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return AbstractInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_AbstractInterfaceDef_cast::tao_upcast (
    void *src
  )
{
  AbstractInterfaceDef **tmp =
    ACE_static_cast (AbstractInterfaceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::AbstractInterfaceDef,
        CORBA::tao_AbstractInterfaceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::AbstractInterfaceDef,
        CORBA::tao_AbstractInterfaceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::AbstractInterfaceDef, \
        CORBA::tao_AbstractInterfaceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::AbstractInterfaceDef, \
        CORBA::tao_AbstractInterfaceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_AbstractInterfaceDef_Proxy_Impl::_TAO_AbstractInterfaceDef_Proxy_Impl (void)
{}

CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Impl::_TAO_AbstractInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_AbstractInterfaceDef_Proxy_Broker::_TAO_AbstractInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_AbstractInterfaceDef_Proxy_Broker::~_TAO_AbstractInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_AbstractInterfaceDef_Proxy_Broker * (*CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker *
CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker::the_TAO_AbstractInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker::~_TAO_AbstractInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_AbstractInterfaceDef_Proxy_Impl&
CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::AbstractInterfaceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::AbstractInterfaceDef::AbstractInterfaceDef (int collocated)
{
  this->CORBA_AbstractInterfaceDef_setup_collocation (collocated);
}

void
CORBA::AbstractInterfaceDef::CORBA_AbstractInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_AbstractInterfaceDef_Proxy_Broker_ =
      ::CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_AbstractInterfaceDef_Proxy_Broker_ =
      ::CORBA::_TAO_AbstractInterfaceDef_Remote_Proxy_Broker::the_TAO_AbstractInterfaceDef_Remote_Proxy_Broker ();
  
  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

CORBA::AbstractInterfaceDef::~AbstractInterfaceDef (void)
{}

void 
CORBA::AbstractInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  AbstractInterfaceDef *tmp = ACE_static_cast (AbstractInterfaceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::AbstractInterfaceDef_ptr
CORBA::AbstractInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return AbstractInterfaceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (AbstractInterfaceDef::_nil ());
      
      if (is_a == 0)
        {
          return AbstractInterfaceDef::_nil ();
        }
    }
  
  return AbstractInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::AbstractInterfaceDef_ptr 
CORBA::AbstractInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return AbstractInterfaceDef::_nil ();
    }
  
  AbstractInterfaceDef_ptr default_proxy = AbstractInterfaceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::AbstractInterfaceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          AbstractInterfaceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::AbstractInterfaceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              AbstractInterfaceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::AbstractInterfaceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              AbstractInterfaceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          AbstractInterfaceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &AbstractInterfaceDef::_tao_class_id
                )
            )
        );
}

CORBA::AbstractInterfaceDef_ptr
CORBA::AbstractInterfaceDef::_duplicate (AbstractInterfaceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::AbstractInterfaceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::AbstractInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, AbstractInterfaceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::AbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0";
}

CORBA::Boolean
CORBA::AbstractInterfaceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_AbstractInterfaceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4162), 
  ACE_NTOHL (0x73747261), 
  ACE_NTOHL (0x6374496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AbstractInterfaceDef:1.0
    21,
  ACE_NTOHL (0x41627374), 
  ACE_NTOHL (0x72616374), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x0),  // name = AbstractInterfaceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_AbstractInterfaceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_AbstractInterfaceDef),
    (char *) &_oc_CORBA_AbstractInterfaceDef,
    0,
    sizeof (CORBA::AbstractInterfaceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AbstractInterfaceDef,
    &_tc_TAO_tc_CORBA_AbstractInterfaceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ExtAbstractInterfaceDef::_tao_class_id = 0;

CORBA::ExtAbstractInterfaceDef_ptr
CORBA::tao_ExtAbstractInterfaceDef_life::tao_duplicate (
    ExtAbstractInterfaceDef_ptr p
  )
{
  return ExtAbstractInterfaceDef::_duplicate (p);
}

void
CORBA::tao_ExtAbstractInterfaceDef_life::tao_release (
    ExtAbstractInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ExtAbstractInterfaceDef_ptr
CORBA::tao_ExtAbstractInterfaceDef_life::tao_nil (
    void
  )
{
  return ExtAbstractInterfaceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ExtAbstractInterfaceDef_life::tao_marshal (
    ExtAbstractInterfaceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ExtAbstractInterfaceDef_ptr
CORBA::tao_ExtAbstractInterfaceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ExtAbstractInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ExtAbstractInterfaceDef_cast::tao_upcast (
    void *src
  )
{
  ExtAbstractInterfaceDef **tmp =
    ACE_static_cast (ExtAbstractInterfaceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ExtAbstractInterfaceDef,
        CORBA::tao_ExtAbstractInterfaceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ExtAbstractInterfaceDef,
        CORBA::tao_ExtAbstractInterfaceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ExtAbstractInterfaceDef, \
        CORBA::tao_ExtAbstractInterfaceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ExtAbstractInterfaceDef, \
        CORBA::tao_ExtAbstractInterfaceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ExtAbstractInterfaceDef_Proxy_Impl::_TAO_ExtAbstractInterfaceDef_Proxy_Impl (void)
{}

CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Impl::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ExtAbstractInterfaceDef_Proxy_Broker::_TAO_ExtAbstractInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAbstractInterfaceDef_Proxy_Broker::~_TAO_ExtAbstractInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAbstractInterfaceDef_Proxy_Broker * (*CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker *
CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker::the_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker::~_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtAbstractInterfaceDef_Proxy_Impl&
CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ExtAbstractInterfaceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (int collocated)
{
  this->CORBA_ExtAbstractInterfaceDef_setup_collocation (collocated);
}

void
CORBA::ExtAbstractInterfaceDef::CORBA_ExtAbstractInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExtAbstractInterfaceDef_Proxy_Broker_ =
      ::CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExtAbstractInterfaceDef_Proxy_Broker_ =
      ::CORBA::_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker::the_TAO_ExtAbstractInterfaceDef_Remote_Proxy_Broker ();
  
  this->CORBA_AbstractInterfaceDef_setup_collocation (collocated);
  this->CORBA_InterfaceAttrExtension_setup_collocation (collocated);
}

CORBA::ExtAbstractInterfaceDef::~ExtAbstractInterfaceDef (void)
{}

void 
CORBA::ExtAbstractInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtAbstractInterfaceDef *tmp = ACE_static_cast (ExtAbstractInterfaceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ExtAbstractInterfaceDef_ptr
CORBA::ExtAbstractInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtAbstractInterfaceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ExtAbstractInterfaceDef::_nil ());
      
      if (is_a == 0)
        {
          return ExtAbstractInterfaceDef::_nil ();
        }
    }
  
  return ExtAbstractInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ExtAbstractInterfaceDef_ptr 
CORBA::ExtAbstractInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtAbstractInterfaceDef::_nil ();
    }
  
  ExtAbstractInterfaceDef_ptr default_proxy = ExtAbstractInterfaceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ExtAbstractInterfaceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ExtAbstractInterfaceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtAbstractInterfaceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ExtAbstractInterfaceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtAbstractInterfaceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ExtAbstractInterfaceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ExtAbstractInterfaceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ExtAbstractInterfaceDef::_tao_class_id
                )
            )
        );
}

CORBA::ExtAbstractInterfaceDef_ptr
CORBA::ExtAbstractInterfaceDef::_duplicate (ExtAbstractInterfaceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ExtAbstractInterfaceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ExtAbstractInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ExtAbstractInterfaceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, AbstractInterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::AbstractInterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceAttrExtension)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceAttrExtension_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ExtAbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0";
}

CORBA::Boolean
CORBA::ExtAbstractInterfaceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtAbstractInterfaceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x74416273), 
  ACE_NTOHL (0x74726163), 
  ACE_NTOHL (0x74496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63654465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0
    24,
  ACE_NTOHL (0x45787441), 
  ACE_NTOHL (0x62737472), 
  ACE_NTOHL (0x61637449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x44656600),  // name = ExtAbstractInterfaceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtAbstractInterfaceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ExtAbstractInterfaceDef),
    (char *) &_oc_CORBA_ExtAbstractInterfaceDef,
    0,
    sizeof (CORBA::ExtAbstractInterfaceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtAbstractInterfaceDef,
    &_tc_TAO_tc_CORBA_ExtAbstractInterfaceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::LocalInterfaceDef::_tao_class_id = 0;

CORBA::LocalInterfaceDef_ptr
CORBA::tao_LocalInterfaceDef_life::tao_duplicate (
    LocalInterfaceDef_ptr p
  )
{
  return LocalInterfaceDef::_duplicate (p);
}

void
CORBA::tao_LocalInterfaceDef_life::tao_release (
    LocalInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::LocalInterfaceDef_ptr
CORBA::tao_LocalInterfaceDef_life::tao_nil (
    void
  )
{
  return LocalInterfaceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_LocalInterfaceDef_life::tao_marshal (
    LocalInterfaceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::LocalInterfaceDef_ptr
CORBA::tao_LocalInterfaceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return LocalInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_LocalInterfaceDef_cast::tao_upcast (
    void *src
  )
{
  LocalInterfaceDef **tmp =
    ACE_static_cast (LocalInterfaceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::LocalInterfaceDef,
        CORBA::tao_LocalInterfaceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::LocalInterfaceDef,
        CORBA::tao_LocalInterfaceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::LocalInterfaceDef, \
        CORBA::tao_LocalInterfaceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::LocalInterfaceDef, \
        CORBA::tao_LocalInterfaceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_LocalInterfaceDef_Proxy_Impl::_TAO_LocalInterfaceDef_Proxy_Impl (void)
{}

CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Impl::_TAO_LocalInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_LocalInterfaceDef_Proxy_Broker::_TAO_LocalInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_LocalInterfaceDef_Proxy_Broker::~_TAO_LocalInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_LocalInterfaceDef_Proxy_Broker * (*CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker *
CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker::the_TAO_LocalInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker::_TAO_LocalInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker::~_TAO_LocalInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_LocalInterfaceDef_Proxy_Impl&
CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::LocalInterfaceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::LocalInterfaceDef::LocalInterfaceDef (int collocated)
{
  this->CORBA_LocalInterfaceDef_setup_collocation (collocated);
}

void
CORBA::LocalInterfaceDef::CORBA_LocalInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_LocalInterfaceDef_Proxy_Broker_ =
      ::CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_LocalInterfaceDef_Proxy_Broker_ =
      ::CORBA::_TAO_LocalInterfaceDef_Remote_Proxy_Broker::the_TAO_LocalInterfaceDef_Remote_Proxy_Broker ();
  
  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

CORBA::LocalInterfaceDef::~LocalInterfaceDef (void)
{}

void 
CORBA::LocalInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  LocalInterfaceDef *tmp = ACE_static_cast (LocalInterfaceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::LocalInterfaceDef_ptr
CORBA::LocalInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return LocalInterfaceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (LocalInterfaceDef::_nil ());
      
      if (is_a == 0)
        {
          return LocalInterfaceDef::_nil ();
        }
    }
  
  return LocalInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::LocalInterfaceDef_ptr 
CORBA::LocalInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return LocalInterfaceDef::_nil ();
    }
  
  LocalInterfaceDef_ptr default_proxy = LocalInterfaceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::LocalInterfaceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          LocalInterfaceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::LocalInterfaceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              LocalInterfaceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::LocalInterfaceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              LocalInterfaceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          LocalInterfaceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &LocalInterfaceDef::_tao_class_id
                )
            )
        );
}

CORBA::LocalInterfaceDef_ptr
CORBA::LocalInterfaceDef::_duplicate (LocalInterfaceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::LocalInterfaceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::LocalInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, LocalInterfaceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::LocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/LocalInterfaceDef:1.0";
}

CORBA::Boolean
CORBA::LocalInterfaceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_LocalInterfaceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4c6f), 
  ACE_NTOHL (0x63616c49), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/LocalInterfaceDef:1.0
    18,
  ACE_NTOHL (0x4c6f6361), 
  ACE_NTOHL (0x6c496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63654465), 
  ACE_NTOHL (0x66000000),  // name = LocalInterfaceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_LocalInterfaceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_LocalInterfaceDef),
    (char *) &_oc_CORBA_LocalInterfaceDef,
    0,
    sizeof (CORBA::LocalInterfaceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_LocalInterfaceDef,
    &_tc_TAO_tc_CORBA_LocalInterfaceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int CORBA::ExtLocalInterfaceDef::_tao_class_id = 0;

CORBA::ExtLocalInterfaceDef_ptr
CORBA::tao_ExtLocalInterfaceDef_life::tao_duplicate (
    ExtLocalInterfaceDef_ptr p
  )
{
  return ExtLocalInterfaceDef::_duplicate (p);
}

void
CORBA::tao_ExtLocalInterfaceDef_life::tao_release (
    ExtLocalInterfaceDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ExtLocalInterfaceDef_ptr
CORBA::tao_ExtLocalInterfaceDef_life::tao_nil (
    void
  )
{
  return ExtLocalInterfaceDef::_nil ();
}

CORBA::Boolean
CORBA::tao_ExtLocalInterfaceDef_life::tao_marshal (
    ExtLocalInterfaceDef_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

CORBA::ExtLocalInterfaceDef_ptr
CORBA::tao_ExtLocalInterfaceDef_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ExtLocalInterfaceDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::tao_ExtLocalInterfaceDef_cast::tao_upcast (
    void *src
  )
{
  ExtLocalInterfaceDef **tmp =
    ACE_static_cast (ExtLocalInterfaceDef **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        CORBA::ExtLocalInterfaceDef,
        CORBA::tao_ExtLocalInterfaceDef_life
      >;
  template class
    TAO_Objref_Out_T<
        CORBA::ExtLocalInterfaceDef,
        CORBA::tao_ExtLocalInterfaceDef_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        CORBA::ExtLocalInterfaceDef, \
        CORBA::tao_ExtLocalInterfaceDef_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        CORBA::ExtLocalInterfaceDef, \
        CORBA::tao_ExtLocalInterfaceDef_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ExtLocalInterfaceDef_Proxy_Impl::_TAO_ExtLocalInterfaceDef_Proxy_Impl (void)
{}

CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Impl::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ExtLocalInterfaceDef_Proxy_Broker::_TAO_ExtLocalInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtLocalInterfaceDef_Proxy_Broker::~_TAO_ExtLocalInterfaceDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtLocalInterfaceDef_Proxy_Broker * (*CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker *
CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker::the_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker::~_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtLocalInterfaceDef_Proxy_Impl&
CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ExtLocalInterfaceDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (int collocated)
{
  this->CORBA_ExtLocalInterfaceDef_setup_collocation (collocated);
}

void
CORBA::ExtLocalInterfaceDef::CORBA_ExtLocalInterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExtLocalInterfaceDef_Proxy_Broker_ =
      ::CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExtLocalInterfaceDef_Proxy_Broker_ =
      ::CORBA::_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker::the_TAO_ExtLocalInterfaceDef_Remote_Proxy_Broker ();
  
  this->CORBA_LocalInterfaceDef_setup_collocation (collocated);
  this->CORBA_InterfaceAttrExtension_setup_collocation (collocated);
}

CORBA::ExtLocalInterfaceDef::~ExtLocalInterfaceDef (void)
{}

void 
CORBA::ExtLocalInterfaceDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtLocalInterfaceDef *tmp = ACE_static_cast (ExtLocalInterfaceDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ExtLocalInterfaceDef_ptr
CORBA::ExtLocalInterfaceDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtLocalInterfaceDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ExtLocalInterfaceDef::_nil ());
      
      if (is_a == 0)
        {
          return ExtLocalInterfaceDef::_nil ();
        }
    }
  
  return ExtLocalInterfaceDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ExtLocalInterfaceDef_ptr 
CORBA::ExtLocalInterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtLocalInterfaceDef::_nil ();
    }
  
  ExtLocalInterfaceDef_ptr default_proxy = ExtLocalInterfaceDef::_nil ();
  
  // Code for lazily evaluated IOR's
  if (!obj->is_evaluated ())
    {
      ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::ExtLocalInterfaceDef (
              obj->steal_ior (),
              obj->orb_core ()
            ),
          ExtLocalInterfaceDef::_nil ()
        );
      
      return default_proxy;
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtLocalInterfaceDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ExtLocalInterfaceDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtLocalInterfaceDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ExtLocalInterfaceDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ExtLocalInterfaceDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ExtLocalInterfaceDef::_tao_class_id
                )
            )
        );
}

CORBA::ExtLocalInterfaceDef_ptr
CORBA::ExtLocalInterfaceDef::_duplicate (ExtLocalInterfaceDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ExtLocalInterfaceDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ExtLocalInterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ExtLocalInterfaceDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, LocalInterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::LocalInterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceAttrExtension)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceAttrExtension_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, InterfaceDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ExtLocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0";
}

CORBA::Boolean
CORBA::ExtLocalInterfaceDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtLocalInterfaceDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x744c6f63), 
  ACE_NTOHL (0x616c496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0
    21,
  ACE_NTOHL (0x4578744c), 
  ACE_NTOHL (0x6f63616c), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x0),  // name = ExtLocalInterfaceDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtLocalInterfaceDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ExtLocalInterfaceDef),
    (char *) &_oc_CORBA_ExtLocalInterfaceDef,
    0,
    sizeof (CORBA::ExtLocalInterfaceDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtLocalInterfaceDef,
    &_tc_TAO_tc_CORBA_ExtLocalInterfaceDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::PrimitiveKind _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CORBA::PrimitiveKind>::insert (
      _tao_any,
      CORBA::_tc_PrimitiveKind,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::PrimitiveKind &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CORBA::PrimitiveKind>::extract (
        _tao_any,
        CORBA::_tc_PrimitiveKind,
        _tao_elem 
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<CORBA::PrimitiveKind>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<CORBA::PrimitiveKind \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Repository_ptr _tao_elem
  )
{
  CORBA::Repository_ptr _tao_objptr =
    CORBA::Repository::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Repository_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::Repository>::insert (
      _tao_any,
      CORBA::Repository::_tao_any_destructor,
      CORBA::_tc_Repository,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Repository_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::Repository>::extract (
        _tao_any,
        CORBA::Repository::_tao_any_destructor,
        CORBA::_tc_Repository,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::Repository>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::Repository>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ModuleDef_ptr _tao_elem
  )
{
  CORBA::ModuleDef_ptr _tao_objptr =
    CORBA::ModuleDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ModuleDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ModuleDef>::insert (
      _tao_any,
      CORBA::ModuleDef::_tao_any_destructor,
      CORBA::_tc_ModuleDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ModuleDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ModuleDef>::extract (
        _tao_any,
        CORBA::ModuleDef::_tao_any_destructor,
        CORBA::_tc_ModuleDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ModuleDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ModuleDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ModuleDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ModuleDescription>::insert_copy (
      _tao_any,
      CORBA::ModuleDescription::_tao_any_destructor,
      CORBA::_tc_ModuleDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ModuleDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ModuleDescription>::insert (
      _tao_any,
      CORBA::ModuleDescription::_tao_any_destructor,
      CORBA::_tc_ModuleDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ModuleDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ModuleDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ModuleDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ModuleDescription>::extract (
        _tao_any,
        CORBA::ModuleDescription::_tao_any_destructor,
        CORBA::_tc_ModuleDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ModuleDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ModuleDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ConstantDef_ptr _tao_elem
  )
{
  CORBA::ConstantDef_ptr _tao_objptr =
    CORBA::ConstantDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ConstantDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ConstantDef>::insert (
      _tao_any,
      CORBA::ConstantDef::_tao_any_destructor,
      CORBA::_tc_ConstantDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ConstantDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ConstantDef>::extract (
        _tao_any,
        CORBA::ConstantDef::_tao_any_destructor,
        CORBA::_tc_ConstantDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ConstantDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ConstantDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ConstantDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ConstantDescription>::insert_copy (
      _tao_any,
      CORBA::ConstantDescription::_tao_any_destructor,
      CORBA::_tc_ConstantDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ConstantDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ConstantDescription>::insert (
      _tao_any,
      CORBA::ConstantDescription::_tao_any_destructor,
      CORBA::_tc_ConstantDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ConstantDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ConstantDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ConstantDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ConstantDescription>::extract (
        _tao_any,
        CORBA::ConstantDescription::_tao_any_destructor,
        CORBA::_tc_ConstantDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ConstantDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ConstantDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::StructDef_ptr _tao_elem
  )
{
  CORBA::StructDef_ptr _tao_objptr =
    CORBA::StructDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::StructDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::StructDef>::insert (
      _tao_any,
      CORBA::StructDef::_tao_any_destructor,
      CORBA::_tc_StructDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::StructDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::StructDef>::extract (
        _tao_any,
        CORBA::StructDef::_tao_any_destructor,
        CORBA::_tc_StructDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::StructDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::StructDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::UnionDef_ptr _tao_elem
  )
{
  CORBA::UnionDef_ptr _tao_objptr =
    CORBA::UnionDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::UnionDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::UnionDef>::insert (
      _tao_any,
      CORBA::UnionDef::_tao_any_destructor,
      CORBA::_tc_UnionDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::UnionDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::UnionDef>::extract (
        _tao_any,
        CORBA::UnionDef::_tao_any_destructor,
        CORBA::_tc_UnionDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::UnionDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::UnionDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::EnumDef_ptr _tao_elem
  )
{
  CORBA::EnumDef_ptr _tao_objptr =
    CORBA::EnumDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::EnumDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::EnumDef>::insert (
      _tao_any,
      CORBA::EnumDef::_tao_any_destructor,
      CORBA::_tc_EnumDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::EnumDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::EnumDef>::extract (
        _tao_any,
        CORBA::EnumDef::_tao_any_destructor,
        CORBA::_tc_EnumDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::EnumDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::EnumDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AliasDef_ptr _tao_elem
  )
{
  CORBA::AliasDef_ptr _tao_objptr =
    CORBA::AliasDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AliasDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::AliasDef>::insert (
      _tao_any,
      CORBA::AliasDef::_tao_any_destructor,
      CORBA::_tc_AliasDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AliasDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::AliasDef>::extract (
        _tao_any,
        CORBA::AliasDef::_tao_any_destructor,
        CORBA::_tc_AliasDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::AliasDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::AliasDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::NativeDef_ptr _tao_elem
  )
{
  CORBA::NativeDef_ptr _tao_objptr =
    CORBA::NativeDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::NativeDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::NativeDef>::insert (
      _tao_any,
      CORBA::NativeDef::_tao_any_destructor,
      CORBA::_tc_NativeDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::NativeDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::NativeDef>::extract (
        _tao_any,
        CORBA::NativeDef::_tao_any_destructor,
        CORBA::_tc_NativeDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::NativeDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::NativeDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::PrimitiveDef_ptr _tao_elem
  )
{
  CORBA::PrimitiveDef_ptr _tao_objptr =
    CORBA::PrimitiveDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::PrimitiveDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::PrimitiveDef>::insert (
      _tao_any,
      CORBA::PrimitiveDef::_tao_any_destructor,
      CORBA::_tc_PrimitiveDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::PrimitiveDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::PrimitiveDef>::extract (
        _tao_any,
        CORBA::PrimitiveDef::_tao_any_destructor,
        CORBA::_tc_PrimitiveDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::PrimitiveDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::PrimitiveDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::StringDef_ptr _tao_elem
  )
{
  CORBA::StringDef_ptr _tao_objptr =
    CORBA::StringDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::StringDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::StringDef>::insert (
      _tao_any,
      CORBA::StringDef::_tao_any_destructor,
      CORBA::_tc_StringDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::StringDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::StringDef>::extract (
        _tao_any,
        CORBA::StringDef::_tao_any_destructor,
        CORBA::_tc_StringDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::StringDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::StringDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::WstringDef_ptr _tao_elem
  )
{
  CORBA::WstringDef_ptr _tao_objptr =
    CORBA::WstringDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::WstringDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::WstringDef>::insert (
      _tao_any,
      CORBA::WstringDef::_tao_any_destructor,
      CORBA::_tc_WstringDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::WstringDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::WstringDef>::extract (
        _tao_any,
        CORBA::WstringDef::_tao_any_destructor,
        CORBA::_tc_WstringDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::WstringDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::WstringDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::SequenceDef_ptr _tao_elem
  )
{
  CORBA::SequenceDef_ptr _tao_objptr =
    CORBA::SequenceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::SequenceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::SequenceDef>::insert (
      _tao_any,
      CORBA::SequenceDef::_tao_any_destructor,
      CORBA::_tc_SequenceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::SequenceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::SequenceDef>::extract (
        _tao_any,
        CORBA::SequenceDef::_tao_any_destructor,
        CORBA::_tc_SequenceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::SequenceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::SequenceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ArrayDef_ptr _tao_elem
  )
{
  CORBA::ArrayDef_ptr _tao_objptr =
    CORBA::ArrayDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ArrayDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ArrayDef>::insert (
      _tao_any,
      CORBA::ArrayDef::_tao_any_destructor,
      CORBA::_tc_ArrayDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ArrayDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ArrayDef>::extract (
        _tao_any,
        CORBA::ArrayDef::_tao_any_destructor,
        CORBA::_tc_ArrayDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ArrayDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ArrayDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExceptionDef_ptr _tao_elem
  )
{
  CORBA::ExceptionDef_ptr _tao_objptr =
    CORBA::ExceptionDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExceptionDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ExceptionDef>::insert (
      _tao_any,
      CORBA::ExceptionDef::_tao_any_destructor,
      CORBA::_tc_ExceptionDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExceptionDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ExceptionDef>::extract (
        _tao_any,
        CORBA::ExceptionDef::_tao_any_destructor,
        CORBA::_tc_ExceptionDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ExceptionDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ExceptionDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExceptionDefSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExceptionDefSeq>::insert_copy (
      _tao_any,
      CORBA::ExceptionDefSeq::_tao_any_destructor,
      CORBA::_tc_ExceptionDefSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExceptionDefSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExceptionDefSeq>::insert (
      _tao_any,
      CORBA::ExceptionDefSeq::_tao_any_destructor,
      CORBA::_tc_ExceptionDefSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExceptionDefSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ExceptionDefSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ExceptionDefSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ExceptionDefSeq>::extract (
        _tao_any,
        CORBA::ExceptionDefSeq::_tao_any_destructor,
        CORBA::_tc_ExceptionDefSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ExceptionDefSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ExceptionDefSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AttributeMode _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CORBA::AttributeMode>::insert (
      _tao_any,
      CORBA::_tc_AttributeMode,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AttributeMode &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CORBA::AttributeMode>::extract (
        _tao_any,
        CORBA::_tc_AttributeMode,
        _tao_elem 
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<CORBA::AttributeMode>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<CORBA::AttributeMode \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AttributeDef_ptr _tao_elem
  )
{
  CORBA::AttributeDef_ptr _tao_objptr =
    CORBA::AttributeDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AttributeDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::AttributeDef>::insert (
      _tao_any,
      CORBA::AttributeDef::_tao_any_destructor,
      CORBA::_tc_AttributeDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AttributeDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::AttributeDef>::extract (
        _tao_any,
        CORBA::AttributeDef::_tao_any_destructor,
        CORBA::_tc_AttributeDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::AttributeDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::AttributeDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::AttributeDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::AttributeDescription>::insert_copy (
      _tao_any,
      CORBA::AttributeDescription::_tao_any_destructor,
      CORBA::_tc_AttributeDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AttributeDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::AttributeDescription>::insert (
      _tao_any,
      CORBA::AttributeDescription::_tao_any_destructor,
      CORBA::_tc_AttributeDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AttributeDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::AttributeDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::AttributeDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::AttributeDescription>::extract (
        _tao_any,
        CORBA::AttributeDescription::_tao_any_destructor,
        CORBA::_tc_AttributeDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::AttributeDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::AttributeDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExtAttributeDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExtAttributeDescription>::insert_copy (
      _tao_any,
      CORBA::ExtAttributeDescription::_tao_any_destructor,
      CORBA::_tc_ExtAttributeDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtAttributeDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExtAttributeDescription>::insert (
      _tao_any,
      CORBA::ExtAttributeDescription::_tao_any_destructor,
      CORBA::_tc_ExtAttributeDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtAttributeDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ExtAttributeDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ExtAttributeDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ExtAttributeDescription>::extract (
        _tao_any,
        CORBA::ExtAttributeDescription::_tao_any_destructor,
        CORBA::_tc_ExtAttributeDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ExtAttributeDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ExtAttributeDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtAttributeDef_ptr _tao_elem
  )
{
  CORBA::ExtAttributeDef_ptr _tao_objptr =
    CORBA::ExtAttributeDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtAttributeDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ExtAttributeDef>::insert (
      _tao_any,
      CORBA::ExtAttributeDef::_tao_any_destructor,
      CORBA::_tc_ExtAttributeDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtAttributeDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ExtAttributeDef>::extract (
        _tao_any,
        CORBA::ExtAttributeDef::_tao_any_destructor,
        CORBA::_tc_ExtAttributeDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ExtAttributeDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ExtAttributeDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::OperationMode _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<CORBA::OperationMode>::insert (
      _tao_any,
      CORBA::_tc_OperationMode,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::OperationMode &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<CORBA::OperationMode>::extract (
        _tao_any,
        CORBA::_tc_OperationMode,
        _tao_elem 
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<CORBA::OperationMode>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<CORBA::OperationMode \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ParameterDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ParameterDescription>::insert_copy (
      _tao_any,
      CORBA::ParameterDescription::_tao_any_destructor,
      CORBA::_tc_ParameterDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ParameterDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ParameterDescription>::insert (
      _tao_any,
      CORBA::ParameterDescription::_tao_any_destructor,
      CORBA::_tc_ParameterDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ParameterDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ParameterDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ParameterDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ParameterDescription>::extract (
        _tao_any,
        CORBA::ParameterDescription::_tao_any_destructor,
        CORBA::_tc_ParameterDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ParameterDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ParameterDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ParDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ParDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::ParDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_ParDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ParDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ParDescriptionSeq>::insert (
      _tao_any,
      CORBA::ParDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_ParDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ParDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ParDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ParDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ParDescriptionSeq>::extract (
        _tao_any,
        CORBA::ParDescriptionSeq::_tao_any_destructor,
        CORBA::_tc_ParDescriptionSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ParDescriptionSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ParDescriptionSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContextIdSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ContextIdSeq>::insert_copy (
      _tao_any,
      CORBA::ContextIdSeq::_tao_any_destructor,
      CORBA::_tc_ContextIdSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ContextIdSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ContextIdSeq>::insert (
      _tao_any,
      CORBA::ContextIdSeq::_tao_any_destructor,
      CORBA::_tc_ContextIdSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ContextIdSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ContextIdSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ContextIdSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ContextIdSeq>::extract (
        _tao_any,
        CORBA::ContextIdSeq::_tao_any_destructor,
        CORBA::_tc_ContextIdSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ContextIdSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ContextIdSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::OperationDef_ptr _tao_elem
  )
{
  CORBA::OperationDef_ptr _tao_objptr =
    CORBA::OperationDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::OperationDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::OperationDef>::insert (
      _tao_any,
      CORBA::OperationDef::_tao_any_destructor,
      CORBA::_tc_OperationDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::OperationDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::OperationDef>::extract (
        _tao_any,
        CORBA::OperationDef::_tao_any_destructor,
        CORBA::_tc_OperationDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::OperationDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::OperationDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::OperationDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::OperationDescription>::insert_copy (
      _tao_any,
      CORBA::OperationDescription::_tao_any_destructor,
      CORBA::_tc_OperationDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::OperationDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::OperationDescription>::insert (
      _tao_any,
      CORBA::OperationDescription::_tao_any_destructor,
      CORBA::_tc_OperationDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::OperationDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::OperationDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::OperationDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::OperationDescription>::extract (
        _tao_any,
        CORBA::OperationDescription::_tao_any_destructor,
        CORBA::_tc_OperationDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::OperationDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::OperationDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::RepositoryIdSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::RepositoryIdSeq>::insert_copy (
      _tao_any,
      CORBA::RepositoryIdSeq::_tao_any_destructor,
      CORBA::_tc_RepositoryIdSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::RepositoryIdSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::RepositoryIdSeq>::insert (
      _tao_any,
      CORBA::RepositoryIdSeq::_tao_any_destructor,
      CORBA::_tc_RepositoryIdSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::RepositoryIdSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::RepositoryIdSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::RepositoryIdSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::RepositoryIdSeq>::extract (
        _tao_any,
        CORBA::RepositoryIdSeq::_tao_any_destructor,
        CORBA::_tc_RepositoryIdSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::RepositoryIdSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::RepositoryIdSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::OpDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::OpDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::OpDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_OpDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::OpDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::OpDescriptionSeq>::insert (
      _tao_any,
      CORBA::OpDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_OpDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::OpDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::OpDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::OpDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::OpDescriptionSeq>::extract (
        _tao_any,
        CORBA::OpDescriptionSeq::_tao_any_destructor,
        CORBA::_tc_OpDescriptionSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::OpDescriptionSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::OpDescriptionSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::AttrDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::AttrDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::AttrDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_AttrDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AttrDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::AttrDescriptionSeq>::insert (
      _tao_any,
      CORBA::AttrDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_AttrDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AttrDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::AttrDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::AttrDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::AttrDescriptionSeq>::extract (
        _tao_any,
        CORBA::AttrDescriptionSeq::_tao_any_destructor,
        CORBA::_tc_AttrDescriptionSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::AttrDescriptionSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::AttrDescriptionSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExtAttrDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExtAttrDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::ExtAttrDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_ExtAttrDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtAttrDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExtAttrDescriptionSeq>::insert (
      _tao_any,
      CORBA::ExtAttrDescriptionSeq::_tao_any_destructor,
      CORBA::_tc_ExtAttrDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtAttrDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ExtAttrDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ExtAttrDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ExtAttrDescriptionSeq>::extract (
        _tao_any,
        CORBA::ExtAttrDescriptionSeq::_tao_any_destructor,
        CORBA::_tc_ExtAttrDescriptionSeq,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ExtAttrDescriptionSeq>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ExtAttrDescriptionSeq>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceDef_ptr _tao_elem
  )
{
  CORBA::InterfaceDef_ptr _tao_objptr =
    CORBA::InterfaceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::InterfaceDef>::insert (
      _tao_any,
      CORBA::InterfaceDef::_tao_any_destructor,
      CORBA::_tc_InterfaceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InterfaceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::InterfaceDef>::extract (
        _tao_any,
        CORBA::InterfaceDef::_tao_any_destructor,
        CORBA::_tc_InterfaceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::InterfaceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::InterfaceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InterfaceDef::FullInterfaceDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::InterfaceDef::FullInterfaceDescription>::insert_copy (
      _tao_any,
      CORBA::InterfaceDef::FullInterfaceDescription::_tao_any_destructor,
      CORBA::InterfaceDef::_tc_FullInterfaceDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceDef::FullInterfaceDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::InterfaceDef::FullInterfaceDescription>::insert (
      _tao_any,
      CORBA::InterfaceDef::FullInterfaceDescription::_tao_any_destructor,
      CORBA::InterfaceDef::_tc_FullInterfaceDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InterfaceDef::FullInterfaceDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::InterfaceDef::FullInterfaceDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::InterfaceDef::FullInterfaceDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::InterfaceDef::FullInterfaceDescription>::extract (
        _tao_any,
        CORBA::InterfaceDef::FullInterfaceDescription::_tao_any_destructor,
        CORBA::InterfaceDef::_tc_FullInterfaceDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::InterfaceDef::FullInterfaceDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::InterfaceDef::FullInterfaceDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InterfaceDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::InterfaceDescription>::insert_copy (
      _tao_any,
      CORBA::InterfaceDescription::_tao_any_destructor,
      CORBA::_tc_InterfaceDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::InterfaceDescription>::insert (
      _tao_any,
      CORBA::InterfaceDescription::_tao_any_destructor,
      CORBA::_tc_InterfaceDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InterfaceDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::InterfaceDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::InterfaceDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::InterfaceDescription>::extract (
        _tao_any,
        CORBA::InterfaceDescription::_tao_any_destructor,
        CORBA::_tc_InterfaceDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::InterfaceDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::InterfaceDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceAttrExtension_ptr _tao_elem
  )
{
  CORBA::InterfaceAttrExtension_ptr _tao_objptr =
    CORBA::InterfaceAttrExtension::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceAttrExtension_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::InterfaceAttrExtension>::insert (
      _tao_any,
      CORBA::InterfaceAttrExtension::_tao_any_destructor,
      CORBA::_tc_InterfaceAttrExtension,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InterfaceAttrExtension_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::InterfaceAttrExtension>::extract (
        _tao_any,
        CORBA::InterfaceAttrExtension::_tao_any_destructor,
        CORBA::_tc_InterfaceAttrExtension,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::InterfaceAttrExtension>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::InterfaceAttrExtension>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::insert_copy (
      _tao_any,
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription::_tao_any_destructor,
      CORBA::InterfaceAttrExtension::_tc_ExtFullInterfaceDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::insert (
      _tao_any,
      CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription::_tao_any_destructor,
      CORBA::InterfaceAttrExtension::_tc_ExtFullInterfaceDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::extract (
        _tao_any,
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription::_tao_any_destructor,
        CORBA::InterfaceAttrExtension::_tc_ExtFullInterfaceDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtInterfaceDef_ptr _tao_elem
  )
{
  CORBA::ExtInterfaceDef_ptr _tao_objptr =
    CORBA::ExtInterfaceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtInterfaceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ExtInterfaceDef>::insert (
      _tao_any,
      CORBA::ExtInterfaceDef::_tao_any_destructor,
      CORBA::_tc_ExtInterfaceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtInterfaceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ExtInterfaceDef>::extract (
        _tao_any,
        CORBA::ExtInterfaceDef::_tao_any_destructor,
        CORBA::_tc_ExtInterfaceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ExtInterfaceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ExtInterfaceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AbstractInterfaceDef_ptr _tao_elem
  )
{
  CORBA::AbstractInterfaceDef_ptr _tao_objptr =
    CORBA::AbstractInterfaceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AbstractInterfaceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::AbstractInterfaceDef>::insert (
      _tao_any,
      CORBA::AbstractInterfaceDef::_tao_any_destructor,
      CORBA::_tc_AbstractInterfaceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AbstractInterfaceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::AbstractInterfaceDef>::extract (
        _tao_any,
        CORBA::AbstractInterfaceDef::_tao_any_destructor,
        CORBA::_tc_AbstractInterfaceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::AbstractInterfaceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::AbstractInterfaceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtAbstractInterfaceDef_ptr _tao_elem
  )
{
  CORBA::ExtAbstractInterfaceDef_ptr _tao_objptr =
    CORBA::ExtAbstractInterfaceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtAbstractInterfaceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ExtAbstractInterfaceDef>::insert (
      _tao_any,
      CORBA::ExtAbstractInterfaceDef::_tao_any_destructor,
      CORBA::_tc_ExtAbstractInterfaceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtAbstractInterfaceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ExtAbstractInterfaceDef>::extract (
        _tao_any,
        CORBA::ExtAbstractInterfaceDef::_tao_any_destructor,
        CORBA::_tc_ExtAbstractInterfaceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ExtAbstractInterfaceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ExtAbstractInterfaceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::LocalInterfaceDef_ptr _tao_elem
  )
{
  CORBA::LocalInterfaceDef_ptr _tao_objptr =
    CORBA::LocalInterfaceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::LocalInterfaceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::LocalInterfaceDef>::insert (
      _tao_any,
      CORBA::LocalInterfaceDef::_tao_any_destructor,
      CORBA::_tc_LocalInterfaceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::LocalInterfaceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::LocalInterfaceDef>::extract (
        _tao_any,
        CORBA::LocalInterfaceDef::_tao_any_destructor,
        CORBA::_tc_LocalInterfaceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::LocalInterfaceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::LocalInterfaceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtLocalInterfaceDef_ptr _tao_elem
  )
{
  CORBA::ExtLocalInterfaceDef_ptr _tao_objptr =
    CORBA::ExtLocalInterfaceDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtLocalInterfaceDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ExtLocalInterfaceDef>::insert (
      _tao_any,
      CORBA::ExtLocalInterfaceDef::_tao_any_destructor,
      CORBA::_tc_ExtLocalInterfaceDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtLocalInterfaceDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ExtLocalInterfaceDef>::extract (
        _tao_any,
        CORBA::ExtLocalInterfaceDef::_tao_any_destructor,
        CORBA::_tc_ExtLocalInterfaceDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<CORBA::ExtLocalInterfaceDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<CORBA::ExtLocalInterfaceDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::Repository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::Repository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::Repository::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ModuleDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ModuleDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ModuleDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ConstantDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ConstantDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ConstantDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::StructDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::StructDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::StructDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::UnionDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::UnionDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::UnionDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::EnumDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::EnumDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::EnumDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::AliasDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::AliasDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::AliasDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::NativeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::NativeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::NativeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::PrimitiveDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::PrimitiveDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::PrimitiveDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::StringDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::StringDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::StringDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::WstringDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::WstringDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::WstringDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::SequenceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::SequenceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::SequenceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ArrayDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ArrayDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ArrayDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExceptionDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExceptionDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ExceptionDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_ExceptionDefSeq_CPP_
#define _TAO_CDR_OP_CORBA_ExceptionDefSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag =
            _tao_sequence[i].in ()->marshal (strm);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_CORBA_ExceptionDefSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::AttributeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::AttributeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::AttributeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExtAttributeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExtAttributeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ExtAttributeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_ParDescriptionSeq_CPP_
#define _TAO_CDR_OP_CORBA_ParDescriptionSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_CORBA_ParDescriptionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_ContextIdSeq_CPP_
#define _TAO_CDR_OP_CORBA_ContextIdSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        
      }
    
    return _tao_marshal_flag;
  
  }

return 0;
}

#endif /* _TAO_CDR_OP_CORBA_ContextIdSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::OperationDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::OperationDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::OperationDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_RepositoryIdSeq_CPP_
#define _TAO_CDR_OP_CORBA_RepositoryIdSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        
      }
    
    return _tao_marshal_flag;
  
  }

return 0;
}

#endif /* _TAO_CDR_OP_CORBA_RepositoryIdSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_OpDescriptionSeq_CPP_
#define _TAO_CDR_OP_CORBA_OpDescriptionSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_CORBA_OpDescriptionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_AttrDescriptionSeq_CPP_
#define _TAO_CDR_OP_CORBA_AttrDescriptionSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_CORBA_AttrDescriptionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:80

#if !defined _TAO_CDR_OP_CORBA_ExtAttrDescriptionSeq_CPP_
#define _TAO_CDR_OP_CORBA_ExtAttrDescriptionSeq_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExtAttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExtAttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    
    }
  
  return 0;
}

#endif /* _TAO_CDR_OP_CORBA_ExtAttrDescriptionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::InterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InterfaceAttrExtension_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InterfaceAttrExtension_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::InterfaceAttrExtension::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExtInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExtInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ExtInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::AbstractInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::AbstractInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::AbstractInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExtAbstractInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExtAbstractInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ExtAbstractInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::LocalInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::LocalInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::LocalInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExtLocalInterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExtLocalInterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ExtLocalInterfaceDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

