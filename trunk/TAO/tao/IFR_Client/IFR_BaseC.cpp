// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:314


#include "IFR_BaseC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */


#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BaseC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Identifier[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4964), 
  ACE_NTOHL (0x656e7469), 
  ACE_NTOHL (0x66696572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
  11,
  ACE_NTOHL (0x4964656e), 
  ACE_NTOHL (0x74696669), 
  ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Identifier (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_Identifier),
    (char *) &_oc_CORBA_Identifier,
    0,
    sizeof (CORBA::Identifier)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Identifier,
    &_tc_TAO_tc_CORBA_Identifier
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ScopedName[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5363), 
  ACE_NTOHL (0x6f706564), 
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
  11,
  ACE_NTOHL (0x53636f70), 
  ACE_NTOHL (0x65644e61), 
  ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ScopedName (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ScopedName),
    (char *) &_oc_CORBA_ScopedName,
    0,
    sizeof (CORBA::ScopedName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ScopedName,
    &_tc_TAO_tc_CORBA_ScopedName
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_RepositoryId[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5265), 
  ACE_NTOHL (0x706f7369), 
  ACE_NTOHL (0x746f7279), 
  ACE_NTOHL (0x49643a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
  13,
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72794964), 
  ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryId (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_RepositoryId),
    (char *) &_oc_CORBA_RepositoryId,
    0,
    sizeof (CORBA::RepositoryId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_RepositoryId,
    &_tc_TAO_tc_CORBA_RepositoryId
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_DefinitionKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4465), 
  ACE_NTOHL (0x66696e69), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x4b696e64), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
15,
  ACE_NTOHL (0x44656669), 
  ACE_NTOHL (0x6e697469), 
  ACE_NTOHL (0x6f6e4b69), 
  ACE_NTOHL (0x6e640000),  // name = DefinitionKind
  26, // member count
8,
  ACE_NTOHL (0x646b5f6e), 
  ACE_NTOHL (0x6f6e6500),  // name = dk_none
7,
  ACE_NTOHL (0x646b5f61), 
  ACE_NTOHL (0x6c6c0000),  // name = dk_all
13,
  ACE_NTOHL (0x646b5f41), 
  ACE_NTOHL (0x74747269), 
  ACE_NTOHL (0x62757465), 
  ACE_NTOHL (0x0),  // name = dk_Attribute
12,
  ACE_NTOHL (0x646b5f43), 
  ACE_NTOHL (0x6f6e7374), 
  ACE_NTOHL (0x616e7400),  // name = dk_Constant
13,
  ACE_NTOHL (0x646b5f45), 
  ACE_NTOHL (0x78636570), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = dk_Exception
13,
  ACE_NTOHL (0x646b5f49), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = dk_Interface
10,
  ACE_NTOHL (0x646b5f4d), 
  ACE_NTOHL (0x6f64756c), 
  ACE_NTOHL (0x65000000),  // name = dk_Module
13,
  ACE_NTOHL (0x646b5f4f), 
  ACE_NTOHL (0x70657261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = dk_Operation
11,
  ACE_NTOHL (0x646b5f54), 
  ACE_NTOHL (0x79706564), 
  ACE_NTOHL (0x65660000),  // name = dk_Typedef
9,
  ACE_NTOHL (0x646b5f41), 
  ACE_NTOHL (0x6c696173), 
  ACE_NTOHL (0x0),  // name = dk_Alias
10,
  ACE_NTOHL (0x646b5f53), 
  ACE_NTOHL (0x74727563), 
  ACE_NTOHL (0x74000000),  // name = dk_Struct
9,
  ACE_NTOHL (0x646b5f55), 
  ACE_NTOHL (0x6e696f6e), 
  ACE_NTOHL (0x0),  // name = dk_Union
8,
  ACE_NTOHL (0x646b5f45), 
  ACE_NTOHL (0x6e756d00),  // name = dk_Enum
13,
  ACE_NTOHL (0x646b5f50), 
  ACE_NTOHL (0x72696d69), 
  ACE_NTOHL (0x74697665), 
  ACE_NTOHL (0x0),  // name = dk_Primitive
10,
  ACE_NTOHL (0x646b5f53), 
  ACE_NTOHL (0x7472696e), 
  ACE_NTOHL (0x67000000),  // name = dk_String
12,
  ACE_NTOHL (0x646b5f53), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x6e636500),  // name = dk_Sequence
9,
  ACE_NTOHL (0x646b5f41), 
  ACE_NTOHL (0x72726179), 
  ACE_NTOHL (0x0),  // name = dk_Array
14,
  ACE_NTOHL (0x646b5f52), 
  ACE_NTOHL (0x65706f73), 
  ACE_NTOHL (0x69746f72), 
  ACE_NTOHL (0x79000000),  // name = dk_Repository
11,
  ACE_NTOHL (0x646b5f57), 
  ACE_NTOHL (0x73747269), 
  ACE_NTOHL (0x6e670000),  // name = dk_Wstring
9,
  ACE_NTOHL (0x646b5f46), 
  ACE_NTOHL (0x69786564), 
  ACE_NTOHL (0x0),  // name = dk_Fixed
9,
  ACE_NTOHL (0x646b5f56), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x0),  // name = dk_Value
12,
  ACE_NTOHL (0x646b5f56), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
15,
  ACE_NTOHL (0x646b5f56), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x65720000),  // name = dk_ValueMember
10,
  ACE_NTOHL (0x646b5f4e), 
  ACE_NTOHL (0x61746976), 
  ACE_NTOHL (0x65000000),  // name = dk_Native
21,
  ACE_NTOHL (0x646b5f41), 
  ACE_NTOHL (0x62737472), 
  ACE_NTOHL (0x61637449), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x0),  // name = dk_AbstractInterface
18,
  ACE_NTOHL (0x646b5f4c), 
  ACE_NTOHL (0x6f63616c), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65000000),  // name = dk_LocalInterface
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_DefinitionKind (
    CORBA::tk_enum,
    sizeof (_oc_CORBA_DefinitionKind),
    (char *) &_oc_CORBA_DefinitionKind,
    0,
    sizeof (CORBA::DefinitionKind)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_DefinitionKind,
    &_tc_TAO_tc_CORBA_DefinitionKind
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:61

int CORBA::IRObject::_tao_class_id = 0;

CORBA::IRObject_ptr
tao_CORBA_IRObject_duplicate (
    CORBA::IRObject_ptr p
  )
{
  return CORBA::IRObject::_duplicate (p);
}

void
tao_CORBA_IRObject_release (
    CORBA::IRObject_ptr p
  )
{
  CORBA::release (p);
}

CORBA::IRObject_ptr
tao_CORBA_IRObject_nil (
    void
  )
{
  return CORBA::IRObject::_nil ();
}

CORBA::IRObject_ptr
tao_CORBA_IRObject_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::IRObject::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_IRObject_upcast (
    void *src
  )
{
  CORBA::IRObject **tmp =
    ACE_static_cast (CORBA::IRObject **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:721

// *************************************************************
// CORBA::IRObject_var
// *************************************************************

CORBA::IRObject_var::IRObject_var (void)
  : ptr_ (IRObject::_nil ())
{}

::CORBA::IRObject_ptr
CORBA::IRObject_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::IRObject_var::IRObject_var (const ::CORBA::IRObject_var &p)
  : TAO_Base_var (),
    ptr_ (IRObject::_duplicate (p.ptr ()))
{}

CORBA::IRObject_var::~IRObject_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::IRObject_var &
CORBA::IRObject_var::operator= (IRObject_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::IRObject_var &
CORBA::IRObject_var::operator= (const ::CORBA::IRObject_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::IRObject::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::IRObject_var::operator const ::CORBA::IRObject_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::IRObject_var::operator ::CORBA::IRObject_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::IRObject_ptr
CORBA::IRObject_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::IRObject_ptr
CORBA::IRObject_var::in (void) const
{
  return this->ptr_;
}

::CORBA::IRObject_ptr &
CORBA::IRObject_var::inout (void)
{
  return this->ptr_;
}

::CORBA::IRObject_ptr &
CORBA::IRObject_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::IRObject::_nil ();
  return this->ptr_;
}

::CORBA::IRObject_ptr
CORBA::IRObject_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::IRObject_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::IRObject::_nil ();
  return val;
}

::CORBA::IRObject_ptr
CORBA::IRObject_var::tao_duplicate (IRObject_ptr p)
{
  return ::CORBA::IRObject::_duplicate (p);
}

void
CORBA::IRObject_var::tao_release (IRObject_ptr p)
{
  CORBA::release (p);
}

::CORBA::IRObject_ptr
CORBA::IRObject_var::tao_nil (void)
{
  return ::CORBA::IRObject::_nil ();
}

::CORBA::IRObject_ptr
CORBA::IRObject_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::IRObject::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::IRObject_var::tao_upcast (void *src)
{
  IRObject **tmp =
    ACE_static_cast (IRObject **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1030

// *************************************************************
// CORBA::IRObject_out
// *************************************************************

CORBA::IRObject_out::IRObject_out (IRObject_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::IRObject::_nil ();
}

CORBA::IRObject_out::IRObject_out (IRObject_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::IRObject::_nil ();
}

CORBA::IRObject_out::IRObject_out (const ::CORBA::IRObject_out &p)
  : ptr_ (ACE_const_cast (IRObject_out &, p).ptr_)
{}

::CORBA::IRObject_out &
CORBA::IRObject_out::operator= (const ::CORBA::IRObject_out &p)
{
  this->ptr_ = ACE_const_cast (IRObject_out&, p).ptr_;
  return *this;
}

CORBA::IRObject_out &
CORBA::IRObject_out::operator= (const ::CORBA::IRObject_var &p)
{
  this->ptr_ = ::CORBA::IRObject::_duplicate (p.ptr ());
  return *this;
}

CORBA::IRObject_out &
CORBA::IRObject_out::operator= (IRObject_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::IRObject_out::operator ::CORBA::IRObject_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::IRObject_ptr &
CORBA::IRObject_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::IRObject_ptr
CORBA::IRObject_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::DefinitionKind result);
    
  private:
    TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (const TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get &);
    
    ::CORBA::DefinitionKind _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (::CORBA::DefinitionKind result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_IRObject_destroy : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_IRObject_destroy (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_IRObject_destroy (const TAO_ClientRequestInfo_CORBA_IRObject_destroy &);
    void operator= (const TAO_ClientRequestInfo_CORBA_IRObject_destroy &);
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_IRObject_destroy::TAO_ClientRequestInfo_CORBA_IRObject_destroy (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_IRObject_destroy::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_IRObject_destroy::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_IRObject_destroy::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_IRObject_Proxy_Impl::_TAO_IRObject_Proxy_Impl (void)
{}

CORBA::_TAO_IRObject_Remote_Proxy_Impl::_TAO_IRObject_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::DefinitionKind CORBA::_TAO_IRObject_Remote_Proxy_Impl::def_kind (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::DefinitionKind _tao_retval = (CORBA::DefinitionKind)0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_def_kind",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      _tao_retval
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval)
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          _tao_retval
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::DefinitionKind _tao_retval_info =
                    _tao_retval;
                  _tao_ri.result (_tao_retval_info);
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_IRObject_Remote_Proxy_Impl::destroy (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_IRObject_destroy _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_IRObject_Proxy_Broker::_TAO_IRObject_Proxy_Broker (void)
{
}

CORBA::_TAO_IRObject_Proxy_Broker::~_TAO_IRObject_Proxy_Broker (void)
{
}

CORBA::_TAO_IRObject_Proxy_Broker * (*CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_IRObject_Remote_Proxy_Broker *
CORBA::_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_IRObject_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_IRObject_Remote_Proxy_Broker::_TAO_IRObject_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_IRObject_Remote_Proxy_Broker::~_TAO_IRObject_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_IRObject_Proxy_Impl&
CORBA::_TAO_IRObject_Remote_Proxy_Broker::select_proxy (
    ::CORBA::IRObject *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:225

CORBA::IRObject::IRObject (int collocated)
{
  this->CORBA_IRObject_setup_collocation (collocated);
}

void
CORBA::IRObject::CORBA_IRObject_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_IRObject_Proxy_Broker_ =
      ::CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_IRObject_Proxy_Broker_ =
      ::CORBA::_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker ();
}

CORBA::IRObject::~IRObject (void)
{}

void 
CORBA::IRObject::_tao_any_destructor (void *_tao_void_pointer)
{
  IRObject *tmp = ACE_static_cast (IRObject *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::IRObject_ptr
CORBA::IRObject::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return IRObject::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/IRObject:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (IRObject::_nil ());
      
      if (is_a == 0)
        {
          return IRObject::_nil ();
        }
    }
  
  return IRObject::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::IRObject_ptr 
CORBA::IRObject::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return IRObject::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      IRObject_ptr default_proxy = IRObject::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::IRObject (
                  stub,
                  1,
                  obj->_servant ()
                ),
              IRObject::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::IRObject (
                  stub,
                  0,
                  obj->_servant ()
                ),
              IRObject::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          IRObject_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &IRObject::_tao_class_id
                )
            )
        );
}

CORBA::IRObject_ptr
CORBA::IRObject::_duplicate (IRObject_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::IRObject::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::IRObject::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IRObject)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::DefinitionKind CORBA::IRObject::def_kind (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_IRObject_Proxy_Impl &proxy = 
    this->the_TAO_IRObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((CORBA::DefinitionKind)0);
  
  return proxy.def_kind (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::IRObject::destroy (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_IRObject_Proxy_Impl &proxy = 
    this->the_TAO_IRObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.destroy (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_IRObject[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4952), 
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/IRObject:1.0
  9,
  ACE_NTOHL (0x49524f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x0),  // name = IRObject
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_IRObject (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_IRObject),
    (char *) &_oc_CORBA_IRObject,
    0,
    sizeof (CORBA::IRObject)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IRObject,
    &_tc_TAO_tc_CORBA_IRObject
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_VersionSpec[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5665), 
  ACE_NTOHL (0x7273696f), 
  ACE_NTOHL (0x6e537065), 
  ACE_NTOHL (0x633a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
  12,
  ACE_NTOHL (0x56657273), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_VersionSpec (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_VersionSpec),
    (char *) &_oc_CORBA_VersionSpec,
    0,
    sizeof (CORBA::VersionSpec)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_VersionSpec,
    &_tc_TAO_tc_CORBA_VersionSpec
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:61

int CORBA::Contained::_tao_class_id = 0;

CORBA::Contained_ptr
tao_CORBA_Contained_duplicate (
    CORBA::Contained_ptr p
  )
{
  return CORBA::Contained::_duplicate (p);
}

void
tao_CORBA_Contained_release (
    CORBA::Contained_ptr p
  )
{
  CORBA::release (p);
}

CORBA::Contained_ptr
tao_CORBA_Contained_nil (
    void
  )
{
  return CORBA::Contained::_nil ();
}

CORBA::Contained_ptr
tao_CORBA_Contained_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::Contained::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_Contained_upcast (
    void *src
  )
{
  CORBA::Contained **tmp =
    ACE_static_cast (CORBA::Contained **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:721

// *************************************************************
// CORBA::Contained_var
// *************************************************************

CORBA::Contained_var::Contained_var (void)
  : ptr_ (Contained::_nil ())
{}

::CORBA::Contained_ptr
CORBA::Contained_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::Contained_var::Contained_var (const ::CORBA::Contained_var &p)
  : TAO_Base_var (),
    ptr_ (Contained::_duplicate (p.ptr ()))
{}

CORBA::Contained_var::~Contained_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::Contained_var &
CORBA::Contained_var::operator= (Contained_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::Contained_var &
CORBA::Contained_var::operator= (const ::CORBA::Contained_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::Contained::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::Contained_var::operator const ::CORBA::Contained_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::Contained_var::operator ::CORBA::Contained_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::Contained_ptr
CORBA::Contained_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::Contained_ptr
CORBA::Contained_var::in (void) const
{
  return this->ptr_;
}

::CORBA::Contained_ptr &
CORBA::Contained_var::inout (void)
{
  return this->ptr_;
}

::CORBA::Contained_ptr &
CORBA::Contained_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::Contained::_nil ();
  return this->ptr_;
}

::CORBA::Contained_ptr
CORBA::Contained_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::Contained_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::Contained::_nil ();
  return val;
}

::CORBA::Contained_ptr
CORBA::Contained_var::tao_duplicate (Contained_ptr p)
{
  return ::CORBA::Contained::_duplicate (p);
}

void
CORBA::Contained_var::tao_release (Contained_ptr p)
{
  CORBA::release (p);
}

::CORBA::Contained_ptr
CORBA::Contained_var::tao_nil (void)
{
  return ::CORBA::Contained::_nil ();
}

::CORBA::Contained_ptr
CORBA::Contained_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::Contained::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::Contained_var::tao_upcast (void *src)
{
  Contained **tmp =
    ACE_static_cast (Contained **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1030

// *************************************************************
// CORBA::Contained_out
// *************************************************************

CORBA::Contained_out::Contained_out (Contained_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::Contained::_nil ();
}

CORBA::Contained_out::Contained_out (Contained_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::Contained::_nil ();
}

CORBA::Contained_out::Contained_out (const ::CORBA::Contained_out &p)
  : ptr_ (ACE_const_cast (Contained_out &, p).ptr_)
{}

::CORBA::Contained_out &
CORBA::Contained_out::operator= (const ::CORBA::Contained_out &p)
{
  this->ptr_ = ACE_const_cast (Contained_out&, p).ptr_;
  return *this;
}

CORBA::Contained_out &
CORBA::Contained_out::operator= (const ::CORBA::Contained_var &p)
{
  this->ptr_ = ::CORBA::Contained::_duplicate (p.ptr ());
  return *this;
}

CORBA::Contained_out &
CORBA::Contained_out::operator= (Contained_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::Contained_out::operator ::CORBA::Contained_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::Contained_ptr &
CORBA::Contained_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::Contained_ptr
CORBA::Contained_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_id_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_id_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (char * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_id_get (const TAO_ClientRequestInfo_CORBA_Contained_id_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_id_get &);
    
    char * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_id_get::TAO_ClientRequestInfo_CORBA_Contained_id_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_id_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_id_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_id_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_id_get::result (char * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_id_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_id_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_Contained_id_set (const TAO_ClientRequestInfo_CORBA_Contained_id_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_id_set &);
    const char * id_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_id_set::TAO_ClientRequestInfo_CORBA_Contained_id_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_id_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_id_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_id_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_name_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_name_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (char * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_name_get (const TAO_ClientRequestInfo_CORBA_Contained_name_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_name_get &);
    
    char * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_name_get::TAO_ClientRequestInfo_CORBA_Contained_name_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_name_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_name_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_name_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_name_get::result (char * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_name_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_name_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_Contained_name_set (const TAO_ClientRequestInfo_CORBA_Contained_name_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_name_set &);
    const char * name_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_name_set::TAO_ClientRequestInfo_CORBA_Contained_name_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      name_ (name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_name_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_name_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_name_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_version_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_version_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (char * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_version_get (const TAO_ClientRequestInfo_CORBA_Contained_version_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_version_get &);
    
    char * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_version_get::TAO_ClientRequestInfo_CORBA_Contained_version_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_version_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_version_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_version_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_version_get::result (char * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_version_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_version_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * version
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_Contained_version_set (const TAO_ClientRequestInfo_CORBA_Contained_version_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_version_set &);
    const char * version_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_version_set::TAO_ClientRequestInfo_CORBA_Contained_version_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * version
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      version_ (version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_version_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_version_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_version_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_defined_in_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_defined_in_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Container_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_defined_in_get (const TAO_ClientRequestInfo_CORBA_Contained_defined_in_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_defined_in_get &);
    
    ::CORBA::Container_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::TAO_ClientRequestInfo_CORBA_Contained_defined_in_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::result (::CORBA::Container_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (char * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get (const TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get &);
    
    char * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::result (char * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Repository_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get (const TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get &);
    
    ::CORBA::Repository_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::result (::CORBA::Repository_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_describe : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_describe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Contained::Description * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Contained_describe (const TAO_ClientRequestInfo_CORBA_Contained_describe &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_describe &);
    
    ::CORBA::Contained::Description * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_describe::TAO_ClientRequestInfo_CORBA_Contained_describe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_describe::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_describe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_describe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_describe::result (::CORBA::Contained::Description * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Contained_move : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_move (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Container_ptr new_container,
      const char * new_name,
      const char * new_version
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_Contained_move (const TAO_ClientRequestInfo_CORBA_Contained_move &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Contained_move &);
    CORBA::Container_ptr new_container_;
    const char * new_name_;
    const char * new_version_;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Contained_move::TAO_ClientRequestInfo_CORBA_Contained_move (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Container_ptr new_container,
      const char * new_name,
      const char * new_version
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      new_container_ (new_container),
      new_name_ (new_name),
      new_version_ (new_version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_move::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->new_container_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= new_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= new_version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_move::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_move::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_Contained_Proxy_Impl::_TAO_Contained_Proxy_Impl (void)
{}

CORBA::_TAO_Contained_Remote_Proxy_Impl::_TAO_Contained_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

char * CORBA::_TAO_Contained_Remote_Proxy_Impl::id (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_id",
      7,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_id_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  char * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_Contained_Remote_Proxy_Impl::id (
    CORBA::Object *_collocated_tao_target_,
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_id",
      7,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_id_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id)
                  ))
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::MARSHAL (
                          
                        )
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

char * CORBA::_TAO_Contained_Remote_Proxy_Impl::name (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_name",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_name_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  char * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_Contained_Remote_Proxy_Impl::name (
    CORBA::Object *_collocated_tao_target_,
    const char * name
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_name",
      9,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_name_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          name
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << name)
                  ))
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::MARSHAL (
                          
                        )
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

char * CORBA::_TAO_Contained_Remote_Proxy_Impl::version (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_version",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_version_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  char * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_Contained_Remote_Proxy_Impl::version (
    CORBA::Object *_collocated_tao_target_,
    const char * version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_version",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_version_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          version
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << version)
                  ))
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::MARSHAL (
                          
                        )
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::Container_ptr CORBA::_TAO_Contained_Remote_Proxy_Impl::defined_in (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Container_var _tao_retval (CORBA::Container::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_defined_in",
      15,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_defined_in_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::Container_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

char * CORBA::_TAO_Contained_Remote_Proxy_Impl::absolute_name (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_absolute_name",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  char * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::Repository_ptr CORBA::_TAO_Contained_Remote_Proxy_Impl::containing_repository (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Repository_var _tao_retval ( tao_CORBA_Repository_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_containing_repository",
      26,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::Repository_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::Contained::Description * CORBA::_TAO_Contained_Remote_Proxy_Impl::describe (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Contained::Description_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::Contained::Description *tmp;
    ACE_NEW_RETURN (tmp, CORBA::Contained::Description, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe",
      8,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_describe _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::Contained::Description * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_Contained_Remote_Proxy_Impl::move (
    CORBA::Object *_collocated_tao_target_,
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "move",
      4,
      3,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_move _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          new_container,
          new_name,
          new_version
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK;

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << new_container) &&
                  (_tao_out << new_name) &&
                  (_tao_out << new_version)
                  ))
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::MARSHAL (
                          
                        )
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK;

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        )
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
#if TAO_HAS_INTERCEPTORS == 1
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_Contained_Proxy_Broker::_TAO_Contained_Proxy_Broker (void)
{
}

CORBA::_TAO_Contained_Proxy_Broker::~_TAO_Contained_Proxy_Broker (void)
{
}

CORBA::_TAO_Contained_Proxy_Broker * (*CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_Contained_Remote_Proxy_Broker *
CORBA::_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_Contained_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_Contained_Remote_Proxy_Broker::_TAO_Contained_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_Contained_Remote_Proxy_Broker::~_TAO_Contained_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_Contained_Proxy_Impl&
CORBA::_TAO_Contained_Remote_Proxy_Broker::select_proxy (
    ::CORBA::Contained *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:225

CORBA::Contained::Contained (int collocated)
{
  this->CORBA_Contained_setup_collocation (collocated);
}

void
CORBA::Contained::CORBA_Contained_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Contained_Proxy_Broker_ =
      ::CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Contained_Proxy_Broker_ =
      ::CORBA::_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

CORBA::Contained::~Contained (void)
{}

void 
CORBA::Contained::_tao_any_destructor (void *_tao_void_pointer)
{
  Contained *tmp = ACE_static_cast (Contained *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::Contained_ptr
CORBA::Contained::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Contained::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/Contained:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Contained::_nil ());
      
      if (is_a == 0)
        {
          return Contained::_nil ();
        }
    }
  
  return Contained::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::Contained_ptr 
CORBA::Contained::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Contained::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Contained_ptr default_proxy = Contained::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::Contained (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Contained::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::Contained (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Contained::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Contained_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Contained::_tao_class_id
                )
            )
        );
}

CORBA::Contained_ptr
CORBA::Contained::_duplicate (Contained_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::Contained::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::Contained::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, Contained)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IRObject)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

char * CORBA::Contained::id (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.id (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::Contained::id (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.id (
      this,
      id
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

char * CORBA::Contained::name (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.name (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::Contained::name (
    const char * name
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.name (
      this,
      name
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

char * CORBA::Contained::version (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.version (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::Contained::version (
    const char * version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.version (
      this,
      version
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::Container_ptr CORBA::Contained::defined_in (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.defined_in (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

char * CORBA::Contained::absolute_name (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.absolute_name (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::Repository_ptr CORBA::Contained::containing_repository (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.containing_repository (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Contained_Description[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65642f), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained/Description:1.0
  12,
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = Description
  2, // member count
  5,
  ACE_NTOHL (0x6b696e64), 
  ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  524, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4465), 
    ACE_NTOHL (0x66696e69), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x4b696e64), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
15,
    ACE_NTOHL (0x44656669), 
    ACE_NTOHL (0x6e697469), 
    ACE_NTOHL (0x6f6e4b69), 
    ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    26, // member count
8,
    ACE_NTOHL (0x646b5f6e), 
    ACE_NTOHL (0x6f6e6500),  // name = dk_none
7,
    ACE_NTOHL (0x646b5f61), 
    ACE_NTOHL (0x6c6c0000),  // name = dk_all
13,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x74747269), 
    ACE_NTOHL (0x62757465), 
    ACE_NTOHL (0x0),  // name = dk_Attribute
12,
    ACE_NTOHL (0x646b5f43), 
    ACE_NTOHL (0x6f6e7374), 
    ACE_NTOHL (0x616e7400),  // name = dk_Constant
13,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x78636570), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Exception
13,
    ACE_NTOHL (0x646b5f49), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_Interface
10,
    ACE_NTOHL (0x646b5f4d), 
    ACE_NTOHL (0x6f64756c), 
    ACE_NTOHL (0x65000000),  // name = dk_Module
13,
    ACE_NTOHL (0x646b5f4f), 
    ACE_NTOHL (0x70657261), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Operation
11,
    ACE_NTOHL (0x646b5f54), 
    ACE_NTOHL (0x79706564), 
    ACE_NTOHL (0x65660000),  // name = dk_Typedef
9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x6c696173), 
    ACE_NTOHL (0x0),  // name = dk_Alias
10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x74727563), 
    ACE_NTOHL (0x74000000),  // name = dk_Struct
9,
    ACE_NTOHL (0x646b5f55), 
    ACE_NTOHL (0x6e696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Union
8,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x6e756d00),  // name = dk_Enum
13,
    ACE_NTOHL (0x646b5f50), 
    ACE_NTOHL (0x72696d69), 
    ACE_NTOHL (0x74697665), 
    ACE_NTOHL (0x0),  // name = dk_Primitive
10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x7472696e), 
    ACE_NTOHL (0x67000000),  // name = dk_String
12,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = dk_Sequence
9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x72726179), 
    ACE_NTOHL (0x0),  // name = dk_Array
14,
    ACE_NTOHL (0x646b5f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x79000000),  // name = dk_Repository
11,
    ACE_NTOHL (0x646b5f57), 
    ACE_NTOHL (0x73747269), 
    ACE_NTOHL (0x6e670000),  // name = dk_Wstring
9,
    ACE_NTOHL (0x646b5f46), 
    ACE_NTOHL (0x69786564), 
    ACE_NTOHL (0x0),  // name = dk_Fixed
9,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x0),  // name = dk_Value
12,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
15,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x4d656d62), 
    ACE_NTOHL (0x65720000),  // name = dk_ValueMember
10,
    ACE_NTOHL (0x646b5f4e), 
    ACE_NTOHL (0x61746976), 
    ACE_NTOHL (0x65000000),  // name = dk_Native
21,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x62737472), 
    ACE_NTOHL (0x61637449), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_AbstractInterface
18,
    ACE_NTOHL (0x646b5f4c), 
    ACE_NTOHL (0x6f63616c), 
    ACE_NTOHL (0x496e7465), 
    ACE_NTOHL (0x72666163), 
    ACE_NTOHL (0x65000000),  // name = dk_LocalInterface

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained_Description (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_Contained_Description),
    (char *) &_oc_CORBA_Contained_Description,
    0,
    sizeof (CORBA::Contained::Description)
  );

::CORBA::TypeCode_ptr CORBA::Contained::_tc_Description =
  &_tc_TAO_tc_CORBA_Contained_Description;

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:67

void CORBA::Contained::Description::_tao_any_destructor (void *_tao_void_pointer)
{
  Description *tmp = ACE_static_cast (Description*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::Contained::Description * CORBA::Contained::describe (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

void CORBA::Contained::move (
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.move (
      this,
      new_container,
      new_name,
      new_version
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Contained[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
  10,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x64000000),  // name = Contained
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_Contained),
    (char *) &_oc_CORBA_Contained,
    0,
    sizeof (CORBA::Contained)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Contained,
    &_tc_TAO_tc_CORBA_Contained
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::Contained **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::Contained **old = ACE_reinterpret_cast (CORBA::Contained**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = CORBA::Contained::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::Contained **tmp = ACE_reinterpret_cast (CORBA::Contained**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::Contained::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::freebuf (tmp);
  this->buffer_ = 0;
}

CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void)
{
  this->_deallocate_buffer ();
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  CORBA::Contained **tmp = ACE_reinterpret_cast (CORBA::Contained**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::Contained::_nil ();
    }
}

void 
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_downcast (
    void* target,
    CORBA::Object *src
    ACE_ENV_ARG_DECL
  )
{
  CORBA::Contained **tmp = ACE_static_cast (CORBA::Contained**, target);
  *tmp = CORBA::Contained::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA::Object*
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_upcast (void *src) const
{
  CORBA::Contained **tmp = ACE_static_cast (CORBA::Contained**, src);
  return *tmp;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_CONTAINEDSEQ_CS_)
#define _CORBA_CONTAINEDSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::ContainedSeq
// *************************************************************

CORBA::ContainedSeq::ContainedSeq (void)
{}

CORBA::ContainedSeq::ContainedSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::ContainedSeq::ContainedSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Contained_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::ContainedSeq::ContainedSeq (const ContainedSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::ContainedSeq::~ContainedSeq (void) // dtor
{}

void CORBA::ContainedSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ContainedSeq *tmp = ACE_static_cast (ContainedSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ContainedSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e656453), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContainedSeq:1.0
  13,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x64536571), 
  ACE_NTOHL (0x0),  // name = ContainedSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6e746169), 
      ACE_NTOHL (0x6e65643a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
      10,
      ACE_NTOHL (0x436f6e74), 
      ACE_NTOHL (0x61696e65), 
      ACE_NTOHL (0x64000000),  // name = Contained

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ContainedSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ContainedSeq),
    (char *) &_oc_CORBA_ContainedSeq,
    0,
    sizeof (CORBA::ContainedSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ContainedSeq,
    &_tc_TAO_tc_CORBA_ContainedSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::InterfaceDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::InterfaceDef **old = ACE_reinterpret_cast (CORBA::InterfaceDef**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = tao_CORBA_InterfaceDef_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::InterfaceDef **tmp = ACE_reinterpret_cast (CORBA::InterfaceDef**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_CORBA_InterfaceDef_release (tmp[i]);
      tmp[i] = tao_CORBA_InterfaceDef_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

CORBA::_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  CORBA::InterfaceDef **tmp = ACE_reinterpret_cast (CORBA::InterfaceDef**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_CORBA_InterfaceDef_release (tmp[i]);
      tmp[i] = tao_CORBA_InterfaceDef_nil ();
    }
}

void 
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_downcast (
    void* target,
    CORBA::Object *src
    ACE_ENV_ARG_DECL
  )
{
  CORBA::InterfaceDef **tmp = ACE_static_cast (CORBA::InterfaceDef**, target);
  *tmp = tao_CORBA_InterfaceDef_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA::Object*
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_upcast (void *src) const
{
  return tao_CORBA_InterfaceDef_upcast (src);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_INTERFACEDEFSEQ_CS_)
#define _CORBA_INTERFACEDEFSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::InterfaceDefSeq
// *************************************************************

CORBA::InterfaceDefSeq::InterfaceDefSeq (void)
{}

CORBA::InterfaceDefSeq::InterfaceDefSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::InterfaceDef,CORBA::InterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::InterfaceDefSeq::InterfaceDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::InterfaceDef_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::InterfaceDef,CORBA::InterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::InterfaceDefSeq::InterfaceDefSeq (const InterfaceDefSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::InterfaceDef,CORBA::InterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::InterfaceDefSeq::~InterfaceDefSeq (void) // dtor
{}

void CORBA::InterfaceDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  InterfaceDefSeq *tmp = ACE_static_cast (InterfaceDefSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InterfaceDefSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/InterfaceDefSeq:1.0
  16,
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x53657100),  // name = InterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f496e), 
      ACE_NTOHL (0x74657266), 
      ACE_NTOHL (0x61636544), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
      13,
      ACE_NTOHL (0x496e7465), 
      ACE_NTOHL (0x72666163), 
      ACE_NTOHL (0x65446566), 
      ACE_NTOHL (0x0),  // name = InterfaceDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_InterfaceDefSeq),
    (char *) &_oc_CORBA_InterfaceDefSeq,
    0,
    sizeof (CORBA::InterfaceDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InterfaceDefSeq,
    &_tc_TAO_tc_CORBA_InterfaceDefSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::ValueDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::ValueDef **old = ACE_reinterpret_cast (CORBA::ValueDef**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = tao_CORBA_ValueDef_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::ValueDef **tmp = ACE_reinterpret_cast (CORBA::ValueDef**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_CORBA_ValueDef_release (tmp[i]);
      tmp[i] = tao_CORBA_ValueDef_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  CORBA::ValueDef **tmp = ACE_reinterpret_cast (CORBA::ValueDef**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_CORBA_ValueDef_release (tmp[i]);
      tmp[i] = tao_CORBA_ValueDef_nil ();
    }
}

void 
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_downcast (
    void* target,
    CORBA::Object *src
    ACE_ENV_ARG_DECL
  )
{
  CORBA::ValueDef **tmp = ACE_static_cast (CORBA::ValueDef**, target);
  *tmp = tao_CORBA_ValueDef_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA::Object*
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_upcast (void *src) const
{
  return tao_CORBA_ValueDef_upcast (src);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_VALUEDEFSEQ_CS_)
#define _CORBA_VALUEDEFSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::ValueDefSeq
// *************************************************************

CORBA::ValueDefSeq::ValueDefSeq (void)
{}

CORBA::ValueDefSeq::ValueDefSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::ValueDef,CORBA::ValueDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::ValueDefSeq::ValueDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ValueDef_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::ValueDef,CORBA::ValueDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::ValueDefSeq::ValueDefSeq (const ValueDefSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::ValueDef,CORBA::ValueDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::ValueDefSeq::~ValueDefSeq (void) // dtor
{}

void CORBA::ValueDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueDefSeq *tmp = ACE_static_cast (ValueDefSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueDefSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c756544), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueDefSeq:1.0
  12,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x53657100),  // name = ValueDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5661), 
      ACE_NTOHL (0x6c756544), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
      9,
      ACE_NTOHL (0x56616c75), 
      ACE_NTOHL (0x65446566), 
      ACE_NTOHL (0x0),  // name = ValueDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ValueDefSeq),
    (char *) &_oc_CORBA_ValueDefSeq,
    0,
    sizeof (CORBA::ValueDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueDefSeq,
    &_tc_TAO_tc_CORBA_ValueDefSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_ABSTRACTINTERFACEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_ABSTRACTINTERFACEDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::AbstractInterfaceDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::AbstractInterfaceDef **old = ACE_reinterpret_cast (CORBA::AbstractInterfaceDef**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = tao_CORBA_AbstractInterfaceDef_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::AbstractInterfaceDef **tmp = ACE_reinterpret_cast (CORBA::AbstractInterfaceDef**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_CORBA_AbstractInterfaceDef_release (tmp[i]);
      tmp[i] = tao_CORBA_AbstractInterfaceDef_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

CORBA::_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  CORBA::AbstractInterfaceDef **tmp = ACE_reinterpret_cast (CORBA::AbstractInterfaceDef**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_CORBA_AbstractInterfaceDef_release (tmp[i]);
      tmp[i] = tao_CORBA_AbstractInterfaceDef_nil ();
    }
}

void 
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::_downcast (
    void* target,
    CORBA::Object *src
    ACE_ENV_ARG_DECL
  )
{
  CORBA::AbstractInterfaceDef **tmp = ACE_static_cast (CORBA::AbstractInterfaceDef**, target);
  *tmp = tao_CORBA_AbstractInterfaceDef_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA::Object*
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq::_upcast (void *src) const
{
  return tao_CORBA_AbstractInterfaceDef_upcast (src);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ_CS_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::AbstractInterfaceDefSeq
// *************************************************************

CORBA::AbstractInterfaceDefSeq::AbstractInterfaceDefSeq (void)
{}

CORBA::AbstractInterfaceDefSeq::AbstractInterfaceDefSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::AbstractInterfaceDef,CORBA::AbstractInterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::AbstractInterfaceDefSeq::AbstractInterfaceDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::AbstractInterfaceDef_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::AbstractInterfaceDef,CORBA::AbstractInterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::AbstractInterfaceDefSeq::AbstractInterfaceDefSeq (const AbstractInterfaceDefSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::AbstractInterfaceDef,CORBA::AbstractInterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::AbstractInterfaceDefSeq::~AbstractInterfaceDefSeq (void) // dtor
{}

void CORBA::AbstractInterfaceDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  AbstractInterfaceDefSeq *tmp = ACE_static_cast (AbstractInterfaceDefSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_AbstractInterfaceDefSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4162), 
  ACE_NTOHL (0x73747261), 
  ACE_NTOHL (0x6374496e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636544), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/AbstractInterfaceDefSeq:1.0
  24,
  ACE_NTOHL (0x41627374), 
  ACE_NTOHL (0x72616374), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x53657100),  // name = AbstractInterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  96, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    80, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4162), 
      ACE_NTOHL (0x73747261), 
      ACE_NTOHL (0x6374496e), 
      ACE_NTOHL (0x74657266), 
      ACE_NTOHL (0x61636544), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AbstractInterfaceDef:1.0
      21,
      ACE_NTOHL (0x41627374), 
      ACE_NTOHL (0x72616374), 
      ACE_NTOHL (0x496e7465), 
      ACE_NTOHL (0x72666163), 
      ACE_NTOHL (0x65446566), 
      ACE_NTOHL (0x0),  // name = AbstractInterfaceDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_AbstractInterfaceDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_AbstractInterfaceDefSeq),
    (char *) &_oc_CORBA_AbstractInterfaceDefSeq,
    0,
    sizeof (CORBA::AbstractInterfaceDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AbstractInterfaceDefSeq,
    &_tc_TAO_tc_CORBA_AbstractInterfaceDefSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_LOCALINTERFACEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_LOCALINTERFACEDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::LocalInterfaceDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::LocalInterfaceDef **old = ACE_reinterpret_cast (CORBA::LocalInterfaceDef**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = tao_CORBA_LocalInterfaceDef_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::LocalInterfaceDef **tmp = ACE_reinterpret_cast (CORBA::LocalInterfaceDef**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_CORBA_LocalInterfaceDef_release (tmp[i]);
      tmp[i] = tao_CORBA_LocalInterfaceDef_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

CORBA::_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  CORBA::LocalInterfaceDef **tmp = ACE_reinterpret_cast (CORBA::LocalInterfaceDef**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_CORBA_LocalInterfaceDef_release (tmp[i]);
      tmp[i] = tao_CORBA_LocalInterfaceDef_nil ();
    }
}

void 
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::_downcast (
    void* target,
    CORBA::Object *src
    ACE_ENV_ARG_DECL
  )
{
  CORBA::LocalInterfaceDef **tmp = ACE_static_cast (CORBA::LocalInterfaceDef**, target);
  *tmp = tao_CORBA_LocalInterfaceDef_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA::Object*
CORBA::_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq::_upcast (void *src) const
{
  return tao_CORBA_LocalInterfaceDef_upcast (src);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_LOCALINTERFACEDEFSEQ_CS_)
#define _CORBA_LOCALINTERFACEDEFSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::LocalInterfaceDefSeq
// *************************************************************

CORBA::LocalInterfaceDefSeq::LocalInterfaceDefSeq (void)
{}

CORBA::LocalInterfaceDefSeq::LocalInterfaceDefSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::LocalInterfaceDef,CORBA::LocalInterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::LocalInterfaceDefSeq::LocalInterfaceDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::LocalInterfaceDef_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::LocalInterfaceDef,CORBA::LocalInterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::LocalInterfaceDefSeq::LocalInterfaceDefSeq (const LocalInterfaceDefSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<CORBA::LocalInterfaceDef,CORBA::LocalInterfaceDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::LocalInterfaceDefSeq::~LocalInterfaceDefSeq (void) // dtor
{}

void CORBA::LocalInterfaceDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  LocalInterfaceDefSeq *tmp = ACE_static_cast (LocalInterfaceDefSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_LocalInterfaceDefSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4c6f), 
  ACE_NTOHL (0x63616c49), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/LocalInterfaceDefSeq:1.0
  21,
  ACE_NTOHL (0x4c6f6361), 
  ACE_NTOHL (0x6c496e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63654465), 
  ACE_NTOHL (0x66536571), 
  ACE_NTOHL (0x0),  // name = LocalInterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4c6f), 
      ACE_NTOHL (0x63616c49), 
      ACE_NTOHL (0x6e746572), 
      ACE_NTOHL (0x66616365), 
      ACE_NTOHL (0x4465663a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/LocalInterfaceDef:1.0
      18,
      ACE_NTOHL (0x4c6f6361), 
      ACE_NTOHL (0x6c496e74), 
      ACE_NTOHL (0x65726661), 
      ACE_NTOHL (0x63654465), 
      ACE_NTOHL (0x66000000),  // name = LocalInterfaceDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_LocalInterfaceDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_LocalInterfaceDefSeq),
    (char *) &_oc_CORBA_LocalInterfaceDefSeq,
    0,
    sizeof (CORBA::LocalInterfaceDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_LocalInterfaceDefSeq,
    &_tc_TAO_tc_CORBA_LocalInterfaceDefSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_StructMember[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5374), 
  ACE_NTOHL (0x72756374), 
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
  13,
  ACE_NTOHL (0x53747275), 
  ACE_NTOHL (0x63744d65), 
  ACE_NTOHL (0x6d626572), 
  ACE_NTOHL (0x0),  // name = StructMember
  3, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f646566), 
  ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4944), 
    ACE_NTOHL (0x4c547970), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8,
    ACE_NTOHL (0x49444c54), 
    ACE_NTOHL (0x79706500),  // name = IDLType

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_StructMember (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_StructMember),
    (char *) &_oc_CORBA_StructMember,
    0,
    sizeof (CORBA::StructMember)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_StructMember,
    &_tc_TAO_tc_CORBA_StructMember
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:67

void CORBA::StructMember::_tao_any_destructor (void *_tao_void_pointer)
{
  StructMember *tmp = ACE_static_cast (StructMember*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_

void
CORBA::_TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::StructMember* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::StructMember *old =
        ACE_reinterpret_cast (CORBA::StructMember *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::StructMember *tmp =
    ACE_reinterpret_cast (CORBA::StructMember *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::_TAO_Unbounded_Sequence_CORBA_StructMemberSeq::~_TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_STRUCTMEMBERSEQ_CS_)
#define _CORBA_STRUCTMEMBERSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::StructMemberSeq
// *************************************************************

CORBA::StructMemberSeq::StructMemberSeq (void)
{}

CORBA::StructMemberSeq::StructMemberSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::StructMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::StructMemberSeq::StructMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::StructMember *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::StructMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::StructMemberSeq::StructMemberSeq (const StructMemberSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::StructMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::StructMemberSeq::~StructMemberSeq (void) // dtor
{}

void CORBA::StructMemberSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  StructMemberSeq *tmp = ACE_static_cast (StructMemberSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_StructMemberSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5374), 
  ACE_NTOHL (0x72756374), 
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x65725365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
  16,
  ACE_NTOHL (0x53747275), 
  ACE_NTOHL (0x63744d65), 
  ACE_NTOHL (0x6d626572), 
  ACE_NTOHL (0x53657100),  // name = StructMemberSeq
  CORBA::tk_sequence, // typecode kind
  264, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    248, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5374), 
      ACE_NTOHL (0x72756374), 
      ACE_NTOHL (0x4d656d62), 
      ACE_NTOHL (0x65723a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
      13,
      ACE_NTOHL (0x53747275), 
      ACE_NTOHL (0x63744d65), 
      ACE_NTOHL (0x6d626572), 
      ACE_NTOHL (0x0),  // name = StructMember
      3, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      5,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x5f646566), 
      ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4944), 
        ACE_NTOHL (0x4c547970), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8,
        ACE_NTOHL (0x49444c54), 
        ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_StructMemberSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_StructMemberSeq),
    (char *) &_oc_CORBA_StructMemberSeq,
    0,
    sizeof (CORBA::StructMemberSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_StructMemberSeq,
    &_tc_TAO_tc_CORBA_StructMemberSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Initializer[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x69746961), 
  ACE_NTOHL (0x6c697a65), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
  12,
  ACE_NTOHL (0x496e6974), 
  ACE_NTOHL (0x69616c69), 
  ACE_NTOHL (0x7a657200),  // name = Initializer
  2, // member count
  8,
  ACE_NTOHL (0x6d656d62), 
  ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5374), 
    ACE_NTOHL (0x72756374), 
    ACE_NTOHL (0x4d656d62), 
    ACE_NTOHL (0x65725365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
    16,
    ACE_NTOHL (0x53747275), 
    ACE_NTOHL (0x63744d65), 
    ACE_NTOHL (0x6d626572), 
    ACE_NTOHL (0x53657100),  // name = StructMemberSeq
    CORBA::tk_sequence, // typecode kind
    264, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      248, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5374), 
        ACE_NTOHL (0x72756374), 
        ACE_NTOHL (0x4d656d62), 
        ACE_NTOHL (0x65723a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
        13,
        ACE_NTOHL (0x53747275), 
        ACE_NTOHL (0x63744d65), 
        ACE_NTOHL (0x6d626572), 
        ACE_NTOHL (0x0),  // name = StructMember
        3, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4964), 
          ACE_NTOHL (0x656e7469), 
          ACE_NTOHL (0x66696572), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11,
          ACE_NTOHL (0x4964656e), 
          ACE_NTOHL (0x74696669), 
          ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f646566), 
        ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4944), 
          ACE_NTOHL (0x4c547970), 
          ACE_NTOHL (0x653a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8,
          ACE_NTOHL (0x49444c54), 
          ACE_NTOHL (0x79706500),  // name = IDLType


      0U,


  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  0xffffffff, // indirection
  0xffffff44, // negative offset (-188)
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Initializer (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_Initializer),
    (char *) &_oc_CORBA_Initializer,
    0,
    sizeof (CORBA::Initializer)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Initializer,
    &_tc_TAO_tc_CORBA_Initializer
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:67

void CORBA::Initializer::_tao_any_destructor (void *_tao_void_pointer)
{
  Initializer *tmp = ACE_static_cast (Initializer*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_

void
CORBA::_TAO_Unbounded_Sequence_CORBA_InitializerSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::Initializer* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_InitializerSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::Initializer *old =
        ACE_reinterpret_cast (CORBA::Initializer *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Sequence_CORBA_InitializerSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::Initializer *tmp =
    ACE_reinterpret_cast (CORBA::Initializer *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::_TAO_Unbounded_Sequence_CORBA_InitializerSeq::~_TAO_Unbounded_Sequence_CORBA_InitializerSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_INITIALIZERSEQ_CS_)
#define _CORBA_INITIALIZERSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::InitializerSeq
// *************************************************************

CORBA::InitializerSeq::InitializerSeq (void)
{}

CORBA::InitializerSeq::InitializerSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Initializer>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::InitializerSeq::InitializerSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Initializer *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Initializer>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::InitializerSeq::InitializerSeq (const InitializerSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Initializer>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::InitializerSeq::~InitializerSeq (void) // dtor
{}

void CORBA::InitializerSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  InitializerSeq *tmp = ACE_static_cast (InitializerSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_InitializerSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f496e), 
  ACE_NTOHL (0x69746961), 
  ACE_NTOHL (0x6c697a65), 
  ACE_NTOHL (0x72536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InitializerSeq:1.0
  15,
  ACE_NTOHL (0x496e6974), 
  ACE_NTOHL (0x69616c69), 
  ACE_NTOHL (0x7a657253), 
  ACE_NTOHL (0x65710000),  // name = InitializerSeq
  CORBA::tk_sequence, // typecode kind
  460, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    444, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f496e), 
      ACE_NTOHL (0x69746961), 
      ACE_NTOHL (0x6c697a65), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
      12,
      ACE_NTOHL (0x496e6974), 
      ACE_NTOHL (0x69616c69), 
      ACE_NTOHL (0x7a657200),  // name = Initializer
      2, // member count
      8,
      ACE_NTOHL (0x6d656d62), 
      ACE_NTOHL (0x65727300),  // name = members
      CORBA::tk_alias, // typecode kind for typedefs
      340, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        38,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5374), 
        ACE_NTOHL (0x72756374), 
        ACE_NTOHL (0x4d656d62), 
        ACE_NTOHL (0x65725365), 
        ACE_NTOHL (0x713a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
        16,
        ACE_NTOHL (0x53747275), 
        ACE_NTOHL (0x63744d65), 
        ACE_NTOHL (0x6d626572), 
        ACE_NTOHL (0x53657100),  // name = StructMemberSeq
        CORBA::tk_sequence, // typecode kind
        264, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          248, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f5374), 
            ACE_NTOHL (0x72756374), 
            ACE_NTOHL (0x4d656d62), 
            ACE_NTOHL (0x65723a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
            13,
            ACE_NTOHL (0x53747275), 
            ACE_NTOHL (0x63744d65), 
            ACE_NTOHL (0x6d626572), 
            ACE_NTOHL (0x0),  // name = StructMember
            3, // member count
            5,
            ACE_NTOHL (0x6e616d65), 
            ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4964), 
              ACE_NTOHL (0x656e7469), 
              ACE_NTOHL (0x66696572), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11,
              ACE_NTOHL (0x4964656e), 
              ACE_NTOHL (0x74696669), 
              ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            5,
            ACE_NTOHL (0x74797065), 
            ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9,
            ACE_NTOHL (0x74797065), 
            ACE_NTOHL (0x5f646566), 
            ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4944), 
              ACE_NTOHL (0x4c547970), 
              ACE_NTOHL (0x653a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
              8,
              ACE_NTOHL (0x49444c54), 
              ACE_NTOHL (0x79706500),  // name = IDLType


          0U,


      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      0xffffffff, // indirection
      0xffffff44, // negative offset (-188)

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_InitializerSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_InitializerSeq),
    (char *) &_oc_CORBA_InitializerSeq,
    0,
    sizeof (CORBA::InitializerSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InitializerSeq,
    &_tc_TAO_tc_CORBA_InitializerSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_UnionMember[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f556e), 
  ACE_NTOHL (0x696f6e4d), 
  ACE_NTOHL (0x656d6265), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/UnionMember:1.0
  12,
  ACE_NTOHL (0x556e696f), 
  ACE_NTOHL (0x6e4d656d), 
  ACE_NTOHL (0x62657200),  // name = UnionMember
  4, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  6,
  ACE_NTOHL (0x6c616265), 
  ACE_NTOHL (0x6c000000),  // name = label
  CORBA::tk_any,

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f646566), 
  ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4944), 
    ACE_NTOHL (0x4c547970), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8,
    ACE_NTOHL (0x49444c54), 
    ACE_NTOHL (0x79706500),  // name = IDLType

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionMember (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_UnionMember),
    (char *) &_oc_CORBA_UnionMember,
    0,
    sizeof (CORBA::UnionMember)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UnionMember,
    &_tc_TAO_tc_CORBA_UnionMember
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:67

void CORBA::UnionMember::_tao_any_destructor (void *_tao_void_pointer)
{
  UnionMember *tmp = ACE_static_cast (UnionMember*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_

void
CORBA::_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::UnionMember* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::UnionMember *old =
        ACE_reinterpret_cast (CORBA::UnionMember *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::UnionMember *tmp =
    ACE_reinterpret_cast (CORBA::UnionMember *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::~_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_UNIONMEMBERSEQ_CS_)
#define _CORBA_UNIONMEMBERSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::UnionMemberSeq
// *************************************************************

CORBA::UnionMemberSeq::UnionMemberSeq (void)
{}

CORBA::UnionMemberSeq::UnionMemberSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::UnionMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::UnionMemberSeq::UnionMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::UnionMember *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::UnionMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::UnionMemberSeq::UnionMemberSeq (const UnionMemberSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::UnionMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::UnionMemberSeq::~UnionMemberSeq (void) // dtor
{}

void CORBA::UnionMemberSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  UnionMemberSeq *tmp = ACE_static_cast (UnionMemberSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_UnionMemberSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f556e), 
  ACE_NTOHL (0x696f6e4d), 
  ACE_NTOHL (0x656d6265), 
  ACE_NTOHL (0x72536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/UnionMemberSeq:1.0
  15,
  ACE_NTOHL (0x556e696f), 
  ACE_NTOHL (0x6e4d656d), 
  ACE_NTOHL (0x62657253), 
  ACE_NTOHL (0x65710000),  // name = UnionMemberSeq
  CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f556e), 
      ACE_NTOHL (0x696f6e4d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/UnionMember:1.0
      12,
      ACE_NTOHL (0x556e696f), 
      ACE_NTOHL (0x6e4d656d), 
      ACE_NTOHL (0x62657200),  // name = UnionMember
      4, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      6,
      ACE_NTOHL (0x6c616265), 
      ACE_NTOHL (0x6c000000),  // name = label
      CORBA::tk_any,

      5,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x5f646566), 
      ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4944), 
        ACE_NTOHL (0x4c547970), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8,
        ACE_NTOHL (0x49444c54), 
        ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionMemberSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_UnionMemberSeq),
    (char *) &_oc_CORBA_UnionMemberSeq,
    0,
    sizeof (CORBA::UnionMemberSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UnionMemberSeq,
    &_tc_TAO_tc_CORBA_UnionMemberSeq
  )
TAO_NAMESPACE_END

#if !defined (_CORBA_ENUMMEMBERSEQ_CS_)
#define _CORBA_ENUMMEMBERSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::EnumMemberSeq
// *************************************************************

CORBA::EnumMemberSeq::EnumMemberSeq (void)
{}

CORBA::EnumMemberSeq::EnumMemberSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::EnumMemberSeq::EnumMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::EnumMemberSeq::EnumMemberSeq (const EnumMemberSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::EnumMemberSeq::~EnumMemberSeq (void) // dtor
{}

void CORBA::EnumMemberSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  EnumMemberSeq *tmp = ACE_static_cast (EnumMemberSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_EnumMemberSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f456e), 
  ACE_NTOHL (0x756d4d65), 
  ACE_NTOHL (0x6d626572), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/EnumMemberSeq:1.0
  14,
  ACE_NTOHL (0x456e756d), 
  ACE_NTOHL (0x4d656d62), 
  ACE_NTOHL (0x65725365), 
  ACE_NTOHL (0x71000000),  // name = EnumMemberSeq
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4964), 
      ACE_NTOHL (0x656e7469), 
      ACE_NTOHL (0x66696572), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11,
      ACE_NTOHL (0x4964656e), 
      ACE_NTOHL (0x74696669), 
      ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_EnumMemberSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_EnumMemberSeq),
    (char *) &_oc_CORBA_EnumMemberSeq,
    0,
    sizeof (CORBA::EnumMemberSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EnumMemberSeq,
    &_tc_TAO_tc_CORBA_EnumMemberSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:61

int CORBA::Container::_tao_class_id = 0;

CORBA::Container_ptr
tao_CORBA_Container_duplicate (
    CORBA::Container_ptr p
  )
{
  return CORBA::Container::_duplicate (p);
}

void
tao_CORBA_Container_release (
    CORBA::Container_ptr p
  )
{
  CORBA::release (p);
}

CORBA::Container_ptr
tao_CORBA_Container_nil (
    void
  )
{
  return CORBA::Container::_nil ();
}

CORBA::Container_ptr
tao_CORBA_Container_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::Container::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_Container_upcast (
    void *src
  )
{
  CORBA::Container **tmp =
    ACE_static_cast (CORBA::Container **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:721

// *************************************************************
// CORBA::Container_var
// *************************************************************

CORBA::Container_var::Container_var (void)
  : ptr_ (Container::_nil ())
{}

::CORBA::Container_ptr
CORBA::Container_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::Container_var::Container_var (const ::CORBA::Container_var &p)
  : TAO_Base_var (),
    ptr_ (Container::_duplicate (p.ptr ()))
{}

CORBA::Container_var::~Container_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::Container_var &
CORBA::Container_var::operator= (Container_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::Container_var &
CORBA::Container_var::operator= (const ::CORBA::Container_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::Container::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::Container_var::operator const ::CORBA::Container_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::Container_var::operator ::CORBA::Container_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::Container_ptr
CORBA::Container_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::Container_ptr
CORBA::Container_var::in (void) const
{
  return this->ptr_;
}

::CORBA::Container_ptr &
CORBA::Container_var::inout (void)
{
  return this->ptr_;
}

::CORBA::Container_ptr &
CORBA::Container_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::Container::_nil ();
  return this->ptr_;
}

::CORBA::Container_ptr
CORBA::Container_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::Container_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::Container::_nil ();
  return val;
}

::CORBA::Container_ptr
CORBA::Container_var::tao_duplicate (Container_ptr p)
{
  return ::CORBA::Container::_duplicate (p);
}

void
CORBA::Container_var::tao_release (Container_ptr p)
{
  CORBA::release (p);
}

::CORBA::Container_ptr
CORBA::Container_var::tao_nil (void)
{
  return ::CORBA::Container::_nil ();
}

::CORBA::Container_ptr
CORBA::Container_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::Container::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::Container_var::tao_upcast (void *src)
{
  Container **tmp =
    ACE_static_cast (Container **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1030

// *************************************************************
// CORBA::Container_out
// *************************************************************

CORBA::Container_out::Container_out (Container_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::Container::_nil ();
}

CORBA::Container_out::Container_out (Container_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::Container::_nil ();
}

CORBA::Container_out::Container_out (const ::CORBA::Container_out &p)
  : ptr_ (ACE_const_cast (Container_out &, p).ptr_)
{}

::CORBA::Container_out &
CORBA::Container_out::operator= (const ::CORBA::Container_out &p)
{
  this->ptr_ = ACE_const_cast (Container_out&, p).ptr_;
  return *this;
}

CORBA::Container_out &
CORBA::Container_out::operator= (const ::CORBA::Container_var &p)
{
  this->ptr_ = ::CORBA::Container::_duplicate (p.ptr ());
  return *this;
}

CORBA::Container_out &
CORBA::Container_out::operator= (Container_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::Container_out::operator ::CORBA::Container_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::Container_ptr &
CORBA::Container_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::Container_ptr
CORBA::Container_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_lookup : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_lookup (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_name
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Contained_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_lookup (const TAO_ClientRequestInfo_CORBA_Container_lookup &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_lookup &);
    const char * search_name_;
    
    ::CORBA::Contained_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_lookup::TAO_ClientRequestInfo_CORBA_Container_lookup (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_name
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      search_name_ (search_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_lookup::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= search_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_lookup::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_lookup::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_lookup::result (::CORBA::Contained_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_contents : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_contents (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ContainedSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_contents (const TAO_ClientRequestInfo_CORBA_Container_contents &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_contents &);
    const CORBA::DefinitionKind & limit_type_;
    const CORBA::Boolean & exclude_inherited_;
    
    ::CORBA::ContainedSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_contents::TAO_ClientRequestInfo_CORBA_Container_contents (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      limit_type_ (limit_type),
      exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_contents::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->limit_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_contents::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_contents::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_contents::result (::CORBA::ContainedSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_lookup_name : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_lookup_name (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_name,
      const CORBA::Long & levels_to_search,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ContainedSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_lookup_name (const TAO_ClientRequestInfo_CORBA_Container_lookup_name &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_lookup_name &);
    const char * search_name_;
    const CORBA::Long & levels_to_search_;
    const CORBA::DefinitionKind & limit_type_;
    const CORBA::Boolean & exclude_inherited_;
    
    ::CORBA::ContainedSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_lookup_name::TAO_ClientRequestInfo_CORBA_Container_lookup_name (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_name,
      const CORBA::Long & levels_to_search,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      search_name_ (search_name),
      levels_to_search_ (levels_to_search),
      limit_type_ (limit_type),
      exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_lookup_name::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= search_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= levels_to_search_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->limit_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_lookup_name::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_lookup_name::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_lookup_name::result (::CORBA::ContainedSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_describe_contents : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_describe_contents (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited,
      const CORBA::Long & max_returned_objs
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Container::DescriptionSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_describe_contents (const TAO_ClientRequestInfo_CORBA_Container_describe_contents &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_describe_contents &);
    const CORBA::DefinitionKind & limit_type_;
    const CORBA::Boolean & exclude_inherited_;
    const CORBA::Long & max_returned_objs_;
    
    ::CORBA::Container::DescriptionSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_describe_contents::TAO_ClientRequestInfo_CORBA_Container_describe_contents (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited,
      const CORBA::Long & max_returned_objs
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      limit_type_ (limit_type),
      exclude_inherited_ (exclude_inherited),
      max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_describe_contents::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->limit_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= max_returned_objs_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_describe_contents::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_describe_contents::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_describe_contents::result (::CORBA::Container::DescriptionSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_module : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_module (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ModuleDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_module (const TAO_ClientRequestInfo_CORBA_Container_create_module &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_module &);
    const char * id_;
    const char * name_;
    const char * version_;
    
    ::CORBA::ModuleDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_module::TAO_ClientRequestInfo_CORBA_Container_create_module (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_module::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_module::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_module::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_module::result (::CORBA::ModuleDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_constant : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_constant (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      const CORBA::Any & value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ConstantDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_constant (const TAO_ClientRequestInfo_CORBA_Container_create_constant &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_constant &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr type_;
    const CORBA::Any & value_;
    
    ::CORBA::ConstantDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_constant::TAO_ClientRequestInfo_CORBA_Container_create_constant (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      const CORBA::Any & value
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      type_ (type),
      value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_constant::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_constant::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_constant::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_constant::result (::CORBA::ConstantDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_struct : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_struct (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::StructDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_struct (const TAO_ClientRequestInfo_CORBA_Container_create_struct &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_struct &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::StructMemberSeq & members_;
    
    ::CORBA::StructDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_struct::TAO_ClientRequestInfo_CORBA_Container_create_struct (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_struct::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_struct::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_struct::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_struct::result (::CORBA::StructDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_union : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_union (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr discriminator_type,
      const CORBA::UnionMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::UnionDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_union (const TAO_ClientRequestInfo_CORBA_Container_create_union &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_union &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr discriminator_type_;
    const CORBA::UnionMemberSeq & members_;
    
    ::CORBA::UnionDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_union::TAO_ClientRequestInfo_CORBA_Container_create_union (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr discriminator_type,
      const CORBA::UnionMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      discriminator_type_ (discriminator_type),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_union::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->discriminator_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_union::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_union::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_union::result (::CORBA::UnionDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_enum : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_enum (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::EnumMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::EnumDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_enum (const TAO_ClientRequestInfo_CORBA_Container_create_enum &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_enum &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::EnumMemberSeq & members_;
    
    ::CORBA::EnumDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_enum::TAO_ClientRequestInfo_CORBA_Container_create_enum (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::EnumMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_enum::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_enum::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_enum::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_enum::result (::CORBA::EnumDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_alias : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_alias (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr original_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::AliasDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_alias (const TAO_ClientRequestInfo_CORBA_Container_create_alias &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_alias &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr original_type_;
    
    ::CORBA::AliasDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_alias::TAO_ClientRequestInfo_CORBA_Container_create_alias (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr original_type
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      original_type_ (original_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_alias::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->original_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_alias::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_alias::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_alias::result (::CORBA::AliasDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_interface : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_interface (const TAO_ClientRequestInfo_CORBA_Container_create_interface &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_interface &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::InterfaceDefSeq & base_interfaces_;
    
    ::CORBA::InterfaceDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_interface::TAO_ClientRequestInfo_CORBA_Container_create_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_interface::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_interface::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_interface::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_interface::result (::CORBA::InterfaceDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_value : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::Boolean & is_custom,
      const CORBA::Boolean & is_abstract,
      CORBA::ValueDef_ptr base_value,
      const CORBA::Boolean & is_truncatable,
      const CORBA::ValueDefSeq & abstract_base_values,
      const CORBA::InterfaceDefSeq & supported_interfaces,
      const CORBA::InitializerSeq & initializers
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_value (const TAO_ClientRequestInfo_CORBA_Container_create_value &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_value &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::Boolean & is_custom_;
    const CORBA::Boolean & is_abstract_;
    CORBA::ValueDef_ptr base_value_;
    const CORBA::Boolean & is_truncatable_;
    const CORBA::ValueDefSeq & abstract_base_values_;
    const CORBA::InterfaceDefSeq & supported_interfaces_;
    const CORBA::InitializerSeq & initializers_;
    
    ::CORBA::ValueDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_value::TAO_ClientRequestInfo_CORBA_Container_create_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::Boolean & is_custom,
      const CORBA::Boolean & is_abstract,
      CORBA::ValueDef_ptr base_value,
      const CORBA::Boolean & is_truncatable,
      const CORBA::ValueDefSeq & abstract_base_values,
      const CORBA::InterfaceDefSeq & supported_interfaces,
      const CORBA::InitializerSeq & initializers
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      is_custom_ (is_custom),
      is_abstract_ (is_abstract),
      base_value_ (base_value),
      is_truncatable_ (is_truncatable),
      abstract_base_values_ (abstract_base_values),
      supported_interfaces_ (supported_interfaces),
      initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_value::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (10);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->abstract_base_values_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->initializers_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_value::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_value::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_value::result (::CORBA::ValueDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_value_box : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_value_box (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueBoxDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_value_box (const TAO_ClientRequestInfo_CORBA_Container_create_value_box &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_value_box &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr original_type_def_;
    
    ::CORBA::ValueBoxDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_value_box::TAO_ClientRequestInfo_CORBA_Container_create_value_box (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_value_box::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->original_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_value_box::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_value_box::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_value_box::result (::CORBA::ValueBoxDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_exception : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_exception (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExceptionDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_exception (const TAO_ClientRequestInfo_CORBA_Container_create_exception &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_exception &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::StructMemberSeq & members_;
    
    ::CORBA::ExceptionDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_exception::TAO_ClientRequestInfo_CORBA_Container_create_exception (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::StructMemberSeq & members
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_exception::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_exception::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_exception::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_exception::result (::CORBA::ExceptionDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_native : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_native (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::NativeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_native (const TAO_ClientRequestInfo_CORBA_Container_create_native &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_native &);
    const char * id_;
    const char * name_;
    const char * version_;
    
    ::CORBA::NativeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_native::TAO_ClientRequestInfo_CORBA_Container_create_native (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_native::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_native::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_native::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_native::result (::CORBA::NativeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::AbstractInterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::AbstractInterfaceDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface (const TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::AbstractInterfaceDefSeq & base_interfaces_;
    
    ::CORBA::AbstractInterfaceDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::AbstractInterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::result (::CORBA::AbstractInterfaceDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_Container_create_local_interface : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_local_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::LocalInterfaceDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_Container_create_local_interface (const TAO_ClientRequestInfo_CORBA_Container_create_local_interface &);
    void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_local_interface &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::InterfaceDefSeq & base_interfaces_;
    
    ::CORBA::LocalInterfaceDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_Container_create_local_interface::TAO_ClientRequestInfo_CORBA_Container_create_local_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::InterfaceDefSeq & base_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_local_interface::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_local_interface::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_create_local_interface::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_local_interface::result (::CORBA::LocalInterfaceDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
{}

CORBA::_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::Contained_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::lookup (
    CORBA::Object *_collocated_tao_target_,
    const char * search_name
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Contained_var _tao_retval (CORBA::Contained::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      6,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_lookup _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          search_name
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << search_name)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::Contained_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ContainedSeq * CORBA::_TAO_Container_Remote_Proxy_Impl::contents (
    CORBA::Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ContainedSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ContainedSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ContainedSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "contents",
      8,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_contents _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          limit_type,
          exclude_inherited
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << limit_type) &&
                  (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ContainedSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ContainedSeq * CORBA::_TAO_Container_Remote_Proxy_Impl::lookup_name (
    CORBA::Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ContainedSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ContainedSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ContainedSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_name",
      11,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_lookup_name _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          search_name,
          levels_to_search,
          limit_type,
          exclude_inherited
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << search_name) &&
                  (_tao_out << levels_to_search) &&
                  (_tao_out << limit_type) &&
                  (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ContainedSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::Container::DescriptionSeq * CORBA::_TAO_Container_Remote_Proxy_Impl::describe_contents (
    CORBA::Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Container::DescriptionSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::Container::DescriptionSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::Container::DescriptionSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_contents",
      17,
      3,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_describe_contents _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          limit_type,
          exclude_inherited,
          max_returned_objs
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << limit_type) &&
                  (_tao_out << CORBA::Any::from_boolean (exclude_inherited)) &&
                  (_tao_out << max_returned_objs)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::Container::DescriptionSeq * _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ModuleDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_module (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ModuleDef_var _tao_retval ( tao_CORBA_ModuleDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_module",
      13,
      3,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_module _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ModuleDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ConstantDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_constant (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ConstantDef_var _tao_retval ( tao_CORBA_ConstantDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_constant",
      15,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_constant _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          type,
          value
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << type) &&
                  (_tao_out << value)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ConstantDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::StructDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_struct (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StructDef_var _tao_retval ( tao_CORBA_StructDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_struct",
      13,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_struct _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << members)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::StructDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::UnionDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_union (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UnionDef_var _tao_retval ( tao_CORBA_UnionDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_union",
      12,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_union _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          discriminator_type,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << discriminator_type) &&
                  (_tao_out << members)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::UnionDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::EnumDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_enum (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::EnumDef_var _tao_retval ( tao_CORBA_EnumDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_enum",
      11,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_enum _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << members)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::EnumDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::AliasDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_alias (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AliasDef_var _tao_retval ( tao_CORBA_AliasDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_alias",
      12,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_alias _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          original_type
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << original_type)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::AliasDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_interface (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef_var _tao_retval ( tao_CORBA_InterfaceDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_interface",
      16,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_interface _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          base_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << base_interfaces)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::InterfaceDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_value (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef_var _tao_retval ( tao_CORBA_ValueDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value",
      12,
      10,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_value _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          is_custom,
          is_abstract,
          base_value,
          is_truncatable,
          abstract_base_values,
          supported_interfaces,
          initializers
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << CORBA::Any::from_boolean (is_custom)) &&
                  (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
                  (_tao_out << base_value) &&
                  (_tao_out << CORBA::Any::from_boolean (is_truncatable)) &&
                  (_tao_out << abstract_base_values) &&
                  (_tao_out << supported_interfaces) &&
                  (_tao_out << initializers)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ValueDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueBoxDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_value_box (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueBoxDef_var _tao_retval ( tao_CORBA_ValueBoxDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_box",
      16,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_value_box _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          original_type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << original_type_def)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ValueBoxDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExceptionDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_exception (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExceptionDef_var _tao_retval ( tao_CORBA_ExceptionDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_exception",
      16,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_exception _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          members
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << members)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::ExceptionDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::NativeDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_native (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::NativeDef_var _tao_retval ( tao_CORBA_NativeDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_native",
      13,
      3,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_native _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::NativeDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::AbstractInterfaceDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_abstract_interface (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AbstractInterfaceDef_var _tao_retval ( tao_CORBA_AbstractInterfaceDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_abstract_interface",
      25,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          base_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << base_interfaces)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::AbstractInterfaceDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::LocalInterfaceDef_ptr CORBA::_TAO_Container_Remote_Proxy_Impl::create_local_interface (
    CORBA::Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::LocalInterfaceDef_var _tao_retval ( tao_CORBA_LocalInterfaceDef_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_local_interface",
      22,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_create_local_interface _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          base_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
              
              if (!(
                  (_tao_out << id) &&
                  (_tao_out << name) &&
                  (_tao_out << version) &&
                  (_tao_out << base_interfaces)
                  ))
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::MARSHAL (
                          
                        ),
                      0
                    );
                }
              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  ::CORBA::LocalInterfaceDef_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
{
}

CORBA::_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
{
}

CORBA::_TAO_Container_Proxy_Broker * (*CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_Container_Remote_Proxy_Broker *
CORBA::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_Container_Proxy_Impl&
CORBA::_TAO_Container_Remote_Proxy_Broker::select_proxy (
    ::CORBA::Container *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:225

CORBA::Container::Container (int collocated)
{
  this->CORBA_Container_setup_collocation (collocated);
}

void
CORBA::Container::CORBA_Container_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Container_Proxy_Broker_ =
      ::CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Container_Proxy_Broker_ =
      ::CORBA::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

CORBA::Container::~Container (void)
{}

void 
CORBA::Container::_tao_any_destructor (void *_tao_void_pointer)
{
  Container *tmp = ACE_static_cast (Container *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::Container_ptr
CORBA::Container::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Container::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/Container:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Container::_nil ());
      
      if (is_a == 0)
        {
          return Container::_nil ();
        }
    }
  
  return Container::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::Container_ptr 
CORBA::Container::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Container::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Container_ptr default_proxy = Container::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::Container (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Container::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::Container (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Container::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Container_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Container::_tao_class_id
                )
            )
        );
}

CORBA::Container_ptr
CORBA::Container::_duplicate (Container_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::Container::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::Container::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, Container)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IRObject)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::Contained_ptr CORBA::Container::lookup (
    const char * search_name
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.lookup (
      this,
      search_name
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ContainedSeq * CORBA::Container::contents (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.contents (
      this,
      limit_type,
      exclude_inherited
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ContainedSeq * CORBA::Container::lookup_name (
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.lookup_name (
      this,
      search_name,
      levels_to_search,
      limit_type,
      exclude_inherited
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Container_Description[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65722f), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
  12,
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = Description
  3, // member count
  17,
  ACE_NTOHL (0x636f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x645f6f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x0),  // name = contained_object
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f436f), 
    ACE_NTOHL (0x6e746169), 
    ACE_NTOHL (0x6e65643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
    10,
    ACE_NTOHL (0x436f6e74), 
    ACE_NTOHL (0x61696e65), 
    ACE_NTOHL (0x64000000),  // name = Contained

  5,
  ACE_NTOHL (0x6b696e64), 
  ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  524, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4465), 
    ACE_NTOHL (0x66696e69), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x4b696e64), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
15,
    ACE_NTOHL (0x44656669), 
    ACE_NTOHL (0x6e697469), 
    ACE_NTOHL (0x6f6e4b69), 
    ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    26, // member count
8,
    ACE_NTOHL (0x646b5f6e), 
    ACE_NTOHL (0x6f6e6500),  // name = dk_none
7,
    ACE_NTOHL (0x646b5f61), 
    ACE_NTOHL (0x6c6c0000),  // name = dk_all
13,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x74747269), 
    ACE_NTOHL (0x62757465), 
    ACE_NTOHL (0x0),  // name = dk_Attribute
12,
    ACE_NTOHL (0x646b5f43), 
    ACE_NTOHL (0x6f6e7374), 
    ACE_NTOHL (0x616e7400),  // name = dk_Constant
13,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x78636570), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Exception
13,
    ACE_NTOHL (0x646b5f49), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_Interface
10,
    ACE_NTOHL (0x646b5f4d), 
    ACE_NTOHL (0x6f64756c), 
    ACE_NTOHL (0x65000000),  // name = dk_Module
13,
    ACE_NTOHL (0x646b5f4f), 
    ACE_NTOHL (0x70657261), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Operation
11,
    ACE_NTOHL (0x646b5f54), 
    ACE_NTOHL (0x79706564), 
    ACE_NTOHL (0x65660000),  // name = dk_Typedef
9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x6c696173), 
    ACE_NTOHL (0x0),  // name = dk_Alias
10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x74727563), 
    ACE_NTOHL (0x74000000),  // name = dk_Struct
9,
    ACE_NTOHL (0x646b5f55), 
    ACE_NTOHL (0x6e696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Union
8,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x6e756d00),  // name = dk_Enum
13,
    ACE_NTOHL (0x646b5f50), 
    ACE_NTOHL (0x72696d69), 
    ACE_NTOHL (0x74697665), 
    ACE_NTOHL (0x0),  // name = dk_Primitive
10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x7472696e), 
    ACE_NTOHL (0x67000000),  // name = dk_String
12,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = dk_Sequence
9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x72726179), 
    ACE_NTOHL (0x0),  // name = dk_Array
14,
    ACE_NTOHL (0x646b5f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x79000000),  // name = dk_Repository
11,
    ACE_NTOHL (0x646b5f57), 
    ACE_NTOHL (0x73747269), 
    ACE_NTOHL (0x6e670000),  // name = dk_Wstring
9,
    ACE_NTOHL (0x646b5f46), 
    ACE_NTOHL (0x69786564), 
    ACE_NTOHL (0x0),  // name = dk_Fixed
9,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x0),  // name = dk_Value
12,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
15,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x4d656d62), 
    ACE_NTOHL (0x65720000),  // name = dk_ValueMember
10,
    ACE_NTOHL (0x646b5f4e), 
    ACE_NTOHL (0x61746976), 
    ACE_NTOHL (0x65000000),  // name = dk_Native
21,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x62737472), 
    ACE_NTOHL (0x61637449), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_AbstractInterface
18,
    ACE_NTOHL (0x646b5f4c), 
    ACE_NTOHL (0x6f63616c), 
    ACE_NTOHL (0x496e7465), 
    ACE_NTOHL (0x72666163), 
    ACE_NTOHL (0x65000000),  // name = dk_LocalInterface

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_Description (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_Container_Description),
    (char *) &_oc_CORBA_Container_Description,
    0,
    sizeof (CORBA::Container::Description)
  );

::CORBA::TypeCode_ptr CORBA::Container::_tc_Description =
  &_tc_TAO_tc_CORBA_Container_Description;

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:67

void CORBA::Container::Description::_tao_any_destructor (void *_tao_void_pointer)
{
  Description *tmp = ACE_static_cast (Description*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/gen_unbounded_sequence_cs.cpp:101

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

void
CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::Container::Description* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::Container::Description *old =
        ACE_reinterpret_cast (CORBA::Container::Description *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::Container::Description *tmp =
    ACE_reinterpret_cast (CORBA::Container::Description *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// CORBA::Container::DescriptionSeq
// *************************************************************

CORBA::Container::DescriptionSeq::DescriptionSeq (void)
{}

CORBA::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Container::Description>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::Container::DescriptionSeq::DescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Container::Description *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Container::Description>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Container::Description>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::Container::DescriptionSeq::~DescriptionSeq (void) // dtor
{}

void CORBA::Container::DescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  DescriptionSeq *tmp = ACE_static_cast (DescriptionSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Container_DescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65722f), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/Container/DescriptionSeq:1.0
  15,
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65710000),  // name = DescriptionSeq
  CORBA::tk_sequence, // typecode kind
  736, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    720, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      44,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6e746169), 
      ACE_NTOHL (0x6e65722f), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e3a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
      12,
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = Description
      3, // member count
      17,
      ACE_NTOHL (0x636f6e74), 
      ACE_NTOHL (0x61696e65), 
      ACE_NTOHL (0x645f6f62), 
      ACE_NTOHL (0x6a656374), 
      ACE_NTOHL (0x0),  // name = contained_object
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6e746169), 
        ACE_NTOHL (0x6e65643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
        10,
        ACE_NTOHL (0x436f6e74), 
        ACE_NTOHL (0x61696e65), 
        ACE_NTOHL (0x64000000),  // name = Contained

      5,
      ACE_NTOHL (0x6b696e64), 
      ACE_NTOHL (0x0),  // name = kind
      CORBA::tk_enum, // typecode kind
      524, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4465), 
        ACE_NTOHL (0x66696e69), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x4b696e64), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
15,
        ACE_NTOHL (0x44656669), 
        ACE_NTOHL (0x6e697469), 
        ACE_NTOHL (0x6f6e4b69), 
        ACE_NTOHL (0x6e640000),  // name = DefinitionKind
        26, // member count
8,
        ACE_NTOHL (0x646b5f6e), 
        ACE_NTOHL (0x6f6e6500),  // name = dk_none
7,
        ACE_NTOHL (0x646b5f61), 
        ACE_NTOHL (0x6c6c0000),  // name = dk_all
13,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x74747269), 
        ACE_NTOHL (0x62757465), 
        ACE_NTOHL (0x0),  // name = dk_Attribute
12,
        ACE_NTOHL (0x646b5f43), 
        ACE_NTOHL (0x6f6e7374), 
        ACE_NTOHL (0x616e7400),  // name = dk_Constant
13,
        ACE_NTOHL (0x646b5f45), 
        ACE_NTOHL (0x78636570), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = dk_Exception
13,
        ACE_NTOHL (0x646b5f49), 
        ACE_NTOHL (0x6e746572), 
        ACE_NTOHL (0x66616365), 
        ACE_NTOHL (0x0),  // name = dk_Interface
10,
        ACE_NTOHL (0x646b5f4d), 
        ACE_NTOHL (0x6f64756c), 
        ACE_NTOHL (0x65000000),  // name = dk_Module
13,
        ACE_NTOHL (0x646b5f4f), 
        ACE_NTOHL (0x70657261), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = dk_Operation
11,
        ACE_NTOHL (0x646b5f54), 
        ACE_NTOHL (0x79706564), 
        ACE_NTOHL (0x65660000),  // name = dk_Typedef
9,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x6c696173), 
        ACE_NTOHL (0x0),  // name = dk_Alias
10,
        ACE_NTOHL (0x646b5f53), 
        ACE_NTOHL (0x74727563), 
        ACE_NTOHL (0x74000000),  // name = dk_Struct
9,
        ACE_NTOHL (0x646b5f55), 
        ACE_NTOHL (0x6e696f6e), 
        ACE_NTOHL (0x0),  // name = dk_Union
8,
        ACE_NTOHL (0x646b5f45), 
        ACE_NTOHL (0x6e756d00),  // name = dk_Enum
13,
        ACE_NTOHL (0x646b5f50), 
        ACE_NTOHL (0x72696d69), 
        ACE_NTOHL (0x74697665), 
        ACE_NTOHL (0x0),  // name = dk_Primitive
10,
        ACE_NTOHL (0x646b5f53), 
        ACE_NTOHL (0x7472696e), 
        ACE_NTOHL (0x67000000),  // name = dk_String
12,
        ACE_NTOHL (0x646b5f53), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = dk_Sequence
9,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x72726179), 
        ACE_NTOHL (0x0),  // name = dk_Array
14,
        ACE_NTOHL (0x646b5f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x79000000),  // name = dk_Repository
11,
        ACE_NTOHL (0x646b5f57), 
        ACE_NTOHL (0x73747269), 
        ACE_NTOHL (0x6e670000),  // name = dk_Wstring
9,
        ACE_NTOHL (0x646b5f46), 
        ACE_NTOHL (0x69786564), 
        ACE_NTOHL (0x0),  // name = dk_Fixed
9,
        ACE_NTOHL (0x646b5f56), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x0),  // name = dk_Value
12,
        ACE_NTOHL (0x646b5f56), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
15,
        ACE_NTOHL (0x646b5f56), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x4d656d62), 
        ACE_NTOHL (0x65720000),  // name = dk_ValueMember
10,
        ACE_NTOHL (0x646b5f4e), 
        ACE_NTOHL (0x61746976), 
        ACE_NTOHL (0x65000000),  // name = dk_Native
21,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x62737472), 
        ACE_NTOHL (0x61637449), 
        ACE_NTOHL (0x6e746572), 
        ACE_NTOHL (0x66616365), 
        ACE_NTOHL (0x0),  // name = dk_AbstractInterface
18,
        ACE_NTOHL (0x646b5f4c), 
        ACE_NTOHL (0x6f63616c), 
        ACE_NTOHL (0x496e7465), 
        ACE_NTOHL (0x72666163), 
        ACE_NTOHL (0x65000000),  // name = dk_LocalInterface

      6,
      ACE_NTOHL (0x76616c75), 
      ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_DescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_Container_DescriptionSeq),
    (char *) &_oc_CORBA_Container_DescriptionSeq,
    0,
    sizeof (CORBA::Container::DescriptionSeq)
  );

::CORBA::TypeCode_ptr CORBA::Container::_tc_DescriptionSeq =
  &_tc_TAO_tc_CORBA_Container_DescriptionSeq;

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::Container::DescriptionSeq * CORBA::Container::describe_contents (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_contents (
      this,
      limit_type,
      exclude_inherited,
      max_returned_objs
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ModuleDef_ptr CORBA::Container::create_module (
    const char * id,
    const char * name,
    const char * version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_module (
      this,
      id,
      name,
      version
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ConstantDef_ptr CORBA::Container::create_constant (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_constant (
      this,
      id,
      name,
      version,
      type,
      value
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::StructDef_ptr CORBA::Container::create_struct (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_struct (
      this,
      id,
      name,
      version,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::UnionDef_ptr CORBA::Container::create_union (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_union (
      this,
      id,
      name,
      version,
      discriminator_type,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::EnumDef_ptr CORBA::Container::create_enum (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_enum (
      this,
      id,
      name,
      version,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::AliasDef_ptr CORBA::Container::create_alias (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_alias (
      this,
      id,
      name,
      version,
      original_type
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDef_ptr CORBA::Container::create_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_interface (
      this,
      id,
      name,
      version,
      base_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueDef_ptr CORBA::Container::create_value (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_value (
      this,
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueBoxDef_ptr CORBA::Container::create_value_box (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_value_box (
      this,
      id,
      name,
      version,
      original_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::ExceptionDef_ptr CORBA::Container::create_exception (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_exception (
      this,
      id,
      name,
      version,
      members
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::NativeDef_ptr CORBA::Container::create_native (
    const char * id,
    const char * name,
    const char * version
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_native (
      this,
      id,
      name,
      version
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::AbstractInterfaceDef_ptr CORBA::Container::create_abstract_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_abstract_interface (
      this,
      id,
      name,
      version,
      base_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

::CORBA::LocalInterfaceDef_ptr CORBA::Container::create_local_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_local_interface (
      this,
      id,
      name,
      version,
      base_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_Container[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container:1.0
  10,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x72000000),  // name = Container
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Container (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_Container),
    (char *) &_oc_CORBA_Container,
    0,
    sizeof (CORBA::Container)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Container,
    &_tc_TAO_tc_CORBA_Container
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:61

int CORBA::IDLType::_tao_class_id = 0;

CORBA::IDLType_ptr
tao_CORBA_IDLType_duplicate (
    CORBA::IDLType_ptr p
  )
{
  return CORBA::IDLType::_duplicate (p);
}

void
tao_CORBA_IDLType_release (
    CORBA::IDLType_ptr p
  )
{
  CORBA::release (p);
}

CORBA::IDLType_ptr
tao_CORBA_IDLType_nil (
    void
  )
{
  return CORBA::IDLType::_nil ();
}

CORBA::IDLType_ptr
tao_CORBA_IDLType_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::IDLType::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_IDLType_upcast (
    void *src
  )
{
  CORBA::IDLType **tmp =
    ACE_static_cast (CORBA::IDLType **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:721

// *************************************************************
// CORBA::IDLType_var
// *************************************************************

CORBA::IDLType_var::IDLType_var (void)
  : ptr_ (IDLType::_nil ())
{}

::CORBA::IDLType_ptr
CORBA::IDLType_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::IDLType_var::IDLType_var (const ::CORBA::IDLType_var &p)
  : TAO_Base_var (),
    ptr_ (IDLType::_duplicate (p.ptr ()))
{}

CORBA::IDLType_var::~IDLType_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::IDLType_var &
CORBA::IDLType_var::operator= (IDLType_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::IDLType_var &
CORBA::IDLType_var::operator= (const ::CORBA::IDLType_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::IDLType::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::IDLType_var::operator const ::CORBA::IDLType_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::IDLType_var::operator ::CORBA::IDLType_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::IDLType_ptr
CORBA::IDLType_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::IDLType_ptr
CORBA::IDLType_var::in (void) const
{
  return this->ptr_;
}

::CORBA::IDLType_ptr &
CORBA::IDLType_var::inout (void)
{
  return this->ptr_;
}

::CORBA::IDLType_ptr &
CORBA::IDLType_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::IDLType::_nil ();
  return this->ptr_;
}

::CORBA::IDLType_ptr
CORBA::IDLType_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::IDLType_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::IDLType::_nil ();
  return val;
}

::CORBA::IDLType_ptr
CORBA::IDLType_var::tao_duplicate (IDLType_ptr p)
{
  return ::CORBA::IDLType::_duplicate (p);
}

void
CORBA::IDLType_var::tao_release (IDLType_ptr p)
{
  CORBA::release (p);
}

::CORBA::IDLType_ptr
CORBA::IDLType_var::tao_nil (void)
{
  return ::CORBA::IDLType::_nil ();
}

::CORBA::IDLType_ptr
CORBA::IDLType_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::IDLType::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::IDLType_var::tao_upcast (void *src)
{
  IDLType **tmp =
    ACE_static_cast (IDLType **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1030

// *************************************************************
// CORBA::IDLType_out
// *************************************************************

CORBA::IDLType_out::IDLType_out (IDLType_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::IDLType::_nil ();
}

CORBA::IDLType_out::IDLType_out (IDLType_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::IDLType::_nil ();
}

CORBA::IDLType_out::IDLType_out (const ::CORBA::IDLType_out &p)
  : ptr_ (ACE_const_cast (IDLType_out &, p).ptr_)
{}

::CORBA::IDLType_out &
CORBA::IDLType_out::operator= (const ::CORBA::IDLType_out &p)
{
  this->ptr_ = ACE_const_cast (IDLType_out&, p).ptr_;
  return *this;
}

CORBA::IDLType_out &
CORBA::IDLType_out::operator= (const ::CORBA::IDLType_var &p)
{
  this->ptr_ = ::CORBA::IDLType::_duplicate (p.ptr ());
  return *this;
}

CORBA::IDLType_out &
CORBA::IDLType_out::operator= (IDLType_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::IDLType_out::operator ::CORBA::IDLType_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::IDLType_ptr &
CORBA::IDLType_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::IDLType_ptr
CORBA::IDLType_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// be/be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_IDLType_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_IDLType_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_IDLType_type_get (const TAO_ClientRequestInfo_CORBA_IDLType_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_IDLType_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/interceptors_cs.cpp:378
  
  TAO_ClientRequestInfo_CORBA_IDLType_type_get::TAO_ClientRequestInfo_CORBA_IDLType_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_IDLType_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_IDLType_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_IDLType_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_IDLType_Proxy_Impl::_TAO_IDLType_Proxy_Impl (void)
{}

CORBA::_TAO_IDLType_Remote_Proxy_Impl::_TAO_IDLType_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// be/be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_IDLType_Remote_Proxy_Impl::type (
    CORBA::Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_IDLType_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
            }
          else
            {
              
#endif /* TAO_HAS_INTERCEPTORS */
              
              _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              _tao_call.prepare_header (
                  ACE_static_cast (CORBA::Octet, _tao_response_flag)
                  ACE_ENV_ARG_PARAMETER
                );
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              
              _invoke_status =
                _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
              TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

              if (_invoke_status == TAO_INVOKE_EXCEPTION)
                {
                  TAO_INTERCEPTOR_THROW_RETURN (
                      CORBA::UNKNOWN (
                          CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                        ),
                      0
                    );
                }
              else if (_invoke_status == TAO_INVOKE_RESTART)
                {
                  _tao_call.restart_flag (1);
                  TAO_INTERCEPTOR (
                      _tao_ri.reply_status (_invoke_status);
                      _tao_vfr.receive_other (
                          &_tao_ri
                          ACE_ENV_ARG_PARAMETER
                        );
                      ACE_TRY_CHECK;
                    )
                }
              else
                {
                  
                  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
                  
                  if (!(
                      (_tao_in >> _tao_retval.inout ())
                      ))
                    {
                      TAO_INTERCEPTOR_THROW_RETURN (
                          CORBA::MARSHAL (
                              TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                            ),
                          0
                        );
                    }
                  
#if TAO_HAS_INTERCEPTORS == 1
                  CORBA::TypeCode_ptr _tao_retval_info =
                    _tao_retval._retn ();
                  _tao_ri.result (_tao_retval_info);
                  _tao_retval = _tao_retval_info;
                  
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_reply (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                
#endif  /* TAO_HAS_INTERCEPTORS */
                }
            
#if TAO_HAS_INTERCEPTORS == 1
            }
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          const PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      const PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status != PortableInterceptor::LOCATION_FORWARD
          && _tao_status != PortableInterceptor::TRANSPORT_RETRY)
        
#endif  /* TAO_HAS_INTERCEPTORS */
        
        if (_invoke_status != TAO_INVOKE_RESTART)
          break;
    }

return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_IDLType_Proxy_Broker::_TAO_IDLType_Proxy_Broker (void)
{
}

CORBA::_TAO_IDLType_Proxy_Broker::~_TAO_IDLType_Proxy_Broker (void)
{
}

CORBA::_TAO_IDLType_Proxy_Broker * (*CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_IDLType_Remote_Proxy_Broker *
CORBA::_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_IDLType_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_IDLType_Remote_Proxy_Broker::_TAO_IDLType_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_IDLType_Remote_Proxy_Broker::~_TAO_IDLType_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_IDLType_Proxy_Impl&
CORBA::_TAO_IDLType_Remote_Proxy_Broker::select_proxy (
    ::CORBA::IDLType *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:225

CORBA::IDLType::IDLType (int collocated)
{
  this->CORBA_IDLType_setup_collocation (collocated);
}

void
CORBA::IDLType::CORBA_IDLType_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_IDLType_Proxy_Broker_ =
      ::CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_IDLType_Proxy_Broker_ =
      ::CORBA::_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

CORBA::IDLType::~IDLType (void)
{}

void 
CORBA::IDLType::_tao_any_destructor (void *_tao_void_pointer)
{
  IDLType *tmp = ACE_static_cast (IDLType *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::IDLType_ptr
CORBA::IDLType::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return IDLType::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/IDLType:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (IDLType::_nil ());
      
      if (is_a == 0)
        {
          return IDLType::_nil ();
        }
    }
  
  return IDLType::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::IDLType_ptr 
CORBA::IDLType::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return IDLType::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      IDLType_ptr default_proxy = IDLType::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::IDLType (
                  stub,
                  1,
                  obj->_servant ()
                ),
              IDLType::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::IDLType (
                  stub,
                  0,
                  obj->_servant ()
                ),
              IDLType::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          IDLType_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &IDLType::_tao_class_id
                )
            )
        );
}

CORBA::IDLType_ptr
CORBA::IDLType::_duplicate (IDLType_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::IDLType::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::IDLType::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IDLType)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IRObject)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::IDLType::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_IDLType_Proxy_Impl &proxy = 
    this->the_TAO_IDLType_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_IDLType[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4944), 
  ACE_NTOHL (0x4c547970), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
  8,
  ACE_NTOHL (0x49444c54), 
  ACE_NTOHL (0x79706500),  // name = IDLType
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_IDLType (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_IDLType),
    (char *) &_oc_CORBA_IDLType,
    0,
    sizeof (CORBA::IDLType)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IDLType,
    &_tc_TAO_tc_CORBA_IDLType
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:61

int CORBA::TypedefDef::_tao_class_id = 0;

CORBA::TypedefDef_ptr
tao_CORBA_TypedefDef_duplicate (
    CORBA::TypedefDef_ptr p
  )
{
  return CORBA::TypedefDef::_duplicate (p);
}

void
tao_CORBA_TypedefDef_release (
    CORBA::TypedefDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::TypedefDef_ptr
tao_CORBA_TypedefDef_nil (
    void
  )
{
  return CORBA::TypedefDef::_nil ();
}

CORBA::TypedefDef_ptr
tao_CORBA_TypedefDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::TypedefDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_TypedefDef_upcast (
    void *src
  )
{
  CORBA::TypedefDef **tmp =
    ACE_static_cast (CORBA::TypedefDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:721

// *************************************************************
// CORBA::TypedefDef_var
// *************************************************************

CORBA::TypedefDef_var::TypedefDef_var (void)
  : ptr_ (TypedefDef::_nil ())
{}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::TypedefDef_var::TypedefDef_var (const ::CORBA::TypedefDef_var &p)
  : TAO_Base_var (),
    ptr_ (TypedefDef::_duplicate (p.ptr ()))
{}

CORBA::TypedefDef_var::~TypedefDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::TypedefDef_var &
CORBA::TypedefDef_var::operator= (TypedefDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::TypedefDef_var &
CORBA::TypedefDef_var::operator= (const ::CORBA::TypedefDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::TypedefDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::TypedefDef_var::operator const ::CORBA::TypedefDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::TypedefDef_var::operator ::CORBA::TypedefDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::TypedefDef_ptr &
CORBA::TypedefDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::TypedefDef_ptr &
CORBA::TypedefDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::TypedefDef::_nil ();
  return this->ptr_;
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::TypedefDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::TypedefDef::_nil ();
  return val;
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::tao_duplicate (TypedefDef_ptr p)
{
  return ::CORBA::TypedefDef::_duplicate (p);
}

void
CORBA::TypedefDef_var::tao_release (TypedefDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::tao_nil (void)
{
  return ::CORBA::TypedefDef::_nil ();
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::TypedefDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::TypedefDef_var::tao_upcast (void *src)
{
  TypedefDef **tmp =
    ACE_static_cast (TypedefDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1030

// *************************************************************
// CORBA::TypedefDef_out
// *************************************************************

CORBA::TypedefDef_out::TypedefDef_out (TypedefDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::TypedefDef::_nil ();
}

CORBA::TypedefDef_out::TypedefDef_out (TypedefDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::TypedefDef::_nil ();
}

CORBA::TypedefDef_out::TypedefDef_out (const ::CORBA::TypedefDef_out &p)
  : ptr_ (ACE_const_cast (TypedefDef_out &, p).ptr_)
{}

::CORBA::TypedefDef_out &
CORBA::TypedefDef_out::operator= (const ::CORBA::TypedefDef_out &p)
{
  this->ptr_ = ACE_const_cast (TypedefDef_out&, p).ptr_;
  return *this;
}

CORBA::TypedefDef_out &
CORBA::TypedefDef_out::operator= (const ::CORBA::TypedefDef_var &p)
{
  this->ptr_ = ::CORBA::TypedefDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::TypedefDef_out &
CORBA::TypedefDef_out::operator= (TypedefDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::TypedefDef_out::operator ::CORBA::TypedefDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::TypedefDef_ptr &
CORBA::TypedefDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::TypedefDef_ptr
CORBA::TypedefDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_TypedefDef_Proxy_Impl::_TAO_TypedefDef_Proxy_Impl (void)
{}

CORBA::_TAO_TypedefDef_Remote_Proxy_Impl::_TAO_TypedefDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be/be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_TypedefDef_Proxy_Broker::_TAO_TypedefDef_Proxy_Broker (void)
{
}

CORBA::_TAO_TypedefDef_Proxy_Broker::~_TAO_TypedefDef_Proxy_Broker (void)
{
}

CORBA::_TAO_TypedefDef_Proxy_Broker * (*CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_TypedefDef_Remote_Proxy_Broker *
CORBA::_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_TypedefDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_TypedefDef_Remote_Proxy_Broker::_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_TypedefDef_Remote_Proxy_Broker::~_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_TypedefDef_Proxy_Impl&
CORBA::_TAO_TypedefDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::TypedefDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:225

CORBA::TypedefDef::TypedefDef (int collocated)
{
  this->CORBA_TypedefDef_setup_collocation (collocated);
}

void
CORBA::TypedefDef::CORBA_TypedefDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_TypedefDef_Proxy_Broker_ =
      ::CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_TypedefDef_Proxy_Broker_ =
      ::CORBA::_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::TypedefDef::~TypedefDef (void)
{}

void 
CORBA::TypedefDef::_tao_any_destructor (void *_tao_void_pointer)
{
  TypedefDef *tmp = ACE_static_cast (TypedefDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::TypedefDef_ptr
CORBA::TypedefDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return TypedefDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/TypedefDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (TypedefDef::_nil ());
      
      if (is_a == 0)
        {
          return TypedefDef::_nil ();
        }
    }
  
  return TypedefDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::TypedefDef_ptr 
CORBA::TypedefDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return TypedefDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      TypedefDef_ptr default_proxy = TypedefDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::TypedefDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              TypedefDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::TypedefDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              TypedefDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          TypedefDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &TypedefDef::_tao_class_id
                )
            )
        );
}

CORBA::TypedefDef_ptr
CORBA::TypedefDef::_duplicate (TypedefDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::TypedefDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->ACE_NESTED_CLASS (CORBA, Object)::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::TypedefDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, TypedefDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, Contained)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IDLType)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, IRObject)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_TypedefDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5479), 
  ACE_NTOHL (0x70656465), 
  ACE_NTOHL (0x66446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/TypedefDef:1.0
  11,
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x64656644), 
  ACE_NTOHL (0x65660000),  // name = TypedefDef
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_TypedefDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_TypedefDef),
    (char *) &_oc_CORBA_TypedefDef,
    0,
    sizeof (CORBA::TypedefDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_TypedefDef,
    &_tc_TAO_tc_CORBA_TypedefDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_TypeDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5479), 
  ACE_NTOHL (0x70654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/TypeDescription:1.0
  16,
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = TypeDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_TypeDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_TypeDescription),
    (char *) &_oc_CORBA_TypeDescription,
    0,
    sizeof (CORBA::TypeDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_TypeDescription,
    &_tc_TAO_tc_CORBA_TypeDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:67

void CORBA::TypeDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  TypeDescription *tmp = ACE_static_cast (TypeDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:52

void operator<<= (CORBA::Any &_tao_any, CORBA::DefinitionKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_DefinitionKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::DefinitionKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result = type->equivalent (CORBA::_tc_DefinitionKind ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::IRObject_ptr _tao_elem
  )
{
  CORBA::IRObject_ptr _tao_objptr =
    CORBA::IRObject::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::IRObject_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_IRObject, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          CORBA::IRObject::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::IRObject_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IRObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_IRObject
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_IRObject,
            1,
            _tao_elem,
            CORBA::IRObject::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::IRObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = CORBA::IRObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Contained_ptr _tao_elem
  )
{
  CORBA::Contained_ptr _tao_objptr =
    CORBA::Contained::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Contained_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Contained, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          CORBA::Contained::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Contained_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Contained::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_Contained
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_Contained,
            1,
            _tao_elem,
            CORBA::Contained::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::Contained::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = CORBA::Contained::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Contained::Description &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::Contained::_tc_Description,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Contained::Description *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::Contained::_tc_Description,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::Contained::Description::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Contained::Description *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::Contained::Description *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::Contained::Description *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::Contained::_tc_Description
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const CORBA::Contained::Description*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::Contained::Description *tmp;
        ACE_NEW_RETURN (
            tmp,
            CORBA::Contained::Description,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::Contained::_tc_Description,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::Contained::Description::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContainedSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ContainedSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ContainedSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ContainedSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::ContainedSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ContainedSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::ContainedSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ContainedSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_ContainedSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::ContainedSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::ContainedSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::ContainedSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_ContainedSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::ContainedSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InterfaceDefSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InterfaceDefSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::InterfaceDefSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InterfaceDefSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::InterfaceDefSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::InterfaceDefSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_InterfaceDefSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::InterfaceDefSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::InterfaceDefSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::InterfaceDefSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_InterfaceDefSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::InterfaceDefSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueDefSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueDefSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::ValueDefSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueDefSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::ValueDefSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ValueDefSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_ValueDefSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::ValueDefSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::ValueDefSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::ValueDefSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_ValueDefSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::ValueDefSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::AbstractInterfaceDefSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_AbstractInterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::AbstractInterfaceDefSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_AbstractInterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::AbstractInterfaceDefSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::AbstractInterfaceDefSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::AbstractInterfaceDefSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::AbstractInterfaceDefSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_AbstractInterfaceDefSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::AbstractInterfaceDefSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::AbstractInterfaceDefSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::AbstractInterfaceDefSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_AbstractInterfaceDefSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::AbstractInterfaceDefSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::LocalInterfaceDefSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_LocalInterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::LocalInterfaceDefSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_LocalInterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::LocalInterfaceDefSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::LocalInterfaceDefSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::LocalInterfaceDefSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::LocalInterfaceDefSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_LocalInterfaceDefSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::LocalInterfaceDefSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::LocalInterfaceDefSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::LocalInterfaceDefSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_LocalInterfaceDefSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::LocalInterfaceDefSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::StructMember &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StructMember,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::StructMember *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StructMember,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::StructMember::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::StructMember *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::StructMember *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::StructMember *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_StructMember
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const CORBA::StructMember*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::StructMember *tmp;
        ACE_NEW_RETURN (
            tmp,
            CORBA::StructMember,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_StructMember,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::StructMember::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::StructMemberSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StructMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::StructMemberSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StructMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::StructMemberSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::StructMemberSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::StructMemberSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::StructMemberSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_StructMemberSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::StructMemberSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::StructMemberSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::StructMemberSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_StructMemberSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::StructMemberSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Initializer &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Initializer,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Initializer *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Initializer,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::Initializer::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Initializer *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::Initializer *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::Initializer *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_Initializer
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const CORBA::Initializer*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::Initializer *tmp;
        ACE_NEW_RETURN (
            tmp,
            CORBA::Initializer,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_Initializer,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::Initializer::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InitializerSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InitializerSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::InitializerSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InitializerSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::InitializerSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::InitializerSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::InitializerSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::InitializerSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_InitializerSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::InitializerSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::InitializerSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::InitializerSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_InitializerSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::InitializerSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::UnionMember &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_UnionMember,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::UnionMember *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_UnionMember,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::UnionMember::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::UnionMember *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::UnionMember *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::UnionMember *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_UnionMember
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const CORBA::UnionMember*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::UnionMember *tmp;
        ACE_NEW_RETURN (
            tmp,
            CORBA::UnionMember,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_UnionMember,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::UnionMember::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::UnionMemberSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_UnionMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::UnionMemberSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_UnionMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::UnionMemberSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::UnionMemberSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::UnionMemberSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::UnionMemberSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_UnionMemberSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::UnionMemberSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::UnionMemberSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::UnionMemberSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_UnionMemberSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::UnionMemberSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::EnumMemberSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_EnumMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::EnumMemberSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_EnumMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::EnumMemberSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::EnumMemberSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::EnumMemberSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::EnumMemberSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_EnumMemberSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::EnumMemberSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::EnumMemberSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::EnumMemberSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_EnumMemberSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::EnumMemberSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Container_ptr _tao_elem
  )
{
  CORBA::Container_ptr _tao_objptr =
    CORBA::Container::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Container_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Container, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          CORBA::Container::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Container_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_Container
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_Container,
            1,
            _tao_elem,
            CORBA::Container::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::Container::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = CORBA::Container::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::Container,CORBA::Container_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::Container,CORBA::Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Container::Description &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::Container::_tc_Description,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Container::Description *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::Container::_tc_Description,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::Container::Description::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Container::Description *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::Container::Description *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::Container::Description *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::Container::_tc_Description
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const CORBA::Container::Description*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::Container::Description *tmp;
        ACE_NEW_RETURN (
            tmp,
            CORBA::Container::Description,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::Container::_tc_Description,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::Container::Description::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Container::DescriptionSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::Container::_tc_DescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::Container::DescriptionSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::Container::_tc_DescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::Container::DescriptionSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::Container::DescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::Container::DescriptionSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::Container::DescriptionSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::Container::_tc_DescriptionSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const CORBA::Container::DescriptionSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::Container::DescriptionSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            CORBA::Container::DescriptionSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::Container::_tc_DescriptionSeq,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::Container::DescriptionSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::IDLType_ptr _tao_elem
  )
{
  CORBA::IDLType_ptr _tao_objptr =
    CORBA::IDLType::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::IDLType_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_IDLType, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          CORBA::IDLType::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::IDLType_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IDLType::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_IDLType
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_IDLType,
            1,
            _tao_elem,
            CORBA::IDLType::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::IDLType::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = CORBA::IDLType::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::TypedefDef_ptr _tao_elem
  )
{
  CORBA::TypedefDef_ptr _tao_objptr =
    CORBA::TypedefDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::TypedefDef_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_TypedefDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          CORBA::TypedefDef::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::TypedefDef_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::TypedefDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_TypedefDef
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!_tao_result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_TypedefDef,
            1,
            _tao_elem,
            CORBA::TypedefDef::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::TypedefDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = CORBA::TypedefDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::TypeDescription &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_TypeDescription,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::TypeDescription *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          CORBA::_tc_TypeDescription,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          CORBA::TypeDescription::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::TypeDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::TypeDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::TypeDescription *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean _tao_result =
      type->equivalent (
          CORBA::_tc_TypeDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (_tao_result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast (
            const CORBA::TypeDescription*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        CORBA::TypeDescription *tmp;
        ACE_NEW_RETURN (
            tmp,
            CORBA::TypeDescription,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                CORBA::_tc_TypeDescription,
                1,
                ACE_static_cast (void *, tmp),
                CORBA::TypeDescription::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::IRObject_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::IRObject_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::IRObject::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::Contained_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::Contained_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::Contained::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::AbstractInterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::AbstractInterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::LocalInterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::LocalInterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::Container_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::Container_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::Container::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::IDLType_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::IDLType_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::IDLType::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::TypedefDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::TypedefDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::TypedefDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

