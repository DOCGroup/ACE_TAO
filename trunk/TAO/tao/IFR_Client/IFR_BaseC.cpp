// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "IFR_BaseC.h"
#include "tao/corbafwd.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BaseC.i"
#endif /* !defined INLINE */

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::DefinitionKind result);

private:
  TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (const TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get &);

  CORBA::DefinitionKind _result;
};

TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::DefinitionKind result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_IRObject_destroy : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_IRObject_destroy (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_IRObject_destroy (const TAO_ClientRequestInfo_CORBA_IRObject_destroy &);
  void operator= (const TAO_ClientRequestInfo_CORBA_IRObject_destroy &);

  
};

TAO_ClientRequestInfo_CORBA_IRObject_destroy::TAO_ClientRequestInfo_CORBA_IRObject_destroy (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_IRObject_destroy::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_IRObject_destroy::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_IRObject_destroy::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_IRObject_Proxy_Impl::_TAO_IRObject_Proxy_Impl (void)
{}

_TAO_IRObject_Remote_Proxy_Impl::_TAO_IRObject_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::DefinitionKind _TAO_IRObject_Remote_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::DefinitionKind _tao_retval = (CORBA::DefinitionKind)0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_def_kind",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::DefinitionKind  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_IRObject_Remote_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_IRObject_destroy ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_IRObject_Proxy_Broker::_TAO_IRObject_Proxy_Broker (void)
{
}

_TAO_IRObject_Proxy_Broker::~_TAO_IRObject_Proxy_Broker (void)
{
}

_TAO_IRObject_Proxy_Broker * (*CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_IRObject_Remote_Proxy_Broker *
_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker (void)
{
  static ::_TAO_IRObject_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_IRObject_Remote_Proxy_Broker::_TAO_IRObject_Remote_Proxy_Broker (void)
{
}

_TAO_IRObject_Remote_Proxy_Broker::~_TAO_IRObject_Remote_Proxy_Broker (void)
{
}

_TAO_IRObject_Proxy_Impl&
_TAO_IRObject_Remote_Proxy_Broker::select_proxy (
  ::CORBA_IRObject *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_IRObject::CORBA_IRObject (int collocated)
{
  this->CORBA_IRObject_setup_collocation (collocated);
}

// destructor
CORBA_IRObject::~CORBA_IRObject (void)
{}

void
CORBA::IRObject::CORBA_IRObject_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_IRObject_Proxy_Broker_ =
      ::CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_IRObject_Proxy_Broker_ =
      ::_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker ();
}

void CORBA::IRObject::_tao_any_destructor (void *x)
{
  CORBA_IRObject *tmp = ACE_static_cast (CORBA_IRObject*,x);
  CORBA::release (tmp);
}

CORBA::IRObject_ptr CORBA::IRObject::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IRObject::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IRObject:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (CORBA::IRObject::_nil ());
      if (is_a == 0)
        return CORBA::IRObject::_nil ();
    }
  return CORBA::IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::IRObject_ptr CORBA::IRObject::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IRObject::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA::IRObject_ptr default_proxy = CORBA::IRObject::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::IRObject (
            stub,
            1,
            obj->_servant ()),
            
          CORBA::IRObject::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA::IRObject (stub, 0, obj->_servant ()), CORBA::IRObject::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            CORBA_IRObject_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_IRObject::_narrow
                    )
                )
          );
}

CORBA::IRObject_ptr
CORBA::IRObject::_duplicate (CORBA::IRObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA::IRObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *CORBA::IRObject::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA::DefinitionKind CORBA::IRObject::def_kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_IRObject_Proxy_Impl &proxy = 
    this->the_TAO_IRObject_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN ((CORBA::DefinitionKind)0);
  
  return proxy.def_kind (
      this,
      ACE_TRY_ENV
    );
}

void CORBA::IRObject::destroy (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_IRObject_Proxy_Impl &proxy = 
    this->the_TAO_IRObject_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK;
  
  proxy.destroy (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_Contained_id_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_id_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_id_get (const TAO_ClientRequestInfo_CORBA_Contained_id_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_id_get &);

  char * _result;
};

TAO_ClientRequestInfo_CORBA_Contained_id_get::TAO_ClientRequestInfo_CORBA_Contained_id_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_id_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_id_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_id_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_id_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_id_set : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_id_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_Contained_id_set (const TAO_ClientRequestInfo_CORBA_Contained_id_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_id_set &);

  const char * id_;
  
};

TAO_ClientRequestInfo_CORBA_Contained_id_set::TAO_ClientRequestInfo_CORBA_Contained_id_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_id_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_id_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_id_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_CORBA_Contained_name_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_name_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_name_get (const TAO_ClientRequestInfo_CORBA_Contained_name_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_name_get &);

  char * _result;
};

TAO_ClientRequestInfo_CORBA_Contained_name_get::TAO_ClientRequestInfo_CORBA_Contained_name_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_name_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_name_set : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_name_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_Contained_name_set (const TAO_ClientRequestInfo_CORBA_Contained_name_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_name_set &);

  const char * name_;
  
};

TAO_ClientRequestInfo_CORBA_Contained_name_set::TAO_ClientRequestInfo_CORBA_Contained_name_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_name_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_name_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_name_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_CORBA_Contained_version_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_version_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_version_get (const TAO_ClientRequestInfo_CORBA_Contained_version_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_version_get &);

  char * _result;
};

TAO_ClientRequestInfo_CORBA_Contained_version_get::TAO_ClientRequestInfo_CORBA_Contained_version_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_version_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_version_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_version_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_version_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_version_set : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_version_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_Contained_version_set (const TAO_ClientRequestInfo_CORBA_Contained_version_set &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_version_set &);

  const char * version_;
  
};

TAO_ClientRequestInfo_CORBA_Contained_version_set::TAO_ClientRequestInfo_CORBA_Contained_version_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_version_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_version_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_version_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_CORBA_Contained_defined_in_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_defined_in_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Container_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_defined_in_get (const TAO_ClientRequestInfo_CORBA_Contained_defined_in_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_defined_in_get &);

  CORBA::Container_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::TAO_ClientRequestInfo_CORBA_Contained_defined_in_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_defined_in_get::result (CORBA::Container_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get (const TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get &);

  char * _result;
};

TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Repository_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get (const TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get &);

  CORBA::Repository_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Contained_containing_repository_get::result (CORBA::Repository_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_describe : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_describe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Contained::Description * result);

private:
  TAO_ClientRequestInfo_CORBA_Contained_describe (const TAO_ClientRequestInfo_CORBA_Contained_describe &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_describe &);

  CORBA::Contained::Description * _result;
};

TAO_ClientRequestInfo_CORBA_Contained_describe::TAO_ClientRequestInfo_CORBA_Contained_describe (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_describe::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_describe::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_describe::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Contained_describe::result (CORBA::Contained::Description * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Contained_move : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Contained_move (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Container_ptr new_container,
      const char * new_name,
      const char * new_version,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_CORBA_Contained_move (const TAO_ClientRequestInfo_CORBA_Contained_move &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Contained_move &);

  CORBA::Container_ptr new_container_;
  const char * new_name_;
  const char * new_version_;
  
};

TAO_ClientRequestInfo_CORBA_Contained_move::TAO_ClientRequestInfo_CORBA_Contained_move (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    new_container_ (new_container),
    new_name_ (new_name),
    new_version_ (new_version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Contained_move::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_new_container = parameter_list->length ();
  parameter_list->length (length_new_container + 1);
  (*parameter_list)[length_new_container].argument <<=  this->new_container_;
  
  (*parameter_list)[length_new_container].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_name = parameter_list->length ();
  parameter_list->length (length_new_name + 1);
  (*parameter_list)[length_new_name].argument <<= new_name_;
  (*parameter_list)[length_new_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_version = parameter_list->length ();
  parameter_list->length (length_new_version + 1);
  (*parameter_list)[length_new_version].argument <<= new_version_;
  (*parameter_list)[length_new_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Contained_move::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Contained_move::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_Contained_Proxy_Impl::_TAO_Contained_Proxy_Impl (void)
{}

_TAO_Contained_Remote_Proxy_Impl::_TAO_Contained_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

char * _TAO_Contained_Remote_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_id",
      7,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_id_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_id",
      7,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_id_set ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

char * _TAO_Contained_Remote_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_name",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_name_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_name",
      9,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_name_set ri (
        &_tao_call,
        _collocated_tao_target_,
        name,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << name)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

char * _TAO_Contained_Remote_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_version",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_version_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_version",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_version_set ri (
        &_tao_call,
        _collocated_tao_target_,
        version,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << version)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Container_ptr _TAO_Contained_Remote_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Container_ptr _tao_retval = CORBA::Container::_nil ();
  CORBA::Container_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_defined_in",
      15,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_defined_in_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Container_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

char * _TAO_Contained_Remote_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_absolute_name",
      18,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_absolute_name_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Contained::Description * _TAO_Contained_Remote_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Contained::Description *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Contained::Description, _tao_retval);
  CORBA::Contained::Description_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe",
      8,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_describe ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Contained::Description * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "move",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Contained_move ri (
        &_tao_call,
        _collocated_tao_target_,
        new_container,
        new_name,
        new_version,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << new_container) &&
              (_tao_out << new_name) &&
              (_tao_out << new_version)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_Contained_Proxy_Broker::_TAO_Contained_Proxy_Broker (void)
{
}

_TAO_Contained_Proxy_Broker::~_TAO_Contained_Proxy_Broker (void)
{
}

_TAO_Contained_Proxy_Broker * (*CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_Contained_Remote_Proxy_Broker *
_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker (void)
{
  static ::_TAO_Contained_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_Contained_Remote_Proxy_Broker::_TAO_Contained_Remote_Proxy_Broker (void)
{
}

_TAO_Contained_Remote_Proxy_Broker::~_TAO_Contained_Remote_Proxy_Broker (void)
{
}

_TAO_Contained_Proxy_Impl&
_TAO_Contained_Remote_Proxy_Broker::select_proxy (
  ::CORBA_Contained *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_Contained::CORBA_Contained (int collocated)
{
  this->CORBA_Contained_setup_collocation (collocated);
}

// destructor
CORBA_Contained::~CORBA_Contained (void)
{}

void
CORBA::Contained::CORBA_Contained_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Contained_Proxy_Broker_ =
      ::CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Contained_Proxy_Broker_ =
      ::_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

void CORBA::Contained::_tao_any_destructor (void *x)
{
  CORBA_Contained *tmp = ACE_static_cast (CORBA_Contained*,x);
  CORBA::release (tmp);
}

CORBA::Contained_ptr CORBA::Contained::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Contained::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Contained:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (CORBA::Contained::_nil ());
      if (is_a == 0)
        return CORBA::Contained::_nil ();
    }
  return CORBA::Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::Contained_ptr CORBA::Contained::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Contained::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA::Contained_ptr default_proxy = CORBA::Contained::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::Contained (
            stub,
            1,
            obj->_servant ()),
            
          CORBA::Contained::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA::Contained (stub, 0, obj->_servant ()), CORBA::Contained::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            CORBA_Contained_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_Contained::_narrow
                    )
                )
          );
}

CORBA::Contained_ptr
CORBA::Contained::_duplicate (CORBA::Contained_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA::Contained::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *CORBA::Contained::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

char * CORBA::Contained::id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.id (
      this,
      ACE_TRY_ENV
    );
}

void CORBA::Contained::id (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK;
  
  proxy.id (
      this,
      id,
      ACE_TRY_ENV
    );
}

char * CORBA::Contained::name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.name (
      this,
      ACE_TRY_ENV
    );
}

void CORBA::Contained::name (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK;
  
  proxy.name (
      this,
      name,
      ACE_TRY_ENV
    );
}

char * CORBA::Contained::version (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.version (
      this,
      ACE_TRY_ENV
    );
}

void CORBA::Contained::version (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK;
  
  proxy.version (
      this,
      version,
      ACE_TRY_ENV
    );
}

CORBA::Container_ptr CORBA::Contained::defined_in (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.defined_in (
      this,
      ACE_TRY_ENV
    );
}

char * CORBA::Contained::absolute_name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.absolute_name (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Repository_ptr CORBA::Contained::containing_repository (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.containing_repository (
      this,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_CORBA_Contained_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65642f), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained/Description:1.0
  12,
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = Description
  2, // member count
  5,
  ACE_NTOHL (0x6b696e64), 
  ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  524, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4465), 
    ACE_NTOHL (0x66696e69), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x4b696e64), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
    15,
    ACE_NTOHL (0x44656669), 
    ACE_NTOHL (0x6e697469), 
    ACE_NTOHL (0x6f6e4b69), 
    ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    26, // member count
    8,
    ACE_NTOHL (0x646b5f6e), 
    ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7,
    ACE_NTOHL (0x646b5f61), 
    ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x74747269), 
    ACE_NTOHL (0x62757465), 
    ACE_NTOHL (0x0),  // name = dk_Attribute
    12,
    ACE_NTOHL (0x646b5f43), 
    ACE_NTOHL (0x6f6e7374), 
    ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x78636570), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Exception
    13,
    ACE_NTOHL (0x646b5f49), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_Interface
    10,
    ACE_NTOHL (0x646b5f4d), 
    ACE_NTOHL (0x6f64756c), 
    ACE_NTOHL (0x65000000),  // name = dk_Module
    13,
    ACE_NTOHL (0x646b5f4f), 
    ACE_NTOHL (0x70657261), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Operation
    11,
    ACE_NTOHL (0x646b5f54), 
    ACE_NTOHL (0x79706564), 
    ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x6c696173), 
    ACE_NTOHL (0x0),  // name = dk_Alias
    10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x74727563), 
    ACE_NTOHL (0x74000000),  // name = dk_Struct
    9,
    ACE_NTOHL (0x646b5f55), 
    ACE_NTOHL (0x6e696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Union
    8,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13,
    ACE_NTOHL (0x646b5f50), 
    ACE_NTOHL (0x72696d69), 
    ACE_NTOHL (0x74697665), 
    ACE_NTOHL (0x0),  // name = dk_Primitive
    10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x7472696e), 
    ACE_NTOHL (0x67000000),  // name = dk_String
    12,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x72726179), 
    ACE_NTOHL (0x0),  // name = dk_Array
    14,
    ACE_NTOHL (0x646b5f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x79000000),  // name = dk_Repository
    11,
    ACE_NTOHL (0x646b5f57), 
    ACE_NTOHL (0x73747269), 
    ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9,
    ACE_NTOHL (0x646b5f46), 
    ACE_NTOHL (0x69786564), 
    ACE_NTOHL (0x0),  // name = dk_Fixed
    9,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x0),  // name = dk_Value
    12,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x4d656d62), 
    ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10,
    ACE_NTOHL (0x646b5f4e), 
    ACE_NTOHL (0x61746976), 
    ACE_NTOHL (0x65000000),  // name = dk_Native
    21,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x62737472), 
    ACE_NTOHL (0x61637449), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_AbstractInterface
    18,
    ACE_NTOHL (0x646b5f4c), 
    ACE_NTOHL (0x6f63616c), 
    ACE_NTOHL (0x496e7465), 
    ACE_NTOHL (0x72666163), 
    ACE_NTOHL (0x65000000),  // name = dk_LocalInterface

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained_Description (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_Contained_Description),
    (char *) &_oc_CORBA_Contained_Description,
    0,
    sizeof (CORBA::Contained::Description)
  );

CORBA::TypeCode_ptr CORBA::Contained::_tc_Description =
  &_tc_TAO_tc_CORBA_Contained_Description;

void CORBA::Contained::Description::_tao_any_destructor (void *x)
{
  Description *tmp = ACE_static_cast (Description*,x);
  delete tmp;
}

CORBA::Contained::Description * CORBA::Contained::describe (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe (
      this,
      ACE_TRY_ENV
    );
}

void CORBA::Contained::move (
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Contained_Proxy_Impl &proxy = 
    this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK;
  
  proxy.move (
      this,
      new_container,
      new_name,
      new_version,
      ACE_TRY_ENV
    );
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_Contained **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA_Contained **old = ACE_reinterpret_cast (CORBA_Contained**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA_Contained::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA_Contained **tmp = ACE_reinterpret_cast (CORBA_Contained**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_Contained::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA_Contained **tmp = ACE_reinterpret_cast (CORBA_Contained**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_Contained::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA_Contained **tmp = ACE_static_cast (CORBA_Contained**, target);
    *tmp = CORBA_Contained::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_upcast (void *src) const
  {
    CORBA_Contained **tmp = ACE_static_cast (CORBA_Contained**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_CONTAINEDSEQ_CS_)
#define _CORBA_CONTAINEDSEQ_CS_

// *************************************************************
// CORBA_ContainedSeq
// *************************************************************

CORBA_ContainedSeq::CORBA_ContainedSeq (void)
{}
CORBA_ContainedSeq::CORBA_ContainedSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA_ContainedSeq::CORBA_ContainedSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Contained_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA_ContainedSeq::CORBA_ContainedSeq (const CORBA_ContainedSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA_ContainedSeq::~CORBA_ContainedSeq (void) // dtor
{}
void CORBA_ContainedSeq::_tao_any_destructor (void *x)
{
  CORBA_ContainedSeq *tmp = ACE_static_cast (CORBA_ContainedSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

void CORBA::StructMember::_tao_any_destructor (void *x)
{
  CORBA_StructMember *tmp = ACE_static_cast (CORBA_StructMember*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_StructMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA_StructMember *old = ACE_reinterpret_cast (CORBA_StructMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA_StructMember *tmp = ACE_reinterpret_cast (CORBA_StructMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::~_TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_STRUCTMEMBERSEQ_CS_)
#define _CORBA_STRUCTMEMBERSEQ_CS_

// *************************************************************
// CORBA_StructMemberSeq
// *************************************************************

CORBA_StructMemberSeq::CORBA_StructMemberSeq (void)
{}
CORBA_StructMemberSeq::CORBA_StructMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA_StructMemberSeq::CORBA_StructMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA::StructMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA_StructMemberSeq::CORBA_StructMemberSeq (const CORBA_StructMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA_StructMemberSeq::~CORBA_StructMemberSeq (void) // dtor
{}
void CORBA_StructMemberSeq::_tao_any_destructor (void *x)
{
  CORBA_StructMemberSeq *tmp = ACE_static_cast (CORBA_StructMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

void CORBA::Initializer::_tao_any_destructor (void *x)
{
  CORBA_Initializer *tmp = ACE_static_cast (CORBA_Initializer*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_Initializer* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_InitializerSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA_Initializer *old = ACE_reinterpret_cast (CORBA_Initializer *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA_Initializer *tmp = ACE_reinterpret_cast (CORBA_Initializer *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::~_TAO_Unbounded_Sequence_CORBA_InitializerSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_INITIALIZERSEQ_CS_)
#define _CORBA_INITIALIZERSEQ_CS_

// *************************************************************
// CORBA_InitializerSeq
// *************************************************************

CORBA_InitializerSeq::CORBA_InitializerSeq (void)
{}
CORBA_InitializerSeq::CORBA_InitializerSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA_InitializerSeq::CORBA_InitializerSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Initializer *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA_InitializerSeq::CORBA_InitializerSeq (const CORBA_InitializerSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA_InitializerSeq::~CORBA_InitializerSeq (void) // dtor
{}
void CORBA_InitializerSeq::_tao_any_destructor (void *x)
{
  CORBA_InitializerSeq *tmp = ACE_static_cast (CORBA_InitializerSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

void CORBA::UnionMember::_tao_any_destructor (void *x)
{
  CORBA_UnionMember *tmp = ACE_static_cast (CORBA_UnionMember*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_UnionMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA_UnionMember *old = ACE_reinterpret_cast (CORBA_UnionMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA_UnionMember *tmp = ACE_reinterpret_cast (CORBA_UnionMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::~_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_UNIONMEMBERSEQ_CS_)
#define _CORBA_UNIONMEMBERSEQ_CS_

// *************************************************************
// CORBA_UnionMemberSeq
// *************************************************************

CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (void)
{}
CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA::UnionMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (const CORBA_UnionMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA_UnionMemberSeq::~CORBA_UnionMemberSeq (void) // dtor
{}
void CORBA_UnionMemberSeq::_tao_any_destructor (void *x)
{
  CORBA_UnionMemberSeq *tmp = ACE_static_cast (CORBA_UnionMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ_CS_)
#define _CORBA_ENUMMEMBERSEQ_CS_

// *************************************************************
// CORBA_EnumMemberSeq
// *************************************************************

CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (void)
{}
CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (const CORBA_EnumMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA_EnumMemberSeq::~CORBA_EnumMemberSeq (void) // dtor
{}
void CORBA_EnumMemberSeq::_tao_any_destructor (void *x)
{
  CORBA_EnumMemberSeq *tmp = ACE_static_cast (CORBA_EnumMemberSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_Container_lookup : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_lookup (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_name,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Contained_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_lookup (const TAO_ClientRequestInfo_CORBA_Container_lookup &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_lookup &);

  const char * search_name_;
  CORBA::Contained_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_lookup::TAO_ClientRequestInfo_CORBA_Container_lookup (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * search_name,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    search_name_ (search_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_lookup::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_lookup::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_lookup::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_lookup::result (CORBA::Contained_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_contents : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_contents (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ContainedSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_Container_contents (const TAO_ClientRequestInfo_CORBA_Container_contents &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_contents &);

  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA::ContainedSeq * _result;
};

TAO_ClientRequestInfo_CORBA_Container_contents::TAO_ClientRequestInfo_CORBA_Container_contents (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_contents::result (CORBA::ContainedSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_lookup_name : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_lookup_name (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * search_name,
      const CORBA::Long & levels_to_search,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ContainedSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_Container_lookup_name (const TAO_ClientRequestInfo_CORBA_Container_lookup_name &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_lookup_name &);

  const char * search_name_;
  const CORBA::Long & levels_to_search_;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA::ContainedSeq * _result;
};

TAO_ClientRequestInfo_CORBA_Container_lookup_name::TAO_ClientRequestInfo_CORBA_Container_lookup_name (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    search_name_ (search_name),
    levels_to_search_ (levels_to_search),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_lookup_name::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_levels_to_search = parameter_list->length ();
  parameter_list->length (length_levels_to_search + 1);
  (*parameter_list)[length_levels_to_search].argument <<= levels_to_search_;
  (*parameter_list)[length_levels_to_search].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_lookup_name::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_lookup_name::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_lookup_name::result (CORBA::ContainedSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_describe_contents : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_describe_contents (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::DefinitionKind & limit_type,
      const CORBA::Boolean & exclude_inherited,
      const CORBA::Long & max_returned_objs,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Container::DescriptionSeq * result);

private:
  TAO_ClientRequestInfo_CORBA_Container_describe_contents (const TAO_ClientRequestInfo_CORBA_Container_describe_contents &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_describe_contents &);

  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  const CORBA::Long & max_returned_objs_;
  CORBA::Container::DescriptionSeq * _result;
};

TAO_ClientRequestInfo_CORBA_Container_describe_contents::TAO_ClientRequestInfo_CORBA_Container_describe_contents (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited),
    max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_describe_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_max_returned_objs = parameter_list->length ();
  parameter_list->length (length_max_returned_objs + 1);
  (*parameter_list)[length_max_returned_objs].argument <<= max_returned_objs_;
  (*parameter_list)[length_max_returned_objs].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_describe_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_Container_describe_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_Container_describe_contents::result (CORBA::Container::DescriptionSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_module : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_module (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ModuleDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_module (const TAO_ClientRequestInfo_CORBA_Container_create_module &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_module &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::ModuleDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_module::TAO_ClientRequestInfo_CORBA_Container_create_module (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_module::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_module::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

void 
TAO_ClientRequestInfo_CORBA_Container_create_module::result (CORBA::ModuleDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_constant : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_constant (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ConstantDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_constant (const TAO_ClientRequestInfo_CORBA_Container_create_constant &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_constant &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr type_;
  const CORBA::Any & value_;
  CORBA::ConstantDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_constant::TAO_ClientRequestInfo_CORBA_Container_create_constant (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_constant::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_constant::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_constant::result (CORBA::ConstantDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_struct : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_struct (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::StructDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_struct (const TAO_ClientRequestInfo_CORBA_Container_create_struct &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_struct &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::StructMemberSeq & members_;
  CORBA::StructDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_struct::TAO_ClientRequestInfo_CORBA_Container_create_struct (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_struct::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_struct::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_struct::result (CORBA::StructDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_union : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_union (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr discriminator_type,
      const CORBA::UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::UnionDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_union (const TAO_ClientRequestInfo_CORBA_Container_create_union &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_union &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr discriminator_type_;
  const CORBA::UnionMemberSeq & members_;
  CORBA::UnionDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_union::TAO_ClientRequestInfo_CORBA_Container_create_union (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    discriminator_type_ (discriminator_type),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_union::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_discriminator_type = parameter_list->length ();
  parameter_list->length (length_discriminator_type + 1);
  (*parameter_list)[length_discriminator_type].argument <<=  this->discriminator_type_;
  
  (*parameter_list)[length_discriminator_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_union::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_union::result (CORBA::UnionDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_enum : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_enum (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::EnumDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_enum (const TAO_ClientRequestInfo_CORBA_Container_create_enum &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_enum &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::EnumMemberSeq & members_;
  CORBA::EnumDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_enum::TAO_ClientRequestInfo_CORBA_Container_create_enum (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_enum::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_enum::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_enum::result (CORBA::EnumDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_alias : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_alias (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr original_type,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AliasDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_alias (const TAO_ClientRequestInfo_CORBA_Container_create_alias &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_alias &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr original_type_;
  CORBA::AliasDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_alias::TAO_ClientRequestInfo_CORBA_Container_create_alias (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_ (original_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_alias::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type = parameter_list->length ();
  parameter_list->length (length_original_type + 1);
  (*parameter_list)[length_original_type].argument <<=  this->original_type_;
  
  (*parameter_list)[length_original_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_alias::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_alias::result (CORBA::AliasDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_interface : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::InterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_interface (const TAO_ClientRequestInfo_CORBA_Container_create_interface &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_interface &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::InterfaceDefSeq & base_interfaces_;
  CORBA::InterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_interface::TAO_ClientRequestInfo_CORBA_Container_create_interface (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_interface::result (CORBA::InterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_value : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::Boolean & is_custom,
      const CORBA::Boolean & is_abstract,
      CORBA::ValueDef_ptr base_value,
      const CORBA::Boolean & is_truncatable,
      const CORBA::ValueDefSeq & abstract_base_values,
      const CORBA::InterfaceDefSeq & supported_interfaces,
      const CORBA::InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_value (const TAO_ClientRequestInfo_CORBA_Container_create_value &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_value &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::Boolean & is_custom_;
  const CORBA::Boolean & is_abstract_;
  CORBA::ValueDef_ptr base_value_;
  const CORBA::Boolean & is_truncatable_;
  const CORBA::ValueDefSeq & abstract_base_values_;
  const CORBA::InterfaceDefSeq & supported_interfaces_;
  const CORBA::InitializerSeq & initializers_;
  CORBA::ValueDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_value::TAO_ClientRequestInfo_CORBA_Container_create_value (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA::ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    is_custom_ (is_custom),
    is_abstract_ (is_abstract),
    base_value_ (base_value),
    is_truncatable_ (is_truncatable),
    abstract_base_values_ (abstract_base_values),
    supported_interfaces_ (supported_interfaces),
    initializers_ (initializers)
{}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_value::result (CORBA::ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_value_box : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_value_box (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueBoxDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_value_box (const TAO_ClientRequestInfo_CORBA_Container_create_value_box &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_value_box &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr original_type_def_;
  CORBA::ValueBoxDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_value_box::TAO_ClientRequestInfo_CORBA_Container_create_value_box (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_value_box::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_value_box::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_value_box::result (CORBA::ValueBoxDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_exception : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_exception (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ExceptionDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_exception (const TAO_ClientRequestInfo_CORBA_Container_create_exception &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_exception &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::StructMemberSeq & members_;
  CORBA::ExceptionDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_exception::TAO_ClientRequestInfo_CORBA_Container_create_exception (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_exception::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_exception::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_exception::result (CORBA::ExceptionDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_native : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_native (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::NativeDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_native (const TAO_ClientRequestInfo_CORBA_Container_create_native &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_native &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::NativeDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_native::TAO_ClientRequestInfo_CORBA_Container_create_native (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_Container_create_native::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_native::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_native::result (CORBA::NativeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::AbstractInterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AbstractInterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface (const TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::AbstractInterfaceDefSeq & base_interfaces_;
  CORBA::AbstractInterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_abstract_interface::result (CORBA::AbstractInterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_CORBA_Container_create_local_interface : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_Container_create_local_interface (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::LocalInterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_Container_create_local_interface (const TAO_ClientRequestInfo_CORBA_Container_create_local_interface &);
  void operator= (const TAO_ClientRequestInfo_CORBA_Container_create_local_interface &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::InterfaceDefSeq & base_interfaces_;
  CORBA::LocalInterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_CORBA_Container_create_local_interface::TAO_ClientRequestInfo_CORBA_Container_create_local_interface (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_Container_create_local_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


void 
TAO_ClientRequestInfo_CORBA_Container_create_local_interface::result (CORBA::LocalInterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
{}

_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Contained_ptr _TAO_Container_Remote_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Contained_ptr _tao_retval = CORBA::Contained::_nil ();
  CORBA::Contained_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      6,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_lookup ri (
        &_tao_call,
        _collocated_tao_target_,
        search_name,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << search_name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Contained_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::ContainedSeq * _TAO_Container_Remote_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ContainedSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ContainedSeq, _tao_retval);
  CORBA::ContainedSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "contents",
      8,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_contents ri (
        &_tao_call,
        _collocated_tao_target_,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::ContainedSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::ContainedSeq * _TAO_Container_Remote_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ContainedSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ContainedSeq, _tao_retval);
  CORBA::ContainedSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_name",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_lookup_name ri (
        &_tao_call,
        _collocated_tao_target_,
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << search_name) &&
              (_tao_out << levels_to_search) &&
              (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::ContainedSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Container::DescriptionSeq * _TAO_Container_Remote_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Container::DescriptionSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Container::DescriptionSeq, _tao_retval);
  CORBA::Container::DescriptionSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_contents",
      17,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_Container_describe_contents ri (
        &_tao_call,
        _collocated_tao_target_,
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited)) &&
              (_tao_out << max_returned_objs)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Container::DescriptionSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
{
}

_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
{
}

_TAO_Container_Proxy_Broker * (*CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_Container_Remote_Proxy_Broker *
_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker (void)
{
  static ::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
{
}

_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
{
}

_TAO_Container_Proxy_Impl&
_TAO_Container_Remote_Proxy_Broker::select_proxy (
  ::CORBA_Container *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_Container::CORBA_Container (int collocated)
{
  this->CORBA_Container_setup_collocation (collocated);
}

// destructor
CORBA_Container::~CORBA_Container (void)
{}

void
CORBA_Container::CORBA_Container_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Container_Proxy_Broker_ =
      ::CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Container_Proxy_Broker_ =
      ::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

void CORBA::Container::_tao_any_destructor (void *x)
{
  CORBA_Container *tmp = ACE_static_cast (CORBA_Container*,x);
  CORBA::release (tmp);
}

CORBA::Container_ptr CORBA::Container::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Container::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Container:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (CORBA::Container::_nil ());
      if (is_a == 0)
        return CORBA::Container::_nil ();
    }
  return CORBA::Container::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::Container_ptr CORBA::Container::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Container::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA::Container_ptr default_proxy = CORBA::Container::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::Container (
            stub,
            1,
            obj->_servant ()),
            
          CORBA::Container::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA::Container (stub, 0, obj->_servant ()), CORBA::Container::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            CORBA_Container_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_Container::_narrow
                    )
                )
          );
}

CORBA::Container_ptr
CORBA::Container::_duplicate (CORBA::Container_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA::Container::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *CORBA::Container::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_Container::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

CORBA::Contained_ptr CORBA::Container::lookup (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.lookup (
      this,
      search_name,
      ACE_TRY_ENV
    );
}

CORBA::ContainedSeq * CORBA::Container::contents (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.contents (
      this,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
}

CORBA::ContainedSeq * CORBA::Container::lookup_name (
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.lookup_name (
      this,
      search_name,
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_CORBA_Container_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65722f), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
  12,
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = Description
  3, // member count
  17,
  ACE_NTOHL (0x636f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x645f6f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x0),  // name = contained_object
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f436f), 
    ACE_NTOHL (0x6e746169), 
    ACE_NTOHL (0x6e65643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
    10,
    ACE_NTOHL (0x436f6e74), 
    ACE_NTOHL (0x61696e65), 
    ACE_NTOHL (0x64000000),  // name = Contained

  5,
  ACE_NTOHL (0x6b696e64), 
  ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  524, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4465), 
    ACE_NTOHL (0x66696e69), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x4b696e64), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
    15,
    ACE_NTOHL (0x44656669), 
    ACE_NTOHL (0x6e697469), 
    ACE_NTOHL (0x6f6e4b69), 
    ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    26, // member count
    8,
    ACE_NTOHL (0x646b5f6e), 
    ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7,
    ACE_NTOHL (0x646b5f61), 
    ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x74747269), 
    ACE_NTOHL (0x62757465), 
    ACE_NTOHL (0x0),  // name = dk_Attribute
    12,
    ACE_NTOHL (0x646b5f43), 
    ACE_NTOHL (0x6f6e7374), 
    ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x78636570), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Exception
    13,
    ACE_NTOHL (0x646b5f49), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_Interface
    10,
    ACE_NTOHL (0x646b5f4d), 
    ACE_NTOHL (0x6f64756c), 
    ACE_NTOHL (0x65000000),  // name = dk_Module
    13,
    ACE_NTOHL (0x646b5f4f), 
    ACE_NTOHL (0x70657261), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Operation
    11,
    ACE_NTOHL (0x646b5f54), 
    ACE_NTOHL (0x79706564), 
    ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x6c696173), 
    ACE_NTOHL (0x0),  // name = dk_Alias
    10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x74727563), 
    ACE_NTOHL (0x74000000),  // name = dk_Struct
    9,
    ACE_NTOHL (0x646b5f55), 
    ACE_NTOHL (0x6e696f6e), 
    ACE_NTOHL (0x0),  // name = dk_Union
    8,
    ACE_NTOHL (0x646b5f45), 
    ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13,
    ACE_NTOHL (0x646b5f50), 
    ACE_NTOHL (0x72696d69), 
    ACE_NTOHL (0x74697665), 
    ACE_NTOHL (0x0),  // name = dk_Primitive
    10,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x7472696e), 
    ACE_NTOHL (0x67000000),  // name = dk_String
    12,
    ACE_NTOHL (0x646b5f53), 
    ACE_NTOHL (0x65717565), 
    ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x72726179), 
    ACE_NTOHL (0x0),  // name = dk_Array
    14,
    ACE_NTOHL (0x646b5f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x79000000),  // name = dk_Repository
    11,
    ACE_NTOHL (0x646b5f57), 
    ACE_NTOHL (0x73747269), 
    ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9,
    ACE_NTOHL (0x646b5f46), 
    ACE_NTOHL (0x69786564), 
    ACE_NTOHL (0x0),  // name = dk_Fixed
    9,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x0),  // name = dk_Value
    12,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15,
    ACE_NTOHL (0x646b5f56), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x4d656d62), 
    ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10,
    ACE_NTOHL (0x646b5f4e), 
    ACE_NTOHL (0x61746976), 
    ACE_NTOHL (0x65000000),  // name = dk_Native
    21,
    ACE_NTOHL (0x646b5f41), 
    ACE_NTOHL (0x62737472), 
    ACE_NTOHL (0x61637449), 
    ACE_NTOHL (0x6e746572), 
    ACE_NTOHL (0x66616365), 
    ACE_NTOHL (0x0),  // name = dk_AbstractInterface
    18,
    ACE_NTOHL (0x646b5f4c), 
    ACE_NTOHL (0x6f63616c), 
    ACE_NTOHL (0x496e7465), 
    ACE_NTOHL (0x72666163), 
    ACE_NTOHL (0x65000000),  // name = dk_LocalInterface

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_Description (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_Container_Description),
    (char *) &_oc_CORBA_Container_Description,
    0,
    sizeof (CORBA::Container::Description)
  );

CORBA::TypeCode_ptr CORBA::Container::_tc_Description =
  &_tc_TAO_tc_CORBA_Container_Description;

void CORBA::Container::Description::_tao_any_destructor (void *x)
{
  Description *tmp = ACE_static_cast (Description*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

  void
  CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::Container::Description* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::Container::Description *old = ACE_reinterpret_cast (CORBA::Container::Description *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::Container::Description *tmp = ACE_reinterpret_cast (CORBA::Container::Description *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA::Container::DescriptionSeq
// *************************************************************

CORBA::Container::DescriptionSeq::DescriptionSeq (void)
{}
CORBA::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Container::Description *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::Container::DescriptionSeq::~DescriptionSeq (void) // dtor
{}
void CORBA::Container::DescriptionSeq::_tao_any_destructor (void *x)
{
  DescriptionSeq *tmp = ACE_static_cast (DescriptionSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_Container_DescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65722f), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/Container/DescriptionSeq:1.0
  15,
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65710000),  // name = DescriptionSeq
  CORBA::tk_sequence, // typecode kind
  736, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    720, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      44,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6e746169), 
      ACE_NTOHL (0x6e65722f), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e3a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
      12,
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = Description
      3, // member count
      17,
      ACE_NTOHL (0x636f6e74), 
      ACE_NTOHL (0x61696e65), 
      ACE_NTOHL (0x645f6f62), 
      ACE_NTOHL (0x6a656374), 
      ACE_NTOHL (0x0),  // name = contained_object
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6e746169), 
        ACE_NTOHL (0x6e65643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
        10,
        ACE_NTOHL (0x436f6e74), 
        ACE_NTOHL (0x61696e65), 
        ACE_NTOHL (0x64000000),  // name = Contained

      5,
      ACE_NTOHL (0x6b696e64), 
      ACE_NTOHL (0x0),  // name = kind
      CORBA::tk_enum, // typecode kind
      524, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4465), 
        ACE_NTOHL (0x66696e69), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x4b696e64), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
        15,
        ACE_NTOHL (0x44656669), 
        ACE_NTOHL (0x6e697469), 
        ACE_NTOHL (0x6f6e4b69), 
        ACE_NTOHL (0x6e640000),  // name = DefinitionKind
        26, // member count
        8,
        ACE_NTOHL (0x646b5f6e), 
        ACE_NTOHL (0x6f6e6500),  // name = dk_none
        7,
        ACE_NTOHL (0x646b5f61), 
        ACE_NTOHL (0x6c6c0000),  // name = dk_all
        13,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x74747269), 
        ACE_NTOHL (0x62757465), 
        ACE_NTOHL (0x0),  // name = dk_Attribute
        12,
        ACE_NTOHL (0x646b5f43), 
        ACE_NTOHL (0x6f6e7374), 
        ACE_NTOHL (0x616e7400),  // name = dk_Constant
        13,
        ACE_NTOHL (0x646b5f45), 
        ACE_NTOHL (0x78636570), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = dk_Exception
        13,
        ACE_NTOHL (0x646b5f49), 
        ACE_NTOHL (0x6e746572), 
        ACE_NTOHL (0x66616365), 
        ACE_NTOHL (0x0),  // name = dk_Interface
        10,
        ACE_NTOHL (0x646b5f4d), 
        ACE_NTOHL (0x6f64756c), 
        ACE_NTOHL (0x65000000),  // name = dk_Module
        13,
        ACE_NTOHL (0x646b5f4f), 
        ACE_NTOHL (0x70657261), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = dk_Operation
        11,
        ACE_NTOHL (0x646b5f54), 
        ACE_NTOHL (0x79706564), 
        ACE_NTOHL (0x65660000),  // name = dk_Typedef
        9,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x6c696173), 
        ACE_NTOHL (0x0),  // name = dk_Alias
        10,
        ACE_NTOHL (0x646b5f53), 
        ACE_NTOHL (0x74727563), 
        ACE_NTOHL (0x74000000),  // name = dk_Struct
        9,
        ACE_NTOHL (0x646b5f55), 
        ACE_NTOHL (0x6e696f6e), 
        ACE_NTOHL (0x0),  // name = dk_Union
        8,
        ACE_NTOHL (0x646b5f45), 
        ACE_NTOHL (0x6e756d00),  // name = dk_Enum
        13,
        ACE_NTOHL (0x646b5f50), 
        ACE_NTOHL (0x72696d69), 
        ACE_NTOHL (0x74697665), 
        ACE_NTOHL (0x0),  // name = dk_Primitive
        10,
        ACE_NTOHL (0x646b5f53), 
        ACE_NTOHL (0x7472696e), 
        ACE_NTOHL (0x67000000),  // name = dk_String
        12,
        ACE_NTOHL (0x646b5f53), 
        ACE_NTOHL (0x65717565), 
        ACE_NTOHL (0x6e636500),  // name = dk_Sequence
        9,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x72726179), 
        ACE_NTOHL (0x0),  // name = dk_Array
        14,
        ACE_NTOHL (0x646b5f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x79000000),  // name = dk_Repository
        11,
        ACE_NTOHL (0x646b5f57), 
        ACE_NTOHL (0x73747269), 
        ACE_NTOHL (0x6e670000),  // name = dk_Wstring
        9,
        ACE_NTOHL (0x646b5f46), 
        ACE_NTOHL (0x69786564), 
        ACE_NTOHL (0x0),  // name = dk_Fixed
        9,
        ACE_NTOHL (0x646b5f56), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x0),  // name = dk_Value
        12,
        ACE_NTOHL (0x646b5f56), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
        15,
        ACE_NTOHL (0x646b5f56), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x4d656d62), 
        ACE_NTOHL (0x65720000),  // name = dk_ValueMember
        10,
        ACE_NTOHL (0x646b5f4e), 
        ACE_NTOHL (0x61746976), 
        ACE_NTOHL (0x65000000),  // name = dk_Native
        21,
        ACE_NTOHL (0x646b5f41), 
        ACE_NTOHL (0x62737472), 
        ACE_NTOHL (0x61637449), 
        ACE_NTOHL (0x6e746572), 
        ACE_NTOHL (0x66616365), 
        ACE_NTOHL (0x0),  // name = dk_AbstractInterface
        18,
        ACE_NTOHL (0x646b5f4c), 
        ACE_NTOHL (0x6f63616c), 
        ACE_NTOHL (0x496e7465), 
        ACE_NTOHL (0x72666163), 
        ACE_NTOHL (0x65000000),  // name = dk_LocalInterface

      6,
      ACE_NTOHL (0x76616c75), 
      ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_DescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_Container_DescriptionSeq),
    (char *) &_oc_CORBA_Container_DescriptionSeq,
    0,
    sizeof (CORBA::Container::DescriptionSeq)
  );

CORBA::TypeCode_ptr CORBA::Container::_tc_DescriptionSeq =
  &_tc_TAO_tc_CORBA_Container_DescriptionSeq;

CORBA::Container::DescriptionSeq * CORBA::Container::describe_contents (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_contents (
      this,
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );
}

CORBA::ModuleDef_ptr CORBA::Container::create_module (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_module (
      this,
      id,
      name,
      version,
      ACE_TRY_ENV
    );
}

CORBA::ConstantDef_ptr CORBA::Container::create_constant (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_constant (
      this,
      id,
      name,
      version,
      type,
      value,
      ACE_TRY_ENV
    );
}

CORBA::StructDef_ptr CORBA::Container::create_struct (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_struct (
      this,
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );
}

CORBA::UnionDef_ptr CORBA::Container::create_union (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_union (
      this,
      id,
      name,
      version,
      discriminator_type,
      members,
      ACE_TRY_ENV
    );
}

CORBA::EnumDef_ptr CORBA::Container::create_enum (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_enum (
      this,
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );
}

CORBA::AliasDef_ptr CORBA::Container::create_alias (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_alias (
      this,
      id,
      name,
      version,
      original_type,
      ACE_TRY_ENV
    );
}

CORBA::InterfaceDef_ptr CORBA::Container::create_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_interface (
      this,
      id,
      name,
      version,
      base_interfaces,
      ACE_TRY_ENV
    );
}

CORBA::ValueDef_ptr CORBA::Container::create_value (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_value (
      this,
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );
}

CORBA::ValueBoxDef_ptr CORBA::Container::create_value_box (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_value_box (
      this,
      id,
      name,
      version,
      original_type_def,
      ACE_TRY_ENV
    );
}

CORBA::ExceptionDef_ptr CORBA::Container::create_exception (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_exception (
      this,
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );
}

CORBA::NativeDef_ptr CORBA::Container::create_native (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_native (
      this,
      id,
      name,
      version,
      ACE_TRY_ENV
    );
}

CORBA::AbstractInterfaceDef_ptr CORBA::Container::create_abstract_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_abstract_interface (
      this,
      id,
      name,
      version,
      base_interfaces,
      ACE_TRY_ENV
    );
}

CORBA::LocalInterfaceDef_ptr CORBA::Container::create_local_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_local_interface (
      this,
      id,
      name,
      version,
      base_interfaces,
      ACE_TRY_ENV
    );
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_CORBA_IDLType_type_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_CORBA_IDLType_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ClientRequestInfo_CORBA_IDLType_type_get (const TAO_ClientRequestInfo_CORBA_IDLType_type_get &);
  void operator= (const TAO_ClientRequestInfo_CORBA_IDLType_type_get &);

  CORBA::TypeCode_ptr _result;
};

TAO_ClientRequestInfo_CORBA_IDLType_type_get::TAO_ClientRequestInfo_CORBA_IDLType_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_IDLType_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_IDLType_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_CORBA_IDLType_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_IDLType_Proxy_Impl::_TAO_IDLType_Proxy_Impl (void)
{}

_TAO_IDLType_Remote_Proxy_Impl::_TAO_IDLType_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_IDLType_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_IDLType_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_IDLType_Proxy_Broker::_TAO_IDLType_Proxy_Broker (void)
{
}

_TAO_IDLType_Proxy_Broker::~_TAO_IDLType_Proxy_Broker (void)
{
}

_TAO_IDLType_Proxy_Broker * (*CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_IDLType_Remote_Proxy_Broker *
_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker (void)
{
  static ::_TAO_IDLType_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_IDLType_Remote_Proxy_Broker::_TAO_IDLType_Remote_Proxy_Broker (void)
{
}

_TAO_IDLType_Remote_Proxy_Broker::~_TAO_IDLType_Remote_Proxy_Broker (void)
{
}

_TAO_IDLType_Proxy_Impl&
_TAO_IDLType_Remote_Proxy_Broker::select_proxy (
  ::CORBA_IDLType *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_IDLType::CORBA_IDLType (int collocated)
{
  this->CORBA_IDLType_setup_collocation (collocated);
}

// destructor
CORBA_IDLType::~CORBA_IDLType (void)
{}

void
CORBA::IDLType::CORBA_IDLType_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_IDLType_Proxy_Broker_ =
      ::CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_IDLType_Proxy_Broker_ =
      ::_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

void CORBA::IDLType::_tao_any_destructor (void *x)
{
  CORBA_IDLType *tmp = ACE_static_cast (CORBA_IDLType*,x);
  CORBA::release (tmp);
}

CORBA::IDLType_ptr CORBA::IDLType::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IDLType::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IDLType:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (CORBA::IDLType::_nil ());
      if (is_a == 0)
        return CORBA::IDLType::_nil ();
    }
  return CORBA::IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::IDLType_ptr CORBA::IDLType::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IDLType::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA::IDLType_ptr default_proxy = CORBA::IDLType::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::IDLType (
            stub,
            1,
            obj->_servant ()),
            
          CORBA::IDLType::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA::IDLType (stub, 0, obj->_servant ()), CORBA::IDLType::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            CORBA_IDLType_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_IDLType::_narrow
                    )
                )
          );
}

CORBA::IDLType_ptr
CORBA::IDLType::_duplicate (CORBA::IDLType_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA::IDLType::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *CORBA::IDLType::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IDLType::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

CORBA::TypeCode_ptr CORBA::IDLType::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_IDLType_Proxy_Impl &proxy = 
    this->the_TAO_IDLType_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.type (
      this,
      ACE_TRY_ENV
    );
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_TypedefDef_Proxy_Impl::_TAO_TypedefDef_Proxy_Impl (void)
{}

_TAO_TypedefDef_Remote_Proxy_Impl::_TAO_TypedefDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_TypedefDef_Proxy_Broker::_TAO_TypedefDef_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Proxy_Broker::~_TAO_TypedefDef_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Proxy_Broker * (*CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_TypedefDef_Remote_Proxy_Broker *
_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_TypedefDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_TypedefDef_Remote_Proxy_Broker::_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Remote_Proxy_Broker::~_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Proxy_Impl&
_TAO_TypedefDef_Remote_Proxy_Broker::select_proxy (
  ::CORBA_TypedefDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_TypedefDef::CORBA_TypedefDef (int collocated)
{
  this->CORBA_TypedefDef_setup_collocation (collocated);
}

// destructor
CORBA_TypedefDef::~CORBA_TypedefDef (void)
{}

void
CORBA::TypedefDef::CORBA_TypedefDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_TypedefDef_Proxy_Broker_ =
      ::CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_TypedefDef_Proxy_Broker_ =
      ::_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

void CORBA::TypedefDef::_tao_any_destructor (void *x)
{
  CORBA_TypedefDef *tmp = ACE_static_cast (CORBA_TypedefDef*,x);
  CORBA::release (tmp);
}

CORBA::TypedefDef_ptr CORBA::TypedefDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::TypedefDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/TypedefDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (CORBA::TypedefDef::_nil ());
      if (is_a == 0)
        return CORBA::TypedefDef::_nil ();
    }
  return CORBA::TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::TypedefDef_ptr CORBA::TypedefDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::TypedefDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA::TypedefDef_ptr default_proxy = CORBA::TypedefDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::CORBA::TypedefDef (
            stub,
            1,
            obj->_servant ()),
            
          CORBA::TypedefDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::CORBA::TypedefDef (stub, 0, obj->_servant ()), CORBA::TypedefDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            CORBA_TypedefDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_TypedefDef::_narrow
                    )
                )
          );
}

CORBA::TypedefDef_ptr
CORBA::TypedefDef::_duplicate (CORBA::TypedefDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA::TypedefDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *CORBA::TypedefDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

void CORBA::TypeDescription::_tao_any_destructor (void *x)
{
  CORBA_TypeDescription *tmp = ACE_static_cast (CORBA_TypeDescription*,x);
  delete tmp;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::DefinitionKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_DefinitionKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::DefinitionKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_DefinitionKind, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::IRObject_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_IRObject, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::IRObject::_duplicate (_tao_elem),
        CORBA::IRObject::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IRObject_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IRObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_IRObject, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_IRObject,
          1,
          _tao_elem,
          CORBA::IRObject::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::IRObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::IRObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA::Contained_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_Contained, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::Contained::_duplicate (_tao_elem),
        CORBA::Contained::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Contained_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Contained::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_Contained, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_Contained,
          1,
          _tao_elem,
          CORBA::Contained::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::Contained::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::Contained::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::Contained::Description &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::Contained::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Contained::Description *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::Contained::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::Contained::Description::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Contained::Description *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA::Contained::Description*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Contained::Description *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::Contained::_tc_Description, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::Contained::Description*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::Contained::Description *tmp;
      ACE_NEW_RETURN (tmp, CORBA::Contained::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Contained::_tc_Description,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::Contained::Description::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContainedSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_ContainedSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ContainedSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_ContainedSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::ContainedSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ContainedSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::ContainedSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ContainedSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_ContainedSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::ContainedSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::ContainedSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA::ContainedSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ContainedSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::ContainedSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::StructMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_StructMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA::StructMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_StructMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::StructMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA::StructMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::StructMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_StructMember, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::StructMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::StructMember *tmp;
      ACE_NEW_RETURN (tmp, CORBA::StructMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_StructMember,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::StructMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::StructMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_StructMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA::StructMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_StructMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::StructMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::StructMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::StructMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_StructMemberSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::StructMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::StructMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA::StructMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_StructMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::StructMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::Initializer &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_Initializer,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Initializer *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_Initializer,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::Initializer::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Initializer *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA::Initializer*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Initializer *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_Initializer, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::Initializer*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::Initializer *tmp;
      ACE_NEW_RETURN (tmp, CORBA::Initializer, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_Initializer,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::Initializer::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InitializerSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_InitializerSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InitializerSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_InitializerSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::InitializerSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InitializerSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::InitializerSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::InitializerSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_InitializerSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::InitializerSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::InitializerSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA::InitializerSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InitializerSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::InitializerSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::UnionMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_UnionMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA::UnionMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_UnionMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::UnionMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA::UnionMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::UnionMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_UnionMember, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::UnionMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::UnionMember *tmp;
      ACE_NEW_RETURN (tmp, CORBA::UnionMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_UnionMember,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::UnionMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::UnionMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_UnionMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA::UnionMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_UnionMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::UnionMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::UnionMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::UnionMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_UnionMemberSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::UnionMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::UnionMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA::UnionMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_UnionMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::UnionMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::EnumMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_EnumMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA::EnumMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_EnumMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::EnumMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::EnumMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::EnumMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::EnumMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_EnumMemberSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::EnumMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::EnumMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA::EnumMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_EnumMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::EnumMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_Container, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::Container::_duplicate (_tao_elem),
        CORBA::Container::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_Container, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_Container,
          1,
          _tao_elem,
          CORBA::Container::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::Container::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::Container::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA::Container,CORBA::Container_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA::Container,CORBA::Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::Container::Description &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::Container::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container::Description *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::Container::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::Container::Description::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container::Description *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA::Container::Description*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Container::Description *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::Container::_tc_Description, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::Container::Description*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::Container::Description *tmp;
      ACE_NEW_RETURN (tmp, CORBA::Container::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Container::_tc_Description,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::Container::Description::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Container::DescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::Container::_tc_DescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container::DescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::Container::_tc_DescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::Container::DescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container::DescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const CORBA::Container::DescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Container::DescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::Container::_tc_DescriptionSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::Container::DescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::Container::DescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, CORBA::Container::DescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Container::_tc_DescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::Container::DescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::IDLType_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_IDLType, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::IDLType::_duplicate (_tao_elem),
        CORBA::IDLType::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IDLType_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IDLType::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_IDLType, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_IDLType,
          1,
          _tao_elem,
          CORBA::IDLType::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::IDLType::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::IDLType::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA::TypedefDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_TypedefDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA::TypedefDef::_duplicate (_tao_elem),
        CORBA::TypedefDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypedefDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::TypedefDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_TypedefDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_TypedefDef,
          1,
          _tao_elem,
          CORBA::TypedefDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA::TypedefDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::TypedefDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::TypeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_TypeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, CORBA::TypeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      CORBA::_tc_TypeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      CORBA::TypeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const CORBA::TypeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::TypeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (CORBA::_tc_TypeDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const CORBA::TypeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      CORBA::TypeDescription *tmp;
      ACE_NEW_RETURN (tmp, CORBA::TypeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_TypeDescription,
            1,
            ACE_static_cast (void *, tmp),
            CORBA::TypeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ContainedSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::StructMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InitializerSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::UnionMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::EnumMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::Container::DescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

