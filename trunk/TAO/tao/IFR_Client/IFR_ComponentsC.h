// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:151

#ifndef _TAO_IDL_ORIG_IFR_COMPONENTSC_H_
#define _TAO_IDL_ORIG_IFR_COMPONENTSC_H_

#include "ace/pre.h"

#include "ifr_client_export.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "IFR_ExtendedC.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_IFR_Client_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_IFR_Client_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:48

TAO_NAMESPACE  IR
{

  // TAO_IDL - Generated from
  // be/be_visitor_enum/enum_ch.cpp:57

  enum DefinitionKind
  {
    dk_none,
    dk_all,
    dk_Attribute,
    dk_Constant,
    dk_Exception,
    dk_Interface,
    dk_Module,
    dk_Operation,
    dk_Typedef,
    dk_Alias,
    dk_Struct,
    dk_Union,
    dk_Enum,
    dk_Primitive,
    dk_String,
    dk_Sequence,
    dk_Array,
    dk_Repository,
    dk_Wstring,
    dk_Fixed,
    dk_Value,
    dk_ValueBox,
    dk_ValueMember,
    dk_Native,
    dk_Component,
    dk_Home,
    dk_Factory,
    dk_Finder,
    dk_PrimaryKey,
    dk_Emits,
    dk_Publishes,
    dk_Consumes,
    dk_Provides,
    dk_Uses
  };

  typedef DefinitionKind &DefinitionKind_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_DefinitionKind;

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:368

  typedef char * Identifier;
  typedef CORBA::String_var Identifier_var;
  typedef CORBA::String_out Identifier_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_Identifier;

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:368

  typedef char * ScopedName;
  typedef CORBA::String_var ScopedName_var;
  typedef CORBA::String_out ScopedName_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ScopedName;

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:368

  typedef char * RepositoryId;
  typedef CORBA::String_var RepositoryId_var;
  typedef CORBA::String_out RepositoryId_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_RepositoryId;

#if !defined (_IR_REPOSITORYIDSEQ_CH_)
#define _IR_REPOSITORYIDSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class RepositoryIdSeq;
  class RepositoryIdSeq_var;

  // *************************************************************
  // IR::RepositoryIdSeq
  // *************************************************************

  class TAO_IFR_Client_Export RepositoryIdSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    RepositoryIdSeq (void);
    RepositoryIdSeq (CORBA::ULong max);
    RepositoryIdSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        char * *buffer,
        CORBA::Boolean release = 0
      );
    RepositoryIdSeq (const RepositoryIdSeq &);
    ~RepositoryIdSeq (void);

    static void _tao_any_destructor (void*);

    typedef RepositoryIdSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_REPOSITORYIDSEQ___VAR_CH_)
#define _IR_REPOSITORYIDSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::RepositoryIdSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export RepositoryIdSeq_var
  {
  public:
    RepositoryIdSeq_var (void);
    RepositoryIdSeq_var (RepositoryIdSeq *);
    RepositoryIdSeq_var (const RepositoryIdSeq_var &);
    ~RepositoryIdSeq_var (void);

    RepositoryIdSeq_var &operator= (RepositoryIdSeq *);
    RepositoryIdSeq_var &operator= (const RepositoryIdSeq_var &);
    RepositoryIdSeq *operator-> (void);
    const RepositoryIdSeq *operator-> (void) const;

    operator const RepositoryIdSeq &() const;
    operator RepositoryIdSeq &();
    operator RepositoryIdSeq &() const;

    // Variable-size base types only.
    operator RepositoryIdSeq *&();

    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const RepositoryIdSeq &in (void) const;
    RepositoryIdSeq &inout (void);
    RepositoryIdSeq *&out (void);
    RepositoryIdSeq *_retn (void);
    RepositoryIdSeq *ptr (void) const;

  private:
    RepositoryIdSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_REPOSITORYIDSEQ___OUT_CH_)
#define _IR_REPOSITORYIDSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export RepositoryIdSeq_out
  {
  public:
    RepositoryIdSeq_out (RepositoryIdSeq *&);
    RepositoryIdSeq_out (RepositoryIdSeq_var &);
    RepositoryIdSeq_out (const RepositoryIdSeq_out &);
    RepositoryIdSeq_out &operator= (const RepositoryIdSeq_out &);
    RepositoryIdSeq_out &operator= (RepositoryIdSeq *);
    operator RepositoryIdSeq *&();
    RepositoryIdSeq *&ptr (void);
    RepositoryIdSeq *operator-> (void);
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  private:
    RepositoryIdSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const RepositoryIdSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_RepositoryIdSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:368

  typedef char * VersionSpec;
  typedef CORBA::String_var VersionSpec_var;
  typedef CORBA::String_out VersionSpec_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_VersionSpec;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class ComponentDef;

#if !defined (_IR_COMPONENTDEF___PTR_CH_)
#define _IR_COMPONENTDEF___PTR_CH_

  typedef ComponentDef *ComponentDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTDEF___VAR_CH_)
#define _IR_COMPONENTDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ComponentDef_var : private TAO_Base_var
  {
  public:
    ComponentDef_var (void); // default constructor
    ComponentDef_var (ComponentDef_ptr p) : ptr_ (p) {}
    ComponentDef_var (const ComponentDef_var &); // copy constructor
    ~ComponentDef_var (void); // destructor

    ComponentDef_var &operator= (ComponentDef_ptr);
    ComponentDef_var &operator= (const ComponentDef_var &);
    ComponentDef_ptr operator-> (void) const;

    operator const ComponentDef_ptr &() const;
    operator ComponentDef_ptr &();
    // in, inout, out, _retn
    ComponentDef_ptr in (void) const;
    ComponentDef_ptr &inout (void);
    ComponentDef_ptr &out (void);
    ComponentDef_ptr _retn (void);
    ComponentDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ComponentDef_ptr tao_duplicate (ComponentDef_ptr);
    static void tao_release (ComponentDef_ptr);
    static ComponentDef_ptr tao_nil (void);
    static ComponentDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ComponentDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ComponentDef_var (const TAO_Base_var & rhs);
    ComponentDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTDEF___OUT_CH_)
#define _IR_COMPONENTDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ComponentDef_out
  {
  public:
    ComponentDef_out (ComponentDef_ptr &);
    ComponentDef_out (ComponentDef_var &);
    ComponentDef_out (const ComponentDef_out &);
    ComponentDef_out &operator= (const ComponentDef_out &);
    ComponentDef_out &operator= (const ComponentDef_var &);
    ComponentDef_out &operator= (ComponentDef_ptr);
    operator ComponentDef_ptr &();
    ComponentDef_ptr &ptr (void);
    ComponentDef_ptr operator-> (void);

  private:
    ComponentDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ComponentDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static ComponentDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (ComponentDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ComponentDef* *get_buffer (CORBA::Boolean orphan = 0);
    const ComponentDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_COMPONENTDEFSEQ_CH_)
#define _IR_COMPONENTDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class ComponentDefSeq;
  class ComponentDefSeq_var;

  // *************************************************************
  // IR::ComponentDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export ComponentDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<ComponentDef,ComponentDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ComponentDefSeq (void);
    ComponentDefSeq (CORBA::ULong max);
    ComponentDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        ComponentDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    ComponentDefSeq (const ComponentDefSeq &);
    ~ComponentDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef ComponentDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTDEFSEQ___VAR_CH_)
#define _IR_COMPONENTDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::ComponentDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export ComponentDefSeq_var
  {
  public:
    ComponentDefSeq_var (void);
    ComponentDefSeq_var (ComponentDefSeq *);
    ComponentDefSeq_var (const ComponentDefSeq_var &);
    ~ComponentDefSeq_var (void);

    ComponentDefSeq_var &operator= (ComponentDefSeq *);
    ComponentDefSeq_var &operator= (const ComponentDefSeq_var &);
    ComponentDefSeq *operator-> (void);
    const ComponentDefSeq *operator-> (void) const;

    operator const ComponentDefSeq &() const;
    operator ComponentDefSeq &();
    operator ComponentDefSeq &() const;

    // Variable-size base types only.
    operator ComponentDefSeq *&();

    TAO_Object_Manager<ComponentDef, ComponentDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const ComponentDefSeq &in (void) const;
    ComponentDefSeq &inout (void);
    ComponentDefSeq *&out (void);
    ComponentDefSeq *_retn (void);
    ComponentDefSeq *ptr (void) const;

  private:
    ComponentDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTDEFSEQ___OUT_CH_)
#define _IR_COMPONENTDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export ComponentDefSeq_out
  {
  public:
    ComponentDefSeq_out (ComponentDefSeq *&);
    ComponentDefSeq_out (ComponentDefSeq_var &);
    ComponentDefSeq_out (const ComponentDefSeq_out &);
    ComponentDefSeq_out &operator= (const ComponentDefSeq_out &);
    ComponentDefSeq_out &operator= (ComponentDefSeq *);
    operator ComponentDefSeq *&();
    ComponentDefSeq *&ptr (void);
    ComponentDefSeq *operator-> (void);
    TAO_Object_Manager<ComponentDef, ComponentDef_var> operator[] (CORBA::ULong index);

  private:
    ComponentDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ComponentDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ComponentDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class ProvidesDef;

#if !defined (_IR_PROVIDESDEF___PTR_CH_)
#define _IR_PROVIDESDEF___PTR_CH_

  typedef ProvidesDef *ProvidesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDEF___VAR_CH_)
#define _IR_PROVIDESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ProvidesDef_var : private TAO_Base_var
  {
  public:
    ProvidesDef_var (void); // default constructor
    ProvidesDef_var (ProvidesDef_ptr p) : ptr_ (p) {}
    ProvidesDef_var (const ProvidesDef_var &); // copy constructor
    ~ProvidesDef_var (void); // destructor

    ProvidesDef_var &operator= (ProvidesDef_ptr);
    ProvidesDef_var &operator= (const ProvidesDef_var &);
    ProvidesDef_ptr operator-> (void) const;

    operator const ProvidesDef_ptr &() const;
    operator ProvidesDef_ptr &();
    // in, inout, out, _retn
    ProvidesDef_ptr in (void) const;
    ProvidesDef_ptr &inout (void);
    ProvidesDef_ptr &out (void);
    ProvidesDef_ptr _retn (void);
    ProvidesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ProvidesDef_ptr tao_duplicate (ProvidesDef_ptr);
    static void tao_release (ProvidesDef_ptr);
    static ProvidesDef_ptr tao_nil (void);
    static ProvidesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ProvidesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ProvidesDef_var (const TAO_Base_var & rhs);
    ProvidesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDEF___OUT_CH_)
#define _IR_PROVIDESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ProvidesDef_out
  {
  public:
    ProvidesDef_out (ProvidesDef_ptr &);
    ProvidesDef_out (ProvidesDef_var &);
    ProvidesDef_out (const ProvidesDef_out &);
    ProvidesDef_out &operator= (const ProvidesDef_out &);
    ProvidesDef_out &operator= (const ProvidesDef_var &);
    ProvidesDef_out &operator= (ProvidesDef_ptr);
    operator ProvidesDef_ptr &();
    ProvidesDef_ptr &ptr (void);
    ProvidesDef_ptr operator-> (void);

  private:
    ProvidesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ProvidesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static ProvidesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (ProvidesDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ProvidesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const ProvidesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_PROVIDESDEFSEQ_CH_)
#define _IR_PROVIDESDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class ProvidesDefSeq;
  class ProvidesDefSeq_var;

  // *************************************************************
  // IR::ProvidesDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export ProvidesDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<ProvidesDef,ProvidesDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ProvidesDefSeq (void);
    ProvidesDefSeq (CORBA::ULong max);
    ProvidesDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        ProvidesDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    ProvidesDefSeq (const ProvidesDefSeq &);
    ~ProvidesDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef ProvidesDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDEFSEQ___VAR_CH_)
#define _IR_PROVIDESDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::ProvidesDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export ProvidesDefSeq_var
  {
  public:
    ProvidesDefSeq_var (void);
    ProvidesDefSeq_var (ProvidesDefSeq *);
    ProvidesDefSeq_var (const ProvidesDefSeq_var &);
    ~ProvidesDefSeq_var (void);

    ProvidesDefSeq_var &operator= (ProvidesDefSeq *);
    ProvidesDefSeq_var &operator= (const ProvidesDefSeq_var &);
    ProvidesDefSeq *operator-> (void);
    const ProvidesDefSeq *operator-> (void) const;

    operator const ProvidesDefSeq &() const;
    operator ProvidesDefSeq &();
    operator ProvidesDefSeq &() const;

    // Variable-size base types only.
    operator ProvidesDefSeq *&();

    TAO_Object_Manager<ProvidesDef, ProvidesDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const ProvidesDefSeq &in (void) const;
    ProvidesDefSeq &inout (void);
    ProvidesDefSeq *&out (void);
    ProvidesDefSeq *_retn (void);
    ProvidesDefSeq *ptr (void) const;

  private:
    ProvidesDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDEFSEQ___OUT_CH_)
#define _IR_PROVIDESDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export ProvidesDefSeq_out
  {
  public:
    ProvidesDefSeq_out (ProvidesDefSeq *&);
    ProvidesDefSeq_out (ProvidesDefSeq_var &);
    ProvidesDefSeq_out (const ProvidesDefSeq_out &);
    ProvidesDefSeq_out &operator= (const ProvidesDefSeq_out &);
    ProvidesDefSeq_out &operator= (ProvidesDefSeq *);
    operator ProvidesDefSeq *&();
    ProvidesDefSeq *&ptr (void);
    ProvidesDefSeq *operator-> (void);
    TAO_Object_Manager<ProvidesDef, ProvidesDef_var> operator[] (CORBA::ULong index);

  private:
    ProvidesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ProvidesDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ProvidesDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class UsesDef;

#if !defined (_IR_USESDEF___PTR_CH_)
#define _IR_USESDEF___PTR_CH_

  typedef UsesDef *UsesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_USESDEF___VAR_CH_)
#define _IR_USESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export UsesDef_var : private TAO_Base_var
  {
  public:
    UsesDef_var (void); // default constructor
    UsesDef_var (UsesDef_ptr p) : ptr_ (p) {}
    UsesDef_var (const UsesDef_var &); // copy constructor
    ~UsesDef_var (void); // destructor

    UsesDef_var &operator= (UsesDef_ptr);
    UsesDef_var &operator= (const UsesDef_var &);
    UsesDef_ptr operator-> (void) const;

    operator const UsesDef_ptr &() const;
    operator UsesDef_ptr &();
    // in, inout, out, _retn
    UsesDef_ptr in (void) const;
    UsesDef_ptr &inout (void);
    UsesDef_ptr &out (void);
    UsesDef_ptr _retn (void);
    UsesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static UsesDef_ptr tao_duplicate (UsesDef_ptr);
    static void tao_release (UsesDef_ptr);
    static UsesDef_ptr tao_nil (void);
    static UsesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    UsesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    UsesDef_var (const TAO_Base_var & rhs);
    UsesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_USESDEF___OUT_CH_)
#define _IR_USESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export UsesDef_out
  {
  public:
    UsesDef_out (UsesDef_ptr &);
    UsesDef_out (UsesDef_var &);
    UsesDef_out (const UsesDef_out &);
    UsesDef_out &operator= (const UsesDef_out &);
    UsesDef_out &operator= (const UsesDef_var &);
    UsesDef_out &operator= (UsesDef_ptr);
    operator UsesDef_ptr &();
    UsesDef_ptr &ptr (void);
    UsesDef_ptr operator-> (void);

  private:
    UsesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        UsesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static UsesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (UsesDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    UsesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const UsesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_USESDEFSEQ_CH_)
#define _IR_USESDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class UsesDefSeq;
  class UsesDefSeq_var;

  // *************************************************************
  // IR::UsesDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export UsesDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<UsesDef,UsesDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    UsesDefSeq (void);
    UsesDefSeq (CORBA::ULong max);
    UsesDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        UsesDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    UsesDefSeq (const UsesDefSeq &);
    ~UsesDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef UsesDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_USESDEFSEQ___VAR_CH_)
#define _IR_USESDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::UsesDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export UsesDefSeq_var
  {
  public:
    UsesDefSeq_var (void);
    UsesDefSeq_var (UsesDefSeq *);
    UsesDefSeq_var (const UsesDefSeq_var &);
    ~UsesDefSeq_var (void);

    UsesDefSeq_var &operator= (UsesDefSeq *);
    UsesDefSeq_var &operator= (const UsesDefSeq_var &);
    UsesDefSeq *operator-> (void);
    const UsesDefSeq *operator-> (void) const;

    operator const UsesDefSeq &() const;
    operator UsesDefSeq &();
    operator UsesDefSeq &() const;

    // Variable-size base types only.
    operator UsesDefSeq *&();

    TAO_Object_Manager<UsesDef, UsesDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const UsesDefSeq &in (void) const;
    UsesDefSeq &inout (void);
    UsesDefSeq *&out (void);
    UsesDefSeq *_retn (void);
    UsesDefSeq *ptr (void) const;

  private:
    UsesDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_USESDEFSEQ___OUT_CH_)
#define _IR_USESDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export UsesDefSeq_out
  {
  public:
    UsesDefSeq_out (UsesDefSeq *&);
    UsesDefSeq_out (UsesDefSeq_var &);
    UsesDefSeq_out (const UsesDefSeq_out &);
    UsesDefSeq_out &operator= (const UsesDefSeq_out &);
    UsesDefSeq_out &operator= (UsesDefSeq *);
    operator UsesDefSeq *&();
    UsesDefSeq *&ptr (void);
    UsesDefSeq *operator-> (void);
    TAO_Object_Manager<UsesDef, UsesDef_var> operator[] (CORBA::ULong index);

  private:
    UsesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const UsesDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_UsesDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class HomeDef;

#if !defined (_IR_HOMEDEF___PTR_CH_)
#define _IR_HOMEDEF___PTR_CH_

  typedef HomeDef *HomeDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_HOMEDEF___VAR_CH_)
#define _IR_HOMEDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export HomeDef_var : private TAO_Base_var
  {
  public:
    HomeDef_var (void); // default constructor
    HomeDef_var (HomeDef_ptr p) : ptr_ (p) {}
    HomeDef_var (const HomeDef_var &); // copy constructor
    ~HomeDef_var (void); // destructor

    HomeDef_var &operator= (HomeDef_ptr);
    HomeDef_var &operator= (const HomeDef_var &);
    HomeDef_ptr operator-> (void) const;

    operator const HomeDef_ptr &() const;
    operator HomeDef_ptr &();
    // in, inout, out, _retn
    HomeDef_ptr in (void) const;
    HomeDef_ptr &inout (void);
    HomeDef_ptr &out (void);
    HomeDef_ptr _retn (void);
    HomeDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static HomeDef_ptr tao_duplicate (HomeDef_ptr);
    static void tao_release (HomeDef_ptr);
    static HomeDef_ptr tao_nil (void);
    static HomeDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    HomeDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    HomeDef_var (const TAO_Base_var & rhs);
    HomeDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_HOMEDEF___OUT_CH_)
#define _IR_HOMEDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export HomeDef_out
  {
  public:
    HomeDef_out (HomeDef_ptr &);
    HomeDef_out (HomeDef_var &);
    HomeDef_out (const HomeDef_out &);
    HomeDef_out &operator= (const HomeDef_out &);
    HomeDef_out &operator= (const HomeDef_var &);
    HomeDef_out &operator= (HomeDef_ptr);
    operator HomeDef_ptr &();
    HomeDef_ptr &ptr (void);
    HomeDef_ptr operator-> (void);

  private:
    HomeDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        HomeDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static HomeDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (HomeDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    HomeDef* *get_buffer (CORBA::Boolean orphan = 0);
    const HomeDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_HOMEDEFSEQ_CH_)
#define _IR_HOMEDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class HomeDefSeq;
  class HomeDefSeq_var;

  // *************************************************************
  // IR::HomeDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export HomeDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<HomeDef,HomeDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    HomeDefSeq (void);
    HomeDefSeq (CORBA::ULong max);
    HomeDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        HomeDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    HomeDefSeq (const HomeDefSeq &);
    ~HomeDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef HomeDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_HOMEDEFSEQ___VAR_CH_)
#define _IR_HOMEDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::HomeDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export HomeDefSeq_var
  {
  public:
    HomeDefSeq_var (void);
    HomeDefSeq_var (HomeDefSeq *);
    HomeDefSeq_var (const HomeDefSeq_var &);
    ~HomeDefSeq_var (void);

    HomeDefSeq_var &operator= (HomeDefSeq *);
    HomeDefSeq_var &operator= (const HomeDefSeq_var &);
    HomeDefSeq *operator-> (void);
    const HomeDefSeq *operator-> (void) const;

    operator const HomeDefSeq &() const;
    operator HomeDefSeq &();
    operator HomeDefSeq &() const;

    // Variable-size base types only.
    operator HomeDefSeq *&();

    TAO_Object_Manager<HomeDef, HomeDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const HomeDefSeq &in (void) const;
    HomeDefSeq &inout (void);
    HomeDefSeq *&out (void);
    HomeDefSeq *_retn (void);
    HomeDefSeq *ptr (void) const;

  private:
    HomeDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_HOMEDEFSEQ___OUT_CH_)
#define _IR_HOMEDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export HomeDefSeq_out
  {
  public:
    HomeDefSeq_out (HomeDefSeq *&);
    HomeDefSeq_out (HomeDefSeq_var &);
    HomeDefSeq_out (const HomeDefSeq_out &);
    HomeDefSeq_out &operator= (const HomeDefSeq_out &);
    HomeDefSeq_out &operator= (HomeDefSeq *);
    operator HomeDefSeq *&();
    HomeDefSeq *&ptr (void);
    HomeDefSeq *operator-> (void);
    TAO_Object_Manager<HomeDef, HomeDef_var> operator[] (CORBA::ULong index);

  private:
    HomeDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const HomeDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_HomeDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class EventDef;

#if !defined (_IR_EVENTDEF___PTR_CH_)
#define _IR_EVENTDEF___PTR_CH_

  typedef EventDef *EventDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_EVENTDEF___VAR_CH_)
#define _IR_EVENTDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export EventDef_var : private TAO_Base_var
  {
  public:
    EventDef_var (void); // default constructor
    EventDef_var (EventDef_ptr p) : ptr_ (p) {}
    EventDef_var (const EventDef_var &); // copy constructor
    ~EventDef_var (void); // destructor

    EventDef_var &operator= (EventDef_ptr);
    EventDef_var &operator= (const EventDef_var &);
    EventDef_ptr operator-> (void) const;

    operator const EventDef_ptr &() const;
    operator EventDef_ptr &();
    // in, inout, out, _retn
    EventDef_ptr in (void) const;
    EventDef_ptr &inout (void);
    EventDef_ptr &out (void);
    EventDef_ptr _retn (void);
    EventDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static EventDef_ptr tao_duplicate (EventDef_ptr);
    static void tao_release (EventDef_ptr);
    static EventDef_ptr tao_nil (void);
    static EventDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    EventDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    EventDef_var (const TAO_Base_var & rhs);
    EventDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_EVENTDEF___OUT_CH_)
#define _IR_EVENTDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export EventDef_out
  {
  public:
    EventDef_out (EventDef_ptr &);
    EventDef_out (EventDef_var &);
    EventDef_out (const EventDef_out &);
    EventDef_out &operator= (const EventDef_out &);
    EventDef_out &operator= (const EventDef_var &);
    EventDef_out &operator= (EventDef_ptr);
    operator EventDef_ptr &();
    EventDef_ptr &ptr (void);
    EventDef_ptr operator-> (void);

  private:
    EventDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class EmitsDef;

#if !defined (_IR_EMITSDEF___PTR_CH_)
#define _IR_EMITSDEF___PTR_CH_

  typedef EmitsDef *EmitsDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_EMITSDEF___VAR_CH_)
#define _IR_EMITSDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export EmitsDef_var : private TAO_Base_var
  {
  public:
    EmitsDef_var (void); // default constructor
    EmitsDef_var (EmitsDef_ptr p) : ptr_ (p) {}
    EmitsDef_var (const EmitsDef_var &); // copy constructor
    ~EmitsDef_var (void); // destructor

    EmitsDef_var &operator= (EmitsDef_ptr);
    EmitsDef_var &operator= (const EmitsDef_var &);
    EmitsDef_ptr operator-> (void) const;

    operator const EmitsDef_ptr &() const;
    operator EmitsDef_ptr &();
    // in, inout, out, _retn
    EmitsDef_ptr in (void) const;
    EmitsDef_ptr &inout (void);
    EmitsDef_ptr &out (void);
    EmitsDef_ptr _retn (void);
    EmitsDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static EmitsDef_ptr tao_duplicate (EmitsDef_ptr);
    static void tao_release (EmitsDef_ptr);
    static EmitsDef_ptr tao_nil (void);
    static EmitsDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    EmitsDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    EmitsDef_var (const TAO_Base_var & rhs);
    EmitsDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_EMITSDEF___OUT_CH_)
#define _IR_EMITSDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export EmitsDef_out
  {
  public:
    EmitsDef_out (EmitsDef_ptr &);
    EmitsDef_out (EmitsDef_var &);
    EmitsDef_out (const EmitsDef_out &);
    EmitsDef_out &operator= (const EmitsDef_out &);
    EmitsDef_out &operator= (const EmitsDef_var &);
    EmitsDef_out &operator= (EmitsDef_ptr);
    operator EmitsDef_ptr &();
    EmitsDef_ptr &ptr (void);
    EmitsDef_ptr operator-> (void);

  private:
    EmitsDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        EmitsDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static EmitsDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (EmitsDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    EmitsDef* *get_buffer (CORBA::Boolean orphan = 0);
    const EmitsDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_EMITSDEFSEQ_CH_)
#define _IR_EMITSDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class EmitsDefSeq;
  class EmitsDefSeq_var;

  // *************************************************************
  // IR::EmitsDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export EmitsDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<EmitsDef,EmitsDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    EmitsDefSeq (void);
    EmitsDefSeq (CORBA::ULong max);
    EmitsDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        EmitsDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    EmitsDefSeq (const EmitsDefSeq &);
    ~EmitsDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef EmitsDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_EMITSDEFSEQ___VAR_CH_)
#define _IR_EMITSDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::EmitsDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export EmitsDefSeq_var
  {
  public:
    EmitsDefSeq_var (void);
    EmitsDefSeq_var (EmitsDefSeq *);
    EmitsDefSeq_var (const EmitsDefSeq_var &);
    ~EmitsDefSeq_var (void);

    EmitsDefSeq_var &operator= (EmitsDefSeq *);
    EmitsDefSeq_var &operator= (const EmitsDefSeq_var &);
    EmitsDefSeq *operator-> (void);
    const EmitsDefSeq *operator-> (void) const;

    operator const EmitsDefSeq &() const;
    operator EmitsDefSeq &();
    operator EmitsDefSeq &() const;

    // Variable-size base types only.
    operator EmitsDefSeq *&();

    TAO_Object_Manager<EmitsDef, EmitsDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const EmitsDefSeq &in (void) const;
    EmitsDefSeq &inout (void);
    EmitsDefSeq *&out (void);
    EmitsDefSeq *_retn (void);
    EmitsDefSeq *ptr (void) const;

  private:
    EmitsDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_EMITSDEFSEQ___OUT_CH_)
#define _IR_EMITSDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export EmitsDefSeq_out
  {
  public:
    EmitsDefSeq_out (EmitsDefSeq *&);
    EmitsDefSeq_out (EmitsDefSeq_var &);
    EmitsDefSeq_out (const EmitsDefSeq_out &);
    EmitsDefSeq_out &operator= (const EmitsDefSeq_out &);
    EmitsDefSeq_out &operator= (EmitsDefSeq *);
    operator EmitsDefSeq *&();
    EmitsDefSeq *&ptr (void);
    EmitsDefSeq *operator-> (void);
    TAO_Object_Manager<EmitsDef, EmitsDef_var> operator[] (CORBA::ULong index);

  private:
    EmitsDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const EmitsDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_EmitsDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class PublishesDef;

#if !defined (_IR_PUBLISHESDEF___PTR_CH_)
#define _IR_PUBLISHESDEF___PTR_CH_

  typedef PublishesDef *PublishesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_PUBLISHESDEF___VAR_CH_)
#define _IR_PUBLISHESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export PublishesDef_var : private TAO_Base_var
  {
  public:
    PublishesDef_var (void); // default constructor
    PublishesDef_var (PublishesDef_ptr p) : ptr_ (p) {}
    PublishesDef_var (const PublishesDef_var &); // copy constructor
    ~PublishesDef_var (void); // destructor

    PublishesDef_var &operator= (PublishesDef_ptr);
    PublishesDef_var &operator= (const PublishesDef_var &);
    PublishesDef_ptr operator-> (void) const;

    operator const PublishesDef_ptr &() const;
    operator PublishesDef_ptr &();
    // in, inout, out, _retn
    PublishesDef_ptr in (void) const;
    PublishesDef_ptr &inout (void);
    PublishesDef_ptr &out (void);
    PublishesDef_ptr _retn (void);
    PublishesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PublishesDef_ptr tao_duplicate (PublishesDef_ptr);
    static void tao_release (PublishesDef_ptr);
    static PublishesDef_ptr tao_nil (void);
    static PublishesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PublishesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PublishesDef_var (const TAO_Base_var & rhs);
    PublishesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_PUBLISHESDEF___OUT_CH_)
#define _IR_PUBLISHESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export PublishesDef_out
  {
  public:
    PublishesDef_out (PublishesDef_ptr &);
    PublishesDef_out (PublishesDef_var &);
    PublishesDef_out (const PublishesDef_out &);
    PublishesDef_out &operator= (const PublishesDef_out &);
    PublishesDef_out &operator= (const PublishesDef_var &);
    PublishesDef_out &operator= (PublishesDef_ptr);
    operator PublishesDef_ptr &();
    PublishesDef_ptr &ptr (void);
    PublishesDef_ptr operator-> (void);

  private:
    PublishesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        PublishesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static PublishesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (PublishesDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    PublishesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const PublishesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_PUBLISHESDEFSEQ_CH_)
#define _IR_PUBLISHESDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class PublishesDefSeq;
  class PublishesDefSeq_var;

  // *************************************************************
  // IR::PublishesDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export PublishesDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<PublishesDef,PublishesDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    PublishesDefSeq (void);
    PublishesDefSeq (CORBA::ULong max);
    PublishesDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        PublishesDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    PublishesDefSeq (const PublishesDefSeq &);
    ~PublishesDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef PublishesDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_PUBLISHESDEFSEQ___VAR_CH_)
#define _IR_PUBLISHESDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::PublishesDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export PublishesDefSeq_var
  {
  public:
    PublishesDefSeq_var (void);
    PublishesDefSeq_var (PublishesDefSeq *);
    PublishesDefSeq_var (const PublishesDefSeq_var &);
    ~PublishesDefSeq_var (void);

    PublishesDefSeq_var &operator= (PublishesDefSeq *);
    PublishesDefSeq_var &operator= (const PublishesDefSeq_var &);
    PublishesDefSeq *operator-> (void);
    const PublishesDefSeq *operator-> (void) const;

    operator const PublishesDefSeq &() const;
    operator PublishesDefSeq &();
    operator PublishesDefSeq &() const;

    // Variable-size base types only.
    operator PublishesDefSeq *&();

    TAO_Object_Manager<PublishesDef, PublishesDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const PublishesDefSeq &in (void) const;
    PublishesDefSeq &inout (void);
    PublishesDefSeq *&out (void);
    PublishesDefSeq *_retn (void);
    PublishesDefSeq *ptr (void) const;

  private:
    PublishesDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_PUBLISHESDEFSEQ___OUT_CH_)
#define _IR_PUBLISHESDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export PublishesDefSeq_out
  {
  public:
    PublishesDefSeq_out (PublishesDefSeq *&);
    PublishesDefSeq_out (PublishesDefSeq_var &);
    PublishesDefSeq_out (const PublishesDefSeq_out &);
    PublishesDefSeq_out &operator= (const PublishesDefSeq_out &);
    PublishesDefSeq_out &operator= (PublishesDefSeq *);
    operator PublishesDefSeq *&();
    PublishesDefSeq *&ptr (void);
    PublishesDefSeq *operator-> (void);
    TAO_Object_Manager<PublishesDef, PublishesDef_var> operator[] (CORBA::ULong index);

  private:
    PublishesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const PublishesDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_PublishesDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class ConsumesDef;

#if !defined (_IR_CONSUMESDEF___PTR_CH_)
#define _IR_CONSUMESDEF___PTR_CH_

  typedef ConsumesDef *ConsumesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_CONSUMESDEF___VAR_CH_)
#define _IR_CONSUMESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ConsumesDef_var : private TAO_Base_var
  {
  public:
    ConsumesDef_var (void); // default constructor
    ConsumesDef_var (ConsumesDef_ptr p) : ptr_ (p) {}
    ConsumesDef_var (const ConsumesDef_var &); // copy constructor
    ~ConsumesDef_var (void); // destructor

    ConsumesDef_var &operator= (ConsumesDef_ptr);
    ConsumesDef_var &operator= (const ConsumesDef_var &);
    ConsumesDef_ptr operator-> (void) const;

    operator const ConsumesDef_ptr &() const;
    operator ConsumesDef_ptr &();
    // in, inout, out, _retn
    ConsumesDef_ptr in (void) const;
    ConsumesDef_ptr &inout (void);
    ConsumesDef_ptr &out (void);
    ConsumesDef_ptr _retn (void);
    ConsumesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ConsumesDef_ptr tao_duplicate (ConsumesDef_ptr);
    static void tao_release (ConsumesDef_ptr);
    static ConsumesDef_ptr tao_nil (void);
    static ConsumesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ConsumesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ConsumesDef_var (const TAO_Base_var & rhs);
    ConsumesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_CONSUMESDEF___OUT_CH_)
#define _IR_CONSUMESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ConsumesDef_out
  {
  public:
    ConsumesDef_out (ConsumesDef_ptr &);
    ConsumesDef_out (ConsumesDef_var &);
    ConsumesDef_out (const ConsumesDef_out &);
    ConsumesDef_out &operator= (const ConsumesDef_out &);
    ConsumesDef_out &operator= (const ConsumesDef_var &);
    ConsumesDef_out &operator= (ConsumesDef_ptr);
    operator ConsumesDef_ptr &();
    ConsumesDef_ptr &ptr (void);
    ConsumesDef_ptr operator-> (void);

  private:
    ConsumesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ConsumesDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static ConsumesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (ConsumesDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ConsumesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const ConsumesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_CONSUMESDEFSEQ_CH_)
#define _IR_CONSUMESDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class ConsumesDefSeq;
  class ConsumesDefSeq_var;

  // *************************************************************
  // IR::ConsumesDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export ConsumesDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<ConsumesDef,ConsumesDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ConsumesDefSeq (void);
    ConsumesDefSeq (CORBA::ULong max);
    ConsumesDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        ConsumesDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    ConsumesDefSeq (const ConsumesDefSeq &);
    ~ConsumesDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef ConsumesDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_CONSUMESDEFSEQ___VAR_CH_)
#define _IR_CONSUMESDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::ConsumesDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export ConsumesDefSeq_var
  {
  public:
    ConsumesDefSeq_var (void);
    ConsumesDefSeq_var (ConsumesDefSeq *);
    ConsumesDefSeq_var (const ConsumesDefSeq_var &);
    ~ConsumesDefSeq_var (void);

    ConsumesDefSeq_var &operator= (ConsumesDefSeq *);
    ConsumesDefSeq_var &operator= (const ConsumesDefSeq_var &);
    ConsumesDefSeq *operator-> (void);
    const ConsumesDefSeq *operator-> (void) const;

    operator const ConsumesDefSeq &() const;
    operator ConsumesDefSeq &();
    operator ConsumesDefSeq &() const;

    // Variable-size base types only.
    operator ConsumesDefSeq *&();

    TAO_Object_Manager<ConsumesDef, ConsumesDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const ConsumesDefSeq &in (void) const;
    ConsumesDefSeq &inout (void);
    ConsumesDefSeq *&out (void);
    ConsumesDefSeq *_retn (void);
    ConsumesDefSeq *ptr (void) const;

  private:
    ConsumesDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_CONSUMESDEFSEQ___OUT_CH_)
#define _IR_CONSUMESDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export ConsumesDefSeq_out
  {
  public:
    ConsumesDefSeq_out (ConsumesDefSeq *&);
    ConsumesDefSeq_out (ConsumesDefSeq_var &);
    ConsumesDefSeq_out (const ConsumesDefSeq_out &);
    ConsumesDefSeq_out &operator= (const ConsumesDefSeq_out &);
    ConsumesDefSeq_out &operator= (ConsumesDefSeq *);
    operator ConsumesDefSeq *&();
    ConsumesDefSeq *&ptr (void);
    ConsumesDefSeq *operator-> (void);
    TAO_Object_Manager<ConsumesDef, ConsumesDef_var> operator[] (CORBA::ULong index);

  private:
    ConsumesDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ConsumesDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ConsumesDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class FactoryDef;

#if !defined (_IR_FACTORYDEF___PTR_CH_)
#define _IR_FACTORYDEF___PTR_CH_

  typedef FactoryDef *FactoryDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_FACTORYDEF___VAR_CH_)
#define _IR_FACTORYDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export FactoryDef_var : private TAO_Base_var
  {
  public:
    FactoryDef_var (void); // default constructor
    FactoryDef_var (FactoryDef_ptr p) : ptr_ (p) {}
    FactoryDef_var (const FactoryDef_var &); // copy constructor
    ~FactoryDef_var (void); // destructor

    FactoryDef_var &operator= (FactoryDef_ptr);
    FactoryDef_var &operator= (const FactoryDef_var &);
    FactoryDef_ptr operator-> (void) const;

    operator const FactoryDef_ptr &() const;
    operator FactoryDef_ptr &();
    // in, inout, out, _retn
    FactoryDef_ptr in (void) const;
    FactoryDef_ptr &inout (void);
    FactoryDef_ptr &out (void);
    FactoryDef_ptr _retn (void);
    FactoryDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static FactoryDef_ptr tao_duplicate (FactoryDef_ptr);
    static void tao_release (FactoryDef_ptr);
    static FactoryDef_ptr tao_nil (void);
    static FactoryDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    FactoryDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FactoryDef_var (const TAO_Base_var & rhs);
    FactoryDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_FACTORYDEF___OUT_CH_)
#define _IR_FACTORYDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export FactoryDef_out
  {
  public:
    FactoryDef_out (FactoryDef_ptr &);
    FactoryDef_out (FactoryDef_var &);
    FactoryDef_out (const FactoryDef_out &);
    FactoryDef_out &operator= (const FactoryDef_out &);
    FactoryDef_out &operator= (const FactoryDef_var &);
    FactoryDef_out &operator= (FactoryDef_ptr);
    operator FactoryDef_ptr &();
    FactoryDef_ptr &ptr (void);
    FactoryDef_ptr operator-> (void);

  private:
    FactoryDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        FactoryDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static FactoryDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (FactoryDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    FactoryDef* *get_buffer (CORBA::Boolean orphan = 0);
    const FactoryDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_FACTORYDEFSEQ_CH_)
#define _IR_FACTORYDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class FactoryDefSeq;
  class FactoryDefSeq_var;

  // *************************************************************
  // IR::FactoryDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export FactoryDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<FactoryDef,FactoryDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    FactoryDefSeq (void);
    FactoryDefSeq (CORBA::ULong max);
    FactoryDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        FactoryDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    FactoryDefSeq (const FactoryDefSeq &);
    ~FactoryDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef FactoryDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_FACTORYDEFSEQ___VAR_CH_)
#define _IR_FACTORYDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::FactoryDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export FactoryDefSeq_var
  {
  public:
    FactoryDefSeq_var (void);
    FactoryDefSeq_var (FactoryDefSeq *);
    FactoryDefSeq_var (const FactoryDefSeq_var &);
    ~FactoryDefSeq_var (void);

    FactoryDefSeq_var &operator= (FactoryDefSeq *);
    FactoryDefSeq_var &operator= (const FactoryDefSeq_var &);
    FactoryDefSeq *operator-> (void);
    const FactoryDefSeq *operator-> (void) const;

    operator const FactoryDefSeq &() const;
    operator FactoryDefSeq &();
    operator FactoryDefSeq &() const;

    // Variable-size base types only.
    operator FactoryDefSeq *&();

    TAO_Object_Manager<FactoryDef, FactoryDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const FactoryDefSeq &in (void) const;
    FactoryDefSeq &inout (void);
    FactoryDefSeq *&out (void);
    FactoryDefSeq *_retn (void);
    FactoryDefSeq *ptr (void) const;

  private:
    FactoryDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_FACTORYDEFSEQ___OUT_CH_)
#define _IR_FACTORYDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export FactoryDefSeq_out
  {
  public:
    FactoryDefSeq_out (FactoryDefSeq *&);
    FactoryDefSeq_out (FactoryDefSeq_var &);
    FactoryDefSeq_out (const FactoryDefSeq_out &);
    FactoryDefSeq_out &operator= (const FactoryDefSeq_out &);
    FactoryDefSeq_out &operator= (FactoryDefSeq *);
    operator FactoryDefSeq *&();
    FactoryDefSeq *&ptr (void);
    FactoryDefSeq *operator-> (void);
    TAO_Object_Manager<FactoryDef, FactoryDef_var> operator[] (CORBA::ULong index);

  private:
    FactoryDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const FactoryDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_FactoryDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class FinderDef;

#if !defined (_IR_FINDERDEF___PTR_CH_)
#define _IR_FINDERDEF___PTR_CH_

  typedef FinderDef *FinderDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_FINDERDEF___VAR_CH_)
#define _IR_FINDERDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export FinderDef_var : private TAO_Base_var
  {
  public:
    FinderDef_var (void); // default constructor
    FinderDef_var (FinderDef_ptr p) : ptr_ (p) {}
    FinderDef_var (const FinderDef_var &); // copy constructor
    ~FinderDef_var (void); // destructor

    FinderDef_var &operator= (FinderDef_ptr);
    FinderDef_var &operator= (const FinderDef_var &);
    FinderDef_ptr operator-> (void) const;

    operator const FinderDef_ptr &() const;
    operator FinderDef_ptr &();
    // in, inout, out, _retn
    FinderDef_ptr in (void) const;
    FinderDef_ptr &inout (void);
    FinderDef_ptr &out (void);
    FinderDef_ptr _retn (void);
    FinderDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static FinderDef_ptr tao_duplicate (FinderDef_ptr);
    static void tao_release (FinderDef_ptr);
    static FinderDef_ptr tao_nil (void);
    static FinderDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    FinderDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FinderDef_var (const TAO_Base_var & rhs);
    FinderDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_FINDERDEF___OUT_CH_)
#define _IR_FINDERDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export FinderDef_out
  {
  public:
    FinderDef_out (FinderDef_ptr &);
    FinderDef_out (FinderDef_var &);
    FinderDef_out (const FinderDef_out &);
    FinderDef_out &operator= (const FinderDef_out &);
    FinderDef_out &operator= (const FinderDef_var &);
    FinderDef_out &operator= (FinderDef_ptr);
    operator FinderDef_ptr &();
    FinderDef_ptr &ptr (void);
    FinderDef_ptr operator-> (void);

  private:
    FinderDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_obj_sequence_ch.cpp:62

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        FinderDef* *value,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (
        const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs
      );
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &operator= (
        const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs
      );
    virtual ~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void);

    // = Accessors.
    TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var> operator[] (CORBA::ULong index) const;

    // = Static operations.
    static FinderDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (FinderDef **buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    FinderDef* *get_buffer (CORBA::Boolean orphan = 0);
    const FinderDef* *get_buffer (void) const;
    virtual void _shrink_buffer (
        CORBA::ULong nl,
        CORBA::ULong ol
      );

    virtual void _downcast (
        void* target,
        CORBA::Object *src
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );
    virtual CORBA::Object* _upcast (void *src) const;
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_FINDERDEFSEQ_CH_)
#define _IR_FINDERDEFSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class FinderDefSeq;
  class FinderDefSeq_var;

  // *************************************************************
  // IR::FinderDefSeq
  // *************************************************************

  class TAO_IFR_Client_Export FinderDefSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<FinderDef,FinderDef_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    FinderDefSeq (void);
    FinderDefSeq (CORBA::ULong max);
    FinderDefSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        FinderDef_ptr *buffer,
        CORBA::Boolean release = 0
      );
    FinderDefSeq (const FinderDefSeq &);
    ~FinderDefSeq (void);

    static void _tao_any_destructor (void*);

    typedef FinderDefSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_FINDERDEFSEQ___VAR_CH_)
#define _IR_FINDERDEFSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::FinderDefSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export FinderDefSeq_var
  {
  public:
    FinderDefSeq_var (void);
    FinderDefSeq_var (FinderDefSeq *);
    FinderDefSeq_var (const FinderDefSeq_var &);
    ~FinderDefSeq_var (void);

    FinderDefSeq_var &operator= (FinderDefSeq *);
    FinderDefSeq_var &operator= (const FinderDefSeq_var &);
    FinderDefSeq *operator-> (void);
    const FinderDefSeq *operator-> (void) const;

    operator const FinderDefSeq &() const;
    operator FinderDefSeq &();
    operator FinderDefSeq &() const;

    // Variable-size base types only.
    operator FinderDefSeq *&();

    TAO_Object_Manager<FinderDef, FinderDef_var> operator[] (CORBA::ULong index);

    // in, inout, out, _retn
    const FinderDefSeq &in (void) const;
    FinderDefSeq &inout (void);
    FinderDefSeq *&out (void);
    FinderDefSeq *_retn (void);
    FinderDefSeq *ptr (void) const;

  private:
    FinderDefSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_FINDERDEFSEQ___OUT_CH_)
#define _IR_FINDERDEFSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export FinderDefSeq_out
  {
  public:
    FinderDefSeq_out (FinderDefSeq *&);
    FinderDefSeq_out (FinderDefSeq_var &);
    FinderDefSeq_out (const FinderDefSeq_out &);
    FinderDefSeq_out &operator= (const FinderDefSeq_out &);
    FinderDefSeq_out &operator= (FinderDefSeq *);
    operator FinderDefSeq *&();
    FinderDefSeq *&ptr (void);
    FinderDefSeq *operator-> (void);
    TAO_Object_Manager<FinderDef, FinderDef_var> operator[] (CORBA::ULong index);

  private:
    FinderDefSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const FinderDefSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_FinderDefSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface_fwd/interface_fwd_ch.cpp:53

  class PrimaryKeyDef;

#if !defined (_IR_PRIMARYKEYDEF___PTR_CH_)
#define _IR_PRIMARYKEYDEF___PTR_CH_

  typedef PrimaryKeyDef *PrimaryKeyDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_PRIMARYKEYDEF___VAR_CH_)
#define _IR_PRIMARYKEYDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export PrimaryKeyDef_var : private TAO_Base_var
  {
  public:
    PrimaryKeyDef_var (void); // default constructor
    PrimaryKeyDef_var (PrimaryKeyDef_ptr p) : ptr_ (p) {}
    PrimaryKeyDef_var (const PrimaryKeyDef_var &); // copy constructor
    ~PrimaryKeyDef_var (void); // destructor

    PrimaryKeyDef_var &operator= (PrimaryKeyDef_ptr);
    PrimaryKeyDef_var &operator= (const PrimaryKeyDef_var &);
    PrimaryKeyDef_ptr operator-> (void) const;

    operator const PrimaryKeyDef_ptr &() const;
    operator PrimaryKeyDef_ptr &();
    // in, inout, out, _retn
    PrimaryKeyDef_ptr in (void) const;
    PrimaryKeyDef_ptr &inout (void);
    PrimaryKeyDef_ptr &out (void);
    PrimaryKeyDef_ptr _retn (void);
    PrimaryKeyDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PrimaryKeyDef_ptr tao_duplicate (PrimaryKeyDef_ptr);
    static void tao_release (PrimaryKeyDef_ptr);
    static PrimaryKeyDef_ptr tao_nil (void);
    static PrimaryKeyDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PrimaryKeyDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PrimaryKeyDef_var (const TAO_Base_var & rhs);
    PrimaryKeyDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_PRIMARYKEYDEF___OUT_CH_)
#define _IR_PRIMARYKEYDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export PrimaryKeyDef_out
  {
  public:
    PrimaryKeyDef_out (PrimaryKeyDef_ptr &);
    PrimaryKeyDef_out (PrimaryKeyDef_var &);
    PrimaryKeyDef_out (const PrimaryKeyDef_out &);
    PrimaryKeyDef_out &operator= (const PrimaryKeyDef_out &);
    PrimaryKeyDef_out &operator= (const PrimaryKeyDef_var &);
    PrimaryKeyDef_out &operator= (PrimaryKeyDef_ptr);
    operator PrimaryKeyDef_ptr &();
    PrimaryKeyDef_ptr &ptr (void);
    PrimaryKeyDef_ptr operator-> (void);

  private:
    PrimaryKeyDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_COMPONENTREPOSITORY___PTR_CH_)
#define _IR_COMPONENTREPOSITORY___PTR_CH_

  class ComponentRepository;
  typedef ComponentRepository *ComponentRepository_ptr;

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTREPOSITORY___VAR_CH_)
#define _IR_COMPONENTREPOSITORY___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ComponentRepository_var : private TAO_Base_var
  {
  public:
    ComponentRepository_var (void); // default constructor
    ComponentRepository_var (ComponentRepository_ptr p) : ptr_ (p) {}
    ComponentRepository_var (const ComponentRepository_var &); // copy constructor
    ~ComponentRepository_var (void); // destructor

    ComponentRepository_var &operator= (ComponentRepository_ptr);
    ComponentRepository_var &operator= (const ComponentRepository_var &);
    ComponentRepository_ptr operator-> (void) const;

    operator const ComponentRepository_ptr &() const;
    operator ComponentRepository_ptr &();
    // in, inout, out, _retn
    ComponentRepository_ptr in (void) const;
    ComponentRepository_ptr &inout (void);
    ComponentRepository_ptr &out (void);
    ComponentRepository_ptr _retn (void);
    ComponentRepository_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ComponentRepository_ptr tao_duplicate (ComponentRepository_ptr);
    static void tao_release (ComponentRepository_ptr);
    static ComponentRepository_ptr tao_nil (void);
    static ComponentRepository_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ComponentRepository_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ComponentRepository_var (const TAO_Base_var & rhs);
    ComponentRepository_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTREPOSITORY___OUT_CH_)
#define _IR_COMPONENTREPOSITORY___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ComponentRepository_out
  {
  public:
    ComponentRepository_out (ComponentRepository_ptr &);
    ComponentRepository_out (ComponentRepository_var &);
    ComponentRepository_out (const ComponentRepository_out &);
    ComponentRepository_out &operator= (const ComponentRepository_out &);
    ComponentRepository_out &operator= (const ComponentRepository_var &);
    ComponentRepository_out &operator= (ComponentRepository_ptr);
    operator ComponentRepository_ptr &();
    ComponentRepository_ptr &ptr (void);
    ComponentRepository_ptr operator-> (void);

  private:
    ComponentRepository_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_COMPONENTREPOSITORY_CH_)
#define _IR_COMPONENTREPOSITORY_CH_

  class _TAO_ComponentRepository_Proxy_Impl;
  class _TAO_ComponentRepository_Remote_Proxy_Impl;
  class _TAO_ComponentRepository_Proxy_Broker;
  class _TAO_ComponentRepository_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export ComponentRepository
    : public virtual CORBA::Repository
  {
  public:
    typedef ComponentRepository_ptr _ptr_type;
    typedef ComponentRepository_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static ComponentRepository_ptr _duplicate (ComponentRepository_ptr obj);

    static ComponentRepository_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ComponentRepository_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ComponentRepository_ptr _nil (void)
      {
        return (ComponentRepository_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ComponentDef_ptr create_component (
        const char * id,
        const char * name,
        const char * version,
        IR::ComponentDef_ptr base_component,
        const CORBA::InterfaceDefSeq & supports_interfaces
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::HomeDef_ptr create_home (
        const char * id,
        const char * name,
        const char * version,
        IR::HomeDef_ptr base_home,
        IR::ComponentDef_ptr managed_component,
        CORBA::ValueDef_ptr primary_key
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_ComponentRepository_Proxy_Broker *the_TAO_ComponentRepository_Proxy_Broker_;

  protected:
    ComponentRepository (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_ComponentRepository_setup_collocation (int collocated);

    ComponentRepository (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~ComponentRepository (void);

    friend class _TAO_ComponentRepository_Remote_Proxy_Impl;
    friend class _TAO_ComponentRepository_ThruPOA_Proxy_Impl;
    friend class _TAO_ComponentRepository_Direct_Proxy_Impl;

  private:
    ComponentRepository (const ComponentRepository &);
    void operator= (const ComponentRepository &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ComponentRepository_Proxy_Impl
    : public virtual CORBA::_TAO_Repository_Proxy_Impl
  {
  public:
    virtual ~_TAO_ComponentRepository_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ComponentDef_ptr create_component (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::ComponentDef_ptr base_component,
        const CORBA::InterfaceDefSeq & supports_interfaces
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::HomeDef_ptr create_home (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::HomeDef_ptr base_home,
        IR::ComponentDef_ptr managed_component,
        CORBA::ValueDef_ptr primary_key
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_ComponentRepository_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_ComponentRepository_Remote_Proxy_Impl
    : public virtual _TAO_ComponentRepository_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_Repository_Remote_Proxy_Impl
  {
  public:
    _TAO_ComponentRepository_Remote_Proxy_Impl (void);

    virtual ~_TAO_ComponentRepository_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ComponentDef_ptr create_component (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::ComponentDef_ptr base_component,
        const CORBA::InterfaceDefSeq & supports_interfaces
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::HomeDef_ptr create_home (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        IR::HomeDef_ptr base_home,
        IR::ComponentDef_ptr managed_component,
        CORBA::ValueDef_ptr primary_key
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ComponentRepository_Proxy_Broker
  {
  public:
    virtual ~_TAO_ComponentRepository_Proxy_Broker (void);
    virtual _TAO_ComponentRepository_Proxy_Impl &select_proxy (
        ComponentRepository *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_ComponentRepository_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_ComponentRepository_Remote_Proxy_Broker
    : public virtual _TAO_ComponentRepository_Proxy_Broker
  {
  public:
    _TAO_ComponentRepository_Remote_Proxy_Broker (void);

    virtual ~_TAO_ComponentRepository_Remote_Proxy_Broker (void);

    virtual _TAO_ComponentRepository_Proxy_Impl &select_proxy (
        ComponentRepository *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_ComponentRepository_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_ComponentRepository_Remote_Proxy_Broker *the_TAO_ComponentRepository_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ComponentRepository;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_PROVIDESDEF___PTR_CH_)
#define _IR_PROVIDESDEF___PTR_CH_

  class ProvidesDef;
  typedef ProvidesDef *ProvidesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDEF___VAR_CH_)
#define _IR_PROVIDESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ProvidesDef_var : private TAO_Base_var
  {
  public:
    ProvidesDef_var (void); // default constructor
    ProvidesDef_var (ProvidesDef_ptr p) : ptr_ (p) {}
    ProvidesDef_var (const ProvidesDef_var &); // copy constructor
    ~ProvidesDef_var (void); // destructor

    ProvidesDef_var &operator= (ProvidesDef_ptr);
    ProvidesDef_var &operator= (const ProvidesDef_var &);
    ProvidesDef_ptr operator-> (void) const;

    operator const ProvidesDef_ptr &() const;
    operator ProvidesDef_ptr &();
    // in, inout, out, _retn
    ProvidesDef_ptr in (void) const;
    ProvidesDef_ptr &inout (void);
    ProvidesDef_ptr &out (void);
    ProvidesDef_ptr _retn (void);
    ProvidesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ProvidesDef_ptr tao_duplicate (ProvidesDef_ptr);
    static void tao_release (ProvidesDef_ptr);
    static ProvidesDef_ptr tao_nil (void);
    static ProvidesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ProvidesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ProvidesDef_var (const TAO_Base_var & rhs);
    ProvidesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDEF___OUT_CH_)
#define _IR_PROVIDESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ProvidesDef_out
  {
  public:
    ProvidesDef_out (ProvidesDef_ptr &);
    ProvidesDef_out (ProvidesDef_var &);
    ProvidesDef_out (const ProvidesDef_out &);
    ProvidesDef_out &operator= (const ProvidesDef_out &);
    ProvidesDef_out &operator= (const ProvidesDef_var &);
    ProvidesDef_out &operator= (ProvidesDef_ptr);
    operator ProvidesDef_ptr &();
    ProvidesDef_ptr &ptr (void);
    ProvidesDef_ptr operator-> (void);

  private:
    ProvidesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_PROVIDESDEF_CH_)
#define _IR_PROVIDESDEF_CH_

  class _TAO_ProvidesDef_Proxy_Impl;
  class _TAO_ProvidesDef_Remote_Proxy_Impl;
  class _TAO_ProvidesDef_Proxy_Broker;
  class _TAO_ProvidesDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export ProvidesDef
    : public virtual CORBA::Contained
  {
  public:
    typedef ProvidesDef_ptr _ptr_type;
    typedef ProvidesDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static ProvidesDef_ptr _duplicate (ProvidesDef_ptr obj);

    static ProvidesDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ProvidesDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ProvidesDef_ptr _nil (void)
      {
        return (ProvidesDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::CORBA::InterfaceDef_ptr interface_type (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_ProvidesDef_Proxy_Broker *the_TAO_ProvidesDef_Proxy_Broker_;

  protected:
    ProvidesDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_ProvidesDef_setup_collocation (int collocated);

    ProvidesDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~ProvidesDef (void);

    friend class _TAO_ProvidesDef_Remote_Proxy_Impl;
    friend class _TAO_ProvidesDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ProvidesDef_Direct_Proxy_Impl;

  private:
    ProvidesDef (const ProvidesDef &);
    void operator= (const ProvidesDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ProvidesDef_Proxy_Impl
    : public virtual CORBA::_TAO_Contained_Proxy_Impl
  {
  public:
    virtual ~_TAO_ProvidesDef_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::CORBA::InterfaceDef_ptr interface_type (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_ProvidesDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_ProvidesDef_Remote_Proxy_Impl
    : public virtual _TAO_ProvidesDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_Contained_Remote_Proxy_Impl
  {
  public:
    _TAO_ProvidesDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_ProvidesDef_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::CORBA::InterfaceDef_ptr interface_type (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ProvidesDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_ProvidesDef_Proxy_Broker (void);
    virtual _TAO_ProvidesDef_Proxy_Impl &select_proxy (
        ProvidesDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_ProvidesDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_ProvidesDef_Remote_Proxy_Broker
    : public virtual _TAO_ProvidesDef_Proxy_Broker
  {
  public:
    _TAO_ProvidesDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_ProvidesDef_Remote_Proxy_Broker (void);

    virtual _TAO_ProvidesDef_Proxy_Impl &select_proxy (
        ProvidesDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_ProvidesDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_ProvidesDef_Remote_Proxy_Broker *the_TAO_ProvidesDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ProvidesDef;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:49

  class ProvidesDescription_var;

  struct TAO_IFR_Client_Export ProvidesDescription
  {
    typedef ProvidesDescription_var _var_type;

    static void _tao_any_destructor (void *);
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::InterfaceDef_var interface_type;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:71

  class TAO_IFR_Client_Export ProvidesDescription_var
  {
  public:
    ProvidesDescription_var (void);
    ProvidesDescription_var (ProvidesDescription *);
    ProvidesDescription_var (const ProvidesDescription_var &);
    ~ProvidesDescription_var (void);

    ProvidesDescription_var &operator= (ProvidesDescription *);
    ProvidesDescription_var &operator= (const ProvidesDescription_var &);
    ProvidesDescription *operator-> (void);
    const ProvidesDescription *operator-> (void) const;

    operator const ProvidesDescription &() const;
    operator ProvidesDescription &();
    operator ProvidesDescription &() const;

    // Variable-size types only.
    operator ProvidesDescription *&();

    // in, inout, out, _retn
    const ProvidesDescription &in (void) const;
    ProvidesDescription &inout (void);
    ProvidesDescription *&out (void);
    ProvidesDescription *_retn (void);
    ProvidesDescription *ptr (void) const;

  private:
    ProvidesDescription *ptr_;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:445

  class TAO_IFR_Client_Export ProvidesDescription_out
  {
  public:
    ProvidesDescription_out (ProvidesDescription *&);
    ProvidesDescription_out (ProvidesDescription_var &);
    ProvidesDescription_out (const ProvidesDescription_out &);
    ProvidesDescription_out &operator= (const ProvidesDescription_out &);
    ProvidesDescription_out &operator= (ProvidesDescription *);
    operator ProvidesDescription *&();
    ProvidesDescription *&ptr (void);
    ProvidesDescription *operator-> (void);

  private:
    ProvidesDescription *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ProvidesDescription_var &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ProvidesDescription;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_USESDEF___PTR_CH_)
#define _IR_USESDEF___PTR_CH_

  class UsesDef;
  typedef UsesDef *UsesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_USESDEF___VAR_CH_)
#define _IR_USESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export UsesDef_var : private TAO_Base_var
  {
  public:
    UsesDef_var (void); // default constructor
    UsesDef_var (UsesDef_ptr p) : ptr_ (p) {}
    UsesDef_var (const UsesDef_var &); // copy constructor
    ~UsesDef_var (void); // destructor

    UsesDef_var &operator= (UsesDef_ptr);
    UsesDef_var &operator= (const UsesDef_var &);
    UsesDef_ptr operator-> (void) const;

    operator const UsesDef_ptr &() const;
    operator UsesDef_ptr &();
    // in, inout, out, _retn
    UsesDef_ptr in (void) const;
    UsesDef_ptr &inout (void);
    UsesDef_ptr &out (void);
    UsesDef_ptr _retn (void);
    UsesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static UsesDef_ptr tao_duplicate (UsesDef_ptr);
    static void tao_release (UsesDef_ptr);
    static UsesDef_ptr tao_nil (void);
    static UsesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    UsesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    UsesDef_var (const TAO_Base_var & rhs);
    UsesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_USESDEF___OUT_CH_)
#define _IR_USESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export UsesDef_out
  {
  public:
    UsesDef_out (UsesDef_ptr &);
    UsesDef_out (UsesDef_var &);
    UsesDef_out (const UsesDef_out &);
    UsesDef_out &operator= (const UsesDef_out &);
    UsesDef_out &operator= (const UsesDef_var &);
    UsesDef_out &operator= (UsesDef_ptr);
    operator UsesDef_ptr &();
    UsesDef_ptr &ptr (void);
    UsesDef_ptr operator-> (void);

  private:
    UsesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_USESDEF_CH_)
#define _IR_USESDEF_CH_

  class _TAO_UsesDef_Proxy_Impl;
  class _TAO_UsesDef_Remote_Proxy_Impl;
  class _TAO_UsesDef_Proxy_Broker;
  class _TAO_UsesDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export UsesDef
    : public virtual CORBA::Contained
  {
  public:
    typedef UsesDef_ptr _ptr_type;
    typedef UsesDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static UsesDef_ptr _duplicate (UsesDef_ptr obj);

    static UsesDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static UsesDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static UsesDef_ptr _nil (void)
      {
        return (UsesDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::CORBA::InterfaceDef_ptr interface_type (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual CORBA::Boolean is_multiple (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_UsesDef_Proxy_Broker *the_TAO_UsesDef_Proxy_Broker_;

  protected:
    UsesDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_UsesDef_setup_collocation (int collocated);

    UsesDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~UsesDef (void);

    friend class _TAO_UsesDef_Remote_Proxy_Impl;
    friend class _TAO_UsesDef_ThruPOA_Proxy_Impl;
    friend class _TAO_UsesDef_Direct_Proxy_Impl;

  private:
    UsesDef (const UsesDef &);
    void operator= (const UsesDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_UsesDef_Proxy_Impl
    : public virtual CORBA::_TAO_Contained_Proxy_Impl
  {
  public:
    virtual ~_TAO_UsesDef_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::CORBA::InterfaceDef_ptr interface_type (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual CORBA::Boolean is_multiple (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_UsesDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_UsesDef_Remote_Proxy_Impl
    : public virtual _TAO_UsesDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_Contained_Remote_Proxy_Impl
  {
  public:
    _TAO_UsesDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_UsesDef_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::CORBA::InterfaceDef_ptr interface_type (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual CORBA::Boolean is_multiple (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_UsesDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_UsesDef_Proxy_Broker (void);
    virtual _TAO_UsesDef_Proxy_Impl &select_proxy (
        UsesDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_UsesDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_UsesDef_Remote_Proxy_Broker
    : public virtual _TAO_UsesDef_Proxy_Broker
  {
  public:
    _TAO_UsesDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_UsesDef_Remote_Proxy_Broker (void);

    virtual _TAO_UsesDef_Proxy_Impl &select_proxy (
        UsesDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_UsesDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_UsesDef_Remote_Proxy_Broker *the_TAO_UsesDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_UsesDef;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:49

  class UsesDescription_var;

  struct TAO_IFR_Client_Export UsesDescription
  {
    typedef UsesDescription_var _var_type;

    static void _tao_any_destructor (void *);
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::InterfaceDef_var interface_type;
    CORBA::Boolean is_multiple;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:71

  class TAO_IFR_Client_Export UsesDescription_var
  {
  public:
    UsesDescription_var (void);
    UsesDescription_var (UsesDescription *);
    UsesDescription_var (const UsesDescription_var &);
    ~UsesDescription_var (void);

    UsesDescription_var &operator= (UsesDescription *);
    UsesDescription_var &operator= (const UsesDescription_var &);
    UsesDescription *operator-> (void);
    const UsesDescription *operator-> (void) const;

    operator const UsesDescription &() const;
    operator UsesDescription &();
    operator UsesDescription &() const;

    // Variable-size types only.
    operator UsesDescription *&();

    // in, inout, out, _retn
    const UsesDescription &in (void) const;
    UsesDescription &inout (void);
    UsesDescription *&out (void);
    UsesDescription *_retn (void);
    UsesDescription *ptr (void) const;

  private:
    UsesDescription *ptr_;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:445

  class TAO_IFR_Client_Export UsesDescription_out
  {
  public:
    UsesDescription_out (UsesDescription *&);
    UsesDescription_out (UsesDescription_var &);
    UsesDescription_out (const UsesDescription_out &);
    UsesDescription_out &operator= (const UsesDescription_out &);
    UsesDescription_out &operator= (UsesDescription *);
    operator UsesDescription *&();
    UsesDescription *&ptr (void);
    UsesDescription *operator-> (void);

  private:
    UsesDescription *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const UsesDescription_var &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_UsesDescription;

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_sequence_ch.cpp:65

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void);
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        ProvidesDescription *data,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (
        const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs
      );
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &operator= (
        const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs
      );
    virtual ~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void);

    // = Accessors.
    ProvidesDescription &operator[] (CORBA::ULong i);
    const ProvidesDescription &operator[] (CORBA::ULong i) const;

    // = Static operations.
    static ProvidesDescription *allocbuf (CORBA::ULong size);
    static void freebuf (ProvidesDescription *buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    ProvidesDescription *get_buffer (CORBA::Boolean orphan = 0);
    const ProvidesDescription *get_buffer (void) const;
    void replace (
        CORBA::ULong max,
        CORBA::ULong length,
        ProvidesDescription *data,
        CORBA::Boolean release
      );
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_PROVIDESDESCSEQ_CH_)
#define _IR_PROVIDESDESCSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class ProvidesDescSeq;
  class ProvidesDescSeq_var;

  // *************************************************************
  // IR::ProvidesDescSeq
  // *************************************************************

  class TAO_IFR_Client_Export ProvidesDescSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ProvidesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ProvidesDescSeq (void);
    ProvidesDescSeq (CORBA::ULong max);
    ProvidesDescSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        ProvidesDescription *buffer,
        CORBA::Boolean release = 0
      );
    ProvidesDescSeq (const ProvidesDescSeq &);
    ~ProvidesDescSeq (void);

    static void _tao_any_destructor (void*);

    typedef ProvidesDescSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDESCSEQ___VAR_CH_)
#define _IR_PROVIDESDESCSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::ProvidesDescSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export ProvidesDescSeq_var
  {
  public:
    ProvidesDescSeq_var (void);
    ProvidesDescSeq_var (ProvidesDescSeq *);
    ProvidesDescSeq_var (const ProvidesDescSeq_var &);
    ~ProvidesDescSeq_var (void);

    ProvidesDescSeq_var &operator= (ProvidesDescSeq *);
    ProvidesDescSeq_var &operator= (const ProvidesDescSeq_var &);
    ProvidesDescSeq *operator-> (void);
    const ProvidesDescSeq *operator-> (void) const;

    operator const ProvidesDescSeq &() const;
    operator ProvidesDescSeq &();
    operator ProvidesDescSeq &() const;

    // Variable-size base types only.
    operator ProvidesDescSeq *&();

    ProvidesDescription & operator[] (CORBA::ULong index);
    const ProvidesDescription & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const ProvidesDescSeq &in (void) const;
    ProvidesDescSeq &inout (void);
    ProvidesDescSeq *&out (void);
    ProvidesDescSeq *_retn (void);
    ProvidesDescSeq *ptr (void) const;

  private:
    ProvidesDescSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_PROVIDESDESCSEQ___OUT_CH_)
#define _IR_PROVIDESDESCSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export ProvidesDescSeq_out
  {
  public:
    ProvidesDescSeq_out (ProvidesDescSeq *&);
    ProvidesDescSeq_out (ProvidesDescSeq_var &);
    ProvidesDescSeq_out (const ProvidesDescSeq_out &);
    ProvidesDescSeq_out &operator= (const ProvidesDescSeq_out &);
    ProvidesDescSeq_out &operator= (ProvidesDescSeq *);
    operator ProvidesDescSeq *&();
    ProvidesDescSeq *&ptr (void);
    ProvidesDescSeq *operator-> (void);
    ProvidesDescription & operator[] (CORBA::ULong index);

  private:
    ProvidesDescSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ProvidesDescSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ProvidesDescSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/gen_unbounded_sequence_ch.cpp:65

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CH_

  class TAO_IFR_Client_Export _TAO_Unbounded_Sequence_IR_UsesDescSeq
    : public TAO_Unbounded_Base_Sequence
  {
  public:
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (void);
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (
        CORBA::ULong maximum,
        CORBA::ULong length,
        UsesDescription *data,
        CORBA::Boolean release = 0
      );
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (
        const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs
      );
    _TAO_Unbounded_Sequence_IR_UsesDescSeq &operator= (
        const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs
      );
    virtual ~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void);

    // = Accessors.
    UsesDescription &operator[] (CORBA::ULong i);
    const UsesDescription &operator[] (CORBA::ULong i) const;

    // = Static operations.
    static UsesDescription *allocbuf (CORBA::ULong size);
    static void freebuf (UsesDescription *buffer);

    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    UsesDescription *get_buffer (CORBA::Boolean orphan = 0);
    const UsesDescription *get_buffer (void) const;
    void replace (
        CORBA::ULong max,
        CORBA::ULong length,
        UsesDescription *data,
        CORBA::Boolean release
      );
  };

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_USESDESCSEQ_CH_)
#define _IR_USESDESCSEQ_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:371

  class UsesDescSeq;
  class UsesDescSeq_var;

  // *************************************************************
  // IR::UsesDescSeq
  // *************************************************************

  class TAO_IFR_Client_Export UsesDescSeq : public

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:51

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<UsesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    UsesDescSeq (void);
    UsesDescSeq (CORBA::ULong max);
    UsesDescSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        UsesDescription *buffer,
        CORBA::Boolean release = 0
      );
    UsesDescSeq (const UsesDescSeq &);
    ~UsesDescSeq (void);

    static void _tao_any_destructor (void*);

    typedef UsesDescSeq_var _var_type;
  };

#endif /* end #if !defined */

#if !defined (_IR_USESDESCSEQ___VAR_CH_)
#define _IR_USESDESCSEQ___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:549

  // *************************************************************
  // class IR::UsesDescSeq_var
  // *************************************************************

  class TAO_IFR_Client_Export UsesDescSeq_var
  {
  public:
    UsesDescSeq_var (void);
    UsesDescSeq_var (UsesDescSeq *);
    UsesDescSeq_var (const UsesDescSeq_var &);
    ~UsesDescSeq_var (void);

    UsesDescSeq_var &operator= (UsesDescSeq *);
    UsesDescSeq_var &operator= (const UsesDescSeq_var &);
    UsesDescSeq *operator-> (void);
    const UsesDescSeq *operator-> (void) const;

    operator const UsesDescSeq &() const;
    operator UsesDescSeq &();
    operator UsesDescSeq &() const;

    // Variable-size base types only.
    operator UsesDescSeq *&();

    UsesDescription & operator[] (CORBA::ULong index);
    const UsesDescription & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const UsesDescSeq &in (void) const;
    UsesDescSeq &inout (void);
    UsesDescSeq *&out (void);
    UsesDescSeq *_retn (void);
    UsesDescSeq *ptr (void) const;

  private:
    UsesDescSeq *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_IR_USESDESCSEQ___OUT_CH_)
#define _IR_USESDESCSEQ___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:753

  class TAO_IFR_Client_Export UsesDescSeq_out
  {
  public:
    UsesDescSeq_out (UsesDescSeq *&);
    UsesDescSeq_out (UsesDescSeq_var &);
    UsesDescSeq_out (const UsesDescSeq_out &);
    UsesDescSeq_out &operator= (const UsesDescSeq_out &);
    UsesDescSeq_out &operator= (UsesDescSeq *);
    operator UsesDescSeq *&();
    UsesDescSeq *&ptr (void);
    UsesDescSeq *operator-> (void);
    UsesDescription & operator[] (CORBA::ULong index);

  private:
    UsesDescSeq *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const UsesDescSeq_var &);
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_UsesDescSeq;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_EVENTDEF___PTR_CH_)
#define _IR_EVENTDEF___PTR_CH_

  class EventDef;
  typedef EventDef *EventDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_EVENTDEF___VAR_CH_)
#define _IR_EVENTDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export EventDef_var : private TAO_Base_var
  {
  public:
    EventDef_var (void); // default constructor
    EventDef_var (EventDef_ptr p) : ptr_ (p) {}
    EventDef_var (const EventDef_var &); // copy constructor
    ~EventDef_var (void); // destructor

    EventDef_var &operator= (EventDef_ptr);
    EventDef_var &operator= (const EventDef_var &);
    EventDef_ptr operator-> (void) const;

    operator const EventDef_ptr &() const;
    operator EventDef_ptr &();
    // in, inout, out, _retn
    EventDef_ptr in (void) const;
    EventDef_ptr &inout (void);
    EventDef_ptr &out (void);
    EventDef_ptr _retn (void);
    EventDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static EventDef_ptr tao_duplicate (EventDef_ptr);
    static void tao_release (EventDef_ptr);
    static EventDef_ptr tao_nil (void);
    static EventDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    EventDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    EventDef_var (const TAO_Base_var & rhs);
    EventDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_EVENTDEF___OUT_CH_)
#define _IR_EVENTDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export EventDef_out
  {
  public:
    EventDef_out (EventDef_ptr &);
    EventDef_out (EventDef_var &);
    EventDef_out (const EventDef_out &);
    EventDef_out &operator= (const EventDef_out &);
    EventDef_out &operator= (const EventDef_var &);
    EventDef_out &operator= (EventDef_ptr);
    operator EventDef_ptr &();
    EventDef_ptr &ptr (void);
    EventDef_ptr operator-> (void);

  private:
    EventDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_EVENTDEF_CH_)
#define _IR_EVENTDEF_CH_

  class _TAO_EventDef_Proxy_Impl;
  class _TAO_EventDef_Remote_Proxy_Impl;
  class _TAO_EventDef_Proxy_Broker;
  class _TAO_EventDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export EventDef
    : public virtual CORBA::Contained
  {
  public:
    typedef EventDef_ptr _ptr_type;
    typedef EventDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static EventDef_ptr _duplicate (EventDef_ptr obj);

    static EventDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static EventDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static EventDef_ptr _nil (void)
      {
        return (EventDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual CORBA::Boolean is_a (
        const char * event_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::CORBA::ValueDef_ptr event (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_EventDef_Proxy_Broker *the_TAO_EventDef_Proxy_Broker_;

  protected:
    EventDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_EventDef_setup_collocation (int collocated);

    EventDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~EventDef (void);

    friend class _TAO_EventDef_Remote_Proxy_Impl;
    friend class _TAO_EventDef_ThruPOA_Proxy_Impl;
    friend class _TAO_EventDef_Direct_Proxy_Impl;

  private:
    EventDef (const EventDef &);
    void operator= (const EventDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_EventDef_Proxy_Impl
    : public virtual CORBA::_TAO_Contained_Proxy_Impl
  {
  public:
    virtual ~_TAO_EventDef_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual CORBA::Boolean is_a (
        CORBA::Object *_collocated_tao_target_,
        const char * event_id
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::CORBA::ValueDef_ptr event (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_EventDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_EventDef_Remote_Proxy_Impl
    : public virtual _TAO_EventDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_Contained_Remote_Proxy_Impl
  {
  public:
    _TAO_EventDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_EventDef_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual CORBA::Boolean is_a (
        CORBA::Object *_collocated_tao_target_,
        const char * event_id
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::CORBA::ValueDef_ptr event (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_EventDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_EventDef_Proxy_Broker (void);
    virtual _TAO_EventDef_Proxy_Impl &select_proxy (
        EventDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_EventDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_EventDef_Remote_Proxy_Broker
    : public virtual _TAO_EventDef_Proxy_Broker
  {
  public:
    _TAO_EventDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_EventDef_Remote_Proxy_Broker (void);

    virtual _TAO_EventDef_Proxy_Impl &select_proxy (
        EventDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_EventDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_EventDef_Remote_Proxy_Broker *the_TAO_EventDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_EventDef;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:49

  class EventDescription_var;

  struct TAO_IFR_Client_Export EventDescription
  {
    typedef EventDescription_var _var_type;

    static void _tao_any_destructor (void *);
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::ValueDef_var value;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:71

  class TAO_IFR_Client_Export EventDescription_var
  {
  public:
    EventDescription_var (void);
    EventDescription_var (EventDescription *);
    EventDescription_var (const EventDescription_var &);
    ~EventDescription_var (void);

    EventDescription_var &operator= (EventDescription *);
    EventDescription_var &operator= (const EventDescription_var &);
    EventDescription *operator-> (void);
    const EventDescription *operator-> (void) const;

    operator const EventDescription &() const;
    operator EventDescription &();
    operator EventDescription &() const;

    // Variable-size types only.
    operator EventDescription *&();

    // in, inout, out, _retn
    const EventDescription &in (void) const;
    EventDescription &inout (void);
    EventDescription *&out (void);
    EventDescription *_retn (void);
    EventDescription *ptr (void) const;

  private:
    EventDescription *ptr_;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:445

  class TAO_IFR_Client_Export EventDescription_out
  {
  public:
    EventDescription_out (EventDescription *&);
    EventDescription_out (EventDescription_var &);
    EventDescription_out (const EventDescription_out &);
    EventDescription_out &operator= (const EventDescription_out &);
    EventDescription_out &operator= (EventDescription *);
    operator EventDescription *&();
    EventDescription *&ptr (void);
    EventDescription *operator-> (void);

  private:
    EventDescription *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const EventDescription_var &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_EventDescription;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_EMITSDEF___PTR_CH_)
#define _IR_EMITSDEF___PTR_CH_

  class EmitsDef;
  typedef EmitsDef *EmitsDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_EMITSDEF___VAR_CH_)
#define _IR_EMITSDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export EmitsDef_var : private TAO_Base_var
  {
  public:
    EmitsDef_var (void); // default constructor
    EmitsDef_var (EmitsDef_ptr p) : ptr_ (p) {}
    EmitsDef_var (const EmitsDef_var &); // copy constructor
    ~EmitsDef_var (void); // destructor

    EmitsDef_var &operator= (EmitsDef_ptr);
    EmitsDef_var &operator= (const EmitsDef_var &);
    EmitsDef_ptr operator-> (void) const;

    operator const EmitsDef_ptr &() const;
    operator EmitsDef_ptr &();
    // in, inout, out, _retn
    EmitsDef_ptr in (void) const;
    EmitsDef_ptr &inout (void);
    EmitsDef_ptr &out (void);
    EmitsDef_ptr _retn (void);
    EmitsDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static EmitsDef_ptr tao_duplicate (EmitsDef_ptr);
    static void tao_release (EmitsDef_ptr);
    static EmitsDef_ptr tao_nil (void);
    static EmitsDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    EmitsDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    EmitsDef_var (const TAO_Base_var & rhs);
    EmitsDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_EMITSDEF___OUT_CH_)
#define _IR_EMITSDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export EmitsDef_out
  {
  public:
    EmitsDef_out (EmitsDef_ptr &);
    EmitsDef_out (EmitsDef_var &);
    EmitsDef_out (const EmitsDef_out &);
    EmitsDef_out &operator= (const EmitsDef_out &);
    EmitsDef_out &operator= (const EmitsDef_var &);
    EmitsDef_out &operator= (EmitsDef_ptr);
    operator EmitsDef_ptr &();
    EmitsDef_ptr &ptr (void);
    EmitsDef_ptr operator-> (void);

  private:
    EmitsDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_EMITSDEF_CH_)
#define _IR_EMITSDEF_CH_

  class _TAO_EmitsDef_Proxy_Impl;
  class _TAO_EmitsDef_Remote_Proxy_Impl;
  class _TAO_EmitsDef_Proxy_Broker;
  class _TAO_EmitsDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export EmitsDef
    : public virtual IR::EventDef
  {
  public:
    typedef EmitsDef_ptr _ptr_type;
    typedef EmitsDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static EmitsDef_ptr _duplicate (EmitsDef_ptr obj);

    static EmitsDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static EmitsDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static EmitsDef_ptr _nil (void)
      {
        return (EmitsDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_EmitsDef_Proxy_Broker *the_TAO_EmitsDef_Proxy_Broker_;

  protected:
    EmitsDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_EmitsDef_setup_collocation (int collocated);

    EmitsDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~EmitsDef (void);

    friend class _TAO_EmitsDef_Remote_Proxy_Impl;
    friend class _TAO_EmitsDef_ThruPOA_Proxy_Impl;
    friend class _TAO_EmitsDef_Direct_Proxy_Impl;

  private:
    EmitsDef (const EmitsDef &);
    void operator= (const EmitsDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_EmitsDef_Proxy_Impl
    : public virtual IR::_TAO_EventDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_EmitsDef_Proxy_Impl (void) {}

  protected:
    _TAO_EmitsDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_EmitsDef_Remote_Proxy_Impl
    : public virtual _TAO_EmitsDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual IR::_TAO_EventDef_Remote_Proxy_Impl
  {
  public:
    _TAO_EmitsDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_EmitsDef_Remote_Proxy_Impl (void) {}
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_EmitsDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_EmitsDef_Proxy_Broker (void);
    virtual _TAO_EmitsDef_Proxy_Impl &select_proxy (
        EmitsDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_EmitsDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_EmitsDef_Remote_Proxy_Broker
    : public virtual _TAO_EmitsDef_Proxy_Broker
  {
  public:
    _TAO_EmitsDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_EmitsDef_Remote_Proxy_Broker (void);

    virtual _TAO_EmitsDef_Proxy_Impl &select_proxy (
        EmitsDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_EmitsDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_EmitsDef_Remote_Proxy_Broker *the_TAO_EmitsDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_EmitsDef;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_PUBLISHESDEF___PTR_CH_)
#define _IR_PUBLISHESDEF___PTR_CH_

  class PublishesDef;
  typedef PublishesDef *PublishesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_PUBLISHESDEF___VAR_CH_)
#define _IR_PUBLISHESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export PublishesDef_var : private TAO_Base_var
  {
  public:
    PublishesDef_var (void); // default constructor
    PublishesDef_var (PublishesDef_ptr p) : ptr_ (p) {}
    PublishesDef_var (const PublishesDef_var &); // copy constructor
    ~PublishesDef_var (void); // destructor

    PublishesDef_var &operator= (PublishesDef_ptr);
    PublishesDef_var &operator= (const PublishesDef_var &);
    PublishesDef_ptr operator-> (void) const;

    operator const PublishesDef_ptr &() const;
    operator PublishesDef_ptr &();
    // in, inout, out, _retn
    PublishesDef_ptr in (void) const;
    PublishesDef_ptr &inout (void);
    PublishesDef_ptr &out (void);
    PublishesDef_ptr _retn (void);
    PublishesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PublishesDef_ptr tao_duplicate (PublishesDef_ptr);
    static void tao_release (PublishesDef_ptr);
    static PublishesDef_ptr tao_nil (void);
    static PublishesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PublishesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PublishesDef_var (const TAO_Base_var & rhs);
    PublishesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_PUBLISHESDEF___OUT_CH_)
#define _IR_PUBLISHESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export PublishesDef_out
  {
  public:
    PublishesDef_out (PublishesDef_ptr &);
    PublishesDef_out (PublishesDef_var &);
    PublishesDef_out (const PublishesDef_out &);
    PublishesDef_out &operator= (const PublishesDef_out &);
    PublishesDef_out &operator= (const PublishesDef_var &);
    PublishesDef_out &operator= (PublishesDef_ptr);
    operator PublishesDef_ptr &();
    PublishesDef_ptr &ptr (void);
    PublishesDef_ptr operator-> (void);

  private:
    PublishesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_PUBLISHESDEF_CH_)
#define _IR_PUBLISHESDEF_CH_

  class _TAO_PublishesDef_Proxy_Impl;
  class _TAO_PublishesDef_Remote_Proxy_Impl;
  class _TAO_PublishesDef_Proxy_Broker;
  class _TAO_PublishesDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export PublishesDef
    : public virtual IR::EventDef
  {
  public:
    typedef PublishesDef_ptr _ptr_type;
    typedef PublishesDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static PublishesDef_ptr _duplicate (PublishesDef_ptr obj);

    static PublishesDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static PublishesDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static PublishesDef_ptr _nil (void)
      {
        return (PublishesDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_PublishesDef_Proxy_Broker *the_TAO_PublishesDef_Proxy_Broker_;

  protected:
    PublishesDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_PublishesDef_setup_collocation (int collocated);

    PublishesDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~PublishesDef (void);

    friend class _TAO_PublishesDef_Remote_Proxy_Impl;
    friend class _TAO_PublishesDef_ThruPOA_Proxy_Impl;
    friend class _TAO_PublishesDef_Direct_Proxy_Impl;

  private:
    PublishesDef (const PublishesDef &);
    void operator= (const PublishesDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_PublishesDef_Proxy_Impl
    : public virtual IR::_TAO_EventDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_PublishesDef_Proxy_Impl (void) {}

  protected:
    _TAO_PublishesDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_PublishesDef_Remote_Proxy_Impl
    : public virtual _TAO_PublishesDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual IR::_TAO_EventDef_Remote_Proxy_Impl
  {
  public:
    _TAO_PublishesDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_PublishesDef_Remote_Proxy_Impl (void) {}
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_PublishesDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_PublishesDef_Proxy_Broker (void);
    virtual _TAO_PublishesDef_Proxy_Impl &select_proxy (
        PublishesDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_PublishesDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_PublishesDef_Remote_Proxy_Broker
    : public virtual _TAO_PublishesDef_Proxy_Broker
  {
  public:
    _TAO_PublishesDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_PublishesDef_Remote_Proxy_Broker (void);

    virtual _TAO_PublishesDef_Proxy_Impl &select_proxy (
        PublishesDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_PublishesDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_PublishesDef_Remote_Proxy_Broker *the_TAO_PublishesDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_PublishesDef;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_CONSUMESDEF___PTR_CH_)
#define _IR_CONSUMESDEF___PTR_CH_

  class ConsumesDef;
  typedef ConsumesDef *ConsumesDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_CONSUMESDEF___VAR_CH_)
#define _IR_CONSUMESDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ConsumesDef_var : private TAO_Base_var
  {
  public:
    ConsumesDef_var (void); // default constructor
    ConsumesDef_var (ConsumesDef_ptr p) : ptr_ (p) {}
    ConsumesDef_var (const ConsumesDef_var &); // copy constructor
    ~ConsumesDef_var (void); // destructor

    ConsumesDef_var &operator= (ConsumesDef_ptr);
    ConsumesDef_var &operator= (const ConsumesDef_var &);
    ConsumesDef_ptr operator-> (void) const;

    operator const ConsumesDef_ptr &() const;
    operator ConsumesDef_ptr &();
    // in, inout, out, _retn
    ConsumesDef_ptr in (void) const;
    ConsumesDef_ptr &inout (void);
    ConsumesDef_ptr &out (void);
    ConsumesDef_ptr _retn (void);
    ConsumesDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ConsumesDef_ptr tao_duplicate (ConsumesDef_ptr);
    static void tao_release (ConsumesDef_ptr);
    static ConsumesDef_ptr tao_nil (void);
    static ConsumesDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ConsumesDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ConsumesDef_var (const TAO_Base_var & rhs);
    ConsumesDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_CONSUMESDEF___OUT_CH_)
#define _IR_CONSUMESDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ConsumesDef_out
  {
  public:
    ConsumesDef_out (ConsumesDef_ptr &);
    ConsumesDef_out (ConsumesDef_var &);
    ConsumesDef_out (const ConsumesDef_out &);
    ConsumesDef_out &operator= (const ConsumesDef_out &);
    ConsumesDef_out &operator= (const ConsumesDef_var &);
    ConsumesDef_out &operator= (ConsumesDef_ptr);
    operator ConsumesDef_ptr &();
    ConsumesDef_ptr &ptr (void);
    ConsumesDef_ptr operator-> (void);

  private:
    ConsumesDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_CONSUMESDEF_CH_)
#define _IR_CONSUMESDEF_CH_

  class _TAO_ConsumesDef_Proxy_Impl;
  class _TAO_ConsumesDef_Remote_Proxy_Impl;
  class _TAO_ConsumesDef_Proxy_Broker;
  class _TAO_ConsumesDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export ConsumesDef
    : public virtual IR::EventDef
  {
  public:
    typedef ConsumesDef_ptr _ptr_type;
    typedef ConsumesDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static ConsumesDef_ptr _duplicate (ConsumesDef_ptr obj);

    static ConsumesDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ConsumesDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ConsumesDef_ptr _nil (void)
      {
        return (ConsumesDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_ConsumesDef_Proxy_Broker *the_TAO_ConsumesDef_Proxy_Broker_;

  protected:
    ConsumesDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_ConsumesDef_setup_collocation (int collocated);

    ConsumesDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~ConsumesDef (void);

    friend class _TAO_ConsumesDef_Remote_Proxy_Impl;
    friend class _TAO_ConsumesDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ConsumesDef_Direct_Proxy_Impl;

  private:
    ConsumesDef (const ConsumesDef &);
    void operator= (const ConsumesDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ConsumesDef_Proxy_Impl
    : public virtual IR::_TAO_EventDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_ConsumesDef_Proxy_Impl (void) {}

  protected:
    _TAO_ConsumesDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_ConsumesDef_Remote_Proxy_Impl
    : public virtual _TAO_ConsumesDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual IR::_TAO_EventDef_Remote_Proxy_Impl
  {
  public:
    _TAO_ConsumesDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_ConsumesDef_Remote_Proxy_Impl (void) {}
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ConsumesDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_ConsumesDef_Proxy_Broker (void);
    virtual _TAO_ConsumesDef_Proxy_Impl &select_proxy (
        ConsumesDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_ConsumesDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_ConsumesDef_Remote_Proxy_Broker
    : public virtual _TAO_ConsumesDef_Proxy_Broker
  {
  public:
    _TAO_ConsumesDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_ConsumesDef_Remote_Proxy_Broker (void);

    virtual _TAO_ConsumesDef_Proxy_Impl &select_proxy (
        ConsumesDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_ConsumesDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_ConsumesDef_Remote_Proxy_Broker *the_TAO_ConsumesDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ConsumesDef;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_COMPONENTDEF___PTR_CH_)
#define _IR_COMPONENTDEF___PTR_CH_

  class ComponentDef;
  typedef ComponentDef *ComponentDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTDEF___VAR_CH_)
#define _IR_COMPONENTDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export ComponentDef_var : private TAO_Base_var
  {
  public:
    ComponentDef_var (void); // default constructor
    ComponentDef_var (ComponentDef_ptr p) : ptr_ (p) {}
    ComponentDef_var (const ComponentDef_var &); // copy constructor
    ~ComponentDef_var (void); // destructor

    ComponentDef_var &operator= (ComponentDef_ptr);
    ComponentDef_var &operator= (const ComponentDef_var &);
    ComponentDef_ptr operator-> (void) const;

    operator const ComponentDef_ptr &() const;
    operator ComponentDef_ptr &();
    // in, inout, out, _retn
    ComponentDef_ptr in (void) const;
    ComponentDef_ptr &inout (void);
    ComponentDef_ptr &out (void);
    ComponentDef_ptr _retn (void);
    ComponentDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ComponentDef_ptr tao_duplicate (ComponentDef_ptr);
    static void tao_release (ComponentDef_ptr);
    static ComponentDef_ptr tao_nil (void);
    static ComponentDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    ComponentDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ComponentDef_var (const TAO_Base_var & rhs);
    ComponentDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_COMPONENTDEF___OUT_CH_)
#define _IR_COMPONENTDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export ComponentDef_out
  {
  public:
    ComponentDef_out (ComponentDef_ptr &);
    ComponentDef_out (ComponentDef_var &);
    ComponentDef_out (const ComponentDef_out &);
    ComponentDef_out &operator= (const ComponentDef_out &);
    ComponentDef_out &operator= (const ComponentDef_var &);
    ComponentDef_out &operator= (ComponentDef_ptr);
    operator ComponentDef_ptr &();
    ComponentDef_ptr &ptr (void);
    ComponentDef_ptr operator-> (void);

  private:
    ComponentDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_COMPONENTDEF_CH_)
#define _IR_COMPONENTDEF_CH_

  class _TAO_ComponentDef_Proxy_Impl;
  class _TAO_ComponentDef_Remote_Proxy_Impl;
  class _TAO_ComponentDef_Proxy_Broker;
  class _TAO_ComponentDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export ComponentDef
    : public virtual CORBA::InterfaceDef
  {
  public:
    typedef ComponentDef_ptr _ptr_type;
    typedef ComponentDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static ComponentDef_ptr _duplicate (ComponentDef_ptr obj);

    static ComponentDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ComponentDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static ComponentDef_ptr _nil (void)
      {
        return (ComponentDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::CORBA::InterfaceDefSeq * supported_interfaces (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual void supported_interfaces (
        const CORBA::InterfaceDefSeq & supported_interfaces
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ComponentDef_ptr base_component (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ProvidesDefSeq * provides_interfaces (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::UsesDefSeq * uses_interfaces (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::EmitsDefSeq * emits_events (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::PublishesDefSeq * publishes_events (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ConsumesDefSeq * consumes_events (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual CORBA::Boolean is_basic (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ProvidesDef_ptr create_provides (
        const char * id,
        const char * name,
        const char * version,
        CORBA::InterfaceDef_ptr interface_type
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::UsesDef_ptr create_uses (
        const char * id,
        const char * name,
        const char * version,
        CORBA::InterfaceDef_ptr interface_type,
        CORBA::Boolean is_multiple
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::EmitsDef_ptr create_emits (
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::PublishesDef_ptr create_publishes (
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ConsumesDef_ptr create_consumes (
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_ComponentDef_Proxy_Broker *the_TAO_ComponentDef_Proxy_Broker_;

  protected:
    ComponentDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_ComponentDef_setup_collocation (int collocated);

    ComponentDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~ComponentDef (void);

    friend class _TAO_ComponentDef_Remote_Proxy_Impl;
    friend class _TAO_ComponentDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ComponentDef_Direct_Proxy_Impl;

  private:
    ComponentDef (const ComponentDef &);
    void operator= (const ComponentDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ComponentDef_Proxy_Impl
    : public virtual CORBA::_TAO_InterfaceDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_ComponentDef_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::CORBA::InterfaceDefSeq * supported_interfaces (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual void supported_interfaces (
        CORBA::Object *_collocated_tao_target_,
        const CORBA::InterfaceDefSeq & supported_interfaces
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ComponentDef_ptr base_component (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ProvidesDefSeq * provides_interfaces (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::UsesDefSeq * uses_interfaces (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::EmitsDefSeq * emits_events (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::PublishesDefSeq * publishes_events (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ConsumesDefSeq * consumes_events (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual CORBA::Boolean is_basic (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ProvidesDef_ptr create_provides (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::InterfaceDef_ptr interface_type
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::UsesDef_ptr create_uses (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::InterfaceDef_ptr interface_type,
        CORBA::Boolean is_multiple
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::EmitsDef_ptr create_emits (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::PublishesDef_ptr create_publishes (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ConsumesDef_ptr create_consumes (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_ComponentDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_ComponentDef_Remote_Proxy_Impl
    : public virtual _TAO_ComponentDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl
  {
  public:
    _TAO_ComponentDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_ComponentDef_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::CORBA::InterfaceDefSeq * supported_interfaces (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual void supported_interfaces (
        CORBA::Object *_collocated_tao_target_,
        const CORBA::InterfaceDefSeq & supported_interfaces
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ComponentDef_ptr base_component (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ProvidesDefSeq * provides_interfaces (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::UsesDefSeq * uses_interfaces (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::EmitsDefSeq * emits_events (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::PublishesDefSeq * publishes_events (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ConsumesDefSeq * consumes_events (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual CORBA::Boolean is_basic (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ProvidesDef_ptr create_provides (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::InterfaceDef_ptr interface_type
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::UsesDef_ptr create_uses (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::InterfaceDef_ptr interface_type,
        CORBA::Boolean is_multiple
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::EmitsDef_ptr create_emits (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::PublishesDef_ptr create_publishes (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ConsumesDef_ptr create_consumes (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr value
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_ComponentDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_ComponentDef_Proxy_Broker (void);
    virtual _TAO_ComponentDef_Proxy_Impl &select_proxy (
        ComponentDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_ComponentDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_ComponentDef_Remote_Proxy_Broker
    : public virtual _TAO_ComponentDef_Proxy_Broker
  {
  public:
    _TAO_ComponentDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_ComponentDef_Remote_Proxy_Broker (void);

    virtual _TAO_ComponentDef_Proxy_Impl &select_proxy (
        ComponentDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_ComponentDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_ComponentDef_Remote_Proxy_Broker *the_TAO_ComponentDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ComponentDef;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:49

  class ComponentDescription_var;

  struct TAO_IFR_Client_Export ComponentDescription
  {
    typedef ComponentDescription_var _var_type;

    static void _tao_any_destructor (void *);
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    TAO_String_Manager base_component;
    IR::RepositoryIdSeq supports_interfaces;
    IR::ProvidesDefSeq provides_interfaces;
    IR::UsesDefSeq uses_interfaces;
    CORBA::AttrDescriptionSeq attributes;
    IR::EmitsDefSeq emits_events;
    IR::PublishesDefSeq publishes_events;
    IR::ConsumesDefSeq consumes_events;
    CORBA::Boolean is_basic;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:71

  class TAO_IFR_Client_Export ComponentDescription_var
  {
  public:
    ComponentDescription_var (void);
    ComponentDescription_var (ComponentDescription *);
    ComponentDescription_var (const ComponentDescription_var &);
    ~ComponentDescription_var (void);

    ComponentDescription_var &operator= (ComponentDescription *);
    ComponentDescription_var &operator= (const ComponentDescription_var &);
    ComponentDescription *operator-> (void);
    const ComponentDescription *operator-> (void) const;

    operator const ComponentDescription &() const;
    operator ComponentDescription &();
    operator ComponentDescription &() const;

    // Variable-size types only.
    operator ComponentDescription *&();

    // in, inout, out, _retn
    const ComponentDescription &in (void) const;
    ComponentDescription &inout (void);
    ComponentDescription *&out (void);
    ComponentDescription *_retn (void);
    ComponentDescription *ptr (void) const;

  private:
    ComponentDescription *ptr_;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:445

  class TAO_IFR_Client_Export ComponentDescription_out
  {
  public:
    ComponentDescription_out (ComponentDescription *&);
    ComponentDescription_out (ComponentDescription_var &);
    ComponentDescription_out (const ComponentDescription_out &);
    ComponentDescription_out &operator= (const ComponentDescription_out &);
    ComponentDescription_out &operator= (ComponentDescription *);
    operator ComponentDescription *&();
    ComponentDescription *&ptr (void);
    ComponentDescription *operator-> (void);

  private:
    ComponentDescription *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const ComponentDescription_var &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_ComponentDescription;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_PRIMARYKEYDEF___PTR_CH_)
#define _IR_PRIMARYKEYDEF___PTR_CH_

  class PrimaryKeyDef;
  typedef PrimaryKeyDef *PrimaryKeyDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_PRIMARYKEYDEF___VAR_CH_)
#define _IR_PRIMARYKEYDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export PrimaryKeyDef_var : private TAO_Base_var
  {
  public:
    PrimaryKeyDef_var (void); // default constructor
    PrimaryKeyDef_var (PrimaryKeyDef_ptr p) : ptr_ (p) {}
    PrimaryKeyDef_var (const PrimaryKeyDef_var &); // copy constructor
    ~PrimaryKeyDef_var (void); // destructor

    PrimaryKeyDef_var &operator= (PrimaryKeyDef_ptr);
    PrimaryKeyDef_var &operator= (const PrimaryKeyDef_var &);
    PrimaryKeyDef_ptr operator-> (void) const;

    operator const PrimaryKeyDef_ptr &() const;
    operator PrimaryKeyDef_ptr &();
    // in, inout, out, _retn
    PrimaryKeyDef_ptr in (void) const;
    PrimaryKeyDef_ptr &inout (void);
    PrimaryKeyDef_ptr &out (void);
    PrimaryKeyDef_ptr _retn (void);
    PrimaryKeyDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static PrimaryKeyDef_ptr tao_duplicate (PrimaryKeyDef_ptr);
    static void tao_release (PrimaryKeyDef_ptr);
    static PrimaryKeyDef_ptr tao_nil (void);
    static PrimaryKeyDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    PrimaryKeyDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    PrimaryKeyDef_var (const TAO_Base_var & rhs);
    PrimaryKeyDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_PRIMARYKEYDEF___OUT_CH_)
#define _IR_PRIMARYKEYDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export PrimaryKeyDef_out
  {
  public:
    PrimaryKeyDef_out (PrimaryKeyDef_ptr &);
    PrimaryKeyDef_out (PrimaryKeyDef_var &);
    PrimaryKeyDef_out (const PrimaryKeyDef_out &);
    PrimaryKeyDef_out &operator= (const PrimaryKeyDef_out &);
    PrimaryKeyDef_out &operator= (const PrimaryKeyDef_var &);
    PrimaryKeyDef_out &operator= (PrimaryKeyDef_ptr);
    operator PrimaryKeyDef_ptr &();
    PrimaryKeyDef_ptr &ptr (void);
    PrimaryKeyDef_ptr operator-> (void);

  private:
    PrimaryKeyDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_PRIMARYKEYDEF_CH_)
#define _IR_PRIMARYKEYDEF_CH_

  class _TAO_PrimaryKeyDef_Proxy_Impl;
  class _TAO_PrimaryKeyDef_Remote_Proxy_Impl;
  class _TAO_PrimaryKeyDef_Proxy_Broker;
  class _TAO_PrimaryKeyDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export PrimaryKeyDef
    : public virtual CORBA::Contained
  {
  public:
    typedef PrimaryKeyDef_ptr _ptr_type;
    typedef PrimaryKeyDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static PrimaryKeyDef_ptr _duplicate (PrimaryKeyDef_ptr obj);

    static PrimaryKeyDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static PrimaryKeyDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static PrimaryKeyDef_ptr _nil (void)
      {
        return (PrimaryKeyDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual CORBA::Boolean is_a (
        const char * primary_key_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::CORBA::ValueDef_ptr primary_key (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_PrimaryKeyDef_Proxy_Broker *the_TAO_PrimaryKeyDef_Proxy_Broker_;

  protected:
    PrimaryKeyDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_PrimaryKeyDef_setup_collocation (int collocated);

    PrimaryKeyDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~PrimaryKeyDef (void);

    friend class _TAO_PrimaryKeyDef_Remote_Proxy_Impl;
    friend class _TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl;
    friend class _TAO_PrimaryKeyDef_Direct_Proxy_Impl;

  private:
    PrimaryKeyDef (const PrimaryKeyDef &);
    void operator= (const PrimaryKeyDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Proxy_Impl
    : public virtual CORBA::_TAO_Contained_Proxy_Impl
  {
  public:
    virtual ~_TAO_PrimaryKeyDef_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual CORBA::Boolean is_a (
        CORBA::Object *_collocated_tao_target_,
        const char * primary_key_id
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::CORBA::ValueDef_ptr primary_key (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_PrimaryKeyDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Remote_Proxy_Impl
    : public virtual _TAO_PrimaryKeyDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_Contained_Remote_Proxy_Impl
  {
  public:
    _TAO_PrimaryKeyDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual CORBA::Boolean is_a (
        CORBA::Object *_collocated_tao_target_,
        const char * primary_key_id
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::CORBA::ValueDef_ptr primary_key (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_PrimaryKeyDef_Proxy_Broker (void);
    virtual _TAO_PrimaryKeyDef_Proxy_Impl &select_proxy (
        PrimaryKeyDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_PrimaryKeyDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_PrimaryKeyDef_Remote_Proxy_Broker
    : public virtual _TAO_PrimaryKeyDef_Proxy_Broker
  {
  public:
    _TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);

    virtual _TAO_PrimaryKeyDef_Proxy_Impl &select_proxy (
        PrimaryKeyDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_PrimaryKeyDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_PrimaryKeyDef_Remote_Proxy_Broker *the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_PrimaryKeyDef;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:49

  class PrimaryKeyDescription_var;

  struct TAO_IFR_Client_Export PrimaryKeyDescription
  {
    typedef PrimaryKeyDescription_var _var_type;

    static void _tao_any_destructor (void *);
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::ValueDef_var primary_key;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:71

  class TAO_IFR_Client_Export PrimaryKeyDescription_var
  {
  public:
    PrimaryKeyDescription_var (void);
    PrimaryKeyDescription_var (PrimaryKeyDescription *);
    PrimaryKeyDescription_var (const PrimaryKeyDescription_var &);
    ~PrimaryKeyDescription_var (void);

    PrimaryKeyDescription_var &operator= (PrimaryKeyDescription *);
    PrimaryKeyDescription_var &operator= (const PrimaryKeyDescription_var &);
    PrimaryKeyDescription *operator-> (void);
    const PrimaryKeyDescription *operator-> (void) const;

    operator const PrimaryKeyDescription &() const;
    operator PrimaryKeyDescription &();
    operator PrimaryKeyDescription &() const;

    // Variable-size types only.
    operator PrimaryKeyDescription *&();

    // in, inout, out, _retn
    const PrimaryKeyDescription &in (void) const;
    PrimaryKeyDescription &inout (void);
    PrimaryKeyDescription *&out (void);
    PrimaryKeyDescription *_retn (void);
    PrimaryKeyDescription *ptr (void) const;

  private:
    PrimaryKeyDescription *ptr_;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:445

  class TAO_IFR_Client_Export PrimaryKeyDescription_out
  {
  public:
    PrimaryKeyDescription_out (PrimaryKeyDescription *&);
    PrimaryKeyDescription_out (PrimaryKeyDescription_var &);
    PrimaryKeyDescription_out (const PrimaryKeyDescription_out &);
    PrimaryKeyDescription_out &operator= (const PrimaryKeyDescription_out &);
    PrimaryKeyDescription_out &operator= (PrimaryKeyDescription *);
    operator PrimaryKeyDescription *&();
    PrimaryKeyDescription *&ptr (void);
    PrimaryKeyDescription *operator-> (void);

  private:
    PrimaryKeyDescription *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const PrimaryKeyDescription_var &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_PrimaryKeyDescription;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_FACTORYDEF___PTR_CH_)
#define _IR_FACTORYDEF___PTR_CH_

  class FactoryDef;
  typedef FactoryDef *FactoryDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_FACTORYDEF___VAR_CH_)
#define _IR_FACTORYDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export FactoryDef_var : private TAO_Base_var
  {
  public:
    FactoryDef_var (void); // default constructor
    FactoryDef_var (FactoryDef_ptr p) : ptr_ (p) {}
    FactoryDef_var (const FactoryDef_var &); // copy constructor
    ~FactoryDef_var (void); // destructor

    FactoryDef_var &operator= (FactoryDef_ptr);
    FactoryDef_var &operator= (const FactoryDef_var &);
    FactoryDef_ptr operator-> (void) const;

    operator const FactoryDef_ptr &() const;
    operator FactoryDef_ptr &();
    // in, inout, out, _retn
    FactoryDef_ptr in (void) const;
    FactoryDef_ptr &inout (void);
    FactoryDef_ptr &out (void);
    FactoryDef_ptr _retn (void);
    FactoryDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static FactoryDef_ptr tao_duplicate (FactoryDef_ptr);
    static void tao_release (FactoryDef_ptr);
    static FactoryDef_ptr tao_nil (void);
    static FactoryDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    FactoryDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FactoryDef_var (const TAO_Base_var & rhs);
    FactoryDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_FACTORYDEF___OUT_CH_)
#define _IR_FACTORYDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export FactoryDef_out
  {
  public:
    FactoryDef_out (FactoryDef_ptr &);
    FactoryDef_out (FactoryDef_var &);
    FactoryDef_out (const FactoryDef_out &);
    FactoryDef_out &operator= (const FactoryDef_out &);
    FactoryDef_out &operator= (const FactoryDef_var &);
    FactoryDef_out &operator= (FactoryDef_ptr);
    operator FactoryDef_ptr &();
    FactoryDef_ptr &ptr (void);
    FactoryDef_ptr operator-> (void);

  private:
    FactoryDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_FACTORYDEF_CH_)
#define _IR_FACTORYDEF_CH_

  class _TAO_FactoryDef_Proxy_Impl;
  class _TAO_FactoryDef_Remote_Proxy_Impl;
  class _TAO_FactoryDef_Proxy_Broker;
  class _TAO_FactoryDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export FactoryDef
    : public virtual CORBA::OperationDef
  {
  public:
    typedef FactoryDef_ptr _ptr_type;
    typedef FactoryDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static FactoryDef_ptr _duplicate (FactoryDef_ptr obj);

    static FactoryDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static FactoryDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static FactoryDef_ptr _nil (void)
      {
        return (FactoryDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_FactoryDef_Proxy_Broker *the_TAO_FactoryDef_Proxy_Broker_;

  protected:
    FactoryDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_FactoryDef_setup_collocation (int collocated);

    FactoryDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~FactoryDef (void);

    friend class _TAO_FactoryDef_Remote_Proxy_Impl;
    friend class _TAO_FactoryDef_ThruPOA_Proxy_Impl;
    friend class _TAO_FactoryDef_Direct_Proxy_Impl;

  private:
    FactoryDef (const FactoryDef &);
    void operator= (const FactoryDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_FactoryDef_Proxy_Impl
    : public virtual CORBA::_TAO_OperationDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_FactoryDef_Proxy_Impl (void) {}

  protected:
    _TAO_FactoryDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_FactoryDef_Remote_Proxy_Impl
    : public virtual _TAO_FactoryDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_OperationDef_Remote_Proxy_Impl
  {
  public:
    _TAO_FactoryDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_FactoryDef_Remote_Proxy_Impl (void) {}
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_FactoryDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_FactoryDef_Proxy_Broker (void);
    virtual _TAO_FactoryDef_Proxy_Impl &select_proxy (
        FactoryDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_FactoryDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_FactoryDef_Remote_Proxy_Broker
    : public virtual _TAO_FactoryDef_Proxy_Broker
  {
  public:
    _TAO_FactoryDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_FactoryDef_Remote_Proxy_Broker (void);

    virtual _TAO_FactoryDef_Proxy_Impl &select_proxy (
        FactoryDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_FactoryDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_FactoryDef_Remote_Proxy_Broker *the_TAO_FactoryDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_FactoryDef;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_FINDERDEF___PTR_CH_)
#define _IR_FINDERDEF___PTR_CH_

  class FinderDef;
  typedef FinderDef *FinderDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_FINDERDEF___VAR_CH_)
#define _IR_FINDERDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export FinderDef_var : private TAO_Base_var
  {
  public:
    FinderDef_var (void); // default constructor
    FinderDef_var (FinderDef_ptr p) : ptr_ (p) {}
    FinderDef_var (const FinderDef_var &); // copy constructor
    ~FinderDef_var (void); // destructor

    FinderDef_var &operator= (FinderDef_ptr);
    FinderDef_var &operator= (const FinderDef_var &);
    FinderDef_ptr operator-> (void) const;

    operator const FinderDef_ptr &() const;
    operator FinderDef_ptr &();
    // in, inout, out, _retn
    FinderDef_ptr in (void) const;
    FinderDef_ptr &inout (void);
    FinderDef_ptr &out (void);
    FinderDef_ptr _retn (void);
    FinderDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static FinderDef_ptr tao_duplicate (FinderDef_ptr);
    static void tao_release (FinderDef_ptr);
    static FinderDef_ptr tao_nil (void);
    static FinderDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    FinderDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    FinderDef_var (const TAO_Base_var & rhs);
    FinderDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_FINDERDEF___OUT_CH_)
#define _IR_FINDERDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export FinderDef_out
  {
  public:
    FinderDef_out (FinderDef_ptr &);
    FinderDef_out (FinderDef_var &);
    FinderDef_out (const FinderDef_out &);
    FinderDef_out &operator= (const FinderDef_out &);
    FinderDef_out &operator= (const FinderDef_var &);
    FinderDef_out &operator= (FinderDef_ptr);
    operator FinderDef_ptr &();
    FinderDef_ptr &ptr (void);
    FinderDef_ptr operator-> (void);

  private:
    FinderDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_FINDERDEF_CH_)
#define _IR_FINDERDEF_CH_

  class _TAO_FinderDef_Proxy_Impl;
  class _TAO_FinderDef_Remote_Proxy_Impl;
  class _TAO_FinderDef_Proxy_Broker;
  class _TAO_FinderDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export FinderDef
    : public virtual CORBA::OperationDef
  {
  public:
    typedef FinderDef_ptr _ptr_type;
    typedef FinderDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static FinderDef_ptr _duplicate (FinderDef_ptr obj);

    static FinderDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static FinderDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static FinderDef_ptr _nil (void)
      {
        return (FinderDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_FinderDef_Proxy_Broker *the_TAO_FinderDef_Proxy_Broker_;

  protected:
    FinderDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_FinderDef_setup_collocation (int collocated);

    FinderDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~FinderDef (void);

    friend class _TAO_FinderDef_Remote_Proxy_Impl;
    friend class _TAO_FinderDef_ThruPOA_Proxy_Impl;
    friend class _TAO_FinderDef_Direct_Proxy_Impl;

  private:
    FinderDef (const FinderDef &);
    void operator= (const FinderDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_FinderDef_Proxy_Impl
    : public virtual CORBA::_TAO_OperationDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_FinderDef_Proxy_Impl (void) {}

  protected:
    _TAO_FinderDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_FinderDef_Remote_Proxy_Impl
    : public virtual _TAO_FinderDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_OperationDef_Remote_Proxy_Impl
  {
  public:
    _TAO_FinderDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_FinderDef_Remote_Proxy_Impl (void) {}
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_FinderDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_FinderDef_Proxy_Broker (void);
    virtual _TAO_FinderDef_Proxy_Impl &select_proxy (
        FinderDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_FinderDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_FinderDef_Remote_Proxy_Broker
    : public virtual _TAO_FinderDef_Proxy_Broker
  {
  public:
    _TAO_FinderDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_FinderDef_Remote_Proxy_Broker (void);

    virtual _TAO_FinderDef_Proxy_Impl &select_proxy (
        FinderDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_FinderDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_FinderDef_Remote_Proxy_Broker *the_TAO_FinderDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_FinderDef;

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:52

#if !defined (_IR_HOMEDEF___PTR_CH_)
#define _IR_HOMEDEF___PTR_CH_

  class HomeDef;
  typedef HomeDef *HomeDef_ptr;

#endif /* end #if !defined */

#if !defined (_IR_HOMEDEF___VAR_CH_)
#define _IR_HOMEDEF___VAR_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:565

  class TAO_IFR_Client_Export HomeDef_var : private TAO_Base_var
  {
  public:
    HomeDef_var (void); // default constructor
    HomeDef_var (HomeDef_ptr p) : ptr_ (p) {}
    HomeDef_var (const HomeDef_var &); // copy constructor
    ~HomeDef_var (void); // destructor

    HomeDef_var &operator= (HomeDef_ptr);
    HomeDef_var &operator= (const HomeDef_var &);
    HomeDef_ptr operator-> (void) const;

    operator const HomeDef_ptr &() const;
    operator HomeDef_ptr &();
    // in, inout, out, _retn
    HomeDef_ptr in (void) const;
    HomeDef_ptr &inout (void);
    HomeDef_ptr &out (void);
    HomeDef_ptr _retn (void);
    HomeDef_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static HomeDef_ptr tao_duplicate (HomeDef_ptr);
    static void tao_release (HomeDef_ptr);
    static HomeDef_ptr tao_nil (void);
    static HomeDef_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    HomeDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    HomeDef_var (const TAO_Base_var & rhs);
    HomeDef_var & operator= (const TAO_Base_var & rhs);
  };

#endif /* end #if !defined */

#if !defined (_IR_HOMEDEF___OUT_CH_)
#define _IR_HOMEDEF___OUT_CH_

  // TAO_IDL - Generated from
  // be/be_interface.cpp:946

  class TAO_IFR_Client_Export HomeDef_out
  {
  public:
    HomeDef_out (HomeDef_ptr &);
    HomeDef_out (HomeDef_var &);
    HomeDef_out (const HomeDef_out &);
    HomeDef_out &operator= (const HomeDef_out &);
    HomeDef_out &operator= (const HomeDef_var &);
    HomeDef_out &operator= (HomeDef_ptr);
    operator HomeDef_ptr &();
    HomeDef_ptr &ptr (void);
    HomeDef_ptr operator-> (void);

  private:
    HomeDef_ptr &ptr_;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:110

#if !defined (_IR_HOMEDEF_CH_)
#define _IR_HOMEDEF_CH_

  class _TAO_HomeDef_Proxy_Impl;
  class _TAO_HomeDef_Remote_Proxy_Impl;
  class _TAO_HomeDef_Proxy_Broker;
  class _TAO_HomeDef_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export HomeDef
    : public virtual CORBA::InterfaceDef
  {
  public:
    typedef HomeDef_ptr _ptr_type;
    typedef HomeDef_var _var_type;
    static int _tao_class_id;

    // The static operations.
    static HomeDef_ptr _duplicate (HomeDef_ptr obj);

    static HomeDef_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static HomeDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    static HomeDef_ptr _nil (void)
      {
        return (HomeDef_ptr)0;
      }

    static void _tao_any_destructor (void *);

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::HomeDef_ptr base_home (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::ComponentDef_ptr managed_component (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::PrimaryKeyDef_ptr primary_key (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::FactoryDefSeq * factories (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::FinderDefSeq * finders (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual CORBA::Boolean is_basic (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::PrimaryKeyDef_ptr create_primary_key (
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr primary_key
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::FactoryDef_ptr create_factory (
        const char * id,
        const char * name,
        const char * version,
        const CORBA::ParDescriptionSeq & params,
        const CORBA::ExceptionDefSeq & exceptions
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/operation_ch.cpp:46

    virtual ::IR::FinderDef_ptr create_finder (
        const char * id,
        const char * name,
        const char * version,
        const CORBA::ParDescriptionSeq & params,
        const CORBA::ExceptionDefSeq & exceptions
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:267

    virtual CORBA::Boolean _is_a (
        const char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      );

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;
  private:
    _TAO_HomeDef_Proxy_Broker *the_TAO_HomeDef_Proxy_Broker_;

  protected:
    HomeDef (int collocated = 0);

    // These methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode.
    virtual void IR_HomeDef_setup_collocation (int collocated);

    HomeDef (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );
    virtual ~HomeDef (void);

    friend class _TAO_HomeDef_Remote_Proxy_Impl;
    friend class _TAO_HomeDef_ThruPOA_Proxy_Impl;
    friend class _TAO_HomeDef_Direct_Proxy_Impl;

  private:
    HomeDef (const HomeDef &);
    void operator= (const HomeDef &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulates
  // an invocation logic.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_impl_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_HomeDef_Proxy_Impl
    : public virtual CORBA::_TAO_InterfaceDef_Proxy_Impl
  {
  public:
    virtual ~_TAO_HomeDef_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::HomeDef_ptr base_home (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::ComponentDef_ptr managed_component (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::PrimaryKeyDef_ptr primary_key (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::FactoryDefSeq * factories (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::FinderDefSeq * finders (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual CORBA::Boolean is_basic (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::PrimaryKeyDef_ptr create_primary_key (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr primary_key
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::FactoryDef_ptr create_factory (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        const CORBA::ParDescriptionSeq & params,
        const CORBA::ExceptionDefSeq & exceptions
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_operation/base_proxy_impl_ch.cpp:24

    virtual ::IR::FinderDef_ptr create_finder (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        const CORBA::ParDescriptionSeq & params,
        const CORBA::ExceptionDefSeq & exceptions
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

  protected:
    _TAO_HomeDef_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_impl_ch.cpp:37

  class TAO_IFR_Client_Export _TAO_HomeDef_Remote_Proxy_Impl
    : public virtual _TAO_HomeDef_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual CORBA::_TAO_InterfaceDef_Remote_Proxy_Impl
  {
  public:
    _TAO_HomeDef_Remote_Proxy_Impl (void);

    virtual ~_TAO_HomeDef_Remote_Proxy_Impl (void) {}

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::HomeDef_ptr base_home (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::ComponentDef_ptr managed_component (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::PrimaryKeyDef_ptr primary_key (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::FactoryDefSeq * factories (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::FinderDefSeq * finders (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual CORBA::Boolean is_basic (
        CORBA::Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::PrimaryKeyDef_ptr create_primary_key (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        CORBA::ValueDef_ptr primary_key
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::FactoryDef_ptr create_factory (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        const CORBA::ParDescriptionSeq & params,
        const CORBA::ExceptionDefSeq & exceptions
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    // TAO_IDL - Generated from
    // be/be_visitor_operation/proxy_impl_xh.cpp:24

    virtual ::IR::FinderDef_ptr create_finder (
        CORBA::Object *_collocated_tao_target_,
        const char * id,
        const char * name,
        const char * version,
        const CORBA::ParDescriptionSeq & params,
        const CORBA::ExceptionDefSeq & exceptions
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));
  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.

  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/base_proxy_broker_ch.cpp:35

  class TAO_IFR_Client_Export _TAO_HomeDef_Proxy_Broker
  {
  public:
    virtual ~_TAO_HomeDef_Proxy_Broker (void);
    virtual _TAO_HomeDef_Proxy_Impl &select_proxy (
        HomeDef *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_HomeDef_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  // TAO_IDL - Generated from
  // be/be_visitor_interface/remote_proxy_broker_ch.cpp:40

  class TAO_IFR_Client_Export _TAO_HomeDef_Remote_Proxy_Broker
    : public virtual _TAO_HomeDef_Proxy_Broker
  {
  public:
    _TAO_HomeDef_Remote_Proxy_Broker (void);

    virtual ~_TAO_HomeDef_Remote_Proxy_Broker (void);

    virtual _TAO_HomeDef_Proxy_Impl &select_proxy (
        HomeDef *object
        ACE_ENV_ARG_DECL
      );

  private:
    _TAO_HomeDef_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_HomeDef_Remote_Proxy_Broker *the_TAO_HomeDef_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_HomeDef;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:49

  class HomeDescription_var;

  struct TAO_IFR_Client_Export HomeDescription
  {
    typedef HomeDescription_var _var_type;

    static void _tao_any_destructor (void *);
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    TAO_String_Manager base_home;
    TAO_String_Manager managed_component;
    IR::PrimaryKeyDef_var primary_key_def;
    IR::FactoryDefSeq factories;
    IR::FinderDefSeq finders;
    CORBA::OpDescriptionSeq operations;
    CORBA::AttrDescriptionSeq attributes;
    CORBA::Boolean is_basic;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:71

  class TAO_IFR_Client_Export HomeDescription_var
  {
  public:
    HomeDescription_var (void);
    HomeDescription_var (HomeDescription *);
    HomeDescription_var (const HomeDescription_var &);
    ~HomeDescription_var (void);

    HomeDescription_var &operator= (HomeDescription *);
    HomeDescription_var &operator= (const HomeDescription_var &);
    HomeDescription *operator-> (void);
    const HomeDescription *operator-> (void) const;

    operator const HomeDescription &() const;
    operator HomeDescription &();
    operator HomeDescription &() const;

    // Variable-size types only.
    operator HomeDescription *&();

    // in, inout, out, _retn
    const HomeDescription &in (void) const;
    HomeDescription &inout (void);
    HomeDescription *&out (void);
    HomeDescription *_retn (void);
    HomeDescription *ptr (void) const;

  private:
    HomeDescription *ptr_;
  };

  // TAO_IDL - Generated from
  // be/be_structure.cpp:445

  class TAO_IFR_Client_Export HomeDescription_out
  {
  public:
    HomeDescription_out (HomeDescription *&);
    HomeDescription_out (HomeDescription_var &);
    HomeDescription_out (const HomeDescription_out &);
    HomeDescription_out &operator= (const HomeDescription_out &);
    HomeDescription_out &operator= (HomeDescription *);
    operator HomeDescription *&();
    HomeDescription *&ptr (void);
    HomeDescription *operator-> (void);

  private:
    HomeDescription *&ptr_;
    // Assignment from T_var not allowed.
    void operator= (const HomeDescription_var &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_typecode/typecode_decl.cpp:44

  TAO_NAMESPACE_STORAGE_CLASS ::CORBA::TypeCode_ptr _tc_HomeDescription;

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

}
TAO_NAMESPACE_CLOSE // module IR

// Proxy Broker Factory function pointer declarations.

// TAO_IDL - Generated from
// be/be_visitor_root/root.cpp:80

extern TAO_IFR_Client_Export
IR::_TAO_ComponentRepository_Proxy_Broker *
(*IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_ProvidesDef_Proxy_Broker *
(*IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_UsesDef_Proxy_Broker *
(*IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_EventDef_Proxy_Broker *
(*IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_EmitsDef_Proxy_Broker *
(*IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_PublishesDef_Proxy_Broker *
(*IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_ConsumesDef_Proxy_Broker *
(*IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_ComponentDef_Proxy_Broker *
(*IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_PrimaryKeyDef_Proxy_Broker *
(*IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_FactoryDef_Proxy_Broker *
(*IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_FinderDef_Proxy_Broker *
(*IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export
IR::_TAO_HomeDef_Proxy_Broker *
(*IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_ch.cpp:51

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::DefinitionKind);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::DefinitionKind &);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::RepositoryIdSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::RepositoryIdSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::RepositoryIdSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::RepositoryIdSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ComponentDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ComponentDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ProvidesDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ProvidesDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::UsesDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::UsesDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::HomeDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::HomeDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::HomeDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::EmitsDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EmitsDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EmitsDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::EmitsDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::PublishesDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PublishesDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PublishesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::PublishesDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ConsumesDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ConsumesDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ConsumesDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ConsumesDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::FactoryDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FactoryDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FactoryDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::FactoryDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::FinderDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FinderDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FinderDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::FinderDefSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentRepository_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentRepository_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentRepository_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ProvidesDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ProvidesDescription *&);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::UsesDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::UsesDescription *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ProvidesDescSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ProvidesDescSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ProvidesDescSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ProvidesDescSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::UsesDescSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::UsesDescSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::UsesDescSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::UsesDescSeq *&);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EventDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EventDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EventDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::EventDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EventDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EventDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::EventDescription *&);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EmitsDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::EmitsDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::EmitsDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PublishesDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PublishesDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PublishesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ConsumesDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ConsumesDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ConsumesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::ComponentDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::ComponentDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::ComponentDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::ComponentDescription *&);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PrimaryKeyDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PrimaryKeyDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PrimaryKeyDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::PrimaryKeyDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::PrimaryKeyDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::PrimaryKeyDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::PrimaryKeyDescription *&);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FactoryDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FactoryDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FactoryDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FinderDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::FinderDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::FinderDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDef_ptr); // copying
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDef_ptr *); // non-copying
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::HomeDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_ch.cpp:52

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const IR::HomeDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, IR::HomeDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR::HomeDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR::HomeDescription *&);

// TAO_IDL - Generated from
// be/be_visitor_root/cdr_op.cpp:48

#ifndef __ACE_INLINE__

// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_ch.cpp:50

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::DefinitionKind &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::DefinitionKind &);

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_RepositoryIdSeq_H_
#define _TAO_CDR_OP_IR_RepositoryIdSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::RepositoryIdSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::RepositoryIdSeq &
  );

#endif /* _TAO_CDR_OP_IR_RepositoryIdSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_ComponentDefSeq_H_
#define _TAO_CDR_OP_IR_ComponentDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ComponentDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ComponentDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ComponentDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_ProvidesDefSeq_H_
#define _TAO_CDR_OP_IR_ProvidesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ProvidesDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ProvidesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ProvidesDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_UsesDefSeq_H_
#define _TAO_CDR_OP_IR_UsesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::UsesDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::UsesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_UsesDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_HomeDefSeq_H_
#define _TAO_CDR_OP_IR_HomeDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::HomeDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::HomeDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_HomeDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_EmitsDefSeq_H_
#define _TAO_CDR_OP_IR_EmitsDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::EmitsDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::EmitsDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_EmitsDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_PublishesDefSeq_H_
#define _TAO_CDR_OP_IR_PublishesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::PublishesDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::PublishesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_PublishesDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_ConsumesDefSeq_H_
#define _TAO_CDR_OP_IR_ConsumesDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ConsumesDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ConsumesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ConsumesDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_FactoryDefSeq_H_
#define _TAO_CDR_OP_IR_FactoryDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::FactoryDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::FactoryDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_FactoryDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_FinderDefSeq_H_
#define _TAO_CDR_OP_IR_FinderDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::FinderDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::FinderDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_FinderDefSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ComponentRepository_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ComponentRepository_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ProvidesDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ProvidesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:54

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ProvidesDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ProvidesDescription &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::UsesDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::UsesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:54

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::UsesDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::UsesDescription &);

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_ProvidesDescSeq_H_
#define _TAO_CDR_OP_IR_ProvidesDescSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ProvidesDescSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ProvidesDescSeq &
  );

#endif /* _TAO_CDR_OP_IR_ProvidesDescSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:57

#if !defined _TAO_CDR_OP_IR_UsesDescSeq_H_
#define _TAO_CDR_OP_IR_UsesDescSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::UsesDescSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::UsesDescSeq &
  );

#endif /* _TAO_CDR_OP_IR_UsesDescSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::EventDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::EventDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:54

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::EventDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::EventDescription &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::EmitsDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::EmitsDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::PublishesDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::PublishesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ConsumesDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ConsumesDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ComponentDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ComponentDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:54

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::ComponentDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ComponentDescription &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::PrimaryKeyDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::PrimaryKeyDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:54

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::PrimaryKeyDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::PrimaryKeyDescription &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::FactoryDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::FactoryDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::FinderDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::FinderDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:55

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::HomeDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::HomeDef_ptr &);

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:54

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR::HomeDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::HomeDescription &);

// TAO_IDL - Generated from
// be/be_visitor_root/cdr_op.cpp:64

#endif /* __ACE_INLINE__ */

// TAO_IDL - Generated from
// be/be_codegen.cpp:1016

#if defined (__ACE_INLINE__)
#include "IFR_ComponentsC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
