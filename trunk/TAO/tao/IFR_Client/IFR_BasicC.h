// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef TAO_IDL_IFR_BASICC_H
#define TAO_IDL_IFR_BASICC_H

#include "ace/pre.h"
#include "IFR_BaseC.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_IFR_Client_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_IFR_Client_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

// *******************************************************************
// Sequence classes moved fron IFR_BaseC.h

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CH_

  class _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_InterfaceDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &rhs);
    TAO_Object_Manager<CORBA::InterfaceDef,CORBA::InterfaceDef_var> operator[] (CORBA::ULong index) const;
    static CORBA_InterfaceDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (CORBA_InterfaceDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    CORBA_InterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_InterfaceDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
    
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_INTERFACEDEFSEQ_CH_)
#define _CORBA_INTERFACEDEFSEQ_CH_

class CORBA_InterfaceDefSeq;
class CORBA_InterfaceDefSeq_var;

// *************************************************************
// CORBA_InterfaceDefSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_InterfaceDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_InterfaceDefSeq (void); // default ctor
  CORBA_InterfaceDefSeq (CORBA::ULong max); // uses max size
  CORBA_InterfaceDefSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA_InterfaceDef_ptr *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_InterfaceDefSeq (const CORBA_InterfaceDefSeq &); // copy ctor
  ~CORBA_InterfaceDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_InterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_INTERFACEDEFSEQ___VAR_CH_

// *************************************************************
// class CORBA_InterfaceDefSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_InterfaceDefSeq_var
{
public:
  CORBA_InterfaceDefSeq_var (void); // default constructor
  CORBA_InterfaceDefSeq_var (CORBA_InterfaceDefSeq *);
  CORBA_InterfaceDefSeq_var (const CORBA_InterfaceDefSeq_var &); // copy constructor
  ~CORBA_InterfaceDefSeq_var (void); // destructor
  
  CORBA_InterfaceDefSeq_var &operator= (CORBA_InterfaceDefSeq *);
  CORBA_InterfaceDefSeq_var &operator= (const CORBA_InterfaceDefSeq_var &);
  CORBA_InterfaceDefSeq *operator-> (void);
  const CORBA_InterfaceDefSeq *operator-> (void) const;
  
  operator const CORBA_InterfaceDefSeq &() const;
  operator CORBA_InterfaceDefSeq &();
  operator CORBA_InterfaceDefSeq &() const;
  operator CORBA_InterfaceDefSeq *&(); // variable-size base types only
  
  TAO_Object_Manager<CORBA::InterfaceDef, CORBA::InterfaceDef_var> operator[] (CORBA::ULong index);
  
  // in, inout, out, _retn 
  const CORBA_InterfaceDefSeq &in (void) const;
  CORBA_InterfaceDefSeq &inout (void);
  CORBA_InterfaceDefSeq *&out (void);
  CORBA_InterfaceDefSeq *_retn (void);
  CORBA_InterfaceDefSeq *ptr (void) const;

private:
  CORBA_InterfaceDefSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_INTERFACEDEFSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_InterfaceDefSeq_out
{
public:
  CORBA_InterfaceDefSeq_out (CORBA_InterfaceDefSeq *&);
  CORBA_InterfaceDefSeq_out (CORBA_InterfaceDefSeq_var &);
  CORBA_InterfaceDefSeq_out (const CORBA_InterfaceDefSeq_out &);
  CORBA_InterfaceDefSeq_out &operator= (const CORBA_InterfaceDefSeq_out &);
  CORBA_InterfaceDefSeq_out &operator= (CORBA_InterfaceDefSeq *);
  operator CORBA_InterfaceDefSeq *&();
  CORBA_InterfaceDefSeq *&ptr (void);
  CORBA_InterfaceDefSeq *operator-> (void);
  TAO_Object_Manager<CORBA::InterfaceDef, CORBA::InterfaceDef_var> operator[] (CORBA::ULong index);
  
private:
  CORBA_InterfaceDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_InterfaceDefSeq_var &);
};


#endif /* end #if !defined */

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_ABSTRACTINTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_ABSTRACTINTERFACEDEFSEQ_CH_

  class _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_AbstractInterfaceDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq &rhs);
    TAO_Object_Manager<CORBA::AbstractInterfaceDef,CORBA::AbstractInterfaceDef_var> operator[] (CORBA::ULong index) const;
    static CORBA_AbstractInterfaceDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (CORBA_AbstractInterfaceDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    CORBA_AbstractInterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_AbstractInterfaceDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
    
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ_CH_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ_CH_

class CORBA_AbstractInterfaceDefSeq;
class CORBA_AbstractInterfaceDefSeq_var;

// *************************************************************
// CORBA_AbstractInterfaceDefSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_AbstractInterfaceDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_AbstractInterfaceDef,CORBA_AbstractInterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_AbstractInterfaceDefSeq (void); // default ctor
  CORBA_AbstractInterfaceDefSeq (CORBA::ULong max); // uses max size
  CORBA_AbstractInterfaceDefSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA_AbstractInterfaceDef_ptr *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_AbstractInterfaceDefSeq (const CORBA_AbstractInterfaceDefSeq &); // copy ctor
  ~CORBA_AbstractInterfaceDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_AbstractInterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ___VAR_CH_

// *************************************************************
// class CORBA_AbstractInterfaceDefSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_AbstractInterfaceDefSeq_var
{
public:
  CORBA_AbstractInterfaceDefSeq_var (void); // default constructor
  CORBA_AbstractInterfaceDefSeq_var (CORBA_AbstractInterfaceDefSeq *);
  CORBA_AbstractInterfaceDefSeq_var (const CORBA_AbstractInterfaceDefSeq_var &); // copy constructor
  ~CORBA_AbstractInterfaceDefSeq_var (void); // destructor
  
  CORBA_AbstractInterfaceDefSeq_var &operator= (CORBA_AbstractInterfaceDefSeq *);
  CORBA_AbstractInterfaceDefSeq_var &operator= (const CORBA_AbstractInterfaceDefSeq_var &);
  CORBA_AbstractInterfaceDefSeq *operator-> (void);
  const CORBA_AbstractInterfaceDefSeq *operator-> (void) const;
  
  operator const CORBA_AbstractInterfaceDefSeq &() const;
  operator CORBA_AbstractInterfaceDefSeq &();
  operator CORBA_AbstractInterfaceDefSeq &() const;
  operator CORBA_AbstractInterfaceDefSeq *&(); // variable-size base types only
  
  TAO_Object_Manager<CORBA::AbstractInterfaceDef, CORBA::AbstractInterfaceDef_var> operator[] (CORBA::ULong index);
  
  // in, inout, out, _retn 
  const CORBA_AbstractInterfaceDefSeq &in (void) const;
  CORBA_AbstractInterfaceDefSeq &inout (void);
  CORBA_AbstractInterfaceDefSeq *&out (void);
  CORBA_AbstractInterfaceDefSeq *_retn (void);
  CORBA_AbstractInterfaceDefSeq *ptr (void) const;

private:
  CORBA_AbstractInterfaceDefSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_AbstractInterfaceDefSeq_out
{
public:
  CORBA_AbstractInterfaceDefSeq_out (CORBA_AbstractInterfaceDefSeq *&);
  CORBA_AbstractInterfaceDefSeq_out (CORBA_AbstractInterfaceDefSeq_var &);
  CORBA_AbstractInterfaceDefSeq_out (const CORBA_AbstractInterfaceDefSeq_out &);
  CORBA_AbstractInterfaceDefSeq_out &operator= (const CORBA_AbstractInterfaceDefSeq_out &);
  CORBA_AbstractInterfaceDefSeq_out &operator= (CORBA_AbstractInterfaceDefSeq *);
  operator CORBA_AbstractInterfaceDefSeq *&();
  CORBA_AbstractInterfaceDefSeq *&ptr (void);
  CORBA_AbstractInterfaceDefSeq *operator-> (void);
  TAO_Object_Manager<CORBA::AbstractInterfaceDef, CORBA::AbstractInterfaceDef_var> operator[] (CORBA::ULong index);
  
private:
  CORBA_AbstractInterfaceDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_AbstractInterfaceDefSeq_var &);
};


#endif /* end #if !defined */

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_LOCALINTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_LOCALINTERFACEDEFSEQ_CH_

  class _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_LocalInterfaceDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq &rhs);
    TAO_Object_Manager<CORBA::LocalInterfaceDef,CORBA::LocalInterfaceDef_var> operator[] (CORBA::ULong index) const;
    static CORBA_LocalInterfaceDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (CORBA_LocalInterfaceDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    CORBA_LocalInterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_LocalInterfaceDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
    
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_LOCALINTERFACEDEFSEQ_CH_)
#define _CORBA_LOCALINTERFACEDEFSEQ_CH_

class CORBA_LocalInterfaceDefSeq;
class CORBA_LocalInterfaceDefSeq_var;

// *************************************************************
// CORBA_LocalInterfaceDefSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_LocalInterfaceDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_LocalInterfaceDef,CORBA_LocalInterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_LocalInterfaceDefSeq (void); // default ctor
  CORBA_LocalInterfaceDefSeq (CORBA::ULong max); // uses max size
  CORBA_LocalInterfaceDefSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA_LocalInterfaceDef_ptr *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_LocalInterfaceDefSeq (const CORBA_LocalInterfaceDefSeq &); // copy ctor
  ~CORBA_LocalInterfaceDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_LocalInterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_LOCALINTERFACEDEFSEQ___VAR_CH_

// *************************************************************
// class CORBA_LocalInterfaceDefSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_LocalInterfaceDefSeq_var
{
public:
  CORBA_LocalInterfaceDefSeq_var (void); // default constructor
  CORBA_LocalInterfaceDefSeq_var (CORBA_LocalInterfaceDefSeq *);
  CORBA_LocalInterfaceDefSeq_var (const CORBA_LocalInterfaceDefSeq_var &); // copy constructor
  ~CORBA_LocalInterfaceDefSeq_var (void); // destructor
  
  CORBA_LocalInterfaceDefSeq_var &operator= (CORBA_LocalInterfaceDefSeq *);
  CORBA_LocalInterfaceDefSeq_var &operator= (const CORBA_LocalInterfaceDefSeq_var &);
  CORBA_LocalInterfaceDefSeq *operator-> (void);
  const CORBA_LocalInterfaceDefSeq *operator-> (void) const;
  
  operator const CORBA_LocalInterfaceDefSeq &() const;
  operator CORBA_LocalInterfaceDefSeq &();
  operator CORBA_LocalInterfaceDefSeq &() const;
  operator CORBA_LocalInterfaceDefSeq *&(); // variable-size base types only
  
  TAO_Object_Manager<CORBA::LocalInterfaceDef, CORBA::LocalInterfaceDef_var> operator[] (CORBA::ULong index);
  
  // in, inout, out, _retn 
  const CORBA_LocalInterfaceDefSeq &in (void) const;
  CORBA_LocalInterfaceDefSeq &inout (void);
  CORBA_LocalInterfaceDefSeq *&out (void);
  CORBA_LocalInterfaceDefSeq *_retn (void);
  CORBA_LocalInterfaceDefSeq *ptr (void) const;

private:
  CORBA_LocalInterfaceDefSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_LOCALINTERFACEDEFSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_LocalInterfaceDefSeq_out
{
public:
  CORBA_LocalInterfaceDefSeq_out (CORBA_LocalInterfaceDefSeq *&);
  CORBA_LocalInterfaceDefSeq_out (CORBA_LocalInterfaceDefSeq_var &);
  CORBA_LocalInterfaceDefSeq_out (const CORBA_LocalInterfaceDefSeq_out &);
  CORBA_LocalInterfaceDefSeq_out &operator= (const CORBA_LocalInterfaceDefSeq_out &);
  CORBA_LocalInterfaceDefSeq_out &operator= (CORBA_LocalInterfaceDefSeq *);
  operator CORBA_LocalInterfaceDefSeq *&();
  CORBA_LocalInterfaceDefSeq *&ptr (void);
  CORBA_LocalInterfaceDefSeq *operator-> (void);
  TAO_Object_Manager<CORBA::LocalInterfaceDef, CORBA::LocalInterfaceDef_var> operator[] (CORBA::ULong index);
  
private:
  CORBA_LocalInterfaceDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_LocalInterfaceDefSeq_var &);
};


#endif /* end #if !defined */

// ************************************************************************

  class CORBA_PrimitiveDef;
  
#if !defined (_CORBA_PRIMITIVEDEF___PTR_CH_)
#define _CORBA_PRIMITIVEDEF___PTR_CH_

typedef CORBA_PrimitiveDef *CORBA_PrimitiveDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF___VAR_CH_)
#define _CORBA_PRIMITIVEDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_PrimitiveDef_var : public TAO_Base_var
  {
  public:
    CORBA_PrimitiveDef_var (void); // default constructor
    CORBA_PrimitiveDef_var (CORBA_PrimitiveDef_ptr p) : ptr_ (p) {} 
    CORBA_PrimitiveDef_var (const CORBA_PrimitiveDef_var &); // copy constructor
    ~CORBA_PrimitiveDef_var (void); // destructor
    
    CORBA_PrimitiveDef_var &operator= (CORBA_PrimitiveDef_ptr);
    CORBA_PrimitiveDef_var &operator= (const CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_ptr operator-> (void) const;
    
    operator const CORBA_PrimitiveDef_ptr &() const;
    operator CORBA_PrimitiveDef_ptr &();
    // in, inout, out, _retn 
    CORBA_PrimitiveDef_ptr in (void) const;
    CORBA_PrimitiveDef_ptr &inout (void);
    CORBA_PrimitiveDef_ptr &out (void);
    CORBA_PrimitiveDef_ptr _retn (void);
    CORBA_PrimitiveDef_ptr ptr (void) const;

  private:
    CORBA_PrimitiveDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_PrimitiveDef_var (const TAO_Base_var &rhs);
    CORBA_PrimitiveDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF___OUT_CH_)
#define _CORBA_PRIMITIVEDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_PrimitiveDef_out
  {
  public:
    CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_ptr &);
    CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_out (const CORBA_PrimitiveDef_out &);
    CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_out &);
    CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_out &operator= (CORBA_PrimitiveDef_ptr);
    operator CORBA_PrimitiveDef_ptr &();
    CORBA_PrimitiveDef_ptr &ptr (void);
    CORBA_PrimitiveDef_ptr operator-> (void);
    
  private:
    CORBA_PrimitiveDef_ptr &ptr_;
  };


#endif /* end #if !defined */

  class CORBA_StringDef;
  
#if !defined (_CORBA_STRINGDEF___PTR_CH_)
#define _CORBA_STRINGDEF___PTR_CH_

typedef CORBA_StringDef *CORBA_StringDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___VAR_CH_)
#define _CORBA_STRINGDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_StringDef_var : public TAO_Base_var
  {
  public:
    CORBA_StringDef_var (void); // default constructor
    CORBA_StringDef_var (CORBA_StringDef_ptr p) : ptr_ (p) {} 
    CORBA_StringDef_var (const CORBA_StringDef_var &); // copy constructor
    ~CORBA_StringDef_var (void); // destructor
    
    CORBA_StringDef_var &operator= (CORBA_StringDef_ptr);
    CORBA_StringDef_var &operator= (const CORBA_StringDef_var &);
    CORBA_StringDef_ptr operator-> (void) const;
    
    operator const CORBA_StringDef_ptr &() const;
    operator CORBA_StringDef_ptr &();
    // in, inout, out, _retn 
    CORBA_StringDef_ptr in (void) const;
    CORBA_StringDef_ptr &inout (void);
    CORBA_StringDef_ptr &out (void);
    CORBA_StringDef_ptr _retn (void);
    CORBA_StringDef_ptr ptr (void) const;

  private:
    CORBA_StringDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_StringDef_var (const TAO_Base_var &rhs);
    CORBA_StringDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___OUT_CH_)
#define _CORBA_STRINGDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_StringDef_out
  {
  public:
    CORBA_StringDef_out (CORBA_StringDef_ptr &);
    CORBA_StringDef_out (CORBA_StringDef_var &);
    CORBA_StringDef_out (const CORBA_StringDef_out &);
    CORBA_StringDef_out &operator= (const CORBA_StringDef_out &);
    CORBA_StringDef_out &operator= (const CORBA_StringDef_var &);
    CORBA_StringDef_out &operator= (CORBA_StringDef_ptr);
    operator CORBA_StringDef_ptr &();
    CORBA_StringDef_ptr &ptr (void);
    CORBA_StringDef_ptr operator-> (void);
    
  private:
    CORBA_StringDef_ptr &ptr_;
  };


#endif /* end #if !defined */

  class CORBA_SequenceDef;
  
#if !defined (_CORBA_SEQUENCEDEF___PTR_CH_)
#define _CORBA_SEQUENCEDEF___PTR_CH_

typedef CORBA_SequenceDef *CORBA_SequenceDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF___VAR_CH_)
#define _CORBA_SEQUENCEDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_SequenceDef_var : public TAO_Base_var
  {
  public:
    CORBA_SequenceDef_var (void); // default constructor
    CORBA_SequenceDef_var (CORBA_SequenceDef_ptr p) : ptr_ (p) {} 
    CORBA_SequenceDef_var (const CORBA_SequenceDef_var &); // copy constructor
    ~CORBA_SequenceDef_var (void); // destructor
    
    CORBA_SequenceDef_var &operator= (CORBA_SequenceDef_ptr);
    CORBA_SequenceDef_var &operator= (const CORBA_SequenceDef_var &);
    CORBA_SequenceDef_ptr operator-> (void) const;
    
    operator const CORBA_SequenceDef_ptr &() const;
    operator CORBA_SequenceDef_ptr &();
    // in, inout, out, _retn 
    CORBA_SequenceDef_ptr in (void) const;
    CORBA_SequenceDef_ptr &inout (void);
    CORBA_SequenceDef_ptr &out (void);
    CORBA_SequenceDef_ptr _retn (void);
    CORBA_SequenceDef_ptr ptr (void) const;

  private:
    CORBA_SequenceDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_SequenceDef_var (const TAO_Base_var &rhs);
    CORBA_SequenceDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF___OUT_CH_)
#define _CORBA_SEQUENCEDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_SequenceDef_out
  {
  public:
    CORBA_SequenceDef_out (CORBA_SequenceDef_ptr &);
    CORBA_SequenceDef_out (CORBA_SequenceDef_var &);
    CORBA_SequenceDef_out (const CORBA_SequenceDef_out &);
    CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_out &);
    CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_var &);
    CORBA_SequenceDef_out &operator= (CORBA_SequenceDef_ptr);
    operator CORBA_SequenceDef_ptr &();
    CORBA_SequenceDef_ptr &ptr (void);
    CORBA_SequenceDef_ptr operator-> (void);
    
  private:
    CORBA_SequenceDef_ptr &ptr_;
  };


#endif /* end #if !defined */

  class CORBA_ArrayDef;
  
#if !defined (_CORBA_ARRAYDEF___PTR_CH_)
#define _CORBA_ARRAYDEF___PTR_CH_

typedef CORBA_ArrayDef *CORBA_ArrayDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___VAR_CH_)
#define _CORBA_ARRAYDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_ArrayDef_var : public TAO_Base_var
  {
  public:
    CORBA_ArrayDef_var (void); // default constructor
    CORBA_ArrayDef_var (CORBA_ArrayDef_ptr p) : ptr_ (p) {} 
    CORBA_ArrayDef_var (const CORBA_ArrayDef_var &); // copy constructor
    ~CORBA_ArrayDef_var (void); // destructor
    
    CORBA_ArrayDef_var &operator= (CORBA_ArrayDef_ptr);
    CORBA_ArrayDef_var &operator= (const CORBA_ArrayDef_var &);
    CORBA_ArrayDef_ptr operator-> (void) const;
    
    operator const CORBA_ArrayDef_ptr &() const;
    operator CORBA_ArrayDef_ptr &();
    // in, inout, out, _retn 
    CORBA_ArrayDef_ptr in (void) const;
    CORBA_ArrayDef_ptr &inout (void);
    CORBA_ArrayDef_ptr &out (void);
    CORBA_ArrayDef_ptr _retn (void);
    CORBA_ArrayDef_ptr ptr (void) const;

  private:
    CORBA_ArrayDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_ArrayDef_var (const TAO_Base_var &rhs);
    CORBA_ArrayDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___OUT_CH_)
#define _CORBA_ARRAYDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_ArrayDef_out
  {
  public:
    CORBA_ArrayDef_out (CORBA_ArrayDef_ptr &);
    CORBA_ArrayDef_out (CORBA_ArrayDef_var &);
    CORBA_ArrayDef_out (const CORBA_ArrayDef_out &);
    CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_out &);
    CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_var &);
    CORBA_ArrayDef_out &operator= (CORBA_ArrayDef_ptr);
    operator CORBA_ArrayDef_ptr &();
    CORBA_ArrayDef_ptr &ptr (void);
    CORBA_ArrayDef_ptr operator-> (void);
    
  private:
    CORBA_ArrayDef_ptr &ptr_;
  };


#endif /* end #if !defined */

  class CORBA_WstringDef;
  
#if !defined (_CORBA_WSTRINGDEF___PTR_CH_)
#define _CORBA_WSTRINGDEF___PTR_CH_

typedef CORBA_WstringDef *CORBA_WstringDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF___VAR_CH_)
#define _CORBA_WSTRINGDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_WstringDef_var : public TAO_Base_var
  {
  public:
    CORBA_WstringDef_var (void); // default constructor
    CORBA_WstringDef_var (CORBA_WstringDef_ptr p) : ptr_ (p) {} 
    CORBA_WstringDef_var (const CORBA_WstringDef_var &); // copy constructor
    ~CORBA_WstringDef_var (void); // destructor
    
    CORBA_WstringDef_var &operator= (CORBA_WstringDef_ptr);
    CORBA_WstringDef_var &operator= (const CORBA_WstringDef_var &);
    CORBA_WstringDef_ptr operator-> (void) const;
    
    operator const CORBA_WstringDef_ptr &() const;
    operator CORBA_WstringDef_ptr &();
    // in, inout, out, _retn 
    CORBA_WstringDef_ptr in (void) const;
    CORBA_WstringDef_ptr &inout (void);
    CORBA_WstringDef_ptr &out (void);
    CORBA_WstringDef_ptr _retn (void);
    CORBA_WstringDef_ptr ptr (void) const;

  private:
    CORBA_WstringDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_WstringDef_var (const TAO_Base_var &rhs);
    CORBA_WstringDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF___OUT_CH_)
#define _CORBA_WSTRINGDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_WstringDef_out
  {
  public:
    CORBA_WstringDef_out (CORBA_WstringDef_ptr &);
    CORBA_WstringDef_out (CORBA_WstringDef_var &);
    CORBA_WstringDef_out (const CORBA_WstringDef_out &);
    CORBA_WstringDef_out &operator= (const CORBA_WstringDef_out &);
    CORBA_WstringDef_out &operator= (const CORBA_WstringDef_var &);
    CORBA_WstringDef_out &operator= (CORBA_WstringDef_ptr);
    operator CORBA_WstringDef_ptr &();
    CORBA_WstringDef_ptr &ptr (void);
    CORBA_WstringDef_ptr operator-> (void);
    
  private:
    CORBA_WstringDef_ptr &ptr_;
  };


#endif /* end #if !defined */

  class CORBA_FixedDef;
  
#if !defined (_CORBA_FIXEDDEF___PTR_CH_)
#define _CORBA_FIXEDDEF___PTR_CH_

typedef CORBA_FixedDef *CORBA_FixedDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___VAR_CH_)
#define _CORBA_FIXEDDEF___VAR_CH_

  class TAO_IFR_Client_Export CORBA_FixedDef_var : public TAO_Base_var
  {
  public:
    CORBA_FixedDef_var (void); // default constructor
    CORBA_FixedDef_var (CORBA_FixedDef_ptr p) : ptr_ (p) {} 
    CORBA_FixedDef_var (const CORBA_FixedDef_var &); // copy constructor
    ~CORBA_FixedDef_var (void); // destructor
    
    CORBA_FixedDef_var &operator= (CORBA_FixedDef_ptr);
    CORBA_FixedDef_var &operator= (const CORBA_FixedDef_var &);
    CORBA_FixedDef_ptr operator-> (void) const;
    
    operator const CORBA_FixedDef_ptr &() const;
    operator CORBA_FixedDef_ptr &();
    // in, inout, out, _retn 
    CORBA_FixedDef_ptr in (void) const;
    CORBA_FixedDef_ptr &inout (void);
    CORBA_FixedDef_ptr &out (void);
    CORBA_FixedDef_ptr _retn (void);
    CORBA_FixedDef_ptr ptr (void) const;

  private:
    CORBA_FixedDef_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_FixedDef_var (const TAO_Base_var &rhs);
    CORBA_FixedDef_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___OUT_CH_)
#define _CORBA_FIXEDDEF___OUT_CH_

  class TAO_IFR_Client_Export CORBA_FixedDef_out
  {
  public:
    CORBA_FixedDef_out (CORBA_FixedDef_ptr &);
    CORBA_FixedDef_out (CORBA_FixedDef_var &);
    CORBA_FixedDef_out (const CORBA_FixedDef_out &);
    CORBA_FixedDef_out &operator= (const CORBA_FixedDef_out &);
    CORBA_FixedDef_out &operator= (const CORBA_FixedDef_var &);
    CORBA_FixedDef_out &operator= (CORBA_FixedDef_ptr);
    operator CORBA_FixedDef_ptr &();
    CORBA_FixedDef_ptr &ptr (void);
    CORBA_FixedDef_ptr operator-> (void);
    
  private:
    CORBA_FixedDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY___VAR_CH_)
#define _CORBA_REPOSITORY___VAR_CH_

  class TAO_IFR_Client_Export CORBA_Repository_var : public TAO_Base_var
  {
  public:
    CORBA_Repository_var (void); // default constructor
    CORBA_Repository_var (CORBA_Repository_ptr p) : ptr_ (p) {} 
    CORBA_Repository_var (const CORBA_Repository_var &); // copy constructor
    ~CORBA_Repository_var (void); // destructor
    
    CORBA_Repository_var &operator= (CORBA_Repository_ptr);
    CORBA_Repository_var &operator= (const CORBA_Repository_var &);
    CORBA_Repository_ptr operator-> (void) const;
    
    operator const CORBA_Repository_ptr &() const;
    operator CORBA_Repository_ptr &();
    // in, inout, out, _retn 
    CORBA_Repository_ptr in (void) const;
    CORBA_Repository_ptr &inout (void);
    CORBA_Repository_ptr &out (void);
    CORBA_Repository_ptr _retn (void);
    CORBA_Repository_ptr ptr (void) const;

  private:
    CORBA_Repository_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_Repository_var (const TAO_Base_var &rhs);
    CORBA_Repository_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY___OUT_CH_)
#define _CORBA_REPOSITORY___OUT_CH_

  class TAO_IFR_Client_Export CORBA_Repository_out
  {
  public:
    CORBA_Repository_out (CORBA_Repository_ptr &);
    CORBA_Repository_out (CORBA_Repository_var &);
    CORBA_Repository_out (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_var &);
    CORBA_Repository_out &operator= (CORBA_Repository_ptr);
    operator CORBA_Repository_ptr &();
    CORBA_Repository_ptr &ptr (void);
    CORBA_Repository_ptr operator-> (void);
    
  private:
    CORBA_Repository_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY_CH_)
#define _CORBA_REPOSITORY_CH_

// Forward Classes Declaration
  class _TAO_Repository_Proxy_Impl;
  class _TAO_Repository_Remote_Proxy_Impl;
  class _TAO_Repository_Proxy_Broker;
  class _TAO_Repository_Remote_Proxy_Broker;
  
  class TAO_IFR_Client_Export CORBA_Repository: public virtual CORBA_Container
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CORBA_Repository_ptr _ptr_type;
    typedef CORBA_Repository_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static CORBA_Repository_ptr _duplicate (CORBA_Repository_ptr obj);
    static CORBA_Repository_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static CORBA_Repository_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    static CORBA_Repository_ptr _nil (void)
      {
        return (CORBA_Repository_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual CORBA::Contained_ptr lookup_id (
        const char * search_id,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::TypeCode_ptr get_canonical_typecode (
        CORBA::TypeCode_ptr tc,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::PrimitiveDef_ptr get_primitive (
        CORBA::PrimitiveKind kind,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::StringDef_ptr create_string (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::WstringDef_ptr create_wstring (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::SequenceDef_ptr create_sequence (
        CORBA::ULong bound,
        CORBA::IDLType_ptr element_type,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::ArrayDef_ptr create_array (
        CORBA::ULong length,
        CORBA::IDLType_ptr element_type,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::FixedDef_ptr create_fixed (
        CORBA::UShort digits,
        CORBA::Short scale,
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id, 
        CORBA::Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);
    
    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_Repository_Proxy_Broker *the_TAO_Repository_Proxy_Broker_;
    
  protected:
    CORBA_Repository (int collocated = 0);
    
    protected:
      // This methods travese the inheritance tree and set the
      // parents piece of the given class in the right mode
      virtual void CORBA_Repository_setup_collocation (int collocated);
      
      CORBA_Repository (
        TAO_Stub *objref, 
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
        );
      
      friend class _TAO_Repository_Remote_Proxy_Impl;
      friend class _TAO_Repository_ThruPOA_Proxy_Impl;
      friend class _TAO_Repository_Direct_Proxy_Impl;
    
    virtual ~CORBA_Repository (void);
  private:
    CORBA_Repository (const CORBA_Repository &);
    void operator= (const CORBA_Repository &);    
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_Repository_Proxy_Impl : 
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_Repository_Proxy_Impl (void) { }
  
    virtual CORBA::Contained_ptr lookup_id (
      CORBA_Object *_collocated_tao_target_,
      const char * search_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::TypeCode_ptr get_canonical_typecode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::TypeCode_ptr tc,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::PrimitiveDef_ptr get_primitive (
      CORBA_Object *_collocated_tao_target_,
      CORBA::PrimitiveKind kind,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::StringDef_ptr create_string (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::WstringDef_ptr create_wstring (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::SequenceDef_ptr create_sequence (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::ArrayDef_ptr create_array (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      CORBA::IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::FixedDef_ptr create_fixed (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_Repository_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_Repository_Remote_Proxy_Impl : 
  public virtual _TAO_Repository_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl
  
{
public:
  _TAO_Repository_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_Repository_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::Contained_ptr lookup_id (
      CORBA_Object *_collocated_tao_target_,
      const char * search_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr get_canonical_typecode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::TypeCode_ptr tc,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::PrimitiveDef_ptr get_primitive (
      CORBA_Object *_collocated_tao_target_,
      CORBA::PrimitiveKind kind,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::StringDef_ptr create_string (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::WstringDef_ptr create_wstring (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::SequenceDef_ptr create_sequence (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ArrayDef_ptr create_array (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      CORBA::IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::FixedDef_ptr create_fixed (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_Repository_Proxy_Broker
{
public:
  virtual ~_TAO_Repository_Proxy_Broker (void);
  virtual _TAO_Repository_Proxy_Impl &select_proxy (
    CORBA_Repository *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_Repository_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_Repository_Remote_Proxy_Broker : public virtual _TAO_Repository_Proxy_Broker
{
public: 
  _TAO_Repository_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_Repository_Remote_Proxy_Broker (void);
  
  virtual _TAO_Repository_Proxy_Impl &select_proxy (
    CORBA_Repository *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_Repository_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_Repository_Remote_Proxy_Broker *the_TAO_Repository_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF___VAR_CH_)
#define _CORBA_MODULEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ModuleDef_var : public TAO_Base_var
{
public:
  CORBA_ModuleDef_var (void); // default constructor
  CORBA_ModuleDef_var (CORBA_ModuleDef_ptr p) : ptr_ (p) {} 
  CORBA_ModuleDef_var (const CORBA_ModuleDef_var &); // copy constructor
  ~CORBA_ModuleDef_var (void); // destructor
  
  CORBA_ModuleDef_var &operator= (CORBA_ModuleDef_ptr);
  CORBA_ModuleDef_var &operator= (const CORBA_ModuleDef_var &);
  CORBA_ModuleDef_ptr operator-> (void) const;
  
  operator const CORBA_ModuleDef_ptr &() const;
  operator CORBA_ModuleDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ModuleDef_ptr in (void) const;
  CORBA_ModuleDef_ptr &inout (void);
  CORBA_ModuleDef_ptr &out (void);
  CORBA_ModuleDef_ptr _retn (void);
  CORBA_ModuleDef_ptr ptr (void) const;

private:
  CORBA_ModuleDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ModuleDef_var (const TAO_Base_var &rhs);
  CORBA_ModuleDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF___OUT_CH_)
#define _CORBA_MODULEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ModuleDef_out
{
public:
  CORBA_ModuleDef_out (CORBA_ModuleDef_ptr &);
  CORBA_ModuleDef_out (CORBA_ModuleDef_var &);
  CORBA_ModuleDef_out (const CORBA_ModuleDef_out &);
  CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_out &);
  CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_var &);
  CORBA_ModuleDef_out &operator= (CORBA_ModuleDef_ptr);
  operator CORBA_ModuleDef_ptr &();
  CORBA_ModuleDef_ptr &ptr (void);
  CORBA_ModuleDef_ptr operator-> (void);
  
private:
  CORBA_ModuleDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF_CH_)
#define _CORBA_MODULEDEF_CH_

// Forward Classes Declaration
class _TAO_ModuleDef_Proxy_Impl;
class _TAO_ModuleDef_Remote_Proxy_Impl;
class _TAO_ModuleDef_Proxy_Broker;
class _TAO_ModuleDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ModuleDef: public virtual CORBA_Container, public virtual CORBA_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ModuleDef_ptr _ptr_type;
  typedef CORBA_ModuleDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ModuleDef_ptr _duplicate (CORBA_ModuleDef_ptr obj);
  static CORBA_ModuleDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ModuleDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ModuleDef_ptr _nil (void)
    {
      return (CORBA_ModuleDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ModuleDef_Proxy_Broker *the_TAO_ModuleDef_Proxy_Broker_;
  
protected:
  CORBA_ModuleDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ModuleDef_setup_collocation (int collocated);
    
    CORBA_ModuleDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_ModuleDef_Remote_Proxy_Impl;
    friend class _TAO_ModuleDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ModuleDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ModuleDef (void);
private:
  CORBA_ModuleDef (const CORBA_ModuleDef &);
  void operator= (const CORBA_ModuleDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ModuleDef_Proxy_Impl : 
  public virtual _TAO_Container_Proxy_Impl, 
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_ModuleDef_Proxy_Impl (void) { }
  
  protected:
  _TAO_ModuleDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ModuleDef_Remote_Proxy_Impl : 
  public virtual _TAO_ModuleDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl, 
  public virtual _TAO_Contained_Remote_Proxy_Impl
  
{
public:
  _TAO_ModuleDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_ModuleDef_Remote_Proxy_Impl (void) { }
  
  };

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ModuleDef_Proxy_Broker
{
public:
  virtual ~_TAO_ModuleDef_Proxy_Broker (void);
  virtual _TAO_ModuleDef_Proxy_Impl &select_proxy (
    CORBA_ModuleDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ModuleDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ModuleDef_Remote_Proxy_Broker : public virtual _TAO_ModuleDef_Proxy_Broker
{
public: 
  _TAO_ModuleDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_ModuleDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_ModuleDef_Proxy_Impl &select_proxy (
    CORBA_ModuleDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ModuleDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ModuleDef_Remote_Proxy_Broker *the_TAO_ModuleDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_ModuleDescription;
class CORBA_ModuleDescription_var;

struct TAO_IFR_Client_Export CORBA_ModuleDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ModuleDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
};

class TAO_IFR_Client_Export CORBA_ModuleDescription_var
{
public:
  CORBA_ModuleDescription_var (void); // default constructor
  CORBA_ModuleDescription_var (CORBA_ModuleDescription *);
  CORBA_ModuleDescription_var (const CORBA_ModuleDescription_var &); // copy constructor
  ~CORBA_ModuleDescription_var (void); // destructor
  
  CORBA_ModuleDescription_var &operator= (CORBA_ModuleDescription *);
  CORBA_ModuleDescription_var &operator= (const CORBA_ModuleDescription_var &);
  CORBA_ModuleDescription *operator-> (void);
  const CORBA_ModuleDescription *operator-> (void) const;
  
  operator const CORBA_ModuleDescription &() const;
  operator CORBA_ModuleDescription &();
  operator CORBA_ModuleDescription &() const;
  operator CORBA_ModuleDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_ModuleDescription &in (void) const;
  CORBA_ModuleDescription &inout (void);
  CORBA_ModuleDescription *&out (void);
  CORBA_ModuleDescription *_retn (void);
  CORBA_ModuleDescription *ptr (void) const;

private:
  CORBA_ModuleDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_ModuleDescription_out
{
public:
  CORBA_ModuleDescription_out (CORBA_ModuleDescription *&);
  CORBA_ModuleDescription_out (CORBA_ModuleDescription_var &);
  CORBA_ModuleDescription_out (const CORBA_ModuleDescription_out &);
  CORBA_ModuleDescription_out &operator= (const CORBA_ModuleDescription_out &);
  CORBA_ModuleDescription_out &operator= (CORBA_ModuleDescription *);
  operator CORBA_ModuleDescription *&();
  CORBA_ModuleDescription *&ptr (void);
  CORBA_ModuleDescription *operator-> (void);
  
private:
  CORBA_ModuleDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ModuleDescription_var &);
};


#if !defined (_CORBA_CONSTANTDEF___VAR_CH_)
#define _CORBA_CONSTANTDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ConstantDef_var : public TAO_Base_var
{
public:
  CORBA_ConstantDef_var (void); // default constructor
  CORBA_ConstantDef_var (CORBA_ConstantDef_ptr p) : ptr_ (p) {} 
  CORBA_ConstantDef_var (const CORBA_ConstantDef_var &); // copy constructor
  ~CORBA_ConstantDef_var (void); // destructor
  
  CORBA_ConstantDef_var &operator= (CORBA_ConstantDef_ptr);
  CORBA_ConstantDef_var &operator= (const CORBA_ConstantDef_var &);
  CORBA_ConstantDef_ptr operator-> (void) const;
  
  operator const CORBA_ConstantDef_ptr &() const;
  operator CORBA_ConstantDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ConstantDef_ptr in (void) const;
  CORBA_ConstantDef_ptr &inout (void);
  CORBA_ConstantDef_ptr &out (void);
  CORBA_ConstantDef_ptr _retn (void);
  CORBA_ConstantDef_ptr ptr (void) const;

private:
  CORBA_ConstantDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ConstantDef_var (const TAO_Base_var &rhs);
  CORBA_ConstantDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF___OUT_CH_)
#define _CORBA_CONSTANTDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ConstantDef_out
{
public:
  CORBA_ConstantDef_out (CORBA_ConstantDef_ptr &);
  CORBA_ConstantDef_out (CORBA_ConstantDef_var &);
  CORBA_ConstantDef_out (const CORBA_ConstantDef_out &);
  CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_out &);
  CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_var &);
  CORBA_ConstantDef_out &operator= (CORBA_ConstantDef_ptr);
  operator CORBA_ConstantDef_ptr &();
  CORBA_ConstantDef_ptr &ptr (void);
  CORBA_ConstantDef_ptr operator-> (void);
  
private:
  CORBA_ConstantDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF_CH_)
#define _CORBA_CONSTANTDEF_CH_

// Forward Classes Declaration
class _TAO_ConstantDef_Proxy_Impl;
class _TAO_ConstantDef_Remote_Proxy_Impl;
class _TAO_ConstantDef_Proxy_Broker;
class _TAO_ConstantDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ConstantDef: public virtual CORBA_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ConstantDef_ptr _ptr_type;
  typedef CORBA_ConstantDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ConstantDef_ptr _duplicate (CORBA_ConstantDef_ptr obj);
  static CORBA_ConstantDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ConstantDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ConstantDef_ptr _nil (void)
    {
      return (CORBA_ConstantDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA::IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Any * value (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void value (
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ConstantDef_Proxy_Broker *the_TAO_ConstantDef_Proxy_Broker_;
  
protected:
  CORBA_ConstantDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ConstantDef_setup_collocation (int collocated);
    
    CORBA_ConstantDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_ConstantDef_Remote_Proxy_Impl;
    friend class _TAO_ConstantDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ConstantDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ConstantDef (void);
private:
  CORBA_ConstantDef (const CORBA_ConstantDef &);
  void operator= (const CORBA_ConstantDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ConstantDef_Proxy_Impl : 
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_ConstantDef_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Any * value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void value (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ConstantDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ConstantDef_Remote_Proxy_Impl : 
  public virtual _TAO_ConstantDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl
  
{
public:
  _TAO_ConstantDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_ConstantDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Any * value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void value (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ConstantDef_Proxy_Broker
{
public:
  virtual ~_TAO_ConstantDef_Proxy_Broker (void);
  virtual _TAO_ConstantDef_Proxy_Impl &select_proxy (
    CORBA_ConstantDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ConstantDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ConstantDef_Remote_Proxy_Broker : public virtual _TAO_ConstantDef_Proxy_Broker
{
public: 
  _TAO_ConstantDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_ConstantDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_ConstantDef_Proxy_Impl &select_proxy (
    CORBA_ConstantDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ConstantDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ConstantDef_Remote_Proxy_Broker *the_TAO_ConstantDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_ConstantDescription;
class CORBA_ConstantDescription_var;

struct TAO_IFR_Client_Export CORBA_ConstantDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ConstantDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
  CORBA::Any value;
};

class TAO_IFR_Client_Export CORBA_ConstantDescription_var
{
public:
  CORBA_ConstantDescription_var (void); // default constructor
  CORBA_ConstantDescription_var (CORBA_ConstantDescription *);
  CORBA_ConstantDescription_var (const CORBA_ConstantDescription_var &); // copy constructor
  ~CORBA_ConstantDescription_var (void); // destructor
  
  CORBA_ConstantDescription_var &operator= (CORBA_ConstantDescription *);
  CORBA_ConstantDescription_var &operator= (const CORBA_ConstantDescription_var &);
  CORBA_ConstantDescription *operator-> (void);
  const CORBA_ConstantDescription *operator-> (void) const;
  
  operator const CORBA_ConstantDescription &() const;
  operator CORBA_ConstantDescription &();
  operator CORBA_ConstantDescription &() const;
  operator CORBA_ConstantDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_ConstantDescription &in (void) const;
  CORBA_ConstantDescription &inout (void);
  CORBA_ConstantDescription *&out (void);
  CORBA_ConstantDescription *_retn (void);
  CORBA_ConstantDescription *ptr (void) const;

private:
  CORBA_ConstantDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_ConstantDescription_out
{
public:
  CORBA_ConstantDescription_out (CORBA_ConstantDescription *&);
  CORBA_ConstantDescription_out (CORBA_ConstantDescription_var &);
  CORBA_ConstantDescription_out (const CORBA_ConstantDescription_out &);
  CORBA_ConstantDescription_out &operator= (const CORBA_ConstantDescription_out &);
  CORBA_ConstantDescription_out &operator= (CORBA_ConstantDescription *);
  operator CORBA_ConstantDescription *&();
  CORBA_ConstantDescription *&ptr (void);
  CORBA_ConstantDescription *operator-> (void);
  
private:
  CORBA_ConstantDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ConstantDescription_var &);
};


#if !defined (_CORBA_STRUCTDEF___VAR_CH_)
#define _CORBA_STRUCTDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_StructDef_var : public TAO_Base_var
{
public:
  CORBA_StructDef_var (void); // default constructor
  CORBA_StructDef_var (CORBA_StructDef_ptr p) : ptr_ (p) {} 
  CORBA_StructDef_var (const CORBA_StructDef_var &); // copy constructor
  ~CORBA_StructDef_var (void); // destructor
  
  CORBA_StructDef_var &operator= (CORBA_StructDef_ptr);
  CORBA_StructDef_var &operator= (const CORBA_StructDef_var &);
  CORBA_StructDef_ptr operator-> (void) const;
  
  operator const CORBA_StructDef_ptr &() const;
  operator CORBA_StructDef_ptr &();
  // in, inout, out, _retn 
  CORBA_StructDef_ptr in (void) const;
  CORBA_StructDef_ptr &inout (void);
  CORBA_StructDef_ptr &out (void);
  CORBA_StructDef_ptr _retn (void);
  CORBA_StructDef_ptr ptr (void) const;

private:
  CORBA_StructDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_StructDef_var (const TAO_Base_var &rhs);
  CORBA_StructDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF___OUT_CH_)
#define _CORBA_STRUCTDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_StructDef_out
{
public:
  CORBA_StructDef_out (CORBA_StructDef_ptr &);
  CORBA_StructDef_out (CORBA_StructDef_var &);
  CORBA_StructDef_out (const CORBA_StructDef_out &);
  CORBA_StructDef_out &operator= (const CORBA_StructDef_out &);
  CORBA_StructDef_out &operator= (const CORBA_StructDef_var &);
  CORBA_StructDef_out &operator= (CORBA_StructDef_ptr);
  operator CORBA_StructDef_ptr &();
  CORBA_StructDef_ptr &ptr (void);
  CORBA_StructDef_ptr operator-> (void);
  
private:
  CORBA_StructDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF_CH_)
#define _CORBA_STRUCTDEF_CH_

// Forward Classes Declaration
class _TAO_StructDef_Proxy_Impl;
class _TAO_StructDef_Remote_Proxy_Impl;
class _TAO_StructDef_Proxy_Broker;
class _TAO_StructDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_StructDef: public virtual CORBA_TypedefDef, public virtual CORBA_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_StructDef_ptr _ptr_type;
  typedef CORBA_StructDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_StructDef_ptr _duplicate (CORBA_StructDef_ptr obj);
  static CORBA_StructDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_StructDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_StructDef_ptr _nil (void)
    {
      return (CORBA_StructDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::StructMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_StructDef_Proxy_Broker *the_TAO_StructDef_Proxy_Broker_;
  
protected:
  CORBA_StructDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_StructDef_setup_collocation (int collocated);
    
    CORBA_StructDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_StructDef_Remote_Proxy_Impl;
    friend class _TAO_StructDef_ThruPOA_Proxy_Impl;
    friend class _TAO_StructDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_StructDef (void);
private:
  CORBA_StructDef (const CORBA_StructDef &);
  void operator= (const CORBA_StructDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_StructDef_Proxy_Impl : 
  public virtual _TAO_TypedefDef_Proxy_Impl, 
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_StructDef_Proxy_Impl (void) { }
  
    virtual CORBA::StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_StructDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_StructDef_Remote_Proxy_Impl : 
  public virtual _TAO_StructDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl, 
  public virtual _TAO_Container_Remote_Proxy_Impl
  
{
public:
  _TAO_StructDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_StructDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_StructDef_Proxy_Broker
{
public:
  virtual ~_TAO_StructDef_Proxy_Broker (void);
  virtual _TAO_StructDef_Proxy_Impl &select_proxy (
    CORBA_StructDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_StructDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_StructDef_Remote_Proxy_Broker : public virtual _TAO_StructDef_Proxy_Broker
{
public: 
  _TAO_StructDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_StructDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_StructDef_Proxy_Impl &select_proxy (
    CORBA_StructDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_StructDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_StructDef_Remote_Proxy_Broker *the_TAO_StructDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___VAR_CH_)
#define _CORBA_UNIONDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_UnionDef_var : public TAO_Base_var
{
public:
  CORBA_UnionDef_var (void); // default constructor
  CORBA_UnionDef_var (CORBA_UnionDef_ptr p) : ptr_ (p) {} 
  CORBA_UnionDef_var (const CORBA_UnionDef_var &); // copy constructor
  ~CORBA_UnionDef_var (void); // destructor
  
  CORBA_UnionDef_var &operator= (CORBA_UnionDef_ptr);
  CORBA_UnionDef_var &operator= (const CORBA_UnionDef_var &);
  CORBA_UnionDef_ptr operator-> (void) const;
  
  operator const CORBA_UnionDef_ptr &() const;
  operator CORBA_UnionDef_ptr &();
  // in, inout, out, _retn 
  CORBA_UnionDef_ptr in (void) const;
  CORBA_UnionDef_ptr &inout (void);
  CORBA_UnionDef_ptr &out (void);
  CORBA_UnionDef_ptr _retn (void);
  CORBA_UnionDef_ptr ptr (void) const;

private:
  CORBA_UnionDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_UnionDef_var (const TAO_Base_var &rhs);
  CORBA_UnionDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___OUT_CH_)
#define _CORBA_UNIONDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_UnionDef_out
{
public:
  CORBA_UnionDef_out (CORBA_UnionDef_ptr &);
  CORBA_UnionDef_out (CORBA_UnionDef_var &);
  CORBA_UnionDef_out (const CORBA_UnionDef_out &);
  CORBA_UnionDef_out &operator= (const CORBA_UnionDef_out &);
  CORBA_UnionDef_out &operator= (const CORBA_UnionDef_var &);
  CORBA_UnionDef_out &operator= (CORBA_UnionDef_ptr);
  operator CORBA_UnionDef_ptr &();
  CORBA_UnionDef_ptr &ptr (void);
  CORBA_UnionDef_ptr operator-> (void);
  
private:
  CORBA_UnionDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF_CH_)
#define _CORBA_UNIONDEF_CH_

// Forward Classes Declaration
class _TAO_UnionDef_Proxy_Impl;
class _TAO_UnionDef_Remote_Proxy_Impl;
class _TAO_UnionDef_Proxy_Broker;
class _TAO_UnionDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_UnionDef: public virtual CORBA_TypedefDef, public virtual CORBA_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_UnionDef_ptr _ptr_type;
  typedef CORBA_UnionDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_UnionDef_ptr _duplicate (CORBA_UnionDef_ptr obj);
  static CORBA_UnionDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_UnionDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_UnionDef_ptr _nil (void)
    {
      return (CORBA_UnionDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr discriminator_type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr discriminator_type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void discriminator_type_def (
      CORBA::IDLType_ptr discriminator_type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::UnionMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const CORBA::UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_UnionDef_Proxy_Broker *the_TAO_UnionDef_Proxy_Broker_;
  
protected:
  CORBA_UnionDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_UnionDef_setup_collocation (int collocated);
    
    CORBA_UnionDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_UnionDef_Remote_Proxy_Impl;
    friend class _TAO_UnionDef_ThruPOA_Proxy_Impl;
    friend class _TAO_UnionDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_UnionDef (void);
private:
  CORBA_UnionDef (const CORBA_UnionDef &);
  void operator= (const CORBA_UnionDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_UnionDef_Proxy_Impl : 
  public virtual _TAO_TypedefDef_Proxy_Impl, 
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_UnionDef_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr discriminator_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::IDLType_ptr discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr discriminator_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::UnionMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_UnionDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_UnionDef_Remote_Proxy_Impl : 
  public virtual _TAO_UnionDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl, 
  public virtual _TAO_Container_Remote_Proxy_Impl
  
{
public:
  _TAO_UnionDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_UnionDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr discriminator_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr discriminator_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::UnionMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_UnionDef_Proxy_Broker
{
public:
  virtual ~_TAO_UnionDef_Proxy_Broker (void);
  virtual _TAO_UnionDef_Proxy_Impl &select_proxy (
    CORBA_UnionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_UnionDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_UnionDef_Remote_Proxy_Broker : public virtual _TAO_UnionDef_Proxy_Broker
{
public: 
  _TAO_UnionDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_UnionDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_UnionDef_Proxy_Impl &select_proxy (
    CORBA_UnionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_UnionDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_UnionDef_Remote_Proxy_Broker *the_TAO_UnionDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF___VAR_CH_)
#define _CORBA_ENUMDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_EnumDef_var : public TAO_Base_var
{
public:
  CORBA_EnumDef_var (void); // default constructor
  CORBA_EnumDef_var (CORBA_EnumDef_ptr p) : ptr_ (p) {} 
  CORBA_EnumDef_var (const CORBA_EnumDef_var &); // copy constructor
  ~CORBA_EnumDef_var (void); // destructor
  
  CORBA_EnumDef_var &operator= (CORBA_EnumDef_ptr);
  CORBA_EnumDef_var &operator= (const CORBA_EnumDef_var &);
  CORBA_EnumDef_ptr operator-> (void) const;
  
  operator const CORBA_EnumDef_ptr &() const;
  operator CORBA_EnumDef_ptr &();
  // in, inout, out, _retn 
  CORBA_EnumDef_ptr in (void) const;
  CORBA_EnumDef_ptr &inout (void);
  CORBA_EnumDef_ptr &out (void);
  CORBA_EnumDef_ptr _retn (void);
  CORBA_EnumDef_ptr ptr (void) const;

private:
  CORBA_EnumDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_EnumDef_var (const TAO_Base_var &rhs);
  CORBA_EnumDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF___OUT_CH_)
#define _CORBA_ENUMDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_EnumDef_out
{
public:
  CORBA_EnumDef_out (CORBA_EnumDef_ptr &);
  CORBA_EnumDef_out (CORBA_EnumDef_var &);
  CORBA_EnumDef_out (const CORBA_EnumDef_out &);
  CORBA_EnumDef_out &operator= (const CORBA_EnumDef_out &);
  CORBA_EnumDef_out &operator= (const CORBA_EnumDef_var &);
  CORBA_EnumDef_out &operator= (CORBA_EnumDef_ptr);
  operator CORBA_EnumDef_ptr &();
  CORBA_EnumDef_ptr &ptr (void);
  CORBA_EnumDef_ptr operator-> (void);
  
private:
  CORBA_EnumDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF_CH_)
#define _CORBA_ENUMDEF_CH_

// Forward Classes Declaration
class _TAO_EnumDef_Proxy_Impl;
class _TAO_EnumDef_Remote_Proxy_Impl;
class _TAO_EnumDef_Proxy_Broker;
class _TAO_EnumDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_EnumDef: public virtual CORBA_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_EnumDef_ptr _ptr_type;
  typedef CORBA_EnumDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_EnumDef_ptr _duplicate (CORBA_EnumDef_ptr obj);
  static CORBA_EnumDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_EnumDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_EnumDef_ptr _nil (void)
    {
      return (CORBA_EnumDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::EnumMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const CORBA::EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_EnumDef_Proxy_Broker *the_TAO_EnumDef_Proxy_Broker_;
  
protected:
  CORBA_EnumDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_EnumDef_setup_collocation (int collocated);
    
    CORBA_EnumDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_EnumDef_Remote_Proxy_Impl;
    friend class _TAO_EnumDef_ThruPOA_Proxy_Impl;
    friend class _TAO_EnumDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_EnumDef (void);
private:
  CORBA_EnumDef (const CORBA_EnumDef &);
  void operator= (const CORBA_EnumDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_EnumDef_Proxy_Impl : 
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_EnumDef_Proxy_Impl (void) { }
  
    virtual CORBA::EnumMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_EnumDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_EnumDef_Remote_Proxy_Impl : 
  public virtual _TAO_EnumDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl
  
{
public:
  _TAO_EnumDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_EnumDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::EnumMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_EnumDef_Proxy_Broker
{
public:
  virtual ~_TAO_EnumDef_Proxy_Broker (void);
  virtual _TAO_EnumDef_Proxy_Impl &select_proxy (
    CORBA_EnumDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_EnumDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_EnumDef_Remote_Proxy_Broker : public virtual _TAO_EnumDef_Proxy_Broker
{
public: 
  _TAO_EnumDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_EnumDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_EnumDef_Proxy_Impl &select_proxy (
    CORBA_EnumDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_EnumDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_EnumDef_Remote_Proxy_Broker *the_TAO_EnumDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF___VAR_CH_)
#define _CORBA_ALIASDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_AliasDef_var : public TAO_Base_var
{
public:
  CORBA_AliasDef_var (void); // default constructor
  CORBA_AliasDef_var (CORBA_AliasDef_ptr p) : ptr_ (p) {} 
  CORBA_AliasDef_var (const CORBA_AliasDef_var &); // copy constructor
  ~CORBA_AliasDef_var (void); // destructor
  
  CORBA_AliasDef_var &operator= (CORBA_AliasDef_ptr);
  CORBA_AliasDef_var &operator= (const CORBA_AliasDef_var &);
  CORBA_AliasDef_ptr operator-> (void) const;
  
  operator const CORBA_AliasDef_ptr &() const;
  operator CORBA_AliasDef_ptr &();
  // in, inout, out, _retn 
  CORBA_AliasDef_ptr in (void) const;
  CORBA_AliasDef_ptr &inout (void);
  CORBA_AliasDef_ptr &out (void);
  CORBA_AliasDef_ptr _retn (void);
  CORBA_AliasDef_ptr ptr (void) const;

private:
  CORBA_AliasDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_AliasDef_var (const TAO_Base_var &rhs);
  CORBA_AliasDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF___OUT_CH_)
#define _CORBA_ALIASDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_AliasDef_out
{
public:
  CORBA_AliasDef_out (CORBA_AliasDef_ptr &);
  CORBA_AliasDef_out (CORBA_AliasDef_var &);
  CORBA_AliasDef_out (const CORBA_AliasDef_out &);
  CORBA_AliasDef_out &operator= (const CORBA_AliasDef_out &);
  CORBA_AliasDef_out &operator= (const CORBA_AliasDef_var &);
  CORBA_AliasDef_out &operator= (CORBA_AliasDef_ptr);
  operator CORBA_AliasDef_ptr &();
  CORBA_AliasDef_ptr &ptr (void);
  CORBA_AliasDef_ptr operator-> (void);
  
private:
  CORBA_AliasDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF_CH_)
#define _CORBA_ALIASDEF_CH_

// Forward Classes Declaration
class _TAO_AliasDef_Proxy_Impl;
class _TAO_AliasDef_Remote_Proxy_Impl;
class _TAO_AliasDef_Proxy_Broker;
class _TAO_AliasDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_AliasDef: public virtual CORBA_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_AliasDef_ptr _ptr_type;
  typedef CORBA_AliasDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_AliasDef_ptr _duplicate (CORBA_AliasDef_ptr obj);
  static CORBA_AliasDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_AliasDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_AliasDef_ptr _nil (void)
    {
      return (CORBA_AliasDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::IDLType_ptr original_type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      CORBA::IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_AliasDef_Proxy_Broker *the_TAO_AliasDef_Proxy_Broker_;
  
protected:
  CORBA_AliasDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_AliasDef_setup_collocation (int collocated);
    
    CORBA_AliasDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_AliasDef_Remote_Proxy_Impl;
    friend class _TAO_AliasDef_ThruPOA_Proxy_Impl;
    friend class _TAO_AliasDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_AliasDef (void);
private:
  CORBA_AliasDef (const CORBA_AliasDef &);
  void operator= (const CORBA_AliasDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_AliasDef_Proxy_Impl : 
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_AliasDef_Proxy_Impl (void) { }
  
    virtual CORBA::IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_AliasDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_AliasDef_Remote_Proxy_Impl : 
  public virtual _TAO_AliasDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl
  
{
public:
  _TAO_AliasDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_AliasDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_AliasDef_Proxy_Broker
{
public:
  virtual ~_TAO_AliasDef_Proxy_Broker (void);
  virtual _TAO_AliasDef_Proxy_Impl &select_proxy (
    CORBA_AliasDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_AliasDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_AliasDef_Remote_Proxy_Broker : public virtual _TAO_AliasDef_Proxy_Broker
{
public: 
  _TAO_AliasDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_AliasDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_AliasDef_Proxy_Impl &select_proxy (
    CORBA_AliasDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_AliasDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_AliasDef_Remote_Proxy_Broker *the_TAO_AliasDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF___VAR_CH_)
#define _CORBA_NATIVEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_NativeDef_var : public TAO_Base_var
{
public:
  CORBA_NativeDef_var (void); // default constructor
  CORBA_NativeDef_var (CORBA_NativeDef_ptr p) : ptr_ (p) {} 
  CORBA_NativeDef_var (const CORBA_NativeDef_var &); // copy constructor
  ~CORBA_NativeDef_var (void); // destructor
  
  CORBA_NativeDef_var &operator= (CORBA_NativeDef_ptr);
  CORBA_NativeDef_var &operator= (const CORBA_NativeDef_var &);
  CORBA_NativeDef_ptr operator-> (void) const;
  
  operator const CORBA_NativeDef_ptr &() const;
  operator CORBA_NativeDef_ptr &();
  // in, inout, out, _retn 
  CORBA_NativeDef_ptr in (void) const;
  CORBA_NativeDef_ptr &inout (void);
  CORBA_NativeDef_ptr &out (void);
  CORBA_NativeDef_ptr _retn (void);
  CORBA_NativeDef_ptr ptr (void) const;

private:
  CORBA_NativeDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_NativeDef_var (const TAO_Base_var &rhs);
  CORBA_NativeDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF___OUT_CH_)
#define _CORBA_NATIVEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_NativeDef_out
{
public:
  CORBA_NativeDef_out (CORBA_NativeDef_ptr &);
  CORBA_NativeDef_out (CORBA_NativeDef_var &);
  CORBA_NativeDef_out (const CORBA_NativeDef_out &);
  CORBA_NativeDef_out &operator= (const CORBA_NativeDef_out &);
  CORBA_NativeDef_out &operator= (const CORBA_NativeDef_var &);
  CORBA_NativeDef_out &operator= (CORBA_NativeDef_ptr);
  operator CORBA_NativeDef_ptr &();
  CORBA_NativeDef_ptr &ptr (void);
  CORBA_NativeDef_ptr operator-> (void);
  
private:
  CORBA_NativeDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF_CH_)
#define _CORBA_NATIVEDEF_CH_

// Forward Classes Declaration
class _TAO_NativeDef_Proxy_Impl;
class _TAO_NativeDef_Remote_Proxy_Impl;
class _TAO_NativeDef_Proxy_Broker;
class _TAO_NativeDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_NativeDef: public virtual CORBA_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_NativeDef_ptr _ptr_type;
  typedef CORBA_NativeDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_NativeDef_ptr _duplicate (CORBA_NativeDef_ptr obj);
  static CORBA_NativeDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_NativeDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_NativeDef_ptr _nil (void)
    {
      return (CORBA_NativeDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_NativeDef_Proxy_Broker *the_TAO_NativeDef_Proxy_Broker_;
  
protected:
  CORBA_NativeDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_NativeDef_setup_collocation (int collocated);
    
    CORBA_NativeDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_NativeDef_Remote_Proxy_Impl;
    friend class _TAO_NativeDef_ThruPOA_Proxy_Impl;
    friend class _TAO_NativeDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_NativeDef (void);
private:
  CORBA_NativeDef (const CORBA_NativeDef &);
  void operator= (const CORBA_NativeDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_NativeDef_Proxy_Impl : 
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_NativeDef_Proxy_Impl (void) { }
  
  protected:
  _TAO_NativeDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_NativeDef_Remote_Proxy_Impl : 
  public virtual _TAO_NativeDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl
  
{
public:
  _TAO_NativeDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_NativeDef_Remote_Proxy_Impl (void) { }
  
  };

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_NativeDef_Proxy_Broker
{
public:
  virtual ~_TAO_NativeDef_Proxy_Broker (void);
  virtual _TAO_NativeDef_Proxy_Impl &select_proxy (
    CORBA_NativeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_NativeDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_NativeDef_Remote_Proxy_Broker : public virtual _TAO_NativeDef_Proxy_Broker
{
public: 
  _TAO_NativeDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_NativeDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_NativeDef_Proxy_Impl &select_proxy (
    CORBA_NativeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_NativeDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_NativeDef_Remote_Proxy_Broker *the_TAO_NativeDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF___VAR_CH_)
#define _CORBA_PRIMITIVEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_PrimitiveDef_var : public TAO_Base_var
{
public:
  CORBA_PrimitiveDef_var (void); // default constructor
  CORBA_PrimitiveDef_var (CORBA_PrimitiveDef_ptr p) : ptr_ (p) {} 
  CORBA_PrimitiveDef_var (const CORBA_PrimitiveDef_var &); // copy constructor
  ~CORBA_PrimitiveDef_var (void); // destructor
  
  CORBA_PrimitiveDef_var &operator= (CORBA_PrimitiveDef_ptr);
  CORBA_PrimitiveDef_var &operator= (const CORBA_PrimitiveDef_var &);
  CORBA_PrimitiveDef_ptr operator-> (void) const;
  
  operator const CORBA_PrimitiveDef_ptr &() const;
  operator CORBA_PrimitiveDef_ptr &();
  // in, inout, out, _retn 
  CORBA_PrimitiveDef_ptr in (void) const;
  CORBA_PrimitiveDef_ptr &inout (void);
  CORBA_PrimitiveDef_ptr &out (void);
  CORBA_PrimitiveDef_ptr _retn (void);
  CORBA_PrimitiveDef_ptr ptr (void) const;

private:
  CORBA_PrimitiveDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_PrimitiveDef_var (const TAO_Base_var &rhs);
  CORBA_PrimitiveDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF___OUT_CH_)
#define _CORBA_PRIMITIVEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_PrimitiveDef_out
{
public:
  CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_ptr &);
  CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_var &);
  CORBA_PrimitiveDef_out (const CORBA_PrimitiveDef_out &);
  CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_out &);
  CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_var &);
  CORBA_PrimitiveDef_out &operator= (CORBA_PrimitiveDef_ptr);
  operator CORBA_PrimitiveDef_ptr &();
  CORBA_PrimitiveDef_ptr &ptr (void);
  CORBA_PrimitiveDef_ptr operator-> (void);
  
private:
  CORBA_PrimitiveDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF_CH_)
#define _CORBA_PRIMITIVEDEF_CH_

// Forward Classes Declaration
class _TAO_PrimitiveDef_Proxy_Impl;
class _TAO_PrimitiveDef_Remote_Proxy_Impl;
class _TAO_PrimitiveDef_Proxy_Broker;
class _TAO_PrimitiveDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_PrimitiveDef: public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_PrimitiveDef_ptr _ptr_type;
  typedef CORBA_PrimitiveDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_PrimitiveDef_ptr _duplicate (CORBA_PrimitiveDef_ptr obj);
  static CORBA_PrimitiveDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_PrimitiveDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_PrimitiveDef_ptr _nil (void)
    {
      return (CORBA_PrimitiveDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::PrimitiveKind kind (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_PrimitiveDef_Proxy_Broker *the_TAO_PrimitiveDef_Proxy_Broker_;
  
protected:
  CORBA_PrimitiveDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_PrimitiveDef_setup_collocation (int collocated);
    
    CORBA_PrimitiveDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_PrimitiveDef_Remote_Proxy_Impl;
    friend class _TAO_PrimitiveDef_ThruPOA_Proxy_Impl;
    friend class _TAO_PrimitiveDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_PrimitiveDef (void);
private:
  CORBA_PrimitiveDef (const CORBA_PrimitiveDef &);
  void operator= (const CORBA_PrimitiveDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_PrimitiveDef_Proxy_Impl : 
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_PrimitiveDef_Proxy_Impl (void) { }
  
    virtual CORBA::PrimitiveKind kind (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_PrimitiveDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_PrimitiveDef_Remote_Proxy_Impl : 
  public virtual _TAO_PrimitiveDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_PrimitiveDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_PrimitiveDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::PrimitiveKind kind (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_PrimitiveDef_Proxy_Broker
{
public:
  virtual ~_TAO_PrimitiveDef_Proxy_Broker (void);
  virtual _TAO_PrimitiveDef_Proxy_Impl &select_proxy (
    CORBA_PrimitiveDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_PrimitiveDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_PrimitiveDef_Remote_Proxy_Broker : public virtual _TAO_PrimitiveDef_Proxy_Broker
{
public: 
  _TAO_PrimitiveDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_PrimitiveDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_PrimitiveDef_Proxy_Impl &select_proxy (
    CORBA_PrimitiveDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_PrimitiveDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_PrimitiveDef_Remote_Proxy_Broker *the_TAO_PrimitiveDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___VAR_CH_)
#define _CORBA_STRINGDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_StringDef_var : public TAO_Base_var
{
public:
  CORBA_StringDef_var (void); // default constructor
  CORBA_StringDef_var (CORBA_StringDef_ptr p) : ptr_ (p) {} 
  CORBA_StringDef_var (const CORBA_StringDef_var &); // copy constructor
  ~CORBA_StringDef_var (void); // destructor
  
  CORBA_StringDef_var &operator= (CORBA_StringDef_ptr);
  CORBA_StringDef_var &operator= (const CORBA_StringDef_var &);
  CORBA_StringDef_ptr operator-> (void) const;
  
  operator const CORBA_StringDef_ptr &() const;
  operator CORBA_StringDef_ptr &();
  // in, inout, out, _retn 
  CORBA_StringDef_ptr in (void) const;
  CORBA_StringDef_ptr &inout (void);
  CORBA_StringDef_ptr &out (void);
  CORBA_StringDef_ptr _retn (void);
  CORBA_StringDef_ptr ptr (void) const;

private:
  CORBA_StringDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_StringDef_var (const TAO_Base_var &rhs);
  CORBA_StringDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___OUT_CH_)
#define _CORBA_STRINGDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_StringDef_out
{
public:
  CORBA_StringDef_out (CORBA_StringDef_ptr &);
  CORBA_StringDef_out (CORBA_StringDef_var &);
  CORBA_StringDef_out (const CORBA_StringDef_out &);
  CORBA_StringDef_out &operator= (const CORBA_StringDef_out &);
  CORBA_StringDef_out &operator= (const CORBA_StringDef_var &);
  CORBA_StringDef_out &operator= (CORBA_StringDef_ptr);
  operator CORBA_StringDef_ptr &();
  CORBA_StringDef_ptr &ptr (void);
  CORBA_StringDef_ptr operator-> (void);
  
private:
  CORBA_StringDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF_CH_)
#define _CORBA_STRINGDEF_CH_

// Forward Classes Declaration
class _TAO_StringDef_Proxy_Impl;
class _TAO_StringDef_Remote_Proxy_Impl;
class _TAO_StringDef_Proxy_Broker;
class _TAO_StringDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_StringDef: public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_StringDef_ptr _ptr_type;
  typedef CORBA_StringDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_StringDef_ptr _duplicate (CORBA_StringDef_ptr obj);
  static CORBA_StringDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_StringDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_StringDef_ptr _nil (void)
    {
      return (CORBA_StringDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong bound (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_StringDef_Proxy_Broker *the_TAO_StringDef_Proxy_Broker_;
  
protected:
  CORBA_StringDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_StringDef_setup_collocation (int collocated);
    
    CORBA_StringDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_StringDef_Remote_Proxy_Impl;
    friend class _TAO_StringDef_ThruPOA_Proxy_Impl;
    friend class _TAO_StringDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_StringDef (void);
private:
  CORBA_StringDef (const CORBA_StringDef &);
  void operator= (const CORBA_StringDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_StringDef_Proxy_Impl : 
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_StringDef_Proxy_Impl (void) { }
  
    virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_StringDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_StringDef_Remote_Proxy_Impl : 
  public virtual _TAO_StringDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_StringDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_StringDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_StringDef_Proxy_Broker
{
public:
  virtual ~_TAO_StringDef_Proxy_Broker (void);
  virtual _TAO_StringDef_Proxy_Impl &select_proxy (
    CORBA_StringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_StringDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_StringDef_Remote_Proxy_Broker : public virtual _TAO_StringDef_Proxy_Broker
{
public: 
  _TAO_StringDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_StringDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_StringDef_Proxy_Impl &select_proxy (
    CORBA_StringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_StringDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_StringDef_Remote_Proxy_Broker *the_TAO_StringDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF___VAR_CH_)
#define _CORBA_WSTRINGDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_WstringDef_var : public TAO_Base_var
{
public:
  CORBA_WstringDef_var (void); // default constructor
  CORBA_WstringDef_var (CORBA_WstringDef_ptr p) : ptr_ (p) {} 
  CORBA_WstringDef_var (const CORBA_WstringDef_var &); // copy constructor
  ~CORBA_WstringDef_var (void); // destructor
  
  CORBA_WstringDef_var &operator= (CORBA_WstringDef_ptr);
  CORBA_WstringDef_var &operator= (const CORBA_WstringDef_var &);
  CORBA_WstringDef_ptr operator-> (void) const;
  
  operator const CORBA_WstringDef_ptr &() const;
  operator CORBA_WstringDef_ptr &();
  // in, inout, out, _retn 
  CORBA_WstringDef_ptr in (void) const;
  CORBA_WstringDef_ptr &inout (void);
  CORBA_WstringDef_ptr &out (void);
  CORBA_WstringDef_ptr _retn (void);
  CORBA_WstringDef_ptr ptr (void) const;

private:
  CORBA_WstringDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_WstringDef_var (const TAO_Base_var &rhs);
  CORBA_WstringDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF___OUT_CH_)
#define _CORBA_WSTRINGDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_WstringDef_out
{
public:
  CORBA_WstringDef_out (CORBA_WstringDef_ptr &);
  CORBA_WstringDef_out (CORBA_WstringDef_var &);
  CORBA_WstringDef_out (const CORBA_WstringDef_out &);
  CORBA_WstringDef_out &operator= (const CORBA_WstringDef_out &);
  CORBA_WstringDef_out &operator= (const CORBA_WstringDef_var &);
  CORBA_WstringDef_out &operator= (CORBA_WstringDef_ptr);
  operator CORBA_WstringDef_ptr &();
  CORBA_WstringDef_ptr &ptr (void);
  CORBA_WstringDef_ptr operator-> (void);
  
private:
  CORBA_WstringDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF_CH_)
#define _CORBA_WSTRINGDEF_CH_

// Forward Classes Declaration
class _TAO_WstringDef_Proxy_Impl;
class _TAO_WstringDef_Remote_Proxy_Impl;
class _TAO_WstringDef_Proxy_Broker;
class _TAO_WstringDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_WstringDef: public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_WstringDef_ptr _ptr_type;
  typedef CORBA_WstringDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_WstringDef_ptr _duplicate (CORBA_WstringDef_ptr obj);
  static CORBA_WstringDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_WstringDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_WstringDef_ptr _nil (void)
    {
      return (CORBA_WstringDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong bound (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_WstringDef_Proxy_Broker *the_TAO_WstringDef_Proxy_Broker_;
  
protected:
  CORBA_WstringDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_WstringDef_setup_collocation (int collocated);
    
    CORBA_WstringDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_WstringDef_Remote_Proxy_Impl;
    friend class _TAO_WstringDef_ThruPOA_Proxy_Impl;
    friend class _TAO_WstringDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_WstringDef (void);
private:
  CORBA_WstringDef (const CORBA_WstringDef &);
  void operator= (const CORBA_WstringDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_WstringDef_Proxy_Impl : 
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_WstringDef_Proxy_Impl (void) { }
  
    virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_WstringDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_WstringDef_Remote_Proxy_Impl : 
  public virtual _TAO_WstringDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_WstringDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_WstringDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_WstringDef_Proxy_Broker
{
public:
  virtual ~_TAO_WstringDef_Proxy_Broker (void);
  virtual _TAO_WstringDef_Proxy_Impl &select_proxy (
    CORBA_WstringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_WstringDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_WstringDef_Remote_Proxy_Broker : public virtual _TAO_WstringDef_Proxy_Broker
{
public: 
  _TAO_WstringDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_WstringDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_WstringDef_Proxy_Impl &select_proxy (
    CORBA_WstringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_WstringDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_WstringDef_Remote_Proxy_Broker *the_TAO_WstringDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF___VAR_CH_)
#define _CORBA_SEQUENCEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_SequenceDef_var : public TAO_Base_var
{
public:
  CORBA_SequenceDef_var (void); // default constructor
  CORBA_SequenceDef_var (CORBA_SequenceDef_ptr p) : ptr_ (p) {} 
  CORBA_SequenceDef_var (const CORBA_SequenceDef_var &); // copy constructor
  ~CORBA_SequenceDef_var (void); // destructor
  
  CORBA_SequenceDef_var &operator= (CORBA_SequenceDef_ptr);
  CORBA_SequenceDef_var &operator= (const CORBA_SequenceDef_var &);
  CORBA_SequenceDef_ptr operator-> (void) const;
  
  operator const CORBA_SequenceDef_ptr &() const;
  operator CORBA_SequenceDef_ptr &();
  // in, inout, out, _retn 
  CORBA_SequenceDef_ptr in (void) const;
  CORBA_SequenceDef_ptr &inout (void);
  CORBA_SequenceDef_ptr &out (void);
  CORBA_SequenceDef_ptr _retn (void);
  CORBA_SequenceDef_ptr ptr (void) const;

private:
  CORBA_SequenceDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_SequenceDef_var (const TAO_Base_var &rhs);
  CORBA_SequenceDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF___OUT_CH_)
#define _CORBA_SEQUENCEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_SequenceDef_out
{
public:
  CORBA_SequenceDef_out (CORBA_SequenceDef_ptr &);
  CORBA_SequenceDef_out (CORBA_SequenceDef_var &);
  CORBA_SequenceDef_out (const CORBA_SequenceDef_out &);
  CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_out &);
  CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_var &);
  CORBA_SequenceDef_out &operator= (CORBA_SequenceDef_ptr);
  operator CORBA_SequenceDef_ptr &();
  CORBA_SequenceDef_ptr &ptr (void);
  CORBA_SequenceDef_ptr operator-> (void);
  
private:
  CORBA_SequenceDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF_CH_)
#define _CORBA_SEQUENCEDEF_CH_

// Forward Classes Declaration
class _TAO_SequenceDef_Proxy_Impl;
class _TAO_SequenceDef_Remote_Proxy_Impl;
class _TAO_SequenceDef_Proxy_Broker;
class _TAO_SequenceDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_SequenceDef: public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_SequenceDef_ptr _ptr_type;
  typedef CORBA_SequenceDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_SequenceDef_ptr _duplicate (CORBA_SequenceDef_ptr obj);
  static CORBA_SequenceDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_SequenceDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_SequenceDef_ptr _nil (void)
    {
      return (CORBA_SequenceDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong bound (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr element_type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      CORBA::IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_SequenceDef_Proxy_Broker *the_TAO_SequenceDef_Proxy_Broker_;
  
protected:
  CORBA_SequenceDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_SequenceDef_setup_collocation (int collocated);
    
    CORBA_SequenceDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_SequenceDef_Remote_Proxy_Impl;
    friend class _TAO_SequenceDef_ThruPOA_Proxy_Impl;
    friend class _TAO_SequenceDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_SequenceDef (void);
private:
  CORBA_SequenceDef (const CORBA_SequenceDef &);
  void operator= (const CORBA_SequenceDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_SequenceDef_Proxy_Impl : 
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_SequenceDef_Proxy_Impl (void) { }
  
    virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::TypeCode_ptr element_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_SequenceDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_SequenceDef_Remote_Proxy_Impl : 
  public virtual _TAO_SequenceDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_SequenceDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_SequenceDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_SequenceDef_Proxy_Broker
{
public:
  virtual ~_TAO_SequenceDef_Proxy_Broker (void);
  virtual _TAO_SequenceDef_Proxy_Impl &select_proxy (
    CORBA_SequenceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_SequenceDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_SequenceDef_Remote_Proxy_Broker : public virtual _TAO_SequenceDef_Proxy_Broker
{
public: 
  _TAO_SequenceDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_SequenceDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_SequenceDef_Proxy_Impl &select_proxy (
    CORBA_SequenceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_SequenceDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_SequenceDef_Remote_Proxy_Broker *the_TAO_SequenceDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___VAR_CH_)
#define _CORBA_ARRAYDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ArrayDef_var : public TAO_Base_var
{
public:
  CORBA_ArrayDef_var (void); // default constructor
  CORBA_ArrayDef_var (CORBA_ArrayDef_ptr p) : ptr_ (p) {} 
  CORBA_ArrayDef_var (const CORBA_ArrayDef_var &); // copy constructor
  ~CORBA_ArrayDef_var (void); // destructor
  
  CORBA_ArrayDef_var &operator= (CORBA_ArrayDef_ptr);
  CORBA_ArrayDef_var &operator= (const CORBA_ArrayDef_var &);
  CORBA_ArrayDef_ptr operator-> (void) const;
  
  operator const CORBA_ArrayDef_ptr &() const;
  operator CORBA_ArrayDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ArrayDef_ptr in (void) const;
  CORBA_ArrayDef_ptr &inout (void);
  CORBA_ArrayDef_ptr &out (void);
  CORBA_ArrayDef_ptr _retn (void);
  CORBA_ArrayDef_ptr ptr (void) const;

private:
  CORBA_ArrayDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ArrayDef_var (const TAO_Base_var &rhs);
  CORBA_ArrayDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___OUT_CH_)
#define _CORBA_ARRAYDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ArrayDef_out
{
public:
  CORBA_ArrayDef_out (CORBA_ArrayDef_ptr &);
  CORBA_ArrayDef_out (CORBA_ArrayDef_var &);
  CORBA_ArrayDef_out (const CORBA_ArrayDef_out &);
  CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_out &);
  CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_var &);
  CORBA_ArrayDef_out &operator= (CORBA_ArrayDef_ptr);
  operator CORBA_ArrayDef_ptr &();
  CORBA_ArrayDef_ptr &ptr (void);
  CORBA_ArrayDef_ptr operator-> (void);
  
private:
  CORBA_ArrayDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF_CH_)
#define _CORBA_ARRAYDEF_CH_

// Forward Classes Declaration
class _TAO_ArrayDef_Proxy_Impl;
class _TAO_ArrayDef_Remote_Proxy_Impl;
class _TAO_ArrayDef_Proxy_Broker;
class _TAO_ArrayDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ArrayDef: public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ArrayDef_ptr _ptr_type;
  typedef CORBA_ArrayDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ArrayDef_ptr _duplicate (CORBA_ArrayDef_ptr obj);
  static CORBA_ArrayDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ArrayDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ArrayDef_ptr _nil (void)
    {
      return (CORBA_ArrayDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong length (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void length (
      CORBA::ULong length,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr element_type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      CORBA::IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ArrayDef_Proxy_Broker *the_TAO_ArrayDef_Proxy_Broker_;
  
protected:
  CORBA_ArrayDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ArrayDef_setup_collocation (int collocated);
    
    CORBA_ArrayDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_ArrayDef_Remote_Proxy_Impl;
    friend class _TAO_ArrayDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ArrayDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ArrayDef (void);
private:
  CORBA_ArrayDef (const CORBA_ArrayDef &);
  void operator= (const CORBA_ArrayDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ArrayDef_Proxy_Impl : 
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_ArrayDef_Proxy_Impl (void) { }
  
    virtual CORBA::ULong length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::TypeCode_ptr element_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ArrayDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ArrayDef_Remote_Proxy_Impl : 
  public virtual _TAO_ArrayDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_ArrayDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_ArrayDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::ULong length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ArrayDef_Proxy_Broker
{
public:
  virtual ~_TAO_ArrayDef_Proxy_Broker (void);
  virtual _TAO_ArrayDef_Proxy_Impl &select_proxy (
    CORBA_ArrayDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ArrayDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ArrayDef_Remote_Proxy_Broker : public virtual _TAO_ArrayDef_Proxy_Broker
{
public: 
  _TAO_ArrayDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_ArrayDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_ArrayDef_Proxy_Impl &select_proxy (
    CORBA_ArrayDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ArrayDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ArrayDef_Remote_Proxy_Broker *the_TAO_ArrayDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF___VAR_CH_)
#define _CORBA_EXCEPTIONDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_ExceptionDef_var : public TAO_Base_var
{
public:
  CORBA_ExceptionDef_var (void); // default constructor
  CORBA_ExceptionDef_var (CORBA_ExceptionDef_ptr p) : ptr_ (p) {} 
  CORBA_ExceptionDef_var (const CORBA_ExceptionDef_var &); // copy constructor
  ~CORBA_ExceptionDef_var (void); // destructor
  
  CORBA_ExceptionDef_var &operator= (CORBA_ExceptionDef_ptr);
  CORBA_ExceptionDef_var &operator= (const CORBA_ExceptionDef_var &);
  CORBA_ExceptionDef_ptr operator-> (void) const;
  
  operator const CORBA_ExceptionDef_ptr &() const;
  operator CORBA_ExceptionDef_ptr &();
  // in, inout, out, _retn 
  CORBA_ExceptionDef_ptr in (void) const;
  CORBA_ExceptionDef_ptr &inout (void);
  CORBA_ExceptionDef_ptr &out (void);
  CORBA_ExceptionDef_ptr _retn (void);
  CORBA_ExceptionDef_ptr ptr (void) const;

private:
  CORBA_ExceptionDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_ExceptionDef_var (const TAO_Base_var &rhs);
  CORBA_ExceptionDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF___OUT_CH_)
#define _CORBA_EXCEPTIONDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_ExceptionDef_out
{
public:
  CORBA_ExceptionDef_out (CORBA_ExceptionDef_ptr &);
  CORBA_ExceptionDef_out (CORBA_ExceptionDef_var &);
  CORBA_ExceptionDef_out (const CORBA_ExceptionDef_out &);
  CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_out &);
  CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_var &);
  CORBA_ExceptionDef_out &operator= (CORBA_ExceptionDef_ptr);
  operator CORBA_ExceptionDef_ptr &();
  CORBA_ExceptionDef_ptr &ptr (void);
  CORBA_ExceptionDef_ptr operator-> (void);
  
private:
  CORBA_ExceptionDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF_CH_)
#define _CORBA_EXCEPTIONDEF_CH_

// Forward Classes Declaration
class _TAO_ExceptionDef_Proxy_Impl;
class _TAO_ExceptionDef_Remote_Proxy_Impl;
class _TAO_ExceptionDef_Proxy_Broker;
class _TAO_ExceptionDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_ExceptionDef: public virtual CORBA_Contained, public virtual CORBA_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ExceptionDef_ptr _ptr_type;
  typedef CORBA_ExceptionDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_ExceptionDef_ptr _duplicate (CORBA_ExceptionDef_ptr obj);
  static CORBA_ExceptionDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ExceptionDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_ExceptionDef_ptr _nil (void)
    {
      return (CORBA_ExceptionDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::StructMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ExceptionDef_Proxy_Broker *the_TAO_ExceptionDef_Proxy_Broker_;
  
protected:
  CORBA_ExceptionDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_ExceptionDef_setup_collocation (int collocated);
    
    CORBA_ExceptionDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_ExceptionDef_Remote_Proxy_Impl;
    friend class _TAO_ExceptionDef_ThruPOA_Proxy_Impl;
    friend class _TAO_ExceptionDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_ExceptionDef (void);
private:
  CORBA_ExceptionDef (const CORBA_ExceptionDef &);
  void operator= (const CORBA_ExceptionDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ExceptionDef_Proxy_Impl : 
  public virtual _TAO_Contained_Proxy_Impl, 
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_ExceptionDef_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ExceptionDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_ExceptionDef_Remote_Proxy_Impl : 
  public virtual _TAO_ExceptionDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl, 
  public virtual _TAO_Container_Remote_Proxy_Impl
  
{
public:
  _TAO_ExceptionDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_ExceptionDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ExceptionDef_Proxy_Broker
{
public:
  virtual ~_TAO_ExceptionDef_Proxy_Broker (void);
  virtual _TAO_ExceptionDef_Proxy_Impl &select_proxy (
    CORBA_ExceptionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ExceptionDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_ExceptionDef_Remote_Proxy_Broker : public virtual _TAO_ExceptionDef_Proxy_Broker
{
public: 
  _TAO_ExceptionDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_ExceptionDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_ExceptionDef_Proxy_Impl &select_proxy (
    CORBA_ExceptionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ExceptionDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ExceptionDef_Remote_Proxy_Broker *the_TAO_ExceptionDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_ExceptionDescription;
class CORBA_ExceptionDescription_var;

struct TAO_IFR_Client_Export CORBA_ExceptionDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ExceptionDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
};

class TAO_IFR_Client_Export CORBA_ExceptionDescription_var
{
public:
  CORBA_ExceptionDescription_var (void); // default constructor
  CORBA_ExceptionDescription_var (CORBA_ExceptionDescription *);
  CORBA_ExceptionDescription_var (const CORBA_ExceptionDescription_var &); // copy constructor
  ~CORBA_ExceptionDescription_var (void); // destructor
  
  CORBA_ExceptionDescription_var &operator= (CORBA_ExceptionDescription *);
  CORBA_ExceptionDescription_var &operator= (const CORBA_ExceptionDescription_var &);
  CORBA_ExceptionDescription *operator-> (void);
  const CORBA_ExceptionDescription *operator-> (void) const;
  
  operator const CORBA_ExceptionDescription &() const;
  operator CORBA_ExceptionDescription &();
  operator CORBA_ExceptionDescription &() const;
  operator CORBA_ExceptionDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_ExceptionDescription &in (void) const;
  CORBA_ExceptionDescription &inout (void);
  CORBA_ExceptionDescription *&out (void);
  CORBA_ExceptionDescription *_retn (void);
  CORBA_ExceptionDescription *ptr (void) const;

private:
  CORBA_ExceptionDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_ExceptionDescription_out
{
public:
  CORBA_ExceptionDescription_out (CORBA_ExceptionDescription *&);
  CORBA_ExceptionDescription_out (CORBA_ExceptionDescription_var &);
  CORBA_ExceptionDescription_out (const CORBA_ExceptionDescription_out &);
  CORBA_ExceptionDescription_out &operator= (const CORBA_ExceptionDescription_out &);
  CORBA_ExceptionDescription_out &operator= (CORBA_ExceptionDescription *);
  operator CORBA_ExceptionDescription *&();
  CORBA_ExceptionDescription *&ptr (void);
  CORBA_ExceptionDescription *operator-> (void);
  
private:
  CORBA_ExceptionDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ExceptionDescription_var &);
};


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CH_

  class _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_ExceptionDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void);
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq &rhs);
    TAO_Object_Manager<CORBA::ExceptionDef,CORBA::ExceptionDef_var> operator[] (CORBA::ULong index) const;
    static CORBA_ExceptionDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (CORBA_ExceptionDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    CORBA_ExceptionDef* *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_ExceptionDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV = 
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;
    
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_EXCEPTIONDEFSEQ_CH_)
#define _CORBA_EXCEPTIONDEFSEQ_CH_

class CORBA_ExceptionDefSeq;
class CORBA_ExceptionDefSeq_var;

// *************************************************************
// CORBA_ExceptionDefSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_ExceptionDefSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_ExceptionDefSeq (void); // default ctor
  CORBA_ExceptionDefSeq (CORBA::ULong max); // uses max size
  CORBA_ExceptionDefSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA_ExceptionDef_ptr *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_ExceptionDefSeq (const CORBA_ExceptionDefSeq &); // copy ctor
  ~CORBA_ExceptionDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ExceptionDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEFSEQ___VAR_CH_)
#define _CORBA_EXCEPTIONDEFSEQ___VAR_CH_

// *************************************************************
// class CORBA_ExceptionDefSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_ExceptionDefSeq_var
{
public:
  CORBA_ExceptionDefSeq_var (void); // default constructor
  CORBA_ExceptionDefSeq_var (CORBA_ExceptionDefSeq *);
  CORBA_ExceptionDefSeq_var (const CORBA_ExceptionDefSeq_var &); // copy constructor
  ~CORBA_ExceptionDefSeq_var (void); // destructor
  
  CORBA_ExceptionDefSeq_var &operator= (CORBA_ExceptionDefSeq *);
  CORBA_ExceptionDefSeq_var &operator= (const CORBA_ExceptionDefSeq_var &);
  CORBA_ExceptionDefSeq *operator-> (void);
  const CORBA_ExceptionDefSeq *operator-> (void) const;
  
  operator const CORBA_ExceptionDefSeq &() const;
  operator CORBA_ExceptionDefSeq &();
  operator CORBA_ExceptionDefSeq &() const;
  operator CORBA_ExceptionDefSeq *&(); // variable-size base types only
  
  TAO_Object_Manager<CORBA::ExceptionDef, CORBA::ExceptionDef_var> operator[] (CORBA::ULong index);
  
  // in, inout, out, _retn 
  const CORBA_ExceptionDefSeq &in (void) const;
  CORBA_ExceptionDefSeq &inout (void);
  CORBA_ExceptionDefSeq *&out (void);
  CORBA_ExceptionDefSeq *_retn (void);
  CORBA_ExceptionDefSeq *ptr (void) const;

private:
  CORBA_ExceptionDefSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEFSEQ___OUT_CH_)
#define _CORBA_EXCEPTIONDEFSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_ExceptionDefSeq_out
{
public:
  CORBA_ExceptionDefSeq_out (CORBA_ExceptionDefSeq *&);
  CORBA_ExceptionDefSeq_out (CORBA_ExceptionDefSeq_var &);
  CORBA_ExceptionDefSeq_out (const CORBA_ExceptionDefSeq_out &);
  CORBA_ExceptionDefSeq_out &operator= (const CORBA_ExceptionDefSeq_out &);
  CORBA_ExceptionDefSeq_out &operator= (CORBA_ExceptionDefSeq *);
  operator CORBA_ExceptionDefSeq *&();
  CORBA_ExceptionDefSeq *&ptr (void);
  CORBA_ExceptionDefSeq *operator-> (void);
  TAO_Object_Manager<CORBA::ExceptionDef, CORBA::ExceptionDef_var> operator[] (CORBA::ULong index);
  
private:
  CORBA_ExceptionDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ExceptionDefSeq_var &);
};


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (CORBA::ULong maximum); 
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_ExceptionDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void); // Dtor.
    // = Accessors.
    CORBA_ExceptionDescription &operator[] (CORBA::ULong i);
    const CORBA_ExceptionDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static CORBA_ExceptionDescription *allocbuf (CORBA::ULong size);
    static void freebuf (CORBA_ExceptionDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    
    CORBA_ExceptionDescription *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_ExceptionDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ExceptionDescription *data,
      CORBA::Boolean release);
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_EXCDESCRIPTIONSEQ_CH_)
#define _CORBA_EXCDESCRIPTIONSEQ_CH_

class CORBA_ExcDescriptionSeq;
class CORBA_ExcDescriptionSeq_var;

// *************************************************************
// CORBA_ExcDescriptionSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_ExcDescriptionSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_ExcDescriptionSeq (void); // default ctor
  CORBA_ExcDescriptionSeq (CORBA::ULong max); // uses max size
  CORBA_ExcDescriptionSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA::ExceptionDescription *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_ExcDescriptionSeq (const CORBA_ExcDescriptionSeq &); // copy ctor
  ~CORBA_ExcDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ExcDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_EXCDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_EXCDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
// class CORBA_ExcDescriptionSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_ExcDescriptionSeq_var
{
public:
  CORBA_ExcDescriptionSeq_var (void); // default constructor
  CORBA_ExcDescriptionSeq_var (CORBA_ExcDescriptionSeq *);
  CORBA_ExcDescriptionSeq_var (const CORBA_ExcDescriptionSeq_var &); // copy constructor
  ~CORBA_ExcDescriptionSeq_var (void); // destructor
  
  CORBA_ExcDescriptionSeq_var &operator= (CORBA_ExcDescriptionSeq *);
  CORBA_ExcDescriptionSeq_var &operator= (const CORBA_ExcDescriptionSeq_var &);
  CORBA_ExcDescriptionSeq *operator-> (void);
  const CORBA_ExcDescriptionSeq *operator-> (void) const;
  
  operator const CORBA_ExcDescriptionSeq &() const;
  operator CORBA_ExcDescriptionSeq &();
  operator CORBA_ExcDescriptionSeq &() const;
  operator CORBA_ExcDescriptionSeq *&(); // variable-size base types only
  
  CORBA::ExceptionDescription & operator[] (CORBA::ULong index);
  const CORBA::ExceptionDescription & operator[] (CORBA::ULong index) const;
  
  // in, inout, out, _retn 
  const CORBA_ExcDescriptionSeq &in (void) const;
  CORBA_ExcDescriptionSeq &inout (void);
  CORBA_ExcDescriptionSeq *&out (void);
  CORBA_ExcDescriptionSeq *_retn (void);
  CORBA_ExcDescriptionSeq *ptr (void) const;

private:
  CORBA_ExcDescriptionSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_EXCDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_EXCDESCRIPTIONSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_ExcDescriptionSeq_out
{
public:
  CORBA_ExcDescriptionSeq_out (CORBA_ExcDescriptionSeq *&);
  CORBA_ExcDescriptionSeq_out (CORBA_ExcDescriptionSeq_var &);
  CORBA_ExcDescriptionSeq_out (const CORBA_ExcDescriptionSeq_out &);
  CORBA_ExcDescriptionSeq_out &operator= (const CORBA_ExcDescriptionSeq_out &);
  CORBA_ExcDescriptionSeq_out &operator= (CORBA_ExcDescriptionSeq *);
  operator CORBA_ExcDescriptionSeq *&();
  CORBA_ExcDescriptionSeq *&ptr (void);
  CORBA_ExcDescriptionSeq *operator-> (void);
  CORBA::ExceptionDescription & operator[] (CORBA::ULong index);
  
private:
  CORBA_ExcDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ExcDescriptionSeq_var &);
};


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRIBUTEDEF___VAR_CH_)
#define _CORBA_ATTRIBUTEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_AttributeDef_var : public TAO_Base_var
{
public:
  CORBA_AttributeDef_var (void); // default constructor
  CORBA_AttributeDef_var (CORBA_AttributeDef_ptr p) : ptr_ (p) {} 
  CORBA_AttributeDef_var (const CORBA_AttributeDef_var &); // copy constructor
  ~CORBA_AttributeDef_var (void); // destructor
  
  CORBA_AttributeDef_var &operator= (CORBA_AttributeDef_ptr);
  CORBA_AttributeDef_var &operator= (const CORBA_AttributeDef_var &);
  CORBA_AttributeDef_ptr operator-> (void) const;
  
  operator const CORBA_AttributeDef_ptr &() const;
  operator CORBA_AttributeDef_ptr &();
  // in, inout, out, _retn 
  CORBA_AttributeDef_ptr in (void) const;
  CORBA_AttributeDef_ptr &inout (void);
  CORBA_AttributeDef_ptr &out (void);
  CORBA_AttributeDef_ptr _retn (void);
  CORBA_AttributeDef_ptr ptr (void) const;

private:
  CORBA_AttributeDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_AttributeDef_var (const TAO_Base_var &rhs);
  CORBA_AttributeDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRIBUTEDEF___OUT_CH_)
#define _CORBA_ATTRIBUTEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_AttributeDef_out
{
public:
  CORBA_AttributeDef_out (CORBA_AttributeDef_ptr &);
  CORBA_AttributeDef_out (CORBA_AttributeDef_var &);
  CORBA_AttributeDef_out (const CORBA_AttributeDef_out &);
  CORBA_AttributeDef_out &operator= (const CORBA_AttributeDef_out &);
  CORBA_AttributeDef_out &operator= (const CORBA_AttributeDef_var &);
  CORBA_AttributeDef_out &operator= (CORBA_AttributeDef_ptr);
  operator CORBA_AttributeDef_ptr &();
  CORBA_AttributeDef_ptr &ptr (void);
  CORBA_AttributeDef_ptr operator-> (void);
  
private:
  CORBA_AttributeDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRIBUTEDEF_CH_)
#define _CORBA_ATTRIBUTEDEF_CH_

// Forward Classes Declaration
class _TAO_AttributeDef_Proxy_Impl;
class _TAO_AttributeDef_Remote_Proxy_Impl;
class _TAO_AttributeDef_Proxy_Broker;
class _TAO_AttributeDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_AttributeDef: public virtual CORBA_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_AttributeDef_ptr _ptr_type;
  typedef CORBA_AttributeDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_AttributeDef_ptr _duplicate (CORBA_AttributeDef_ptr obj);
  static CORBA_AttributeDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_AttributeDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_AttributeDef_ptr _nil (void)
    {
      return (CORBA_AttributeDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr type_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA::IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::AttributeMode mode (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_AttributeDef_Proxy_Broker *the_TAO_AttributeDef_Proxy_Broker_;
  
protected:
  CORBA_AttributeDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_AttributeDef_setup_collocation (int collocated);
    
    CORBA_AttributeDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_AttributeDef_Remote_Proxy_Impl;
    friend class _TAO_AttributeDef_ThruPOA_Proxy_Impl;
    friend class _TAO_AttributeDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_AttributeDef (void);
private:
  CORBA_AttributeDef (const CORBA_AttributeDef &);
  void operator= (const CORBA_AttributeDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_AttributeDef_Proxy_Impl : 
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_AttributeDef_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::AttributeMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_AttributeDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_AttributeDef_Remote_Proxy_Impl : 
  public virtual _TAO_AttributeDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl
  
{
public:
  _TAO_AttributeDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_AttributeDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::AttributeMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_AttributeDef_Proxy_Broker
{
public:
  virtual ~_TAO_AttributeDef_Proxy_Broker (void);
  virtual _TAO_AttributeDef_Proxy_Impl &select_proxy (
    CORBA_AttributeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_AttributeDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_AttributeDef_Remote_Proxy_Broker : public virtual _TAO_AttributeDef_Proxy_Broker
{
public: 
  _TAO_AttributeDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_AttributeDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_AttributeDef_Proxy_Impl &select_proxy (
    CORBA_AttributeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_AttributeDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_AttributeDef_Remote_Proxy_Broker *the_TAO_AttributeDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_AttributeDescription;
class CORBA_AttributeDescription_var;

struct TAO_IFR_Client_Export CORBA_AttributeDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_AttributeDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
  CORBA::AttributeMode mode;
};

class TAO_IFR_Client_Export CORBA_AttributeDescription_var
{
public:
  CORBA_AttributeDescription_var (void); // default constructor
  CORBA_AttributeDescription_var (CORBA_AttributeDescription *);
  CORBA_AttributeDescription_var (const CORBA_AttributeDescription_var &); // copy constructor
  ~CORBA_AttributeDescription_var (void); // destructor
  
  CORBA_AttributeDescription_var &operator= (CORBA_AttributeDescription *);
  CORBA_AttributeDescription_var &operator= (const CORBA_AttributeDescription_var &);
  CORBA_AttributeDescription *operator-> (void);
  const CORBA_AttributeDescription *operator-> (void) const;
  
  operator const CORBA_AttributeDescription &() const;
  operator CORBA_AttributeDescription &();
  operator CORBA_AttributeDescription &() const;
  operator CORBA_AttributeDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_AttributeDescription &in (void) const;
  CORBA_AttributeDescription &inout (void);
  CORBA_AttributeDescription *&out (void);
  CORBA_AttributeDescription *_retn (void);
  CORBA_AttributeDescription *ptr (void) const;

private:
  CORBA_AttributeDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_AttributeDescription_out
{
public:
  CORBA_AttributeDescription_out (CORBA_AttributeDescription *&);
  CORBA_AttributeDescription_out (CORBA_AttributeDescription_var &);
  CORBA_AttributeDescription_out (const CORBA_AttributeDescription_out &);
  CORBA_AttributeDescription_out &operator= (const CORBA_AttributeDescription_out &);
  CORBA_AttributeDescription_out &operator= (CORBA_AttributeDescription *);
  operator CORBA_AttributeDescription *&();
  CORBA_AttributeDescription *&ptr (void);
  CORBA_AttributeDescription *operator-> (void);
  
private:
  CORBA_AttributeDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_AttributeDescription_var &);
};

struct CORBA_ParameterDescription;
class CORBA_ParameterDescription_var;

struct TAO_IFR_Client_Export CORBA_ParameterDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ParameterDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  CORBA::TypeCode_var type;
  CORBA::IDLType_var type_def;
  CORBA::ParameterMode mode;
};

class TAO_IFR_Client_Export CORBA_ParameterDescription_var
{
public:
  CORBA_ParameterDescription_var (void); // default constructor
  CORBA_ParameterDescription_var (CORBA_ParameterDescription *);
  CORBA_ParameterDescription_var (const CORBA_ParameterDescription_var &); // copy constructor
  ~CORBA_ParameterDescription_var (void); // destructor
  
  CORBA_ParameterDescription_var &operator= (CORBA_ParameterDescription *);
  CORBA_ParameterDescription_var &operator= (const CORBA_ParameterDescription_var &);
  CORBA_ParameterDescription *operator-> (void);
  const CORBA_ParameterDescription *operator-> (void) const;
  
  operator const CORBA_ParameterDescription &() const;
  operator CORBA_ParameterDescription &();
  operator CORBA_ParameterDescription &() const;
  operator CORBA_ParameterDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_ParameterDescription &in (void) const;
  CORBA_ParameterDescription &inout (void);
  CORBA_ParameterDescription *&out (void);
  CORBA_ParameterDescription *_retn (void);
  CORBA_ParameterDescription *ptr (void) const;

private:
  CORBA_ParameterDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_ParameterDescription_out
{
public:
  CORBA_ParameterDescription_out (CORBA_ParameterDescription *&);
  CORBA_ParameterDescription_out (CORBA_ParameterDescription_var &);
  CORBA_ParameterDescription_out (const CORBA_ParameterDescription_out &);
  CORBA_ParameterDescription_out &operator= (const CORBA_ParameterDescription_out &);
  CORBA_ParameterDescription_out &operator= (CORBA_ParameterDescription *);
  operator CORBA_ParameterDescription *&();
  CORBA_ParameterDescription *&ptr (void);
  CORBA_ParameterDescription *operator-> (void);
  
private:
  CORBA_ParameterDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ParameterDescription_var &);
};


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (CORBA::ULong maximum); 
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_ParameterDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void); // Dtor.
    // = Accessors.
    CORBA_ParameterDescription &operator[] (CORBA::ULong i);
    const CORBA_ParameterDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static CORBA_ParameterDescription *allocbuf (CORBA::ULong size);
    static void freebuf (CORBA_ParameterDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    
    CORBA_ParameterDescription *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_ParameterDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ParameterDescription *data,
      CORBA::Boolean release);
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_PARDESCRIPTIONSEQ_CH_)
#define _CORBA_PARDESCRIPTIONSEQ_CH_

class CORBA_ParDescriptionSeq;
class CORBA_ParDescriptionSeq_var;

// *************************************************************
// CORBA_ParDescriptionSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_ParDescriptionSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_ParDescriptionSeq (void); // default ctor
  CORBA_ParDescriptionSeq (CORBA::ULong max); // uses max size
  CORBA_ParDescriptionSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA::ParameterDescription *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_ParDescriptionSeq (const CORBA_ParDescriptionSeq &); // copy ctor
  ~CORBA_ParDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ParDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_PARDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_PARDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
// class CORBA_ParDescriptionSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_ParDescriptionSeq_var
{
public:
  CORBA_ParDescriptionSeq_var (void); // default constructor
  CORBA_ParDescriptionSeq_var (CORBA_ParDescriptionSeq *);
  CORBA_ParDescriptionSeq_var (const CORBA_ParDescriptionSeq_var &); // copy constructor
  ~CORBA_ParDescriptionSeq_var (void); // destructor
  
  CORBA_ParDescriptionSeq_var &operator= (CORBA_ParDescriptionSeq *);
  CORBA_ParDescriptionSeq_var &operator= (const CORBA_ParDescriptionSeq_var &);
  CORBA_ParDescriptionSeq *operator-> (void);
  const CORBA_ParDescriptionSeq *operator-> (void) const;
  
  operator const CORBA_ParDescriptionSeq &() const;
  operator CORBA_ParDescriptionSeq &();
  operator CORBA_ParDescriptionSeq &() const;
  operator CORBA_ParDescriptionSeq *&(); // variable-size base types only
  
  CORBA::ParameterDescription & operator[] (CORBA::ULong index);
  const CORBA::ParameterDescription & operator[] (CORBA::ULong index) const;
  
  // in, inout, out, _retn 
  const CORBA_ParDescriptionSeq &in (void) const;
  CORBA_ParDescriptionSeq &inout (void);
  CORBA_ParDescriptionSeq *&out (void);
  CORBA_ParDescriptionSeq *_retn (void);
  CORBA_ParDescriptionSeq *ptr (void) const;

private:
  CORBA_ParDescriptionSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_PARDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_PARDESCRIPTIONSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_ParDescriptionSeq_out
{
public:
  CORBA_ParDescriptionSeq_out (CORBA_ParDescriptionSeq *&);
  CORBA_ParDescriptionSeq_out (CORBA_ParDescriptionSeq_var &);
  CORBA_ParDescriptionSeq_out (const CORBA_ParDescriptionSeq_out &);
  CORBA_ParDescriptionSeq_out &operator= (const CORBA_ParDescriptionSeq_out &);
  CORBA_ParDescriptionSeq_out &operator= (CORBA_ParDescriptionSeq *);
  operator CORBA_ParDescriptionSeq *&();
  CORBA_ParDescriptionSeq *&ptr (void);
  CORBA_ParDescriptionSeq *operator-> (void);
  CORBA::ParameterDescription & operator[] (CORBA::ULong index);
  
private:
  CORBA_ParDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ParDescriptionSeq_var &);
};


#endif /* end #if !defined */

typedef char * ContextIdentifier;
typedef CORBA::String_var ContextIdentifier_var;
typedef CORBA::String_out ContextIdentifier_out;

#if !defined (_CORBA_CONTEXTIDSEQ_CH_)
#define _CORBA_CONTEXTIDSEQ_CH_

class CORBA_ContextIdSeq;
class CORBA_ContextIdSeq_var;

// *************************************************************
// CORBA_ContextIdSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_ContextIdSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_ContextIdSeq (void); // default ctor
  CORBA_ContextIdSeq (CORBA::ULong max); // uses max size
  CORBA_ContextIdSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    char * *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_ContextIdSeq (const CORBA_ContextIdSeq &); // copy ctor
  ~CORBA_ContextIdSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_ContextIdSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_CONTEXTIDSEQ___VAR_CH_)
#define _CORBA_CONTEXTIDSEQ___VAR_CH_

// *************************************************************
// class CORBA_ContextIdSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_ContextIdSeq_var
{
public:
  CORBA_ContextIdSeq_var (void); // default constructor
  CORBA_ContextIdSeq_var (CORBA_ContextIdSeq *);
  CORBA_ContextIdSeq_var (const CORBA_ContextIdSeq_var &); // copy constructor
  ~CORBA_ContextIdSeq_var (void); // destructor
  
  CORBA_ContextIdSeq_var &operator= (CORBA_ContextIdSeq *);
  CORBA_ContextIdSeq_var &operator= (const CORBA_ContextIdSeq_var &);
  CORBA_ContextIdSeq *operator-> (void);
  const CORBA_ContextIdSeq *operator-> (void) const;
  
  operator const CORBA_ContextIdSeq &() const;
  operator CORBA_ContextIdSeq &();
  operator CORBA_ContextIdSeq &() const;
  operator CORBA_ContextIdSeq *&(); // variable-size base types only
  
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
  
  // in, inout, out, _retn 
  const CORBA_ContextIdSeq &in (void) const;
  CORBA_ContextIdSeq &inout (void);
  CORBA_ContextIdSeq *&out (void);
  CORBA_ContextIdSeq *_retn (void);
  CORBA_ContextIdSeq *ptr (void) const;

private:
  CORBA_ContextIdSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_CONTEXTIDSEQ___OUT_CH_)
#define _CORBA_CONTEXTIDSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_ContextIdSeq_out
{
public:
  CORBA_ContextIdSeq_out (CORBA_ContextIdSeq *&);
  CORBA_ContextIdSeq_out (CORBA_ContextIdSeq_var &);
  CORBA_ContextIdSeq_out (const CORBA_ContextIdSeq_out &);
  CORBA_ContextIdSeq_out &operator= (const CORBA_ContextIdSeq_out &);
  CORBA_ContextIdSeq_out &operator= (CORBA_ContextIdSeq *);
  operator CORBA_ContextIdSeq *&();
  CORBA_ContextIdSeq *&ptr (void);
  CORBA_ContextIdSeq *operator-> (void);
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
  
private:
  CORBA_ContextIdSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_ContextIdSeq_var &);
};


#endif /* end #if !defined */


#if !defined (_CORBA_OPERATIONDEF___VAR_CH_)
#define _CORBA_OPERATIONDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_OperationDef_var : public TAO_Base_var
{
public:
  CORBA_OperationDef_var (void); // default constructor
  CORBA_OperationDef_var (CORBA_OperationDef_ptr p) : ptr_ (p) {} 
  CORBA_OperationDef_var (const CORBA_OperationDef_var &); // copy constructor
  ~CORBA_OperationDef_var (void); // destructor
  
  CORBA_OperationDef_var &operator= (CORBA_OperationDef_ptr);
  CORBA_OperationDef_var &operator= (const CORBA_OperationDef_var &);
  CORBA_OperationDef_ptr operator-> (void) const;
  
  operator const CORBA_OperationDef_ptr &() const;
  operator CORBA_OperationDef_ptr &();
  // in, inout, out, _retn 
  CORBA_OperationDef_ptr in (void) const;
  CORBA_OperationDef_ptr &inout (void);
  CORBA_OperationDef_ptr &out (void);
  CORBA_OperationDef_ptr _retn (void);
  CORBA_OperationDef_ptr ptr (void) const;

private:
  CORBA_OperationDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_OperationDef_var (const TAO_Base_var &rhs);
  CORBA_OperationDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_OPERATIONDEF___OUT_CH_)
#define _CORBA_OPERATIONDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_OperationDef_out
{
public:
  CORBA_OperationDef_out (CORBA_OperationDef_ptr &);
  CORBA_OperationDef_out (CORBA_OperationDef_var &);
  CORBA_OperationDef_out (const CORBA_OperationDef_out &);
  CORBA_OperationDef_out &operator= (const CORBA_OperationDef_out &);
  CORBA_OperationDef_out &operator= (const CORBA_OperationDef_var &);
  CORBA_OperationDef_out &operator= (CORBA_OperationDef_ptr);
  operator CORBA_OperationDef_ptr &();
  CORBA_OperationDef_ptr &ptr (void);
  CORBA_OperationDef_ptr operator-> (void);
  
private:
  CORBA_OperationDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_OPERATIONDEF_CH_)
#define _CORBA_OPERATIONDEF_CH_

// Forward Classes Declaration
class _TAO_OperationDef_Proxy_Impl;
class _TAO_OperationDef_Remote_Proxy_Impl;
class _TAO_OperationDef_Proxy_Broker;
class _TAO_OperationDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_OperationDef: public virtual CORBA_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_OperationDef_ptr _ptr_type;
  typedef CORBA_OperationDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_OperationDef_ptr _duplicate (CORBA_OperationDef_ptr obj);
  static CORBA_OperationDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_OperationDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_OperationDef_ptr _nil (void)
    {
      return (CORBA_OperationDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr result_def (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void result_def (
      CORBA::IDLType_ptr result_def,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ParDescriptionSeq * params (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void params (
      const CORBA::ParDescriptionSeq & params,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::OperationMode mode (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      CORBA::OperationMode mode,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ContextIdSeq * contexts (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void contexts (
      const CORBA::ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ExceptionDefSeq * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void exceptions (
      const CORBA::ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_OperationDef_Proxy_Broker *the_TAO_OperationDef_Proxy_Broker_;
  
protected:
  CORBA_OperationDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_OperationDef_setup_collocation (int collocated);
    
    CORBA_OperationDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_OperationDef_Remote_Proxy_Impl;
    friend class _TAO_OperationDef_ThruPOA_Proxy_Impl;
    friend class _TAO_OperationDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_OperationDef (void);
private:
  CORBA_OperationDef (const CORBA_OperationDef &);
  void operator= (const CORBA_OperationDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_OperationDef_Proxy_Impl : 
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_OperationDef_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr result (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::IDLType_ptr result_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void result_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr result_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::ParDescriptionSeq * params (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void params (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::ParDescriptionSeq & params,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::OperationMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::OperationMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::ContextIdSeq * contexts (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void contexts (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::ExceptionDefSeq * exceptions (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void exceptions (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_OperationDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_OperationDef_Remote_Proxy_Impl : 
  public virtual _TAO_OperationDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl
  
{
public:
  _TAO_OperationDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_OperationDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::TypeCode_ptr result (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::IDLType_ptr result_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void result_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::IDLType_ptr result_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ParDescriptionSeq * params (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void params (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::ParDescriptionSeq & params,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::OperationMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::OperationMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ContextIdSeq * contexts (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void contexts (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::ExceptionDefSeq * exceptions (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void exceptions (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_OperationDef_Proxy_Broker
{
public:
  virtual ~_TAO_OperationDef_Proxy_Broker (void);
  virtual _TAO_OperationDef_Proxy_Impl &select_proxy (
    CORBA_OperationDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_OperationDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_OperationDef_Remote_Proxy_Broker : public virtual _TAO_OperationDef_Proxy_Broker
{
public: 
  _TAO_OperationDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_OperationDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_OperationDef_Proxy_Impl &select_proxy (
    CORBA_OperationDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_OperationDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_OperationDef_Remote_Proxy_Broker *the_TAO_OperationDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_OperationDescription;
class CORBA_OperationDescription_var;

struct TAO_IFR_Client_Export CORBA_OperationDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_OperationDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var result;
  CORBA::OperationMode mode;
  CORBA::ContextIdSeq contexts;
  CORBA::ParDescriptionSeq parameters;
  CORBA::ExcDescriptionSeq exceptions;
};

class TAO_IFR_Client_Export CORBA_OperationDescription_var
{
public:
  CORBA_OperationDescription_var (void); // default constructor
  CORBA_OperationDescription_var (CORBA_OperationDescription *);
  CORBA_OperationDescription_var (const CORBA_OperationDescription_var &); // copy constructor
  ~CORBA_OperationDescription_var (void); // destructor
  
  CORBA_OperationDescription_var &operator= (CORBA_OperationDescription *);
  CORBA_OperationDescription_var &operator= (const CORBA_OperationDescription_var &);
  CORBA_OperationDescription *operator-> (void);
  const CORBA_OperationDescription *operator-> (void) const;
  
  operator const CORBA_OperationDescription &() const;
  operator CORBA_OperationDescription &();
  operator CORBA_OperationDescription &() const;
  operator CORBA_OperationDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_OperationDescription &in (void) const;
  CORBA_OperationDescription &inout (void);
  CORBA_OperationDescription *&out (void);
  CORBA_OperationDescription *_retn (void);
  CORBA_OperationDescription *ptr (void) const;

private:
  CORBA_OperationDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_OperationDescription_out
{
public:
  CORBA_OperationDescription_out (CORBA_OperationDescription *&);
  CORBA_OperationDescription_out (CORBA_OperationDescription_var &);
  CORBA_OperationDescription_out (const CORBA_OperationDescription_out &);
  CORBA_OperationDescription_out &operator= (const CORBA_OperationDescription_out &);
  CORBA_OperationDescription_out &operator= (CORBA_OperationDescription *);
  operator CORBA_OperationDescription *&();
  CORBA_OperationDescription *&ptr (void);
  CORBA_OperationDescription *operator-> (void);
  
private:
  CORBA_OperationDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_OperationDescription_var &);
};


#if !defined (_CORBA_REPOSITORYIDSEQ_CH_)
#define _CORBA_REPOSITORYIDSEQ_CH_

class CORBA_RepositoryIdSeq;
class CORBA_RepositoryIdSeq_var;

// *************************************************************
// CORBA_RepositoryIdSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_RepositoryIdSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_RepositoryIdSeq (void); // default ctor
  CORBA_RepositoryIdSeq (CORBA::ULong max); // uses max size
  CORBA_RepositoryIdSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    char * *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_RepositoryIdSeq (const CORBA_RepositoryIdSeq &); // copy ctor
  ~CORBA_RepositoryIdSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_RepositoryIdSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORYIDSEQ___VAR_CH_)
#define _CORBA_REPOSITORYIDSEQ___VAR_CH_

// *************************************************************
// class CORBA_RepositoryIdSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_RepositoryIdSeq_var
{
public:
  CORBA_RepositoryIdSeq_var (void); // default constructor
  CORBA_RepositoryIdSeq_var (CORBA_RepositoryIdSeq *);
  CORBA_RepositoryIdSeq_var (const CORBA_RepositoryIdSeq_var &); // copy constructor
  ~CORBA_RepositoryIdSeq_var (void); // destructor
  
  CORBA_RepositoryIdSeq_var &operator= (CORBA_RepositoryIdSeq *);
  CORBA_RepositoryIdSeq_var &operator= (const CORBA_RepositoryIdSeq_var &);
  CORBA_RepositoryIdSeq *operator-> (void);
  const CORBA_RepositoryIdSeq *operator-> (void) const;
  
  operator const CORBA_RepositoryIdSeq &() const;
  operator CORBA_RepositoryIdSeq &();
  operator CORBA_RepositoryIdSeq &() const;
  operator CORBA_RepositoryIdSeq *&(); // variable-size base types only
  
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
  
  // in, inout, out, _retn 
  const CORBA_RepositoryIdSeq &in (void) const;
  CORBA_RepositoryIdSeq &inout (void);
  CORBA_RepositoryIdSeq *&out (void);
  CORBA_RepositoryIdSeq *_retn (void);
  CORBA_RepositoryIdSeq *ptr (void) const;

private:
  CORBA_RepositoryIdSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORYIDSEQ___OUT_CH_)
#define _CORBA_REPOSITORYIDSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_RepositoryIdSeq_out
{
public:
  CORBA_RepositoryIdSeq_out (CORBA_RepositoryIdSeq *&);
  CORBA_RepositoryIdSeq_out (CORBA_RepositoryIdSeq_var &);
  CORBA_RepositoryIdSeq_out (const CORBA_RepositoryIdSeq_out &);
  CORBA_RepositoryIdSeq_out &operator= (const CORBA_RepositoryIdSeq_out &);
  CORBA_RepositoryIdSeq_out &operator= (CORBA_RepositoryIdSeq *);
  operator CORBA_RepositoryIdSeq *&();
  CORBA_RepositoryIdSeq *&ptr (void);
  CORBA_RepositoryIdSeq *operator-> (void);
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
  
private:
  CORBA_RepositoryIdSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_RepositoryIdSeq_var &);
};


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (CORBA::ULong maximum); 
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_OperationDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void); // Dtor.
    // = Accessors.
    CORBA_OperationDescription &operator[] (CORBA::ULong i);
    const CORBA_OperationDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static CORBA_OperationDescription *allocbuf (CORBA::ULong size);
    static void freebuf (CORBA_OperationDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    
    CORBA_OperationDescription *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_OperationDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      CORBA_OperationDescription *data,
      CORBA::Boolean release);
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_OPDESCRIPTIONSEQ_CH_)
#define _CORBA_OPDESCRIPTIONSEQ_CH_

class CORBA_OpDescriptionSeq;
class CORBA_OpDescriptionSeq_var;

// *************************************************************
// CORBA_OpDescriptionSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_OpDescriptionSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_OpDescriptionSeq (void); // default ctor
  CORBA_OpDescriptionSeq (CORBA::ULong max); // uses max size
  CORBA_OpDescriptionSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA::OperationDescription *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_OpDescriptionSeq (const CORBA_OpDescriptionSeq &); // copy ctor
  ~CORBA_OpDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_OpDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_OPDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_OPDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
// class CORBA_OpDescriptionSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_OpDescriptionSeq_var
{
public:
  CORBA_OpDescriptionSeq_var (void); // default constructor
  CORBA_OpDescriptionSeq_var (CORBA_OpDescriptionSeq *);
  CORBA_OpDescriptionSeq_var (const CORBA_OpDescriptionSeq_var &); // copy constructor
  ~CORBA_OpDescriptionSeq_var (void); // destructor
  
  CORBA_OpDescriptionSeq_var &operator= (CORBA_OpDescriptionSeq *);
  CORBA_OpDescriptionSeq_var &operator= (const CORBA_OpDescriptionSeq_var &);
  CORBA_OpDescriptionSeq *operator-> (void);
  const CORBA_OpDescriptionSeq *operator-> (void) const;
  
  operator const CORBA_OpDescriptionSeq &() const;
  operator CORBA_OpDescriptionSeq &();
  operator CORBA_OpDescriptionSeq &() const;
  operator CORBA_OpDescriptionSeq *&(); // variable-size base types only
  
  CORBA::OperationDescription & operator[] (CORBA::ULong index);
  const CORBA::OperationDescription & operator[] (CORBA::ULong index) const;
  
  // in, inout, out, _retn 
  const CORBA_OpDescriptionSeq &in (void) const;
  CORBA_OpDescriptionSeq &inout (void);
  CORBA_OpDescriptionSeq *&out (void);
  CORBA_OpDescriptionSeq *_retn (void);
  CORBA_OpDescriptionSeq *ptr (void) const;

private:
  CORBA_OpDescriptionSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_OPDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_OPDESCRIPTIONSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_OpDescriptionSeq_out
{
public:
  CORBA_OpDescriptionSeq_out (CORBA_OpDescriptionSeq *&);
  CORBA_OpDescriptionSeq_out (CORBA_OpDescriptionSeq_var &);
  CORBA_OpDescriptionSeq_out (const CORBA_OpDescriptionSeq_out &);
  CORBA_OpDescriptionSeq_out &operator= (const CORBA_OpDescriptionSeq_out &);
  CORBA_OpDescriptionSeq_out &operator= (CORBA_OpDescriptionSeq *);
  operator CORBA_OpDescriptionSeq *&();
  CORBA_OpDescriptionSeq *&ptr (void);
  CORBA_OpDescriptionSeq *operator-> (void);
  CORBA::OperationDescription & operator[] (CORBA::ULong index);
  
private:
  CORBA_OpDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_OpDescriptionSeq_var &);
};


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CH_

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.
    
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (CORBA::ULong maximum); 
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      CORBA_AttributeDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void); // Dtor.
    // = Accessors.
    CORBA_AttributeDescription &operator[] (CORBA::ULong i);
    const CORBA_AttributeDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static CORBA_AttributeDescription *allocbuf (CORBA::ULong size);
    static void freebuf (CORBA_AttributeDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)
    
    CORBA_AttributeDescription *get_buffer (CORBA::Boolean orphan = 0);
    const CORBA_AttributeDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      CORBA_AttributeDescription *data,
      CORBA::Boolean release);
  };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_ATTRDESCRIPTIONSEQ_CH_)
#define _CORBA_ATTRDESCRIPTIONSEQ_CH_

class CORBA_AttrDescriptionSeq;
class CORBA_AttrDescriptionSeq_var;

// *************************************************************
// CORBA_AttrDescriptionSeq
// *************************************************************

class TAO_IFR_Client_Export CORBA_AttrDescriptionSeq : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
{
public:
  CORBA_AttrDescriptionSeq (void); // default ctor
  CORBA_AttrDescriptionSeq (CORBA::ULong max); // uses max size
  CORBA_AttrDescriptionSeq (
    CORBA::ULong max, 
    CORBA::ULong length, 
    CORBA::AttributeDescription *buffer, 
    CORBA::Boolean release = 0
  );
  CORBA_AttrDescriptionSeq (const CORBA_AttrDescriptionSeq &); // copy ctor
  ~CORBA_AttrDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_AttrDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

#endif /* end #if !defined */


#if !defined (_CORBA_ATTRDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_ATTRDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
// class CORBA_AttrDescriptionSeq_var
// *************************************************************

class TAO_IFR_Client_Export CORBA_AttrDescriptionSeq_var
{
public:
  CORBA_AttrDescriptionSeq_var (void); // default constructor
  CORBA_AttrDescriptionSeq_var (CORBA_AttrDescriptionSeq *);
  CORBA_AttrDescriptionSeq_var (const CORBA_AttrDescriptionSeq_var &); // copy constructor
  ~CORBA_AttrDescriptionSeq_var (void); // destructor
  
  CORBA_AttrDescriptionSeq_var &operator= (CORBA_AttrDescriptionSeq *);
  CORBA_AttrDescriptionSeq_var &operator= (const CORBA_AttrDescriptionSeq_var &);
  CORBA_AttrDescriptionSeq *operator-> (void);
  const CORBA_AttrDescriptionSeq *operator-> (void) const;
  
  operator const CORBA_AttrDescriptionSeq &() const;
  operator CORBA_AttrDescriptionSeq &();
  operator CORBA_AttrDescriptionSeq &() const;
  operator CORBA_AttrDescriptionSeq *&(); // variable-size base types only
  
  CORBA::AttributeDescription & operator[] (CORBA::ULong index);
  const CORBA::AttributeDescription & operator[] (CORBA::ULong index) const;
  
  // in, inout, out, _retn 
  const CORBA_AttrDescriptionSeq &in (void) const;
  CORBA_AttrDescriptionSeq &inout (void);
  CORBA_AttrDescriptionSeq *&out (void);
  CORBA_AttrDescriptionSeq *_retn (void);
  CORBA_AttrDescriptionSeq *ptr (void) const;

private:
  CORBA_AttrDescriptionSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_ATTRDESCRIPTIONSEQ___OUT_CH_

class TAO_IFR_Client_Export CORBA_AttrDescriptionSeq_out
{
public:
  CORBA_AttrDescriptionSeq_out (CORBA_AttrDescriptionSeq *&);
  CORBA_AttrDescriptionSeq_out (CORBA_AttrDescriptionSeq_var &);
  CORBA_AttrDescriptionSeq_out (const CORBA_AttrDescriptionSeq_out &);
  CORBA_AttrDescriptionSeq_out &operator= (const CORBA_AttrDescriptionSeq_out &);
  CORBA_AttrDescriptionSeq_out &operator= (CORBA_AttrDescriptionSeq *);
  operator CORBA_AttrDescriptionSeq *&();
  CORBA_AttrDescriptionSeq *&ptr (void);
  CORBA_AttrDescriptionSeq *operator-> (void);
  CORBA::AttributeDescription & operator[] (CORBA::ULong index);
  
private:
  CORBA_AttrDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_AttrDescriptionSeq_var &);
};


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___VAR_CH_)
#define _CORBA_INTERFACEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_InterfaceDef_var : public TAO_Base_var
{
public:
  CORBA_InterfaceDef_var (void); // default constructor
  CORBA_InterfaceDef_var (CORBA_InterfaceDef_ptr p) : ptr_ (p) {} 
  CORBA_InterfaceDef_var (const CORBA_InterfaceDef_var &); // copy constructor
  ~CORBA_InterfaceDef_var (void); // destructor
  
  CORBA_InterfaceDef_var &operator= (CORBA_InterfaceDef_ptr);
  CORBA_InterfaceDef_var &operator= (const CORBA_InterfaceDef_var &);
  CORBA_InterfaceDef_ptr operator-> (void) const;
  
  operator const CORBA_InterfaceDef_ptr &() const;
  operator CORBA_InterfaceDef_ptr &();
  // in, inout, out, _retn 
  CORBA_InterfaceDef_ptr in (void) const;
  CORBA_InterfaceDef_ptr &inout (void);
  CORBA_InterfaceDef_ptr &out (void);
  CORBA_InterfaceDef_ptr _retn (void);
  CORBA_InterfaceDef_ptr ptr (void) const;

private:
  CORBA_InterfaceDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_InterfaceDef_var (const TAO_Base_var &rhs);
  CORBA_InterfaceDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___OUT_CH_)
#define _CORBA_INTERFACEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_InterfaceDef_out
{
public:
  CORBA_InterfaceDef_out (CORBA_InterfaceDef_ptr &);
  CORBA_InterfaceDef_out (CORBA_InterfaceDef_var &);
  CORBA_InterfaceDef_out (const CORBA_InterfaceDef_out &);
  CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_out &);
  CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_var &);
  CORBA_InterfaceDef_out &operator= (CORBA_InterfaceDef_ptr);
  operator CORBA_InterfaceDef_ptr &();
  CORBA_InterfaceDef_ptr &ptr (void);
  CORBA_InterfaceDef_ptr operator-> (void);
  
private:
  CORBA_InterfaceDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF_CH_)
#define _CORBA_INTERFACEDEF_CH_

// Forward Classes Declaration
class _TAO_InterfaceDef_Proxy_Impl;
class _TAO_InterfaceDef_Remote_Proxy_Impl;
class _TAO_InterfaceDef_Proxy_Broker;
class _TAO_InterfaceDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_InterfaceDef: public virtual CORBA_Container, public virtual CORBA_Contained, public virtual CORBA_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_InterfaceDef_ptr _ptr_type;
  typedef CORBA_InterfaceDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_InterfaceDef_ptr _duplicate (CORBA_InterfaceDef_ptr obj);
  static CORBA_InterfaceDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_InterfaceDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_InterfaceDef_ptr _nil (void)
    {
      return (CORBA_InterfaceDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::InterfaceDefSeq * base_interfaces (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_interfaces (
      const CORBA::InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      const char * interface_id,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  struct FullInterfaceDescription;
  class FullInterfaceDescription_var;
  
  struct TAO_IFR_Client_Export FullInterfaceDescription
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef FullInterfaceDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::OpDescriptionSeq operations;
    CORBA::AttrDescriptionSeq attributes;
    CORBA::RepositoryIdSeq base_interfaces;
    CORBA::TypeCode_var type;
  };

  class TAO_IFR_Client_Export FullInterfaceDescription_var
  {
  public:
    FullInterfaceDescription_var (void); // default constructor
    FullInterfaceDescription_var (FullInterfaceDescription *);
    FullInterfaceDescription_var (const FullInterfaceDescription_var &); // copy constructor
    ~FullInterfaceDescription_var (void); // destructor
    
    FullInterfaceDescription_var &operator= (FullInterfaceDescription *);
    FullInterfaceDescription_var &operator= (const FullInterfaceDescription_var &);
    FullInterfaceDescription *operator-> (void);
    const FullInterfaceDescription *operator-> (void) const;
    
    operator const FullInterfaceDescription &() const;
    operator FullInterfaceDescription &();
    operator FullInterfaceDescription &() const;
    operator FullInterfaceDescription *&(); // variable-size types only
    
    // in, inout, out, _retn 
    const FullInterfaceDescription &in (void) const;
    FullInterfaceDescription &inout (void);
    FullInterfaceDescription *&out (void);
    FullInterfaceDescription *_retn (void);
    FullInterfaceDescription *ptr (void) const;

  private:
    FullInterfaceDescription *ptr_;
  };

  class TAO_IFR_Client_Export FullInterfaceDescription_out
  {
  public:
    FullInterfaceDescription_out (FullInterfaceDescription *&);
    FullInterfaceDescription_out (FullInterfaceDescription_var &);
    FullInterfaceDescription_out (const FullInterfaceDescription_out &);
    FullInterfaceDescription_out &operator= (const FullInterfaceDescription_out &);
    FullInterfaceDescription_out &operator= (FullInterfaceDescription *);
    operator FullInterfaceDescription *&();
    FullInterfaceDescription *&ptr (void);
    FullInterfaceDescription *operator-> (void);
    
  private:
    FullInterfaceDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const FullInterfaceDescription_var &);
  };

  static CORBA::TypeCode_ptr _tc_FullInterfaceDescription;

  virtual CORBA::InterfaceDef::FullInterfaceDescription * describe_interface (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::AttributeDef_ptr create_attribute (
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::OperationDef_ptr create_operation (
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_InterfaceDef_Proxy_Broker *the_TAO_InterfaceDef_Proxy_Broker_;
  
protected:
  CORBA_InterfaceDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_InterfaceDef_setup_collocation (int collocated);
    
    CORBA_InterfaceDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_InterfaceDef_Remote_Proxy_Impl;
    friend class _TAO_InterfaceDef_ThruPOA_Proxy_Impl;
    friend class _TAO_InterfaceDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_InterfaceDef (void);
private:
  CORBA_InterfaceDef (const CORBA_InterfaceDef &);
  void operator= (const CORBA_InterfaceDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_InterfaceDef_Proxy_Impl : 
  public virtual _TAO_Container_Proxy_Impl, 
  public virtual _TAO_Contained_Proxy_Impl, 
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_InterfaceDef_Proxy_Impl (void) { }
  
    virtual CORBA::InterfaceDefSeq * base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * interface_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::InterfaceDef::FullInterfaceDescription * describe_interface (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_InterfaceDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_InterfaceDef_Remote_Proxy_Impl : 
  public virtual _TAO_InterfaceDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl, 
  public virtual _TAO_Contained_Remote_Proxy_Impl, 
  public virtual _TAO_IDLType_Remote_Proxy_Impl
  
{
public:
  _TAO_InterfaceDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_InterfaceDef_Remote_Proxy_Impl (void) { }
  
    virtual CORBA::InterfaceDefSeq * base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * interface_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::InterfaceDef::FullInterfaceDescription * describe_interface (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_InterfaceDef_Proxy_Broker
{
public:
  virtual ~_TAO_InterfaceDef_Proxy_Broker (void);
  virtual _TAO_InterfaceDef_Proxy_Impl &select_proxy (
    CORBA_InterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_InterfaceDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_InterfaceDef_Remote_Proxy_Broker : public virtual _TAO_InterfaceDef_Proxy_Broker
{
public: 
  _TAO_InterfaceDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_InterfaceDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_InterfaceDef_Proxy_Impl &select_proxy (
    CORBA_InterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_InterfaceDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_InterfaceDef_Remote_Proxy_Broker *the_TAO_InterfaceDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

struct CORBA_InterfaceDescription;
class CORBA_InterfaceDescription_var;

struct TAO_IFR_Client_Export CORBA_InterfaceDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_InterfaceDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::RepositoryIdSeq base_interfaces;
};

class TAO_IFR_Client_Export CORBA_InterfaceDescription_var
{
public:
  CORBA_InterfaceDescription_var (void); // default constructor
  CORBA_InterfaceDescription_var (CORBA_InterfaceDescription *);
  CORBA_InterfaceDescription_var (const CORBA_InterfaceDescription_var &); // copy constructor
  ~CORBA_InterfaceDescription_var (void); // destructor
  
  CORBA_InterfaceDescription_var &operator= (CORBA_InterfaceDescription *);
  CORBA_InterfaceDescription_var &operator= (const CORBA_InterfaceDescription_var &);
  CORBA_InterfaceDescription *operator-> (void);
  const CORBA_InterfaceDescription *operator-> (void) const;
  
  operator const CORBA_InterfaceDescription &() const;
  operator CORBA_InterfaceDescription &();
  operator CORBA_InterfaceDescription &() const;
  operator CORBA_InterfaceDescription *&(); // variable-size types only
  
  // in, inout, out, _retn 
  const CORBA_InterfaceDescription &in (void) const;
  CORBA_InterfaceDescription &inout (void);
  CORBA_InterfaceDescription *&out (void);
  CORBA_InterfaceDescription *_retn (void);
  CORBA_InterfaceDescription *ptr (void) const;

private:
  CORBA_InterfaceDescription *ptr_;
};

class TAO_IFR_Client_Export CORBA_InterfaceDescription_out
{
public:
  CORBA_InterfaceDescription_out (CORBA_InterfaceDescription *&);
  CORBA_InterfaceDescription_out (CORBA_InterfaceDescription_var &);
  CORBA_InterfaceDescription_out (const CORBA_InterfaceDescription_out &);
  CORBA_InterfaceDescription_out &operator= (const CORBA_InterfaceDescription_out &);
  CORBA_InterfaceDescription_out &operator= (CORBA_InterfaceDescription *);
  operator CORBA_InterfaceDescription *&();
  CORBA_InterfaceDescription *&ptr (void);
  CORBA_InterfaceDescription *operator-> (void);
  
private:
  CORBA_InterfaceDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const CORBA_InterfaceDescription_var &);
};


#if !defined (_CORBA_ABSTRACTINTERFACEDEF___VAR_CH_)
#define _CORBA_ABSTRACTINTERFACEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_AbstractInterfaceDef_var : public TAO_Base_var
{
public:
  CORBA_AbstractInterfaceDef_var (void); // default constructor
  CORBA_AbstractInterfaceDef_var (CORBA_AbstractInterfaceDef_ptr p) : ptr_ (p) {} 
  CORBA_AbstractInterfaceDef_var (const CORBA_AbstractInterfaceDef_var &); // copy constructor
  ~CORBA_AbstractInterfaceDef_var (void); // destructor
  
  CORBA_AbstractInterfaceDef_var &operator= (CORBA_AbstractInterfaceDef_ptr);
  CORBA_AbstractInterfaceDef_var &operator= (const CORBA_AbstractInterfaceDef_var &);
  CORBA_AbstractInterfaceDef_ptr operator-> (void) const;
  
  operator const CORBA_AbstractInterfaceDef_ptr &() const;
  operator CORBA_AbstractInterfaceDef_ptr &();
  // in, inout, out, _retn 
  CORBA_AbstractInterfaceDef_ptr in (void) const;
  CORBA_AbstractInterfaceDef_ptr &inout (void);
  CORBA_AbstractInterfaceDef_ptr &out (void);
  CORBA_AbstractInterfaceDef_ptr _retn (void);
  CORBA_AbstractInterfaceDef_ptr ptr (void) const;

private:
  CORBA_AbstractInterfaceDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_AbstractInterfaceDef_var (const TAO_Base_var &rhs);
  CORBA_AbstractInterfaceDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEF___OUT_CH_)
#define _CORBA_ABSTRACTINTERFACEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_AbstractInterfaceDef_out
{
public:
  CORBA_AbstractInterfaceDef_out (CORBA_AbstractInterfaceDef_ptr &);
  CORBA_AbstractInterfaceDef_out (CORBA_AbstractInterfaceDef_var &);
  CORBA_AbstractInterfaceDef_out (const CORBA_AbstractInterfaceDef_out &);
  CORBA_AbstractInterfaceDef_out &operator= (const CORBA_AbstractInterfaceDef_out &);
  CORBA_AbstractInterfaceDef_out &operator= (const CORBA_AbstractInterfaceDef_var &);
  CORBA_AbstractInterfaceDef_out &operator= (CORBA_AbstractInterfaceDef_ptr);
  operator CORBA_AbstractInterfaceDef_ptr &();
  CORBA_AbstractInterfaceDef_ptr &ptr (void);
  CORBA_AbstractInterfaceDef_ptr operator-> (void);
  
private:
  CORBA_AbstractInterfaceDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEF_CH_)
#define _CORBA_ABSTRACTINTERFACEDEF_CH_

// Forward Classes Declaration
class _TAO_AbstractInterfaceDef_Proxy_Impl;
class _TAO_AbstractInterfaceDef_Remote_Proxy_Impl;
class _TAO_AbstractInterfaceDef_Proxy_Broker;
class _TAO_AbstractInterfaceDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_AbstractInterfaceDef: public virtual CORBA_InterfaceDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_AbstractInterfaceDef_ptr _ptr_type;
  typedef CORBA_AbstractInterfaceDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_AbstractInterfaceDef_ptr _duplicate (CORBA_AbstractInterfaceDef_ptr obj);
  static CORBA_AbstractInterfaceDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_AbstractInterfaceDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_AbstractInterfaceDef_ptr _nil (void)
    {
      return (CORBA_AbstractInterfaceDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_AbstractInterfaceDef_Proxy_Broker *the_TAO_AbstractInterfaceDef_Proxy_Broker_;
  
protected:
  CORBA_AbstractInterfaceDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_AbstractInterfaceDef_setup_collocation (int collocated);
    
    CORBA_AbstractInterfaceDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_AbstractInterfaceDef_Remote_Proxy_Impl;
    friend class _TAO_AbstractInterfaceDef_ThruPOA_Proxy_Impl;
    friend class _TAO_AbstractInterfaceDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_AbstractInterfaceDef (void);
private:
  CORBA_AbstractInterfaceDef (const CORBA_AbstractInterfaceDef &);
  void operator= (const CORBA_AbstractInterfaceDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_AbstractInterfaceDef_Proxy_Impl : 
  public virtual _TAO_InterfaceDef_Proxy_Impl
{
public:
  virtual ~_TAO_AbstractInterfaceDef_Proxy_Impl (void) { }
  
  protected:
  _TAO_AbstractInterfaceDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_AbstractInterfaceDef_Remote_Proxy_Impl : 
  public virtual _TAO_AbstractInterfaceDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_InterfaceDef_Remote_Proxy_Impl
  
{
public:
  _TAO_AbstractInterfaceDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_AbstractInterfaceDef_Remote_Proxy_Impl (void) { }
  
  };

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_AbstractInterfaceDef_Proxy_Broker
{
public:
  virtual ~_TAO_AbstractInterfaceDef_Proxy_Broker (void);
  virtual _TAO_AbstractInterfaceDef_Proxy_Impl &select_proxy (
    CORBA_AbstractInterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_AbstractInterfaceDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_AbstractInterfaceDef_Remote_Proxy_Broker : public virtual _TAO_AbstractInterfaceDef_Proxy_Broker
{
public: 
  _TAO_AbstractInterfaceDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_AbstractInterfaceDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_AbstractInterfaceDef_Proxy_Impl &select_proxy (
    CORBA_AbstractInterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_AbstractInterfaceDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_AbstractInterfaceDef_Remote_Proxy_Broker *the_TAO_AbstractInterfaceDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEF___VAR_CH_)
#define _CORBA_LOCALINTERFACEDEF___VAR_CH_

class TAO_IFR_Client_Export CORBA_LocalInterfaceDef_var : public TAO_Base_var
{
public:
  CORBA_LocalInterfaceDef_var (void); // default constructor
  CORBA_LocalInterfaceDef_var (CORBA_LocalInterfaceDef_ptr p) : ptr_ (p) {} 
  CORBA_LocalInterfaceDef_var (const CORBA_LocalInterfaceDef_var &); // copy constructor
  ~CORBA_LocalInterfaceDef_var (void); // destructor
  
  CORBA_LocalInterfaceDef_var &operator= (CORBA_LocalInterfaceDef_ptr);
  CORBA_LocalInterfaceDef_var &operator= (const CORBA_LocalInterfaceDef_var &);
  CORBA_LocalInterfaceDef_ptr operator-> (void) const;
  
  operator const CORBA_LocalInterfaceDef_ptr &() const;
  operator CORBA_LocalInterfaceDef_ptr &();
  // in, inout, out, _retn 
  CORBA_LocalInterfaceDef_ptr in (void) const;
  CORBA_LocalInterfaceDef_ptr &inout (void);
  CORBA_LocalInterfaceDef_ptr &out (void);
  CORBA_LocalInterfaceDef_ptr _retn (void);
  CORBA_LocalInterfaceDef_ptr ptr (void) const;

private:
  CORBA_LocalInterfaceDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_LocalInterfaceDef_var (const TAO_Base_var &rhs);
  CORBA_LocalInterfaceDef_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEF___OUT_CH_)
#define _CORBA_LOCALINTERFACEDEF___OUT_CH_

class TAO_IFR_Client_Export CORBA_LocalInterfaceDef_out
{
public:
  CORBA_LocalInterfaceDef_out (CORBA_LocalInterfaceDef_ptr &);
  CORBA_LocalInterfaceDef_out (CORBA_LocalInterfaceDef_var &);
  CORBA_LocalInterfaceDef_out (const CORBA_LocalInterfaceDef_out &);
  CORBA_LocalInterfaceDef_out &operator= (const CORBA_LocalInterfaceDef_out &);
  CORBA_LocalInterfaceDef_out &operator= (const CORBA_LocalInterfaceDef_var &);
  CORBA_LocalInterfaceDef_out &operator= (CORBA_LocalInterfaceDef_ptr);
  operator CORBA_LocalInterfaceDef_ptr &();
  CORBA_LocalInterfaceDef_ptr &ptr (void);
  CORBA_LocalInterfaceDef_ptr operator-> (void);
  
private:
  CORBA_LocalInterfaceDef_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEF_CH_)
#define _CORBA_LOCALINTERFACEDEF_CH_

// Forward Classes Declaration
class _TAO_LocalInterfaceDef_Proxy_Impl;
class _TAO_LocalInterfaceDef_Remote_Proxy_Impl;
class _TAO_LocalInterfaceDef_Proxy_Broker;
class _TAO_LocalInterfaceDef_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_LocalInterfaceDef: public virtual CORBA_InterfaceDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_LocalInterfaceDef_ptr _ptr_type;
  typedef CORBA_LocalInterfaceDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static CORBA_LocalInterfaceDef_ptr _duplicate (CORBA_LocalInterfaceDef_ptr obj);
  static CORBA_LocalInterfaceDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_LocalInterfaceDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static CORBA_LocalInterfaceDef_ptr _nil (void)
    {
      return (CORBA_LocalInterfaceDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_LocalInterfaceDef_Proxy_Broker *the_TAO_LocalInterfaceDef_Proxy_Broker_;
  
protected:
  CORBA_LocalInterfaceDef (int collocated = 0);
  
  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_LocalInterfaceDef_setup_collocation (int collocated);
    
    CORBA_LocalInterfaceDef (
      TAO_Stub *objref, 
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
      );
    
    friend class _TAO_LocalInterfaceDef_Remote_Proxy_Impl;
    friend class _TAO_LocalInterfaceDef_ThruPOA_Proxy_Impl;
    friend class _TAO_LocalInterfaceDef_Direct_Proxy_Impl;
  
  virtual ~CORBA_LocalInterfaceDef (void);
private:
  CORBA_LocalInterfaceDef (const CORBA_LocalInterfaceDef &);
  void operator= (const CORBA_LocalInterfaceDef &);  
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_LocalInterfaceDef_Proxy_Impl : 
  public virtual _TAO_InterfaceDef_Proxy_Impl
{
public:
  virtual ~_TAO_LocalInterfaceDef_Proxy_Impl (void) { }
  
  protected:
  _TAO_LocalInterfaceDef_Proxy_Impl (void);

};
//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_LocalInterfaceDef_Remote_Proxy_Impl : 
  public virtual _TAO_LocalInterfaceDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_InterfaceDef_Remote_Proxy_Impl
  
{
public:
  _TAO_LocalInterfaceDef_Remote_Proxy_Impl (void);
  
  virtual ~_TAO_LocalInterfaceDef_Remote_Proxy_Impl (void) { }
  
  };

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new 
// collocation scheme, the proxy to be used can vary on
// a call by call basis. 



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_LocalInterfaceDef_Proxy_Broker
{
public:
  virtual ~_TAO_LocalInterfaceDef_Proxy_Broker (void);
  virtual _TAO_LocalInterfaceDef_Proxy_Impl &select_proxy (
    CORBA_LocalInterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_LocalInterfaceDef_Proxy_Broker (void);
  
};

//
//              End Base Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration 
//

class TAO_IFR_Client_Export _TAO_LocalInterfaceDef_Remote_Proxy_Broker : public virtual _TAO_LocalInterfaceDef_Proxy_Broker
{
public: 
  _TAO_LocalInterfaceDef_Remote_Proxy_Broker (void);
  
  virtual ~_TAO_LocalInterfaceDef_Remote_Proxy_Broker (void);
  
  virtual _TAO_LocalInterfaceDef_Proxy_Impl &select_proxy (
    CORBA_LocalInterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_LocalInterfaceDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_LocalInterfaceDef_Remote_Proxy_Broker *the_TAO_LocalInterfaceDef_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration 
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

// Proxy Broker Factory function pointer declarations.

extern TAO_IFR_Client_Export _TAO_Repository_Proxy_Broker * (*CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_ModuleDef_Proxy_Broker * (*CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_ConstantDef_Proxy_Broker * (*CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_StructDef_Proxy_Broker * (*CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_UnionDef_Proxy_Broker * (*CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_EnumDef_Proxy_Broker * (*CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_AliasDef_Proxy_Broker * (*CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_NativeDef_Proxy_Broker * (*CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_PrimitiveDef_Proxy_Broker * (*CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_StringDef_Proxy_Broker * (*CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_WstringDef_Proxy_Broker * (*CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_SequenceDef_Proxy_Broker * (*CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_ArrayDef_Proxy_Broker * (*CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_ExceptionDef_Proxy_Broker * (*CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_AttributeDef_Proxy_Broker * (*CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_OperationDef_Proxy_Broker * (*CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_InterfaceDef_Proxy_Broker * (*CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_AbstractInterfaceDef_Proxy_Broker * (*CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

extern TAO_IFR_Client_Export _TAO_LocalInterfaceDef_Proxy_Broker * (*CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

// ********************************************************
// Any operators for classes moved from IFR_BaseC.h

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::InterfaceDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::InterfaceDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::InterfaceDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::InterfaceDefSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::AbstractInterfaceDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AbstractInterfaceDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AbstractInterfaceDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::AbstractInterfaceDefSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::LocalInterfaceDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::LocalInterfaceDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::LocalInterfaceDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::LocalInterfaceDefSeq *&);

// ********************************************************

TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::PrimitiveKind);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::PrimitiveKind &);
// Any operators for interface CORBA::Repository
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::Repository_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::Repository *&);
// Any operators for interface CORBA::ModuleDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ModuleDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ModuleDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ModuleDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ModuleDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ModuleDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ModuleDescription *&);
// Any operators for interface CORBA::ConstantDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ConstantDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ConstantDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ConstantDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ConstantDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ConstantDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ConstantDescription *&);
// Any operators for interface CORBA::StructDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::StructDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::StructDef *&);
// Any operators for interface CORBA::UnionDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::UnionDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::UnionDef *&);
// Any operators for interface CORBA::EnumDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::EnumDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::EnumDef *&);
// Any operators for interface CORBA::AliasDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AliasDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AliasDef *&);
// Any operators for interface CORBA::NativeDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::NativeDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::NativeDef *&);
// Any operators for interface CORBA::PrimitiveDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::PrimitiveDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::PrimitiveDef *&);
// Any operators for interface CORBA::StringDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::StringDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::StringDef *&);
// Any operators for interface CORBA::WstringDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::WstringDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::WstringDef *&);
// Any operators for interface CORBA::SequenceDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::SequenceDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::SequenceDef *&);
// Any operators for interface CORBA::ArrayDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ArrayDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ArrayDef *&);
// Any operators for interface CORBA::ExceptionDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ExceptionDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ExceptionDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ExceptionDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ExceptionDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ExceptionDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ExceptionDescription *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ExceptionDefSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ExceptionDefSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ExceptionDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ExceptionDefSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ExcDescriptionSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ExcDescriptionSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ExcDescriptionSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ExcDescriptionSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AttributeMode);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AttributeMode &);
// Any operators for interface CORBA::AttributeDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AttributeDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AttributeDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::AttributeDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AttributeDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AttributeDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::AttributeDescription *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::OperationMode);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::OperationMode &);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ParameterMode);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ParameterMode &);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ParameterDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ParameterDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ParameterDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ParameterDescription *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ParDescriptionSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ParDescriptionSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ParDescriptionSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ParDescriptionSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::ContextIdSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::ContextIdSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::ContextIdSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::ContextIdSeq *&);
// Any operators for interface CORBA::OperationDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::OperationDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::OperationDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::OperationDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::OperationDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::OperationDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::OperationDescription *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::RepositoryIdSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::RepositoryIdSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::RepositoryIdSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::RepositoryIdSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::OpDescriptionSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::OpDescriptionSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::OpDescriptionSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::OpDescriptionSeq *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::AttrDescriptionSeq &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AttrDescriptionSeq*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AttrDescriptionSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::AttrDescriptionSeq *&);
// Any operators for interface CORBA::InterfaceDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::InterfaceDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::InterfaceDef *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::InterfaceDef::FullInterfaceDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::InterfaceDef::FullInterfaceDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::InterfaceDef::FullInterfaceDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::InterfaceDef::FullInterfaceDescription *&);
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA::InterfaceDescription &); // copying version
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::InterfaceDescription*); // noncopying version
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::InterfaceDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA::InterfaceDescription *&);
// Any operators for interface CORBA::AbstractInterfaceDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::AbstractInterfaceDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::AbstractInterfaceDef *&);
// Any operators for interface CORBA::LocalInterfaceDef
TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::LocalInterfaceDef_ptr);
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::LocalInterfaceDef *&);

// **************************************************************
// CDR operators for classes moved from IFR_BaseC.h

#if !defined _TAO_CDR_OP_CORBA_InterfaceDefSeq_H_
#define _TAO_CDR_OP_CORBA_InterfaceDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::InterfaceDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::InterfaceDefSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_InterfaceDefSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_AbstractInterfaceDefSeq_H_
#define _TAO_CDR_OP_CORBA_AbstractInterfaceDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::AbstractInterfaceDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::AbstractInterfaceDefSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_AbstractInterfaceDefSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_LocalInterfaceDefSeq_H_
#define _TAO_CDR_OP_CORBA_LocalInterfaceDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::LocalInterfaceDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::LocalInterfaceDefSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_LocalInterfaceDefSeq_H_ */

// **********************************************************

#ifndef __ACE_INLINE__

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::PrimitiveKind &); // 
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::PrimitiveKind &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::Repository_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::Repository_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ModuleDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ModuleDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ModuleDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ModuleDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ConstantDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ConstantDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ConstantDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ConstantDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::StructDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::StructDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::UnionDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::UnionDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::EnumDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::EnumDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::AliasDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::AliasDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::NativeDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::NativeDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::PrimitiveDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::PrimitiveDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::StringDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::StringDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::WstringDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::WstringDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::SequenceDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::SequenceDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ArrayDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ArrayDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ExceptionDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ExceptionDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ExceptionDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ExceptionDescription &);

#if !defined _TAO_CDR_OP_CORBA_ExceptionDefSeq_H_
#define _TAO_CDR_OP_CORBA_ExceptionDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ExceptionDefSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ExceptionDefSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ExceptionDefSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_ExcDescriptionSeq_H_
#define _TAO_CDR_OP_CORBA_ExcDescriptionSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ExcDescriptionSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ExcDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ExcDescriptionSeq_H_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::AttributeMode &); // 
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::AttributeMode &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::AttributeDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::AttributeDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::AttributeDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::AttributeDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::OperationMode &); // 
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::OperationMode &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ParameterMode &); // 
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ParameterMode &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::ParameterDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::ParameterDescription &);

#if !defined _TAO_CDR_OP_CORBA_ParDescriptionSeq_H_
#define _TAO_CDR_OP_CORBA_ParDescriptionSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ParDescriptionSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ParDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ParDescriptionSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_ContextIdSeq_H_
#define _TAO_CDR_OP_CORBA_ContextIdSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ContextIdSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ContextIdSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ContextIdSeq_H_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::OperationDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::OperationDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::OperationDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::OperationDescription &);

#if !defined _TAO_CDR_OP_CORBA_RepositoryIdSeq_H_
#define _TAO_CDR_OP_CORBA_RepositoryIdSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::RepositoryIdSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::RepositoryIdSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_RepositoryIdSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_OpDescriptionSeq_H_
#define _TAO_CDR_OP_CORBA_OpDescriptionSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::OpDescriptionSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::OpDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_OpDescriptionSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_AttrDescriptionSeq_H_
#define _TAO_CDR_OP_CORBA_AttrDescriptionSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::AttrDescriptionSeq &
  );
TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::AttrDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_AttrDescriptionSeq_H_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::InterfaceDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::InterfaceDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::InterfaceDef::FullInterfaceDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::InterfaceDef::FullInterfaceDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::InterfaceDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::InterfaceDescription &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::AbstractInterfaceDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::AbstractInterfaceDef_ptr &);
TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::LocalInterfaceDef_ptr );
TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::LocalInterfaceDef_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "IFR_BasicC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
