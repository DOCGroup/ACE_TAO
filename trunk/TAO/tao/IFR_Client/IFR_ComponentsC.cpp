// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "IFR_ComponentsC.h"

#include "tao/ClientRequestInfo.h"
#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ComponentsC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_IR_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f49), 
  ACE_NTOHL (0x64656e74), 
  ACE_NTOHL (0x69666965), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
  11,
  ACE_NTOHL (0x4964656e), 
  ACE_NTOHL (0x74696669), 
  ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_Identifier (
    CORBA::tk_alias,
    sizeof (_oc_IR_Identifier),
    (char *) &_oc_IR_Identifier,
    0,
    sizeof (IR::Identifier)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_IR_Identifier)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ScopedName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f53), 
  ACE_NTOHL (0x636f7065), 
  ACE_NTOHL (0x644e616d), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ScopedName:1.0
  11,
  ACE_NTOHL (0x53636f70), 
  ACE_NTOHL (0x65644e61), 
  ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_ScopedName (
    CORBA::tk_alias,
    sizeof (_oc_IR_ScopedName),
    (char *) &_oc_IR_ScopedName,
    0,
    sizeof (IR::ScopedName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_IR_ScopedName)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f52), 
  ACE_NTOHL (0x65706f73), 
  ACE_NTOHL (0x69746f72), 
  ACE_NTOHL (0x7949643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
  13,
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72794964), 
  ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryId (
    CORBA::tk_alias,
    sizeof (_oc_IR_RepositoryId),
    (char *) &_oc_IR_RepositoryId,
    0,
    sizeof (IR::RepositoryId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_IR_RepositoryId)
TAO_NAMESPACE_END


#if !defined (_IR_REPOSITORYIDSEQ_CS_)
#define _IR_REPOSITORYIDSEQ_CS_

// *************************************************************
// IR::RepositoryIdSeq
// *************************************************************

IR::RepositoryIdSeq::RepositoryIdSeq (void)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (const RepositoryIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::RepositoryIdSeq::~RepositoryIdSeq (void) // dtor
{}
void IR::RepositoryIdSeq::_tao_any_destructor (void *x)
{
  RepositoryIdSeq *tmp = ACE_static_cast (RepositoryIdSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_RepositoryIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f52), 
  ACE_NTOHL (0x65706f73), 
  ACE_NTOHL (0x69746f72), 
  ACE_NTOHL (0x79496453), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
  16,
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72794964), 
  ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f52), 
      ACE_NTOHL (0x65706f73), 
      ACE_NTOHL (0x69746f72), 
      ACE_NTOHL (0x7949643a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryIdSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_RepositoryIdSeq),
    (char *) &_oc_IR_RepositoryIdSeq,
    0,
    sizeof (IR::RepositoryIdSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_IR_RepositoryIdSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_VersionSpec[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f56), 
  ACE_NTOHL (0x65727369), 
  ACE_NTOHL (0x6f6e5370), 
  ACE_NTOHL (0x65633a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
  12,
  ACE_NTOHL (0x56657273), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_VersionSpec (
    CORBA::tk_alias,
    sizeof (_oc_IR_VersionSpec),
    (char *) &_oc_IR_VersionSpec,
    0,
    sizeof (IR::VersionSpec)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_VersionSpec, &_tc_TAO_tc_IR_VersionSpec)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ComponentDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ComponentDef **old = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::ComponentDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::ComponentDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::ComponentDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, target);
    *tmp = IR::ComponentDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_upcast (void *src) const
  {
    IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_COMPONENTDEFSEQ_CS_)
#define _IR_COMPONENTDEFSEQ_CS_

// *************************************************************
// IR::ComponentDefSeq
// *************************************************************

IR::ComponentDefSeq::ComponentDefSeq (void)
{}
IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ComponentDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ComponentDefSeq::ComponentDefSeq (const ComponentDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ComponentDefSeq::~ComponentDefSeq (void) // dtor
{}
void IR::ComponentDefSeq::_tao_any_destructor (void *x)
{
  ComponentDefSeq *tmp = ACE_static_cast (ComponentDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ComponentDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentDefSeq:1.0
  16,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x53657100),  // name = ComponentDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f43), 
      ACE_NTOHL (0x6f6d706f), 
      ACE_NTOHL (0x6e656e74), 
      ACE_NTOHL (0x4465663a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
      13,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74446566), 
      ACE_NTOHL (0x0),  // name = ComponentDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ComponentDefSeq),
    (char *) &_oc_IR_ComponentDefSeq,
    0,
    sizeof (IR::ComponentDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDefSeq, &_tc_TAO_tc_IR_ComponentDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ProvidesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ProvidesDef **old = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::ProvidesDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::ProvidesDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::ProvidesDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, target);
    *tmp = IR::ProvidesDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_upcast (void *src) const
  {
    IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PROVIDESDEFSEQ_CS_)
#define _IR_PROVIDESDEFSEQ_CS_

// *************************************************************
// IR::ProvidesDefSeq
// *************************************************************

IR::ProvidesDefSeq::ProvidesDefSeq (void)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (const ProvidesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ProvidesDefSeq::~ProvidesDefSeq (void) // dtor
{}
void IR::ProvidesDefSeq::_tao_any_destructor (void *x)
{
  ProvidesDefSeq *tmp = ACE_static_cast (ProvidesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ProvidesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x726f7669), 
  ACE_NTOHL (0x64657344), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
  15,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f50), 
      ACE_NTOHL (0x726f7669), 
      ACE_NTOHL (0x64657344), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
      12,
      ACE_NTOHL (0x50726f76), 
      ACE_NTOHL (0x69646573), 
      ACE_NTOHL (0x44656600),  // name = ProvidesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ProvidesDefSeq),
    (char *) &_oc_IR_ProvidesDefSeq,
    0,
    sizeof (IR::ProvidesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDefSeq, &_tc_TAO_tc_IR_ProvidesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::UsesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::UsesDef **old = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::UsesDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::UsesDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::UsesDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, target);
    *tmp = IR::UsesDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_upcast (void *src) const
  {
    IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_USESDEFSEQ_CS_)
#define _IR_USESDEFSEQ_CS_

// *************************************************************
// IR::UsesDefSeq
// *************************************************************

IR::UsesDefSeq::UsesDefSeq (void)
{}
IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::UsesDefSeq::UsesDefSeq (const UsesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::UsesDefSeq::~UsesDefSeq (void) // dtor
{}
void IR::UsesDefSeq::_tao_any_destructor (void *x)
{
  UsesDefSeq *tmp = ACE_static_cast (UsesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UsesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f55), 
  ACE_NTOHL (0x73657344), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
  11,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65710000),  // name = UsesDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f55), 
      ACE_NTOHL (0x73657344), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
      8,
      ACE_NTOHL (0x55736573), 
      ACE_NTOHL (0x44656600),  // name = UsesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_UsesDefSeq),
    (char *) &_oc_IR_UsesDefSeq,
    0,
    sizeof (IR::UsesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDefSeq, &_tc_TAO_tc_IR_UsesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::HomeDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::HomeDef **old = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::HomeDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::HomeDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::HomeDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, target);
    *tmp = IR::HomeDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_upcast (void *src) const
  {
    IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_HOMEDEFSEQ_CS_)
#define _IR_HOMEDEFSEQ_CS_

// *************************************************************
// IR::HomeDefSeq
// *************************************************************

IR::HomeDefSeq::HomeDefSeq (void)
{}
IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max, CORBA::ULong length, IR::HomeDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::HomeDefSeq::HomeDefSeq (const HomeDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::HomeDefSeq::~HomeDefSeq (void) // dtor
{}
void IR::HomeDefSeq::_tao_any_destructor (void *x)
{
  HomeDefSeq *tmp = ACE_static_cast (HomeDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_HomeDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f48), 
  ACE_NTOHL (0x6f6d6544), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/HomeDefSeq:1.0
  11,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65710000),  // name = HomeDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f48), 
      ACE_NTOHL (0x6f6d6544), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
      8,
      ACE_NTOHL (0x486f6d65), 
      ACE_NTOHL (0x44656600),  // name = HomeDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_HomeDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_HomeDefSeq),
    (char *) &_oc_IR_HomeDefSeq,
    0,
    sizeof (IR::HomeDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDefSeq, &_tc_TAO_tc_IR_HomeDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::EmitsDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::EmitsDef **old = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::EmitsDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::EmitsDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::EmitsDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, target);
    *tmp = IR::EmitsDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_upcast (void *src) const
  {
    IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_EMITSDEFSEQ_CS_)
#define _IR_EMITSDEFSEQ_CS_

// *************************************************************
// IR::EmitsDefSeq
// *************************************************************

IR::EmitsDefSeq::EmitsDefSeq (void)
{}
IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max, CORBA::ULong length, IR::EmitsDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::EmitsDefSeq::EmitsDefSeq (const EmitsDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::EmitsDefSeq::~EmitsDefSeq (void) // dtor
{}
void IR::EmitsDefSeq::_tao_any_destructor (void *x)
{
  EmitsDefSeq *tmp = ACE_static_cast (EmitsDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_EmitsDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f45), 
  ACE_NTOHL (0x6d697473), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
  12,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f45), 
      ACE_NTOHL (0x6d697473), 
      ACE_NTOHL (0x4465663a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
      9,
      ACE_NTOHL (0x456d6974), 
      ACE_NTOHL (0x73446566), 
      ACE_NTOHL (0x0),  // name = EmitsDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_EmitsDefSeq),
    (char *) &_oc_IR_EmitsDefSeq,
    0,
    sizeof (IR::EmitsDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDefSeq, &_tc_TAO_tc_IR_EmitsDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::PublishesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::PublishesDef **old = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::PublishesDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::PublishesDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::PublishesDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, target);
    *tmp = IR::PublishesDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_upcast (void *src) const
  {
    IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PUBLISHESDEFSEQ_CS_)
#define _IR_PUBLISHESDEFSEQ_CS_

// *************************************************************
// IR::PublishesDefSeq
// *************************************************************

IR::PublishesDefSeq::PublishesDefSeq (void)
{}
IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::PublishesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::PublishesDefSeq::PublishesDefSeq (const PublishesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::PublishesDefSeq::~PublishesDefSeq (void) // dtor
{}
void IR::PublishesDefSeq::_tao_any_destructor (void *x)
{
  PublishesDefSeq *tmp = ACE_static_cast (PublishesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_PublishesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x75626c69), 
  ACE_NTOHL (0x73686573), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
  16,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f50), 
      ACE_NTOHL (0x75626c69), 
      ACE_NTOHL (0x73686573), 
      ACE_NTOHL (0x4465663a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
      13,
      ACE_NTOHL (0x5075626c), 
      ACE_NTOHL (0x69736865), 
      ACE_NTOHL (0x73446566), 
      ACE_NTOHL (0x0),  // name = PublishesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_PublishesDefSeq),
    (char *) &_oc_IR_PublishesDefSeq,
    0,
    sizeof (IR::PublishesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDefSeq, &_tc_TAO_tc_IR_PublishesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ConsumesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ConsumesDef **old = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::ConsumesDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::ConsumesDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::ConsumesDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, target);
    *tmp = IR::ConsumesDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_upcast (void *src) const
  {
    IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_CONSUMESDEFSEQ_CS_)
#define _IR_CONSUMESDEFSEQ_CS_

// *************************************************************
// IR::ConsumesDefSeq
// *************************************************************

IR::ConsumesDefSeq::ConsumesDefSeq (void)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ConsumesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (const ConsumesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ConsumesDefSeq::~ConsumesDefSeq (void) // dtor
{}
void IR::ConsumesDefSeq::_tao_any_destructor (void *x)
{
  ConsumesDefSeq *tmp = ACE_static_cast (ConsumesDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ConsumesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f43), 
  ACE_NTOHL (0x6f6e7375), 
  ACE_NTOHL (0x6d657344), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
  15,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6573), 
  ACE_NTOHL (0x44656653), 
  ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f43), 
      ACE_NTOHL (0x6f6e7375), 
      ACE_NTOHL (0x6d657344), 
      ACE_NTOHL (0x65663a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
      12,
      ACE_NTOHL (0x436f6e73), 
      ACE_NTOHL (0x756d6573), 
      ACE_NTOHL (0x44656600),  // name = ConsumesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ConsumesDefSeq),
    (char *) &_oc_IR_ConsumesDefSeq,
    0,
    sizeof (IR::ConsumesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDefSeq, &_tc_TAO_tc_IR_ConsumesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::FactoryDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::FactoryDef **old = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::FactoryDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::FactoryDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::FactoryDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, target);
    *tmp = IR::FactoryDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_upcast (void *src) const
  {
    IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_FACTORYDEFSEQ_CS_)
#define _IR_FACTORYDEFSEQ_CS_

// *************************************************************
// IR::FactoryDefSeq
// *************************************************************

IR::FactoryDefSeq::FactoryDefSeq (void)
{}
IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FactoryDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::FactoryDefSeq::FactoryDefSeq (const FactoryDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::FactoryDefSeq::~FactoryDefSeq (void) // dtor
{}
void IR::FactoryDefSeq::_tao_any_destructor (void *x)
{
  FactoryDefSeq *tmp = ACE_static_cast (FactoryDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_FactoryDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f46), 
  ACE_NTOHL (0x6163746f), 
  ACE_NTOHL (0x72794465), 
  ACE_NTOHL (0x66536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
  14,
  ACE_NTOHL (0x46616374), 
  ACE_NTOHL (0x6f727944), 
  ACE_NTOHL (0x65665365), 
  ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f46), 
      ACE_NTOHL (0x6163746f), 
      ACE_NTOHL (0x72794465), 
      ACE_NTOHL (0x663a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
      11,
      ACE_NTOHL (0x46616374), 
      ACE_NTOHL (0x6f727944), 
      ACE_NTOHL (0x65660000),  // name = FactoryDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_FactoryDefSeq),
    (char *) &_oc_IR_FactoryDefSeq,
    0,
    sizeof (IR::FactoryDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDefSeq, &_tc_TAO_tc_IR_FactoryDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::FinderDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::FinderDef **old = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = IR::FinderDef::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete[] old;
        }
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::FinderDef::_nil ();
      }
    
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR::FinderDef::_nil ();
      }
  }
  
  void 
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, target);
    *tmp = IR::FinderDef::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_upcast (void *src) const
  {
    IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_FINDERDEFSEQ_CS_)
#define _IR_FINDERDEFSEQ_CS_

// *************************************************************
// IR::FinderDefSeq
// *************************************************************

IR::FinderDefSeq::FinderDefSeq (void)
{}
IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FinderDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::FinderDefSeq::FinderDefSeq (const FinderDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::FinderDefSeq::~FinderDefSeq (void) // dtor
{}
void IR::FinderDefSeq::_tao_any_destructor (void *x)
{
  FinderDefSeq *tmp = ACE_static_cast (FinderDefSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_FinderDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f46), 
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x72446566), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
  13,
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x66536571), 
  ACE_NTOHL (0x0),  // name = FinderDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f46), 
      ACE_NTOHL (0x696e6465), 
      ACE_NTOHL (0x72446566), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
      10,
      ACE_NTOHL (0x46696e64), 
      ACE_NTOHL (0x65724465), 
      ACE_NTOHL (0x66000000),  // name = FinderDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_FinderDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_FinderDefSeq),
    (char *) &_oc_IR_FinderDefSeq,
    0,
    sizeof (IR::FinderDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDefSeq, &_tc_TAO_tc_IR_FinderDefSeq)
TAO_NAMESPACE_END

IR::ComponentRepository_ptr
tao_IR_ComponentRepository_duplicate (
    IR::ComponentRepository_ptr p
  )
{
  return IR::ComponentRepository::_duplicate (p);
}

void
tao_IR_ComponentRepository_release (
    IR::ComponentRepository_ptr p
  )
{
  CORBA::release (p);
}

IR::ComponentRepository_ptr
tao_IR_ComponentRepository_nil (
    void
  )
{
  return IR::ComponentRepository::_nil ();
}

IR::ComponentRepository_ptr
tao_IR_ComponentRepository_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::ComponentRepository::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_ComponentRepository_upcast (
    void *src
  )
{
  IR::ComponentRepository **tmp =
    ACE_static_cast (IR::ComponentRepository **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ComponentRepository_var
// *************************************************************

IR::ComponentRepository_var::ComponentRepository_var (void) // default constructor
  : ptr_ (ComponentRepository::_nil ())
{}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::ptr (void) const
{
  return this->ptr_;
}

IR::ComponentRepository_var::ComponentRepository_var (const ::IR::ComponentRepository_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentRepository::_duplicate (p.ptr ()))
{}

IR::ComponentRepository_var::~ComponentRepository_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ComponentRepository_var &
IR::ComponentRepository_var::operator= (ComponentRepository_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ComponentRepository_var &
IR::ComponentRepository_var::operator= (const ::IR::ComponentRepository_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ComponentRepository::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ComponentRepository_var::operator const ::IR::ComponentRepository_ptr &() const // cast
{
  return this->ptr_;
}

IR::ComponentRepository_var::operator ::IR::ComponentRepository_ptr &() // cast 
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::in (void) const
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr &
IR::ComponentRepository_var::inout (void)
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr &
IR::ComponentRepository_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentRepository::_nil ();
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ComponentRepository_ptr val = this->ptr_;
  this->ptr_ = ::IR::ComponentRepository::_nil ();
  return val;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::duplicate (ComponentRepository_ptr p)
{
  return ::IR::ComponentRepository::_duplicate (p);
}

void
IR::ComponentRepository_var::release (ComponentRepository_ptr p)
{
  CORBA::release (p);
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::nil (void)
{
  return ::IR::ComponentRepository::_nil ();
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::ComponentRepository::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::ComponentRepository_var::upcast (void *src)
{
  ComponentRepository **tmp =
    ACE_static_cast (ComponentRepository **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::ComponentRepository_out
// *************************************************************

IR::ComponentRepository_out::ComponentRepository_out (ComponentRepository_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ComponentRepository::_nil ();
}

IR::ComponentRepository_out::ComponentRepository_out (ComponentRepository_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentRepository::_nil ();
}

IR::ComponentRepository_out::ComponentRepository_out (const ::IR::ComponentRepository_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentRepository_out &, p).ptr_)
{}

::IR::ComponentRepository_out &
IR::ComponentRepository_out::operator= (const ::IR::ComponentRepository_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentRepository_out&, p).ptr_;
  return *this;
}

IR::ComponentRepository_out &
IR::ComponentRepository_out::operator= (const ::IR::ComponentRepository_var &p)
{
  this->ptr_ = ::IR::ComponentRepository::_duplicate (p.ptr ());
  return *this;
}

IR::ComponentRepository_out &
IR::ComponentRepository_out::operator= (ComponentRepository_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ComponentRepository_out::operator ::IR::ComponentRepository_ptr &() // cast
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr &
IR::ComponentRepository_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_ComponentRepository_create_component : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      IR::ComponentDef_ptr base_component,
      const CORBA_InterfaceDefSeq & supports_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_component (const TAO_ClientRequestInfo_IR_ComponentRepository_create_component &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentRepository_create_component &);

  const char * id_;
  const char * name_;
  const char * version_;
  IR::ComponentDef_ptr base_component_;
  const CORBA_InterfaceDefSeq & supports_interfaces_;
  IR::ComponentDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentRepository_create_component::TAO_ClientRequestInfo_IR_ComponentRepository_create_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_component_ (base_component),
    supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_component = parameter_list->length ();
  parameter_list->length (length_base_component + 1);
  (*parameter_list)[length_base_component].argument <<=  this->base_component_;
  
  (*parameter_list)[length_base_component].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_supports_interfaces = parameter_list->length ();
  parameter_list->length (length_supports_interfaces + 1);
  (*parameter_list)[length_supports_interfaces].argument <<=  this->supports_interfaces_;
  
  (*parameter_list)[length_supports_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (IR::ComponentDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentRepository_create_home : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      IR::HomeDef_ptr base_home,
      IR::ComponentDef_ptr managed_component,
      CORBA_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_home (const TAO_ClientRequestInfo_IR_ComponentRepository_create_home &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentRepository_create_home &);

  const char * id_;
  const char * name_;
  const char * version_;
  IR::HomeDef_ptr base_home_;
  IR::ComponentDef_ptr managed_component_;
  CORBA_ValueDef_ptr primary_key_;
  IR::HomeDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentRepository_create_home::TAO_ClientRequestInfo_IR_ComponentRepository_create_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_home_ (base_home),
    managed_component_ (managed_component),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_home = parameter_list->length ();
  parameter_list->length (length_base_home + 1);
  (*parameter_list)[length_base_home].argument <<=  this->base_home_;
  
  (*parameter_list)[length_base_home].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_managed_component = parameter_list->length ();
  parameter_list->length (length_managed_component + 1);
  (*parameter_list)[length_managed_component].argument <<=  this->managed_component_;
  
  (*parameter_list)[length_managed_component].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
  
  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (IR::HomeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_ComponentRepository_Proxy_Impl::_TAO_ComponentRepository_Proxy_Impl (void)
{}

IR::_TAO_ComponentRepository_Remote_Proxy_Impl::_TAO_ComponentRepository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR::ComponentDef_ptr IR::_TAO_ComponentRepository_Remote_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentRepository_create_component ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_component,
        supports_interfaces,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_component) &&
              (_tao_out << supports_interfaces)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::HomeDef_ptr IR::_TAO_ComponentRepository_Remote_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
  IR::HomeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_home",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentRepository_create_home ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_home) &&
              (_tao_out << managed_component) &&
              (_tao_out << primary_key)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ComponentRepository_Proxy_Broker::_TAO_ComponentRepository_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Proxy_Broker::~_TAO_ComponentRepository_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Proxy_Broker * (*IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ComponentRepository_Remote_Proxy_Broker *
IR::_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ComponentRepository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ComponentRepository_Remote_Proxy_Broker::_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Remote_Proxy_Broker::~_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Proxy_Impl&
IR::_TAO_ComponentRepository_Remote_Proxy_Broker::select_proxy (
  ::IR::ComponentRepository *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ComponentRepository::ComponentRepository (int collocated)
{
  this->IR_ComponentRepository_setup_collocation (collocated);
}

// destructor
IR::ComponentRepository::~ComponentRepository (void)
{}

void
IR::ComponentRepository::IR_ComponentRepository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentRepository_Proxy_Broker_ =
      ::IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentRepository_Proxy_Broker_ =
      ::IR::_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker ();
  
  this->CORBA_Repository_setup_collocation (collocated);
}

void IR::ComponentRepository::_tao_any_destructor (void *x)
{
  ComponentRepository *tmp = ACE_static_cast (ComponentRepository*,x);
  CORBA::release (tmp);
}

IR::ComponentRepository_ptr IR::ComponentRepository::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ComponentRepository::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentRepository:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ComponentRepository::_nil ());
      if (is_a == 0)
        return ComponentRepository::_nil ();
    }
  return ComponentRepository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ComponentRepository_ptr IR::ComponentRepository::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ComponentRepository::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ComponentRepository_ptr default_proxy = ComponentRepository::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ComponentRepository (
            stub,
            1,
            obj->_servant ()),
            
          ComponentRepository::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ComponentRepository (stub, 0, obj->_servant ()), ComponentRepository::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            ComponentRepository_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ComponentRepository::_narrow
                    )
                )
          );
}

IR::ComponentRepository_ptr
IR::ComponentRepository::_duplicate (ComponentRepository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ComponentRepository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::ComponentRepository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ComponentRepository)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Repository::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Repository_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentDef_ptr IR::ComponentRepository::create_component (
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentRepository_Proxy_Impl &proxy = 
    this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_component (
      this,
      id,
      name,
      version,
      base_component,
      supports_interfaces,
      ACE_TRY_ENV
    );
}

IR::HomeDef_ptr IR::ComponentRepository::create_home (
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentRepository_Proxy_Impl &proxy = 
    this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_home (
      this,
      id,
      name,
      version,
      base_home,
      managed_component,
      primary_key,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_ComponentRepository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72793a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentRepository:1.0
  20,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74526570), 
  ACE_NTOHL (0x6f736974), 
  ACE_NTOHL (0x6f727900),  // name = ComponentRepository
};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentRepository (
    CORBA::tk_objref,
    sizeof (_oc_IR_ComponentRepository),
    (char *) &_oc_IR_ComponentRepository,
    0,
    sizeof (IR::ComponentRepository)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentRepository, &_tc_TAO_tc_IR_ComponentRepository)
TAO_NAMESPACE_END

IR::ProvidesDef_ptr
tao_IR_ProvidesDef_duplicate (
    IR::ProvidesDef_ptr p
  )
{
  return IR::ProvidesDef::_duplicate (p);
}

void
tao_IR_ProvidesDef_release (
    IR::ProvidesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::ProvidesDef_ptr
tao_IR_ProvidesDef_nil (
    void
  )
{
  return IR::ProvidesDef::_nil ();
}

IR::ProvidesDef_ptr
tao_IR_ProvidesDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::ProvidesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_ProvidesDef_upcast (
    void *src
  )
{
  IR::ProvidesDef **tmp =
    ACE_static_cast (IR::ProvidesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ProvidesDef_var
// *************************************************************

IR::ProvidesDef_var::ProvidesDef_var (void) // default constructor
  : ptr_ (ProvidesDef::_nil ())
{}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::ProvidesDef_var::ProvidesDef_var (const ::IR::ProvidesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ProvidesDef::_duplicate (p.ptr ()))
{}

IR::ProvidesDef_var::~ProvidesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ProvidesDef_var &
IR::ProvidesDef_var::operator= (ProvidesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ProvidesDef_var &
IR::ProvidesDef_var::operator= (const ::IR::ProvidesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ProvidesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ProvidesDef_var::operator const ::IR::ProvidesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::ProvidesDef_var::operator ::IR::ProvidesDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr &
IR::ProvidesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr &
IR::ProvidesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ProvidesDef::_nil ();
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ProvidesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::ProvidesDef::_nil ();
  return val;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::duplicate (ProvidesDef_ptr p)
{
  return ::IR::ProvidesDef::_duplicate (p);
}

void
IR::ProvidesDef_var::release (ProvidesDef_ptr p)
{
  CORBA::release (p);
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::nil (void)
{
  return ::IR::ProvidesDef::_nil ();
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::ProvidesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::ProvidesDef_var::upcast (void *src)
{
  ProvidesDef **tmp =
    ACE_static_cast (ProvidesDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::ProvidesDef_out
// *************************************************************

IR::ProvidesDef_out::ProvidesDef_out (ProvidesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ProvidesDef::_nil ();
}

IR::ProvidesDef_out::ProvidesDef_out (ProvidesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ProvidesDef::_nil ();
}

IR::ProvidesDef_out::ProvidesDef_out (const ::IR::ProvidesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ProvidesDef_out &, p).ptr_)
{}

::IR::ProvidesDef_out &
IR::ProvidesDef_out::operator= (const ::IR::ProvidesDef_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDef_out&, p).ptr_;
  return *this;
}

IR::ProvidesDef_out &
IR::ProvidesDef_out::operator= (const ::IR::ProvidesDef_var &p)
{
  this->ptr_ = ::IR::ProvidesDef::_duplicate (p.ptr ());
  return *this;
}

IR::ProvidesDef_out &
IR::ProvidesDef_out::operator= (ProvidesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ProvidesDef_out::operator ::IR::ProvidesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr &
IR::ProvidesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (const TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get &);

  CORBA_InterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_ProvidesDef_Proxy_Impl::_TAO_ProvidesDef_Proxy_Impl (void)
{}

IR::_TAO_ProvidesDef_Remote_Proxy_Impl::_TAO_ProvidesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr IR::_TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA_InterfaceDef_ptr _tao_retval = CORBA_InterfaceDef::_nil ();
  CORBA_InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ProvidesDef_Proxy_Broker::_TAO_ProvidesDef_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Proxy_Broker::~_TAO_ProvidesDef_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Proxy_Broker * (*IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ProvidesDef_Remote_Proxy_Broker *
IR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ProvidesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ProvidesDef_Remote_Proxy_Broker::_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Remote_Proxy_Broker::~_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Proxy_Impl&
IR::_TAO_ProvidesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::ProvidesDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ProvidesDef::ProvidesDef (int collocated)
{
  this->IR_ProvidesDef_setup_collocation (collocated);
}

// destructor
IR::ProvidesDef::~ProvidesDef (void)
{}

void
IR::ProvidesDef::IR_ProvidesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      ::IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      ::IR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::ProvidesDef::_tao_any_destructor (void *x)
{
  ProvidesDef *tmp = ACE_static_cast (ProvidesDef*,x);
  CORBA::release (tmp);
}

IR::ProvidesDef_ptr IR::ProvidesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ProvidesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ProvidesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ProvidesDef::_nil ());
      if (is_a == 0)
        return ProvidesDef::_nil ();
    }
  return ProvidesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ProvidesDef_ptr IR::ProvidesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ProvidesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ProvidesDef_ptr default_proxy = ProvidesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ProvidesDef (
            stub,
            1,
            obj->_servant ()),
            
          ProvidesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ProvidesDef (stub, 0, obj->_servant ()), ProvidesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            ProvidesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ProvidesDef::_narrow
                    )
                )
          );
}

IR::ProvidesDef_ptr
IR::ProvidesDef::_duplicate (ProvidesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ProvidesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::ProvidesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ProvidesDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

CORBA_InterfaceDef_ptr IR::ProvidesDef::interface_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ProvidesDef_Proxy_Impl &proxy = 
    this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.interface_type (
      this,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_ProvidesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x726f7669), 
  ACE_NTOHL (0x64657344), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
  12,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44656600),  // name = ProvidesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_ProvidesDef),
    (char *) &_oc_IR_ProvidesDef,
    0,
    sizeof (IR::ProvidesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDef, &_tc_TAO_tc_IR_ProvidesDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ProvidesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x726f7669), 
  ACE_NTOHL (0x64657344), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
  20,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f49), 
    ACE_NTOHL (0x64656e74), 
    ACE_NTOHL (0x69666965), 
    ACE_NTOHL (0x723a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f56), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x6f6e5370), 
    ACE_NTOHL (0x65633a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15,
  ACE_NTOHL (0x696e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x655f7479), 
  ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f496e), 
    ACE_NTOHL (0x74657266), 
    ACE_NTOHL (0x61636544), 
    ACE_NTOHL (0x65663a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_InterfaceDef:1.0
    19,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f496e), 
    ACE_NTOHL (0x74657266), 
    ACE_NTOHL (0x61636544), 
    ACE_NTOHL (0x65660000),  // name = CORBA_InterfaceDef

};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_ProvidesDescription),
    (char *) &_oc_IR_ProvidesDescription,
    0,
    sizeof (IR::ProvidesDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescription, &_tc_TAO_tc_IR_ProvidesDescription)
TAO_NAMESPACE_END

void IR::ProvidesDescription::_tao_any_destructor (void *x)
{
  ProvidesDescription *tmp = ACE_static_cast (ProvidesDescription*,x);
  delete tmp;
}

IR::UsesDef_ptr
tao_IR_UsesDef_duplicate (
    IR::UsesDef_ptr p
  )
{
  return IR::UsesDef::_duplicate (p);
}

void
tao_IR_UsesDef_release (
    IR::UsesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::UsesDef_ptr
tao_IR_UsesDef_nil (
    void
  )
{
  return IR::UsesDef::_nil ();
}

IR::UsesDef_ptr
tao_IR_UsesDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::UsesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_UsesDef_upcast (
    void *src
  )
{
  IR::UsesDef **tmp =
    ACE_static_cast (IR::UsesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::UsesDef_var
// *************************************************************

IR::UsesDef_var::UsesDef_var (void) // default constructor
  : ptr_ (UsesDef::_nil ())
{}

::IR::UsesDef_ptr
IR::UsesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::UsesDef_var::UsesDef_var (const ::IR::UsesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (UsesDef::_duplicate (p.ptr ()))
{}

IR::UsesDef_var::~UsesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::UsesDef_var &
IR::UsesDef_var::operator= (UsesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::UsesDef_var &
IR::UsesDef_var::operator= (const ::IR::UsesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::UsesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::UsesDef_var::operator const ::IR::UsesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::UsesDef_var::operator ::IR::UsesDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::UsesDef_ptr &
IR::UsesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::UsesDef_ptr &
IR::UsesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::UsesDef::_nil ();
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::UsesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::UsesDef::_nil ();
  return val;
}

::IR::UsesDef_ptr
IR::UsesDef_var::duplicate (UsesDef_ptr p)
{
  return ::IR::UsesDef::_duplicate (p);
}

void
IR::UsesDef_var::release (UsesDef_ptr p)
{
  CORBA::release (p);
}

::IR::UsesDef_ptr
IR::UsesDef_var::nil (void)
{
  return ::IR::UsesDef::_nil ();
}

::IR::UsesDef_ptr
IR::UsesDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::UsesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::UsesDef_var::upcast (void *src)
{
  UsesDef **tmp =
    ACE_static_cast (UsesDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::UsesDef_out
// *************************************************************

IR::UsesDef_out::UsesDef_out (UsesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::UsesDef::_nil ();
}

IR::UsesDef_out::UsesDef_out (UsesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::UsesDef::_nil ();
}

IR::UsesDef_out::UsesDef_out (const ::IR::UsesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UsesDef_out &, p).ptr_)
{}

::IR::UsesDef_out &
IR::UsesDef_out::operator= (const ::IR::UsesDef_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDef_out&, p).ptr_;
  return *this;
}

IR::UsesDef_out &
IR::UsesDef_out::operator= (const ::IR::UsesDef_var &p)
{
  this->ptr_ = ::IR::UsesDef::_duplicate (p.ptr ());
  return *this;
}

IR::UsesDef_out &
IR::UsesDef_out::operator= (UsesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::UsesDef_out::operator ::IR::UsesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::UsesDef_ptr &
IR::UsesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_UsesDef_interface_type_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (const TAO_ClientRequestInfo_IR_UsesDef_interface_type_get &);
  void operator= (const TAO_ClientRequestInfo_IR_UsesDef_interface_type_get &);

  CORBA_InterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (const TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get &);
  void operator= (const TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get &);

  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_UsesDef_Proxy_Impl::_TAO_UsesDef_Proxy_Impl (void)
{}

IR::_TAO_UsesDef_Remote_Proxy_Impl::_TAO_UsesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr IR::_TAO_UsesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA_InterfaceDef_ptr _tao_retval = CORBA_InterfaceDef::_nil ();
  CORBA_InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_UsesDef_interface_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::_TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_multiple",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_UsesDef_Proxy_Broker::_TAO_UsesDef_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Proxy_Broker::~_TAO_UsesDef_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Proxy_Broker * (*IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_UsesDef_Remote_Proxy_Broker *
IR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_UsesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_UsesDef_Remote_Proxy_Broker::_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Remote_Proxy_Broker::~_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Proxy_Impl&
IR::_TAO_UsesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::UsesDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::UsesDef::UsesDef (int collocated)
{
  this->IR_UsesDef_setup_collocation (collocated);
}

// destructor
IR::UsesDef::~UsesDef (void)
{}

void
IR::UsesDef::IR_UsesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_UsesDef_Proxy_Broker_ =
      ::IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_UsesDef_Proxy_Broker_ =
      ::IR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::UsesDef::_tao_any_destructor (void *x)
{
  UsesDef *tmp = ACE_static_cast (UsesDef*,x);
  CORBA::release (tmp);
}

IR::UsesDef_ptr IR::UsesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return UsesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UsesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (UsesDef::_nil ());
      if (is_a == 0)
        return UsesDef::_nil ();
    }
  return UsesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::UsesDef_ptr IR::UsesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return UsesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      UsesDef_ptr default_proxy = UsesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::UsesDef (
            stub,
            1,
            obj->_servant ()),
            
          UsesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::UsesDef (stub, 0, obj->_servant ()), UsesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            UsesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &UsesDef::_narrow
                    )
                )
          );
}

IR::UsesDef_ptr
IR::UsesDef::_duplicate (UsesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::UsesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::UsesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, UsesDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

CORBA_InterfaceDef_ptr IR::UsesDef::interface_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy = 
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.interface_type (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR::UsesDef::is_multiple (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy = 
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_multiple (
      this,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_UsesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f55), 
  ACE_NTOHL (0x73657344), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
  8,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44656600),  // name = UsesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_UsesDef),
    (char *) &_oc_IR_UsesDef,
    0,
    sizeof (IR::UsesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDef, &_tc_TAO_tc_IR_UsesDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_UsesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f55), 
  ACE_NTOHL (0x73657344), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
  16,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = UsesDescription
  6, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f49), 
    ACE_NTOHL (0x64656e74), 
    ACE_NTOHL (0x69666965), 
    ACE_NTOHL (0x723a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f56), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x6f6e5370), 
    ACE_NTOHL (0x65633a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15,
  ACE_NTOHL (0x696e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x655f7479), 
  ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f496e), 
    ACE_NTOHL (0x74657266), 
    ACE_NTOHL (0x61636544), 
    ACE_NTOHL (0x65663a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_InterfaceDef:1.0
    19,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f496e), 
    ACE_NTOHL (0x74657266), 
    ACE_NTOHL (0x61636544), 
    ACE_NTOHL (0x65660000),  // name = CORBA_InterfaceDef

  12,
  ACE_NTOHL (0x69735f6d), 
  ACE_NTOHL (0x756c7469), 
  ACE_NTOHL (0x706c6500),  // name = is_multiple
  CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_UsesDescription),
    (char *) &_oc_IR_UsesDescription,
    0,
    sizeof (IR::UsesDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescription, &_tc_TAO_tc_IR_UsesDescription)
TAO_NAMESPACE_END

void IR::UsesDescription::_tao_any_destructor (void *x)
{
  UsesDescription *tmp = ACE_static_cast (UsesDescription*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::ProvidesDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::ProvidesDescription *old = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::ProvidesDescription *tmp = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PROVIDESDESCSEQ_CS_)
#define _IR_PROVIDESDESCSEQ_CS_

// *************************************************************
// IR::ProvidesDescSeq
// *************************************************************

IR::ProvidesDescSeq::ProvidesDescSeq (void)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (const ProvidesDescSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::ProvidesDescSeq::~ProvidesDescSeq (void) // dtor
{}
void IR::ProvidesDescSeq::_tao_any_destructor (void *x)
{
  ProvidesDescSeq *tmp = ACE_static_cast (ProvidesDescSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ProvidesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x726f7669), 
  ACE_NTOHL (0x64657344), 
  ACE_NTOHL (0x65736353), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescSeq:1.0
  16,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x53657100),  // name = ProvidesDescSeq
  CORBA::tk_sequence, // typecode kind
  532, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    516, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f50), 
      ACE_NTOHL (0x726f7669), 
      ACE_NTOHL (0x64657344), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
      20,
      ACE_NTOHL (0x50726f76), 
      ACE_NTOHL (0x69646573), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
      5, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f49), 
        ACE_NTOHL (0x64656e74), 
        ACE_NTOHL (0x69666965), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x7949643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x7949643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f56), 
        ACE_NTOHL (0x65727369), 
        ACE_NTOHL (0x6f6e5370), 
        ACE_NTOHL (0x65633a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      15,
      ACE_NTOHL (0x696e7465), 
      ACE_NTOHL (0x72666163), 
      ACE_NTOHL (0x655f7479), 
      ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f496e), 
        ACE_NTOHL (0x74657266), 
        ACE_NTOHL (0x61636544), 
        ACE_NTOHL (0x65663a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_InterfaceDef:1.0
        19,
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f496e), 
        ACE_NTOHL (0x74657266), 
        ACE_NTOHL (0x61636544), 
        ACE_NTOHL (0x65660000),  // name = CORBA_InterfaceDef


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ProvidesDescSeq),
    (char *) &_oc_IR_ProvidesDescSeq,
    0,
    sizeof (IR::ProvidesDescSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescSeq, &_tc_TAO_tc_IR_ProvidesDescSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_

  void
  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR::UsesDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR::UsesDescription *old = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR::UsesDescription *tmp = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_USESDESCSEQ_CS_)
#define _IR_USESDESCSEQ_CS_

// *************************************************************
// IR::UsesDescSeq
// *************************************************************

IR::UsesDescSeq::UsesDescSeq (void)
{}
IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR::UsesDescSeq::UsesDescSeq (const UsesDescSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR::UsesDescSeq::~UsesDescSeq (void) // dtor
{}
void IR::UsesDescSeq::_tao_any_destructor (void *x)
{
  UsesDescSeq *tmp = ACE_static_cast (UsesDescSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UsesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f55), 
  ACE_NTOHL (0x73657344), 
  ACE_NTOHL (0x65736353), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescSeq:1.0
  12,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x53657100),  // name = UsesDescSeq
  CORBA::tk_sequence, // typecode kind
  544, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    528, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x49522f55), 
      ACE_NTOHL (0x73657344), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
      16,
      ACE_NTOHL (0x55736573), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = UsesDescription
      6, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f49), 
        ACE_NTOHL (0x64656e74), 
        ACE_NTOHL (0x69666965), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x7949643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x7949643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f56), 
        ACE_NTOHL (0x65727369), 
        ACE_NTOHL (0x6f6e5370), 
        ACE_NTOHL (0x65633a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      15,
      ACE_NTOHL (0x696e7465), 
      ACE_NTOHL (0x72666163), 
      ACE_NTOHL (0x655f7479), 
      ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f496e), 
        ACE_NTOHL (0x74657266), 
        ACE_NTOHL (0x61636544), 
        ACE_NTOHL (0x65663a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_InterfaceDef:1.0
        19,
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f496e), 
        ACE_NTOHL (0x74657266), 
        ACE_NTOHL (0x61636544), 
        ACE_NTOHL (0x65660000),  // name = CORBA_InterfaceDef

      12,
      ACE_NTOHL (0x69735f6d), 
      ACE_NTOHL (0x756c7469), 
      ACE_NTOHL (0x706c6500),  // name = is_multiple
      CORBA::tk_boolean,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_UsesDescSeq),
    (char *) &_oc_IR_UsesDescSeq,
    0,
    sizeof (IR::UsesDescSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescSeq, &_tc_TAO_tc_IR_UsesDescSeq)
TAO_NAMESPACE_END

IR::EventDef_ptr
tao_IR_EventDef_duplicate (
    IR::EventDef_ptr p
  )
{
  return IR::EventDef::_duplicate (p);
}

void
tao_IR_EventDef_release (
    IR::EventDef_ptr p
  )
{
  CORBA::release (p);
}

IR::EventDef_ptr
tao_IR_EventDef_nil (
    void
  )
{
  return IR::EventDef::_nil ();
}

IR::EventDef_ptr
tao_IR_EventDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::EventDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_EventDef_upcast (
    void *src
  )
{
  IR::EventDef **tmp =
    ACE_static_cast (IR::EventDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::EventDef_var
// *************************************************************

IR::EventDef_var::EventDef_var (void) // default constructor
  : ptr_ (EventDef::_nil ())
{}

::IR::EventDef_ptr
IR::EventDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::EventDef_var::EventDef_var (const ::IR::EventDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EventDef::_duplicate (p.ptr ()))
{}

IR::EventDef_var::~EventDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::EventDef_var &
IR::EventDef_var::operator= (EventDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::EventDef_var &
IR::EventDef_var::operator= (const ::IR::EventDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::EventDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::EventDef_var::operator const ::IR::EventDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::EventDef_var::operator ::IR::EventDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_var::in (void) const
{
  return this->ptr_;
}

::IR::EventDef_ptr &
IR::EventDef_var::inout (void)
{
  return this->ptr_;
}

::IR::EventDef_ptr &
IR::EventDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EventDef::_nil ();
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::EventDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::EventDef::_nil ();
  return val;
}

::IR::EventDef_ptr
IR::EventDef_var::duplicate (EventDef_ptr p)
{
  return ::IR::EventDef::_duplicate (p);
}

void
IR::EventDef_var::release (EventDef_ptr p)
{
  CORBA::release (p);
}

::IR::EventDef_ptr
IR::EventDef_var::nil (void)
{
  return ::IR::EventDef::_nil ();
}

::IR::EventDef_ptr
IR::EventDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::EventDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::EventDef_var::upcast (void *src)
{
  EventDef **tmp =
    ACE_static_cast (EventDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::EventDef_out
// *************************************************************

IR::EventDef_out::EventDef_out (EventDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::EventDef::_nil ();
}

IR::EventDef_out::EventDef_out (EventDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EventDef::_nil ();
}

IR::EventDef_out::EventDef_out (const ::IR::EventDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EventDef_out &, p).ptr_)
{}

::IR::EventDef_out &
IR::EventDef_out::operator= (const ::IR::EventDef_out &p)
{
  this->ptr_ = ACE_const_cast (EventDef_out&, p).ptr_;
  return *this;
}

IR::EventDef_out &
IR::EventDef_out::operator= (const ::IR::EventDef_var &p)
{
  this->ptr_ = ::IR::EventDef::_duplicate (p.ptr ());
  return *this;
}

IR::EventDef_out &
IR::EventDef_out::operator= (EventDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::EventDef_out::operator ::IR::EventDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::EventDef_ptr &
IR::EventDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_EventDef_is_a : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_EventDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * event_id,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_EventDef_is_a (const TAO_ClientRequestInfo_IR_EventDef_is_a &);
  void operator= (const TAO_ClientRequestInfo_IR_EventDef_is_a &);

  const char * event_id_;
  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_EventDef_is_a::TAO_ClientRequestInfo_IR_EventDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * event_id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    event_id_ (event_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_EventDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_event_id = parameter_list->length ();
  parameter_list->length (length_event_id + 1);
  (*parameter_list)[length_event_id].argument <<= event_id_;
  (*parameter_list)[length_event_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_EventDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_EventDef_event_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_EventDef_event_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_EventDef_event_get (const TAO_ClientRequestInfo_IR_EventDef_event_get &);
  void operator= (const TAO_ClientRequestInfo_IR_EventDef_event_get &);

  CORBA_ValueDef_ptr _result;
};

TAO_ClientRequestInfo_IR_EventDef_event_get::TAO_ClientRequestInfo_IR_EventDef_event_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_EventDef_event_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_EventDef_event_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_EventDef_event_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_EventDef_event_get::result (CORBA_ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_EventDef_Proxy_Impl::_TAO_EventDef_Proxy_Impl (void)
{}

IR::_TAO_EventDef_Remote_Proxy_Impl::_TAO_EventDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Boolean IR::_TAO_EventDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_EventDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        event_id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << event_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

CORBA_ValueDef_ptr IR::_TAO_EventDef_Remote_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA_ValueDef_ptr _tao_retval = CORBA_ValueDef::_nil ();
  CORBA_ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_event",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_EventDef_event_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_EventDef_Proxy_Broker::_TAO_EventDef_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Proxy_Broker::~_TAO_EventDef_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Proxy_Broker * (*IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_EventDef_Remote_Proxy_Broker *
IR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_EventDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_EventDef_Remote_Proxy_Broker::_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Remote_Proxy_Broker::~_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Proxy_Impl&
IR::_TAO_EventDef_Remote_Proxy_Broker::select_proxy (
  ::IR::EventDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::EventDef::EventDef (int collocated)
{
  this->IR_EventDef_setup_collocation (collocated);
}

// destructor
IR::EventDef::~EventDef (void)
{}

void
IR::EventDef::IR_EventDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventDef_Proxy_Broker_ =
      ::IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventDef_Proxy_Broker_ =
      ::IR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::EventDef::_tao_any_destructor (void *x)
{
  EventDef *tmp = ACE_static_cast (EventDef*,x);
  CORBA::release (tmp);
}

IR::EventDef_ptr IR::EventDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return EventDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EventDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (EventDef::_nil ());
      if (is_a == 0)
        return EventDef::_nil ();
    }
  return EventDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::EventDef_ptr IR::EventDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return EventDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      EventDef_ptr default_proxy = EventDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::EventDef (
            stub,
            1,
            obj->_servant ()),
            
          EventDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::EventDef (stub, 0, obj->_servant ()), EventDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            EventDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &EventDef::_narrow
                    )
                )
          );
}

IR::EventDef_ptr
IR::EventDef::_duplicate (EventDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::EventDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::EventDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

CORBA::Boolean IR::EventDef::is_a (
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventDef_Proxy_Impl &proxy = 
    this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_a (
      this,
      event_id,
      ACE_TRY_ENV
    );
}

CORBA_ValueDef_ptr IR::EventDef::event (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventDef_Proxy_Impl &proxy = 
    this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.event (
      this,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_EventDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDef:1.0
  9,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x0),  // name = EventDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_EventDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_EventDef),
    (char *) &_oc_IR_EventDef,
    0,
    sizeof (IR::EventDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDef, &_tc_TAO_tc_IR_EventDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_EventDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDescription:1.0
  17,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = EventDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f49), 
    ACE_NTOHL (0x64656e74), 
    ACE_NTOHL (0x69666965), 
    ACE_NTOHL (0x723a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f56), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x6f6e5370), 
    ACE_NTOHL (0x65633a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_objref, // typecode kind
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f5661), 
    ACE_NTOHL (0x6c756544), 
    ACE_NTOHL (0x65663a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_ValueDef:1.0
    15,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f5661), 
    ACE_NTOHL (0x6c756544), 
    ACE_NTOHL (0x65660000),  // name = CORBA_ValueDef

};

static CORBA::TypeCode _tc_TAO_tc_IR_EventDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_EventDescription),
    (char *) &_oc_IR_EventDescription,
    0,
    sizeof (IR::EventDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDescription, &_tc_TAO_tc_IR_EventDescription)
TAO_NAMESPACE_END

void IR::EventDescription::_tao_any_destructor (void *x)
{
  EventDescription *tmp = ACE_static_cast (EventDescription*,x);
  delete tmp;
}

IR::EmitsDef_ptr
tao_IR_EmitsDef_duplicate (
    IR::EmitsDef_ptr p
  )
{
  return IR::EmitsDef::_duplicate (p);
}

void
tao_IR_EmitsDef_release (
    IR::EmitsDef_ptr p
  )
{
  CORBA::release (p);
}

IR::EmitsDef_ptr
tao_IR_EmitsDef_nil (
    void
  )
{
  return IR::EmitsDef::_nil ();
}

IR::EmitsDef_ptr
tao_IR_EmitsDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::EmitsDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_EmitsDef_upcast (
    void *src
  )
{
  IR::EmitsDef **tmp =
    ACE_static_cast (IR::EmitsDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::EmitsDef_var
// *************************************************************

IR::EmitsDef_var::EmitsDef_var (void) // default constructor
  : ptr_ (EmitsDef::_nil ())
{}

::IR::EmitsDef_ptr
IR::EmitsDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::EmitsDef_var::EmitsDef_var (const ::IR::EmitsDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EmitsDef::_duplicate (p.ptr ()))
{}

IR::EmitsDef_var::~EmitsDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::EmitsDef_var &
IR::EmitsDef_var::operator= (EmitsDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::EmitsDef_var &
IR::EmitsDef_var::operator= (const ::IR::EmitsDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::EmitsDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::EmitsDef_var::operator const ::IR::EmitsDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::EmitsDef_var::operator ::IR::EmitsDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::in (void) const
{
  return this->ptr_;
}

::IR::EmitsDef_ptr &
IR::EmitsDef_var::inout (void)
{
  return this->ptr_;
}

::IR::EmitsDef_ptr &
IR::EmitsDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EmitsDef::_nil ();
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::EmitsDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::EmitsDef::_nil ();
  return val;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::duplicate (EmitsDef_ptr p)
{
  return ::IR::EmitsDef::_duplicate (p);
}

void
IR::EmitsDef_var::release (EmitsDef_ptr p)
{
  CORBA::release (p);
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::nil (void)
{
  return ::IR::EmitsDef::_nil ();
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::EmitsDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::EmitsDef_var::upcast (void *src)
{
  EmitsDef **tmp =
    ACE_static_cast (EmitsDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::EmitsDef_out
// *************************************************************

IR::EmitsDef_out::EmitsDef_out (EmitsDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::EmitsDef::_nil ();
}

IR::EmitsDef_out::EmitsDef_out (EmitsDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EmitsDef::_nil ();
}

IR::EmitsDef_out::EmitsDef_out (const ::IR::EmitsDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EmitsDef_out &, p).ptr_)
{}

::IR::EmitsDef_out &
IR::EmitsDef_out::operator= (const ::IR::EmitsDef_out &p)
{
  this->ptr_ = ACE_const_cast (EmitsDef_out&, p).ptr_;
  return *this;
}

IR::EmitsDef_out &
IR::EmitsDef_out::operator= (const ::IR::EmitsDef_var &p)
{
  this->ptr_ = ::IR::EmitsDef::_duplicate (p.ptr ());
  return *this;
}

IR::EmitsDef_out &
IR::EmitsDef_out::operator= (EmitsDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::EmitsDef_out::operator ::IR::EmitsDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::EmitsDef_ptr &
IR::EmitsDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_EmitsDef_Proxy_Impl::_TAO_EmitsDef_Proxy_Impl (void)
{}

IR::_TAO_EmitsDef_Remote_Proxy_Impl::_TAO_EmitsDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_EmitsDef_Proxy_Broker::_TAO_EmitsDef_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Proxy_Broker::~_TAO_EmitsDef_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Proxy_Broker * (*IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_EmitsDef_Remote_Proxy_Broker *
IR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_EmitsDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_EmitsDef_Remote_Proxy_Broker::_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Remote_Proxy_Broker::~_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Proxy_Impl&
IR::_TAO_EmitsDef_Remote_Proxy_Broker::select_proxy (
  ::IR::EmitsDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::EmitsDef::EmitsDef (int collocated)
{
  this->IR_EmitsDef_setup_collocation (collocated);
}

// destructor
IR::EmitsDef::~EmitsDef (void)
{}

void
IR::EmitsDef::IR_EmitsDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      ::IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      ::IR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker ();
  
  this->IR_EventDef_setup_collocation (collocated);
}

void IR::EmitsDef::_tao_any_destructor (void *x)
{
  EmitsDef *tmp = ACE_static_cast (EmitsDef*,x);
  CORBA::release (tmp);
}

IR::EmitsDef_ptr IR::EmitsDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return EmitsDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EmitsDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (EmitsDef::_nil ());
      if (is_a == 0)
        return EmitsDef::_nil ();
    }
  return EmitsDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::EmitsDef_ptr IR::EmitsDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return EmitsDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      EmitsDef_ptr default_proxy = EmitsDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::EmitsDef (
            stub,
            1,
            obj->_servant ()),
            
          EmitsDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::EmitsDef (stub, 0, obj->_servant ()), EmitsDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            EmitsDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &EmitsDef::_narrow
                    )
                )
          );
}

IR::EmitsDef_ptr
IR::EmitsDef::_duplicate (EmitsDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::EmitsDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::EmitsDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EmitsDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR::EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

static const CORBA::Long _oc_IR_EmitsDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f45), 
  ACE_NTOHL (0x6d697473), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
  9,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x0),  // name = EmitsDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_EmitsDef),
    (char *) &_oc_IR_EmitsDef,
    0,
    sizeof (IR::EmitsDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDef, &_tc_TAO_tc_IR_EmitsDef)
TAO_NAMESPACE_END

IR::PublishesDef_ptr
tao_IR_PublishesDef_duplicate (
    IR::PublishesDef_ptr p
  )
{
  return IR::PublishesDef::_duplicate (p);
}

void
tao_IR_PublishesDef_release (
    IR::PublishesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::PublishesDef_ptr
tao_IR_PublishesDef_nil (
    void
  )
{
  return IR::PublishesDef::_nil ();
}

IR::PublishesDef_ptr
tao_IR_PublishesDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::PublishesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_PublishesDef_upcast (
    void *src
  )
{
  IR::PublishesDef **tmp =
    ACE_static_cast (IR::PublishesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::PublishesDef_var
// *************************************************************

IR::PublishesDef_var::PublishesDef_var (void) // default constructor
  : ptr_ (PublishesDef::_nil ())
{}

::IR::PublishesDef_ptr
IR::PublishesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::PublishesDef_var::PublishesDef_var (const ::IR::PublishesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (PublishesDef::_duplicate (p.ptr ()))
{}

IR::PublishesDef_var::~PublishesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::PublishesDef_var &
IR::PublishesDef_var::operator= (PublishesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::PublishesDef_var &
IR::PublishesDef_var::operator= (const ::IR::PublishesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::PublishesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::PublishesDef_var::operator const ::IR::PublishesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::PublishesDef_var::operator ::IR::PublishesDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::PublishesDef_ptr &
IR::PublishesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::PublishesDef_ptr &
IR::PublishesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PublishesDef::_nil ();
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::PublishesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::PublishesDef::_nil ();
  return val;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::duplicate (PublishesDef_ptr p)
{
  return ::IR::PublishesDef::_duplicate (p);
}

void
IR::PublishesDef_var::release (PublishesDef_ptr p)
{
  CORBA::release (p);
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::nil (void)
{
  return ::IR::PublishesDef::_nil ();
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::PublishesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::PublishesDef_var::upcast (void *src)
{
  PublishesDef **tmp =
    ACE_static_cast (PublishesDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::PublishesDef_out
// *************************************************************

IR::PublishesDef_out::PublishesDef_out (PublishesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::PublishesDef::_nil ();
}

IR::PublishesDef_out::PublishesDef_out (PublishesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PublishesDef::_nil ();
}

IR::PublishesDef_out::PublishesDef_out (const ::IR::PublishesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PublishesDef_out &, p).ptr_)
{}

::IR::PublishesDef_out &
IR::PublishesDef_out::operator= (const ::IR::PublishesDef_out &p)
{
  this->ptr_ = ACE_const_cast (PublishesDef_out&, p).ptr_;
  return *this;
}

IR::PublishesDef_out &
IR::PublishesDef_out::operator= (const ::IR::PublishesDef_var &p)
{
  this->ptr_ = ::IR::PublishesDef::_duplicate (p.ptr ());
  return *this;
}

IR::PublishesDef_out &
IR::PublishesDef_out::operator= (PublishesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::PublishesDef_out::operator ::IR::PublishesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::PublishesDef_ptr &
IR::PublishesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_PublishesDef_Proxy_Impl::_TAO_PublishesDef_Proxy_Impl (void)
{}

IR::_TAO_PublishesDef_Remote_Proxy_Impl::_TAO_PublishesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_PublishesDef_Proxy_Broker::_TAO_PublishesDef_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Proxy_Broker::~_TAO_PublishesDef_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Proxy_Broker * (*IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_PublishesDef_Remote_Proxy_Broker *
IR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_PublishesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_PublishesDef_Remote_Proxy_Broker::_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Remote_Proxy_Broker::~_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Proxy_Impl&
IR::_TAO_PublishesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::PublishesDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::PublishesDef::PublishesDef (int collocated)
{
  this->IR_PublishesDef_setup_collocation (collocated);
}

// destructor
IR::PublishesDef::~PublishesDef (void)
{}

void
IR::PublishesDef::IR_PublishesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      ::IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      ::IR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker ();
  
  this->IR_EventDef_setup_collocation (collocated);
}

void IR::PublishesDef::_tao_any_destructor (void *x)
{
  PublishesDef *tmp = ACE_static_cast (PublishesDef*,x);
  CORBA::release (tmp);
}

IR::PublishesDef_ptr IR::PublishesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return PublishesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PublishesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (PublishesDef::_nil ());
      if (is_a == 0)
        return PublishesDef::_nil ();
    }
  return PublishesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::PublishesDef_ptr IR::PublishesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PublishesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      PublishesDef_ptr default_proxy = PublishesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::PublishesDef (
            stub,
            1,
            obj->_servant ()),
            
          PublishesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::PublishesDef (stub, 0, obj->_servant ()), PublishesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            PublishesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &PublishesDef::_narrow
                    )
                )
          );
}

IR::PublishesDef_ptr
IR::PublishesDef::_duplicate (PublishesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::PublishesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::PublishesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, PublishesDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR::EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

static const CORBA::Long _oc_IR_PublishesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x75626c69), 
  ACE_NTOHL (0x73686573), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
  13,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x0),  // name = PublishesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_PublishesDef),
    (char *) &_oc_IR_PublishesDef,
    0,
    sizeof (IR::PublishesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDef, &_tc_TAO_tc_IR_PublishesDef)
TAO_NAMESPACE_END

IR::ConsumesDef_ptr
tao_IR_ConsumesDef_duplicate (
    IR::ConsumesDef_ptr p
  )
{
  return IR::ConsumesDef::_duplicate (p);
}

void
tao_IR_ConsumesDef_release (
    IR::ConsumesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::ConsumesDef_ptr
tao_IR_ConsumesDef_nil (
    void
  )
{
  return IR::ConsumesDef::_nil ();
}

IR::ConsumesDef_ptr
tao_IR_ConsumesDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::ConsumesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_ConsumesDef_upcast (
    void *src
  )
{
  IR::ConsumesDef **tmp =
    ACE_static_cast (IR::ConsumesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ConsumesDef_var
// *************************************************************

IR::ConsumesDef_var::ConsumesDef_var (void) // default constructor
  : ptr_ (ConsumesDef::_nil ())
{}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::ConsumesDef_var::ConsumesDef_var (const ::IR::ConsumesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ConsumesDef::_duplicate (p.ptr ()))
{}

IR::ConsumesDef_var::~ConsumesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ConsumesDef_var &
IR::ConsumesDef_var::operator= (ConsumesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ConsumesDef_var &
IR::ConsumesDef_var::operator= (const ::IR::ConsumesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ConsumesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ConsumesDef_var::operator const ::IR::ConsumesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::ConsumesDef_var::operator ::IR::ConsumesDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr &
IR::ConsumesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr &
IR::ConsumesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ConsumesDef::_nil ();
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ConsumesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::ConsumesDef::_nil ();
  return val;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::duplicate (ConsumesDef_ptr p)
{
  return ::IR::ConsumesDef::_duplicate (p);
}

void
IR::ConsumesDef_var::release (ConsumesDef_ptr p)
{
  CORBA::release (p);
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::nil (void)
{
  return ::IR::ConsumesDef::_nil ();
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::ConsumesDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::ConsumesDef_var::upcast (void *src)
{
  ConsumesDef **tmp =
    ACE_static_cast (ConsumesDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::ConsumesDef_out
// *************************************************************

IR::ConsumesDef_out::ConsumesDef_out (ConsumesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ConsumesDef::_nil ();
}

IR::ConsumesDef_out::ConsumesDef_out (ConsumesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ConsumesDef::_nil ();
}

IR::ConsumesDef_out::ConsumesDef_out (const ::IR::ConsumesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConsumesDef_out &, p).ptr_)
{}

::IR::ConsumesDef_out &
IR::ConsumesDef_out::operator= (const ::IR::ConsumesDef_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumesDef_out&, p).ptr_;
  return *this;
}

IR::ConsumesDef_out &
IR::ConsumesDef_out::operator= (const ::IR::ConsumesDef_var &p)
{
  this->ptr_ = ::IR::ConsumesDef::_duplicate (p.ptr ());
  return *this;
}

IR::ConsumesDef_out &
IR::ConsumesDef_out::operator= (ConsumesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ConsumesDef_out::operator ::IR::ConsumesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr &
IR::ConsumesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_ConsumesDef_Proxy_Impl::_TAO_ConsumesDef_Proxy_Impl (void)
{}

IR::_TAO_ConsumesDef_Remote_Proxy_Impl::_TAO_ConsumesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ConsumesDef_Proxy_Broker::_TAO_ConsumesDef_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Proxy_Broker::~_TAO_ConsumesDef_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Proxy_Broker * (*IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ConsumesDef_Remote_Proxy_Broker *
IR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ConsumesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ConsumesDef_Remote_Proxy_Broker::_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Remote_Proxy_Broker::~_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Proxy_Impl&
IR::_TAO_ConsumesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::ConsumesDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ConsumesDef::ConsumesDef (int collocated)
{
  this->IR_ConsumesDef_setup_collocation (collocated);
}

// destructor
IR::ConsumesDef::~ConsumesDef (void)
{}

void
IR::ConsumesDef::IR_ConsumesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      ::IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      ::IR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker ();
  
  this->IR_EventDef_setup_collocation (collocated);
}

void IR::ConsumesDef::_tao_any_destructor (void *x)
{
  ConsumesDef *tmp = ACE_static_cast (ConsumesDef*,x);
  CORBA::release (tmp);
}

IR::ConsumesDef_ptr IR::ConsumesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ConsumesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConsumesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ConsumesDef::_nil ());
      if (is_a == 0)
        return ConsumesDef::_nil ();
    }
  return ConsumesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ConsumesDef_ptr IR::ConsumesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ConsumesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ConsumesDef_ptr default_proxy = ConsumesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ConsumesDef (
            stub,
            1,
            obj->_servant ()),
            
          ConsumesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ConsumesDef (stub, 0, obj->_servant ()), ConsumesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            ConsumesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ConsumesDef::_narrow
                    )
                )
          );
}

IR::ConsumesDef_ptr
IR::ConsumesDef::_duplicate (ConsumesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ConsumesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::ConsumesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ConsumesDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR::EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

static const CORBA::Long _oc_IR_ConsumesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f43), 
  ACE_NTOHL (0x6f6e7375), 
  ACE_NTOHL (0x6d657344), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
  12,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6573), 
  ACE_NTOHL (0x44656600),  // name = ConsumesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_ConsumesDef),
    (char *) &_oc_IR_ConsumesDef,
    0,
    sizeof (IR::ConsumesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDef, &_tc_TAO_tc_IR_ConsumesDef)
TAO_NAMESPACE_END

IR::ComponentDef_ptr
tao_IR_ComponentDef_duplicate (
    IR::ComponentDef_ptr p
  )
{
  return IR::ComponentDef::_duplicate (p);
}

void
tao_IR_ComponentDef_release (
    IR::ComponentDef_ptr p
  )
{
  CORBA::release (p);
}

IR::ComponentDef_ptr
tao_IR_ComponentDef_nil (
    void
  )
{
  return IR::ComponentDef::_nil ();
}

IR::ComponentDef_ptr
tao_IR_ComponentDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::ComponentDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_ComponentDef_upcast (
    void *src
  )
{
  IR::ComponentDef **tmp =
    ACE_static_cast (IR::ComponentDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ComponentDef_var
// *************************************************************

IR::ComponentDef_var::ComponentDef_var (void) // default constructor
  : ptr_ (ComponentDef::_nil ())
{}

::IR::ComponentDef_ptr
IR::ComponentDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::ComponentDef_var::ComponentDef_var (const ::IR::ComponentDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentDef::_duplicate (p.ptr ()))
{}

IR::ComponentDef_var::~ComponentDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ComponentDef_var &
IR::ComponentDef_var::operator= (ComponentDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ComponentDef_var &
IR::ComponentDef_var::operator= (const ::IR::ComponentDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ComponentDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ComponentDef_var::operator const ::IR::ComponentDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::ComponentDef_var::operator ::IR::ComponentDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::in (void) const
{
  return this->ptr_;
}

::IR::ComponentDef_ptr &
IR::ComponentDef_var::inout (void)
{
  return this->ptr_;
}

::IR::ComponentDef_ptr &
IR::ComponentDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentDef::_nil ();
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ComponentDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::ComponentDef::_nil ();
  return val;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::duplicate (ComponentDef_ptr p)
{
  return ::IR::ComponentDef::_duplicate (p);
}

void
IR::ComponentDef_var::release (ComponentDef_ptr p)
{
  CORBA::release (p);
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::nil (void)
{
  return ::IR::ComponentDef::_nil ();
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::ComponentDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::ComponentDef_var::upcast (void *src)
{
  ComponentDef **tmp =
    ACE_static_cast (ComponentDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::ComponentDef_out
// *************************************************************

IR::ComponentDef_out::ComponentDef_out (ComponentDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ComponentDef::_nil ();
}

IR::ComponentDef_out::ComponentDef_out (ComponentDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentDef::_nil ();
}

IR::ComponentDef_out::ComponentDef_out (const ::IR::ComponentDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentDef_out &, p).ptr_)
{}

::IR::ComponentDef_out &
IR::ComponentDef_out::operator= (const ::IR::ComponentDef_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentDef_out&, p).ptr_;
  return *this;
}

IR::ComponentDef_out &
IR::ComponentDef_out::operator= (const ::IR::ComponentDef_var &p)
{
  this->ptr_ = ::IR::ComponentDef::_duplicate (p.ptr ());
  return *this;
}

IR::ComponentDef_out &
IR::ComponentDef_out::operator= (ComponentDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ComponentDef_out::operator ::IR::ComponentDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ComponentDef_ptr &
IR::ComponentDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get &);

  CORBA_InterfaceDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA_InterfaceDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set &);

  const CORBA_InterfaceDefSeq & supported_interfaces_;
  
};

TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_IR_ComponentDef_base_component_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (const TAO_ClientRequestInfo_IR_ComponentDef_base_component_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_base_component_get &);

  IR::ComponentDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (IR::ComponentDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (const TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get &);

  IR::ProvidesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR::ProvidesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (const TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get &);

  IR::UsesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR::UsesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (const TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get &);

  IR::EmitsDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (IR::EmitsDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (const TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get &);

  IR::PublishesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (IR::PublishesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (const TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get &);

  IR::ConsumesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (IR::ConsumesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (const TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get &);

  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_provides : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_provides (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_InterfaceDef_ptr interface_type,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_provides (const TAO_ClientRequestInfo_IR_ComponentDef_create_provides &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_provides &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  IR::ProvidesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_provides::TAO_ClientRequestInfo_IR_ComponentDef_create_provides (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
  
  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (IR::ProvidesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_uses : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_uses (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_InterfaceDef_ptr interface_type,
      const CORBA::Boolean & is_multiple,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_uses (const TAO_ClientRequestInfo_IR_ComponentDef_create_uses &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_uses &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  const CORBA::Boolean & is_multiple_;
  IR::UsesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_uses::TAO_ClientRequestInfo_IR_ComponentDef_create_uses (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type),
    is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
  
  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_multiple = parameter_list->length ();
  parameter_list->length (length_is_multiple + 1);
  (*parameter_list)[length_is_multiple].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[length_is_multiple].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (IR::UsesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_emits : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_emits (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_emits (const TAO_ClientRequestInfo_IR_ComponentDef_create_emits &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_emits &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::EmitsDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_emits::TAO_ClientRequestInfo_IR_ComponentDef_create_emits (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (IR::EmitsDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_publishes : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (const TAO_ClientRequestInfo_IR_ComponentDef_create_publishes &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_publishes &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::PublishesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (IR::PublishesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_consumes : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (const TAO_ClientRequestInfo_IR_ComponentDef_create_consumes &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_consumes &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::ConsumesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (IR::ConsumesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_ComponentDef_Proxy_Impl::_TAO_ComponentDef_Proxy_Impl (void)
{}

IR::_TAO_ComponentDef_Remote_Proxy_Impl::_TAO_ComponentDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA_InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA_InterfaceDefSeq, _tao_retval);
  CORBA_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA_InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void IR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
        &_tao_call,
        _collocated_tao_target_,
        supported_interfaces,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << supported_interfaces)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR::ComponentDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_component",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_base_component_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::ProvidesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ProvidesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ProvidesDefSeq, _tao_retval);
  IR::ProvidesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_provides_interfaces",
      24,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ProvidesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::UsesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::UsesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::UsesDefSeq, _tao_retval);
  IR::UsesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_uses_interfaces",
      20,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::UsesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::EmitsDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::EmitsDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::EmitsDefSeq, _tao_retval);
  IR::EmitsDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_emits_events",
      17,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::EmitsDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::PublishesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PublishesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::PublishesDefSeq, _tao_retval);
  IR::PublishesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_publishes_events",
      21,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::PublishesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::ConsumesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ConsumesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::ConsumesDefSeq, _tao_retval);
  IR::ConsumesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_consumes_events",
      20,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ConsumesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::_TAO_ComponentDef_Remote_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR::ProvidesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ProvidesDef_ptr _tao_retval = IR::ProvidesDef::_nil ();
  IR::ProvidesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_provides",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_provides ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        interface_type,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ProvidesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::UsesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::UsesDef_ptr _tao_retval = IR::UsesDef::_nil ();
  IR::UsesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_uses",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_uses ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        interface_type,
        is_multiple,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type) &&
              (_tao_out << CORBA::Any::from_boolean (is_multiple))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::UsesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::EmitsDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::EmitsDef_ptr _tao_retval = IR::EmitsDef::_nil ();
  IR::EmitsDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_emits",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_emits ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::EmitsDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::PublishesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PublishesDef_ptr _tao_retval = IR::PublishesDef::_nil ();
  IR::PublishesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_publishes",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_publishes ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::PublishesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::ConsumesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ConsumesDef_ptr _tao_retval = IR::ConsumesDef::_nil ();
  IR::ConsumesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_consumes",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_consumes ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ConsumesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ComponentDef_Proxy_Broker::_TAO_ComponentDef_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Proxy_Broker::~_TAO_ComponentDef_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Proxy_Broker * (*IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ComponentDef_Remote_Proxy_Broker *
IR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ComponentDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ComponentDef_Remote_Proxy_Broker::_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Remote_Proxy_Broker::~_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Proxy_Impl&
IR::_TAO_ComponentDef_Remote_Proxy_Broker::select_proxy (
  ::IR::ComponentDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ComponentDef::ComponentDef (int collocated)
{
  this->IR_ComponentDef_setup_collocation (collocated);
}

// destructor
IR::ComponentDef::~ComponentDef (void)
{}

void
IR::ComponentDef::IR_ComponentDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      ::IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      ::IR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker ();
  
  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void IR::ComponentDef::_tao_any_destructor (void *x)
{
  ComponentDef *tmp = ACE_static_cast (ComponentDef*,x);
  CORBA::release (tmp);
}

IR::ComponentDef_ptr IR::ComponentDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ComponentDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ComponentDef::_nil ());
      if (is_a == 0)
        return ComponentDef::_nil ();
    }
  return ComponentDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::ComponentDef_ptr IR::ComponentDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ComponentDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ComponentDef_ptr default_proxy = ComponentDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ComponentDef (
            stub,
            1,
            obj->_servant ()),
            
          ComponentDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ComponentDef (stub, 0, obj->_servant ()), ComponentDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            ComponentDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ComponentDef::_narrow
                    )
                )
          );
}

IR::ComponentDef_ptr
IR::ComponentDef::_duplicate (ComponentDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ComponentDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::ComponentDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ComponentDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

CORBA_InterfaceDefSeq * IR::ComponentDef::supported_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.supported_interfaces (
      this,
      ACE_TRY_ENV
    );
}

void IR::ComponentDef::supported_interfaces (
    const CORBA_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK;
  
  proxy.supported_interfaces (
      this,
      supported_interfaces,
      ACE_TRY_ENV
    );
}

IR::ComponentDef_ptr IR::ComponentDef::base_component (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.base_component (
      this,
      ACE_TRY_ENV
    );
}

IR::ProvidesDefSeq * IR::ComponentDef::provides_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.provides_interfaces (
      this,
      ACE_TRY_ENV
    );
}

IR::UsesDefSeq * IR::ComponentDef::uses_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.uses_interfaces (
      this,
      ACE_TRY_ENV
    );
}

IR::EmitsDefSeq * IR::ComponentDef::emits_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.emits_events (
      this,
      ACE_TRY_ENV
    );
}

IR::PublishesDefSeq * IR::ComponentDef::publishes_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.publishes_events (
      this,
      ACE_TRY_ENV
    );
}

IR::ConsumesDefSeq * IR::ComponentDef::consumes_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.consumes_events (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR::ComponentDef::is_basic (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_basic (
      this,
      ACE_TRY_ENV
    );
}

IR::ProvidesDef_ptr IR::ComponentDef::create_provides (
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_provides (
      this,
      id,
      name,
      version,
      interface_type,
      ACE_TRY_ENV
    );
}

IR::UsesDef_ptr IR::ComponentDef::create_uses (
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_uses (
      this,
      id,
      name,
      version,
      interface_type,
      is_multiple,
      ACE_TRY_ENV
    );
}

IR::EmitsDef_ptr IR::ComponentDef::create_emits (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_emits (
      this,
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );
}

IR::PublishesDef_ptr IR::ComponentDef::create_publishes (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_publishes (
      this,
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );
}

IR::ConsumesDef_ptr IR::ComponentDef::create_consumes (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_consumes (
      this,
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_ComponentDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
  13,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x0),  // name = ComponentDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_ComponentDef),
    (char *) &_oc_IR_ComponentDef,
    0,
    sizeof (IR::ComponentDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDef, &_tc_TAO_tc_IR_ComponentDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ComponentDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDescription:1.0
  21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ComponentDescription
  13, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f49), 
    ACE_NTOHL (0x64656e74), 
    ACE_NTOHL (0x69666965), 
    ACE_NTOHL (0x723a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f56), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x6f6e5370), 
    ACE_NTOHL (0x65633a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f636f6d), 
  ACE_NTOHL (0x706f6e65), 
  ACE_NTOHL (0x6e740000),  // name = base_component
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  20,
  ACE_NTOHL (0x73757070), 
  ACE_NTOHL (0x6f727473), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = supports_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x79496453), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f52), 
        ACE_NTOHL (0x65706f73), 
        ACE_NTOHL (0x69746f72), 
        ACE_NTOHL (0x7949643a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  20,
  ACE_NTOHL (0x70726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = provides_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f50), 
    ACE_NTOHL (0x726f7669), 
    ACE_NTOHL (0x64657344), 
    ACE_NTOHL (0x65665365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
    15,
    ACE_NTOHL (0x50726f76), 
    ACE_NTOHL (0x69646573), 
    ACE_NTOHL (0x44656653), 
    ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f50), 
        ACE_NTOHL (0x726f7669), 
        ACE_NTOHL (0x64657344), 
        ACE_NTOHL (0x65663a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
        12,
        ACE_NTOHL (0x50726f76), 
        ACE_NTOHL (0x69646573), 
        ACE_NTOHL (0x44656600),  // name = ProvidesDef

      0U,


  16,
  ACE_NTOHL (0x75736573), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = uses_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  128, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f55), 
    ACE_NTOHL (0x73657344), 
    ACE_NTOHL (0x65665365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
    11,
    ACE_NTOHL (0x55736573), 
    ACE_NTOHL (0x44656653), 
    ACE_NTOHL (0x65710000),  // name = UsesDefSeq
    CORBA::tk_sequence, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f55), 
        ACE_NTOHL (0x73657344), 
        ACE_NTOHL (0x65663a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
        8,
        ACE_NTOHL (0x55736573), 
        ACE_NTOHL (0x44656600),  // name = UsesDef

      0U,


  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  420, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f4174), 
    ACE_NTOHL (0x74724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA_AttrDescriptionSeq:1.0
    25,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f4174), 
    ACE_NTOHL (0x74724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = CORBA_AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    328, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      312, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x75746544), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_AttributeDescription:1.0
        27,
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x75746544), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e0000),  // name = CORBA_AttributeDescription
        6, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_string, 
        0U, // string length
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_string, 
        0U, // string length
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_string, 
        0U, // string length
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        108, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA_AttributeMode:1.0
          20,
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f646500),  // name = CORBA_AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  13,
  ACE_NTOHL (0x656d6974), 
  ACE_NTOHL (0x735f6576), 
  ACE_NTOHL (0x656e7473), 
  ACE_NTOHL (0x0),  // name = emits_events
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f45), 
    ACE_NTOHL (0x6d697473), 
    ACE_NTOHL (0x44656653), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
    12,
    ACE_NTOHL (0x456d6974), 
    ACE_NTOHL (0x73446566), 
    ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
    CORBA::tk_sequence, // typecode kind
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        28,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f45), 
        ACE_NTOHL (0x6d697473), 
        ACE_NTOHL (0x4465663a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
        9,
        ACE_NTOHL (0x456d6974), 
        ACE_NTOHL (0x73446566), 
        ACE_NTOHL (0x0),  // name = EmitsDef

      0U,


  17,
  ACE_NTOHL (0x7075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x735f6576), 
  ACE_NTOHL (0x656e7473), 
  ACE_NTOHL (0x0),  // name = publishes_events
  CORBA::tk_alias, // typecode kind for typedefs
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f50), 
    ACE_NTOHL (0x75626c69), 
    ACE_NTOHL (0x73686573), 
    ACE_NTOHL (0x44656653), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
    16,
    ACE_NTOHL (0x5075626c), 
    ACE_NTOHL (0x69736865), 
    ACE_NTOHL (0x73446566), 
    ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
    CORBA::tk_sequence, // typecode kind
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f50), 
        ACE_NTOHL (0x75626c69), 
        ACE_NTOHL (0x73686573), 
        ACE_NTOHL (0x4465663a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
        13,
        ACE_NTOHL (0x5075626c), 
        ACE_NTOHL (0x69736865), 
        ACE_NTOHL (0x73446566), 
        ACE_NTOHL (0x0),  // name = PublishesDef

      0U,


  16,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6573), 
  ACE_NTOHL (0x5f657665), 
  ACE_NTOHL (0x6e747300),  // name = consumes_events
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f43), 
    ACE_NTOHL (0x6f6e7375), 
    ACE_NTOHL (0x6d657344), 
    ACE_NTOHL (0x65665365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
    15,
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6573), 
    ACE_NTOHL (0x44656653), 
    ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f43), 
        ACE_NTOHL (0x6f6e7375), 
        ACE_NTOHL (0x6d657344), 
        ACE_NTOHL (0x65663a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
        12,
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6573), 
        ACE_NTOHL (0x44656600),  // name = ConsumesDef

      0U,


  9,
  ACE_NTOHL (0x69735f62), 
  ACE_NTOHL (0x61736963), 
  ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_ComponentDescription),
    (char *) &_oc_IR_ComponentDescription,
    0,
    sizeof (IR::ComponentDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDescription, &_tc_TAO_tc_IR_ComponentDescription)
TAO_NAMESPACE_END

void IR::ComponentDescription::_tao_any_destructor (void *x)
{
  ComponentDescription *tmp = ACE_static_cast (ComponentDescription*,x);
  delete tmp;
}

IR::PrimaryKeyDef_ptr
tao_IR_PrimaryKeyDef_duplicate (
    IR::PrimaryKeyDef_ptr p
  )
{
  return IR::PrimaryKeyDef::_duplicate (p);
}

void
tao_IR_PrimaryKeyDef_release (
    IR::PrimaryKeyDef_ptr p
  )
{
  CORBA::release (p);
}

IR::PrimaryKeyDef_ptr
tao_IR_PrimaryKeyDef_nil (
    void
  )
{
  return IR::PrimaryKeyDef::_nil ();
}

IR::PrimaryKeyDef_ptr
tao_IR_PrimaryKeyDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::PrimaryKeyDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_PrimaryKeyDef_upcast (
    void *src
  )
{
  IR::PrimaryKeyDef **tmp =
    ACE_static_cast (IR::PrimaryKeyDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::PrimaryKeyDef_var
// *************************************************************

IR::PrimaryKeyDef_var::PrimaryKeyDef_var (void) // default constructor
  : ptr_ (PrimaryKeyDef::_nil ())
{}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::PrimaryKeyDef_var::PrimaryKeyDef_var (const ::IR::PrimaryKeyDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (PrimaryKeyDef::_duplicate (p.ptr ()))
{}

IR::PrimaryKeyDef_var::~PrimaryKeyDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::PrimaryKeyDef_var &
IR::PrimaryKeyDef_var::operator= (PrimaryKeyDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::PrimaryKeyDef_var &
IR::PrimaryKeyDef_var::operator= (const ::IR::PrimaryKeyDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::PrimaryKeyDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::PrimaryKeyDef_var::operator const ::IR::PrimaryKeyDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::PrimaryKeyDef_var::operator ::IR::PrimaryKeyDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::in (void) const
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr &
IR::PrimaryKeyDef_var::inout (void)
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr &
IR::PrimaryKeyDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::PrimaryKeyDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
  return val;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::duplicate (PrimaryKeyDef_ptr p)
{
  return ::IR::PrimaryKeyDef::_duplicate (p);
}

void
IR::PrimaryKeyDef_var::release (PrimaryKeyDef_ptr p)
{
  CORBA::release (p);
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::nil (void)
{
  return ::IR::PrimaryKeyDef::_nil ();
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::PrimaryKeyDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::PrimaryKeyDef_var::upcast (void *src)
{
  PrimaryKeyDef **tmp =
    ACE_static_cast (PrimaryKeyDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::PrimaryKeyDef_out
// *************************************************************

IR::PrimaryKeyDef_out::PrimaryKeyDef_out (PrimaryKeyDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
}

IR::PrimaryKeyDef_out::PrimaryKeyDef_out (PrimaryKeyDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
}

IR::PrimaryKeyDef_out::PrimaryKeyDef_out (const ::IR::PrimaryKeyDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PrimaryKeyDef_out &, p).ptr_)
{}

::IR::PrimaryKeyDef_out &
IR::PrimaryKeyDef_out::operator= (const ::IR::PrimaryKeyDef_out &p)
{
  this->ptr_ = ACE_const_cast (PrimaryKeyDef_out&, p).ptr_;
  return *this;
}

IR::PrimaryKeyDef_out &
IR::PrimaryKeyDef_out::operator= (const ::IR::PrimaryKeyDef_var &p)
{
  this->ptr_ = ::IR::PrimaryKeyDef::_duplicate (p.ptr ());
  return *this;
}

IR::PrimaryKeyDef_out &
IR::PrimaryKeyDef_out::operator= (PrimaryKeyDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::PrimaryKeyDef_out::operator ::IR::PrimaryKeyDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr &
IR::PrimaryKeyDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * primary_key_id,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a &);
  void operator= (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a &);

  const char * primary_key_id_;
  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * primary_key_id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    primary_key_id_ (primary_key_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_primary_key_id = parameter_list->length ();
  parameter_list->length (length_primary_key_id + 1);
  (*parameter_list)[length_primary_key_id].argument <<= primary_key_id_;
  (*parameter_list)[length_primary_key_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get &);
  void operator= (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get &);

  CORBA_ValueDef_ptr _result;
};

TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA_ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_PrimaryKeyDef_Proxy_Impl::_TAO_PrimaryKeyDef_Proxy_Impl (void)
{}

IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Boolean IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        primary_key_id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << primary_key_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

CORBA_ValueDef_ptr IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA_ValueDef_ptr _tao_retval = CORBA_ValueDef::_nil ();
  CORBA_ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_PrimaryKeyDef_Proxy_Broker::_TAO_PrimaryKeyDef_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Proxy_Broker::~_TAO_PrimaryKeyDef_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Proxy_Broker * (*IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker *
IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Proxy_Impl&
IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::select_proxy (
  ::IR::PrimaryKeyDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::PrimaryKeyDef::PrimaryKeyDef (int collocated)
{
  this->IR_PrimaryKeyDef_setup_collocation (collocated);
}

// destructor
IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{}

void
IR::PrimaryKeyDef::IR_PrimaryKeyDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
      ::IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
      ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::PrimaryKeyDef::_tao_any_destructor (void *x)
{
  PrimaryKeyDef *tmp = ACE_static_cast (PrimaryKeyDef*,x);
  CORBA::release (tmp);
}

IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return PrimaryKeyDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimaryKeyDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (PrimaryKeyDef::_nil ());
      if (is_a == 0)
        return PrimaryKeyDef::_nil ();
    }
  return PrimaryKeyDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PrimaryKeyDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      PrimaryKeyDef_ptr default_proxy = PrimaryKeyDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::PrimaryKeyDef (
            stub,
            1,
            obj->_servant ()),
            
          PrimaryKeyDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::PrimaryKeyDef (stub, 0, obj->_servant ()), PrimaryKeyDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            PrimaryKeyDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &PrimaryKeyDef::_narrow
                    )
                )
          );
}

IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef::_duplicate (PrimaryKeyDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::PrimaryKeyDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::PrimaryKeyDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, PrimaryKeyDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

CORBA::Boolean IR::PrimaryKeyDef::is_a (
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_PrimaryKeyDef_Proxy_Impl &proxy = 
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_a (
      this,
      primary_key_id,
      ACE_TRY_ENV
    );
}

CORBA_ValueDef_ptr IR::PrimaryKeyDef::primary_key (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_PrimaryKeyDef_Proxy_Impl &proxy = 
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.primary_key (
      this,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_PrimaryKeyDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x72696d61), 
  ACE_NTOHL (0x72794b65), 
  ACE_NTOHL (0x79446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
  14,
  ACE_NTOHL (0x5072696d), 
  ACE_NTOHL (0x6172794b), 
  ACE_NTOHL (0x65794465), 
  ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_PrimaryKeyDef),
    (char *) &_oc_IR_PrimaryKeyDef,
    0,
    sizeof (IR::PrimaryKeyDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDef, &_tc_TAO_tc_IR_PrimaryKeyDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_PrimaryKeyDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f50), 
  ACE_NTOHL (0x72696d61), 
  ACE_NTOHL (0x72794b65), 
  ACE_NTOHL (0x79446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDescription:1.0
  22,
  ACE_NTOHL (0x5072696d), 
  ACE_NTOHL (0x6172794b), 
  ACE_NTOHL (0x65794465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = PrimaryKeyDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f49), 
    ACE_NTOHL (0x64656e74), 
    ACE_NTOHL (0x69666965), 
    ACE_NTOHL (0x723a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f56), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x6f6e5370), 
    ACE_NTOHL (0x65633a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  12,
  ACE_NTOHL (0x7072696d), 
  ACE_NTOHL (0x6172795f), 
  ACE_NTOHL (0x6b657900),  // name = primary_key
  CORBA::tk_objref, // typecode kind
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f5661), 
    ACE_NTOHL (0x6c756544), 
    ACE_NTOHL (0x65663a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_ValueDef:1.0
    15,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f5661), 
    ACE_NTOHL (0x6c756544), 
    ACE_NTOHL (0x65660000),  // name = CORBA_ValueDef

};

static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_PrimaryKeyDescription),
    (char *) &_oc_IR_PrimaryKeyDescription,
    0,
    sizeof (IR::PrimaryKeyDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDescription, &_tc_TAO_tc_IR_PrimaryKeyDescription)
TAO_NAMESPACE_END

void IR::PrimaryKeyDescription::_tao_any_destructor (void *x)
{
  PrimaryKeyDescription *tmp = ACE_static_cast (PrimaryKeyDescription*,x);
  delete tmp;
}

IR::FactoryDef_ptr
tao_IR_FactoryDef_duplicate (
    IR::FactoryDef_ptr p
  )
{
  return IR::FactoryDef::_duplicate (p);
}

void
tao_IR_FactoryDef_release (
    IR::FactoryDef_ptr p
  )
{
  CORBA::release (p);
}

IR::FactoryDef_ptr
tao_IR_FactoryDef_nil (
    void
  )
{
  return IR::FactoryDef::_nil ();
}

IR::FactoryDef_ptr
tao_IR_FactoryDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::FactoryDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_FactoryDef_upcast (
    void *src
  )
{
  IR::FactoryDef **tmp =
    ACE_static_cast (IR::FactoryDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::FactoryDef_var
// *************************************************************

IR::FactoryDef_var::FactoryDef_var (void) // default constructor
  : ptr_ (FactoryDef::_nil ())
{}

::IR::FactoryDef_ptr
IR::FactoryDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::FactoryDef_var::FactoryDef_var (const ::IR::FactoryDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (FactoryDef::_duplicate (p.ptr ()))
{}

IR::FactoryDef_var::~FactoryDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::FactoryDef_var &
IR::FactoryDef_var::operator= (FactoryDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::FactoryDef_var &
IR::FactoryDef_var::operator= (const ::IR::FactoryDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::FactoryDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::FactoryDef_var::operator const ::IR::FactoryDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::FactoryDef_var::operator ::IR::FactoryDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::in (void) const
{
  return this->ptr_;
}

::IR::FactoryDef_ptr &
IR::FactoryDef_var::inout (void)
{
  return this->ptr_;
}

::IR::FactoryDef_ptr &
IR::FactoryDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FactoryDef::_nil ();
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::FactoryDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::FactoryDef::_nil ();
  return val;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::duplicate (FactoryDef_ptr p)
{
  return ::IR::FactoryDef::_duplicate (p);
}

void
IR::FactoryDef_var::release (FactoryDef_ptr p)
{
  CORBA::release (p);
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::nil (void)
{
  return ::IR::FactoryDef::_nil ();
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::FactoryDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::FactoryDef_var::upcast (void *src)
{
  FactoryDef **tmp =
    ACE_static_cast (FactoryDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::FactoryDef_out
// *************************************************************

IR::FactoryDef_out::FactoryDef_out (FactoryDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::FactoryDef::_nil ();
}

IR::FactoryDef_out::FactoryDef_out (FactoryDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FactoryDef::_nil ();
}

IR::FactoryDef_out::FactoryDef_out (const ::IR::FactoryDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FactoryDef_out &, p).ptr_)
{}

::IR::FactoryDef_out &
IR::FactoryDef_out::operator= (const ::IR::FactoryDef_out &p)
{
  this->ptr_ = ACE_const_cast (FactoryDef_out&, p).ptr_;
  return *this;
}

IR::FactoryDef_out &
IR::FactoryDef_out::operator= (const ::IR::FactoryDef_var &p)
{
  this->ptr_ = ::IR::FactoryDef::_duplicate (p.ptr ());
  return *this;
}

IR::FactoryDef_out &
IR::FactoryDef_out::operator= (FactoryDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::FactoryDef_out::operator ::IR::FactoryDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::FactoryDef_ptr &
IR::FactoryDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_FactoryDef_Proxy_Impl::_TAO_FactoryDef_Proxy_Impl (void)
{}

IR::_TAO_FactoryDef_Remote_Proxy_Impl::_TAO_FactoryDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_FactoryDef_Proxy_Broker::_TAO_FactoryDef_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Proxy_Broker::~_TAO_FactoryDef_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Proxy_Broker * (*IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_FactoryDef_Remote_Proxy_Broker *
IR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_FactoryDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_FactoryDef_Remote_Proxy_Broker::_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Remote_Proxy_Broker::~_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Proxy_Impl&
IR::_TAO_FactoryDef_Remote_Proxy_Broker::select_proxy (
  ::IR::FactoryDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::FactoryDef::FactoryDef (int collocated)
{
  this->IR_FactoryDef_setup_collocation (collocated);
}

// destructor
IR::FactoryDef::~FactoryDef (void)
{}

void
IR::FactoryDef::IR_FactoryDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      ::IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      ::IR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker ();
  
  this->CORBA_OperationDef_setup_collocation (collocated);
}

void IR::FactoryDef::_tao_any_destructor (void *x)
{
  FactoryDef *tmp = ACE_static_cast (FactoryDef*,x);
  CORBA::release (tmp);
}

IR::FactoryDef_ptr IR::FactoryDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FactoryDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FactoryDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (FactoryDef::_nil ());
      if (is_a == 0)
        return FactoryDef::_nil ();
    }
  return FactoryDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::FactoryDef_ptr IR::FactoryDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FactoryDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FactoryDef_ptr default_proxy = FactoryDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::FactoryDef (
            stub,
            1,
            obj->_servant ()),
            
          FactoryDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::FactoryDef (stub, 0, obj->_servant ()), FactoryDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            FactoryDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &FactoryDef::_narrow
                    )
                )
          );
}

IR::FactoryDef_ptr
IR::FactoryDef::_duplicate (FactoryDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::FactoryDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::FactoryDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, FactoryDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_OperationDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_OperationDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

static const CORBA::Long _oc_IR_FactoryDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f46), 
  ACE_NTOHL (0x6163746f), 
  ACE_NTOHL (0x72794465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
  11,
  ACE_NTOHL (0x46616374), 
  ACE_NTOHL (0x6f727944), 
  ACE_NTOHL (0x65660000),  // name = FactoryDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_FactoryDef),
    (char *) &_oc_IR_FactoryDef,
    0,
    sizeof (IR::FactoryDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDef, &_tc_TAO_tc_IR_FactoryDef)
TAO_NAMESPACE_END

IR::FinderDef_ptr
tao_IR_FinderDef_duplicate (
    IR::FinderDef_ptr p
  )
{
  return IR::FinderDef::_duplicate (p);
}

void
tao_IR_FinderDef_release (
    IR::FinderDef_ptr p
  )
{
  CORBA::release (p);
}

IR::FinderDef_ptr
tao_IR_FinderDef_nil (
    void
  )
{
  return IR::FinderDef::_nil ();
}

IR::FinderDef_ptr
tao_IR_FinderDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::FinderDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_FinderDef_upcast (
    void *src
  )
{
  IR::FinderDef **tmp =
    ACE_static_cast (IR::FinderDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::FinderDef_var
// *************************************************************

IR::FinderDef_var::FinderDef_var (void) // default constructor
  : ptr_ (FinderDef::_nil ())
{}

::IR::FinderDef_ptr
IR::FinderDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::FinderDef_var::FinderDef_var (const ::IR::FinderDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (FinderDef::_duplicate (p.ptr ()))
{}

IR::FinderDef_var::~FinderDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::FinderDef_var &
IR::FinderDef_var::operator= (FinderDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::FinderDef_var &
IR::FinderDef_var::operator= (const ::IR::FinderDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::FinderDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::FinderDef_var::operator const ::IR::FinderDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::FinderDef_var::operator ::IR::FinderDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_var::in (void) const
{
  return this->ptr_;
}

::IR::FinderDef_ptr &
IR::FinderDef_var::inout (void)
{
  return this->ptr_;
}

::IR::FinderDef_ptr &
IR::FinderDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FinderDef::_nil ();
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::FinderDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::FinderDef::_nil ();
  return val;
}

::IR::FinderDef_ptr
IR::FinderDef_var::duplicate (FinderDef_ptr p)
{
  return ::IR::FinderDef::_duplicate (p);
}

void
IR::FinderDef_var::release (FinderDef_ptr p)
{
  CORBA::release (p);
}

::IR::FinderDef_ptr
IR::FinderDef_var::nil (void)
{
  return ::IR::FinderDef::_nil ();
}

::IR::FinderDef_ptr
IR::FinderDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::FinderDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::FinderDef_var::upcast (void *src)
{
  FinderDef **tmp =
    ACE_static_cast (FinderDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::FinderDef_out
// *************************************************************

IR::FinderDef_out::FinderDef_out (FinderDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::FinderDef::_nil ();
}

IR::FinderDef_out::FinderDef_out (FinderDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FinderDef::_nil ();
}

IR::FinderDef_out::FinderDef_out (const ::IR::FinderDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FinderDef_out &, p).ptr_)
{}

::IR::FinderDef_out &
IR::FinderDef_out::operator= (const ::IR::FinderDef_out &p)
{
  this->ptr_ = ACE_const_cast (FinderDef_out&, p).ptr_;
  return *this;
}

IR::FinderDef_out &
IR::FinderDef_out::operator= (const ::IR::FinderDef_var &p)
{
  this->ptr_ = ::IR::FinderDef::_duplicate (p.ptr ());
  return *this;
}

IR::FinderDef_out &
IR::FinderDef_out::operator= (FinderDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::FinderDef_out::operator ::IR::FinderDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::FinderDef_ptr &
IR::FinderDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_FinderDef_Proxy_Impl::_TAO_FinderDef_Proxy_Impl (void)
{}

IR::_TAO_FinderDef_Remote_Proxy_Impl::_TAO_FinderDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_FinderDef_Proxy_Broker::_TAO_FinderDef_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Proxy_Broker::~_TAO_FinderDef_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Proxy_Broker * (*IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_FinderDef_Remote_Proxy_Broker *
IR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_FinderDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_FinderDef_Remote_Proxy_Broker::_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Remote_Proxy_Broker::~_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Proxy_Impl&
IR::_TAO_FinderDef_Remote_Proxy_Broker::select_proxy (
  ::IR::FinderDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::FinderDef::FinderDef (int collocated)
{
  this->IR_FinderDef_setup_collocation (collocated);
}

// destructor
IR::FinderDef::~FinderDef (void)
{}

void
IR::FinderDef::IR_FinderDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FinderDef_Proxy_Broker_ =
      ::IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FinderDef_Proxy_Broker_ =
      ::IR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker ();
  
  this->CORBA_OperationDef_setup_collocation (collocated);
}

void IR::FinderDef::_tao_any_destructor (void *x)
{
  FinderDef *tmp = ACE_static_cast (FinderDef*,x);
  CORBA::release (tmp);
}

IR::FinderDef_ptr IR::FinderDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return FinderDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FinderDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (FinderDef::_nil ());
      if (is_a == 0)
        return FinderDef::_nil ();
    }
  return FinderDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::FinderDef_ptr IR::FinderDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return FinderDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FinderDef_ptr default_proxy = FinderDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::FinderDef (
            stub,
            1,
            obj->_servant ()),
            
          FinderDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::FinderDef (stub, 0, obj->_servant ()), FinderDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            FinderDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &FinderDef::_narrow
                    )
                )
          );
}

IR::FinderDef_ptr
IR::FinderDef::_duplicate (FinderDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::FinderDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::FinderDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, FinderDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_OperationDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_OperationDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

static const CORBA::Long _oc_IR_FinderDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f46), 
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x72446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
  10,
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x66000000),  // name = FinderDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_FinderDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_FinderDef),
    (char *) &_oc_IR_FinderDef,
    0,
    sizeof (IR::FinderDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDef, &_tc_TAO_tc_IR_FinderDef)
TAO_NAMESPACE_END

IR::HomeDef_ptr
tao_IR_HomeDef_duplicate (
    IR::HomeDef_ptr p
  )
{
  return IR::HomeDef::_duplicate (p);
}

void
tao_IR_HomeDef_release (
    IR::HomeDef_ptr p
  )
{
  CORBA::release (p);
}

IR::HomeDef_ptr
tao_IR_HomeDef_nil (
    void
  )
{
  return IR::HomeDef::_nil ();
}

IR::HomeDef_ptr
tao_IR_HomeDef_narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return IR::HomeDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
tao_IR_HomeDef_upcast (
    void *src
  )
{
  IR::HomeDef **tmp =
    ACE_static_cast (IR::HomeDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::HomeDef_var
// *************************************************************

IR::HomeDef_var::HomeDef_var (void) // default constructor
  : ptr_ (HomeDef::_nil ())
{}

::IR::HomeDef_ptr
IR::HomeDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::HomeDef_var::HomeDef_var (const ::IR::HomeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (HomeDef::_duplicate (p.ptr ()))
{}

IR::HomeDef_var::~HomeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::HomeDef_var &
IR::HomeDef_var::operator= (HomeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::HomeDef_var &
IR::HomeDef_var::operator= (const ::IR::HomeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::HomeDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::HomeDef_var::operator const ::IR::HomeDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::HomeDef_var::operator ::IR::HomeDef_ptr &() // cast 
{
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_var::in (void) const
{
  return this->ptr_;
}

::IR::HomeDef_ptr &
IR::HomeDef_var::inout (void)
{
  return this->ptr_;
}

::IR::HomeDef_ptr &
IR::HomeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::HomeDef::_nil ();
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::HomeDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::HomeDef::_nil ();
  return val;
}

::IR::HomeDef_ptr
IR::HomeDef_var::duplicate (HomeDef_ptr p)
{
  return ::IR::HomeDef::_duplicate (p);
}

void
IR::HomeDef_var::release (HomeDef_ptr p)
{
  CORBA::release (p);
}

::IR::HomeDef_ptr
IR::HomeDef_var::nil (void)
{
  return ::IR::HomeDef::_nil ();
}

::IR::HomeDef_ptr
IR::HomeDef_var::narrow (
    CORBA::Object *p,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return ::IR::HomeDef::_narrow (p, ACE_TRY_ENV);
}

CORBA::Object *
IR::HomeDef_var::upcast (void *src)
{
  HomeDef **tmp =
    ACE_static_cast (HomeDef **, src);
  return *tmp;
}

// *************************************************************
// Inline operations for class IR::HomeDef_out
// *************************************************************

IR::HomeDef_out::HomeDef_out (HomeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::HomeDef::_nil ();
}

IR::HomeDef_out::HomeDef_out (HomeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::HomeDef::_nil ();
}

IR::HomeDef_out::HomeDef_out (const ::IR::HomeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeDef_out &, p).ptr_)
{}

::IR::HomeDef_out &
IR::HomeDef_out::operator= (const ::IR::HomeDef_out &p)
{
  this->ptr_ = ACE_const_cast (HomeDef_out&, p).ptr_;
  return *this;
}

IR::HomeDef_out &
IR::HomeDef_out::operator= (const ::IR::HomeDef_var &p)
{
  this->ptr_ = ::IR::HomeDef::_duplicate (p.ptr ());
  return *this;
}

IR::HomeDef_out &
IR::HomeDef_out::operator= (HomeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::HomeDef_out::operator ::IR::HomeDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::HomeDef_ptr &
IR::HomeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_HomeDef_base_home_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_base_home_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_base_home_get (const TAO_ClientRequestInfo_IR_HomeDef_base_home_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_base_home_get &);

  IR::HomeDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_base_home_get::TAO_ClientRequestInfo_IR_HomeDef_base_home_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (IR::HomeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_managed_component_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (const TAO_ClientRequestInfo_IR_HomeDef_managed_component_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_managed_component_get &);

  IR::ComponentDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (IR::ComponentDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_primary_key_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (const TAO_ClientRequestInfo_IR_HomeDef_primary_key_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_primary_key_get &);

  IR::PrimaryKeyDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (IR::PrimaryKeyDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_factories_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_factories_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_factories_get (const TAO_ClientRequestInfo_IR_HomeDef_factories_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_factories_get &);

  IR::FactoryDefSeq * _result;
};

TAO_ClientRequestInfo_IR_HomeDef_factories_get::TAO_ClientRequestInfo_IR_HomeDef_factories_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_factories_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_factories_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (IR::FactoryDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_finders_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_finders_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_finders_get (const TAO_ClientRequestInfo_IR_HomeDef_finders_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_finders_get &);

  IR::FinderDefSeq * _result;
};

TAO_ClientRequestInfo_IR_HomeDef_finders_get::TAO_ClientRequestInfo_IR_HomeDef_finders_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_finders_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_finders_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (IR::FinderDefSeq * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_is_basic_get : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (const TAO_ClientRequestInfo_IR_HomeDef_is_basic_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_is_basic_get &);

  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_create_primary_key : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (const TAO_ClientRequestInfo_IR_HomeDef_create_primary_key &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_create_primary_key &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr primary_key_;
  IR::PrimaryKeyDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
  
  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (IR::PrimaryKeyDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_create_factory : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_create_factory (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_create_factory (const TAO_ClientRequestInfo_IR_HomeDef_create_factory &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_create_factory &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FactoryDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_create_factory::TAO_ClientRequestInfo_IR_HomeDef_create_factory (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_create_factory::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_create_factory::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (IR::FactoryDef_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_create_finder : public TAO_ClientRequestInfo
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_create_finder (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_create_finder (const TAO_ClientRequestInfo_IR_HomeDef_create_finder &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_create_finder &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FinderDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_create_finder::TAO_ClientRequestInfo_IR_HomeDef_create_finder (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_create_finder::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_create_finder::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (IR::FinderDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

IR::_TAO_HomeDef_Proxy_Impl::_TAO_HomeDef_Proxy_Impl (void)
{}

IR::_TAO_HomeDef_Remote_Proxy_Impl::_TAO_HomeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR::HomeDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
  IR::HomeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_home",
      14,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_base_home_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::ComponentDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_managed_component",
      22,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_managed_component_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::PrimaryKeyDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_primary_key_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::FactoryDefSeq * IR::_TAO_HomeDef_Remote_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FactoryDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::FactoryDefSeq, _tao_retval);
  IR::FactoryDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_factories",
      14,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_factories_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::FactoryDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::FinderDefSeq * IR::_TAO_HomeDef_Remote_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FinderDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR::FinderDefSeq, _tao_retval);
  IR::FinderDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_finders",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_finders_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::FinderDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::_TAO_HomeDef_Remote_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_is_basic_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR::PrimaryKeyDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_primary_key",
      18,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_create_primary_key ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        primary_key,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << primary_key)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::FactoryDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FactoryDef_ptr _tao_retval = IR::FactoryDef::_nil ();
  IR::FactoryDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_factory",
      14,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_create_factory ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::FactoryDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR::FinderDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR::FinderDef_ptr _tao_retval = IR::FinderDef::_nil ();
  IR::FinderDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_finder",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_create_finder ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR::FinderDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_HomeDef_Proxy_Broker::_TAO_HomeDef_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Proxy_Broker::~_TAO_HomeDef_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Proxy_Broker * (*IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_HomeDef_Remote_Proxy_Broker *
IR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_HomeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_HomeDef_Remote_Proxy_Broker::_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Remote_Proxy_Broker::~_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Proxy_Impl&
IR::_TAO_HomeDef_Remote_Proxy_Broker::select_proxy (
  ::IR::HomeDef *,
  CORBA::Environment &
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::HomeDef::HomeDef (int collocated)
{
  this->IR_HomeDef_setup_collocation (collocated);
}

// destructor
IR::HomeDef::~HomeDef (void)
{}

void
IR::HomeDef::IR_HomeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeDef_Proxy_Broker_ =
      ::IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeDef_Proxy_Broker_ =
      ::IR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker ();
  
  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void IR::HomeDef::_tao_any_destructor (void *x)
{
  HomeDef *tmp = ACE_static_cast (HomeDef*,x);
  CORBA::release (tmp);
}

IR::HomeDef_ptr IR::HomeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return HomeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/HomeDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (HomeDef::_nil ());
      if (is_a == 0)
        return HomeDef::_nil ();
    }
  return HomeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR::HomeDef_ptr IR::HomeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return HomeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      HomeDef_ptr default_proxy = HomeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::HomeDef (
            stub,
            1,
            obj->_servant ()),
            
          HomeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::HomeDef (stub, 0, obj->_servant ()), HomeDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            HomeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &HomeDef::_narrow
                    )
                )
          );
}

IR::HomeDef_ptr
IR::HomeDef::_duplicate (HomeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::HomeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA_IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR::HomeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, HomeDef)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef_ptr IR::HomeDef::base_home (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.base_home (
      this,
      ACE_TRY_ENV
    );
}

IR::ComponentDef_ptr IR::HomeDef::managed_component (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.managed_component (
      this,
      ACE_TRY_ENV
    );
}

IR::PrimaryKeyDef_ptr IR::HomeDef::primary_key (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.primary_key (
      this,
      ACE_TRY_ENV
    );
}

IR::FactoryDefSeq * IR::HomeDef::factories (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.factories (
      this,
      ACE_TRY_ENV
    );
}

IR::FinderDefSeq * IR::HomeDef::finders (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.finders (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR::HomeDef::is_basic (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_basic (
      this,
      ACE_TRY_ENV
    );
}

IR::PrimaryKeyDef_ptr IR::HomeDef::create_primary_key (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_primary_key (
      this,
      id,
      name,
      version,
      primary_key,
      ACE_TRY_ENV
    );
}

IR::FactoryDef_ptr IR::HomeDef::create_factory (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_factory (
      this,
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );
}

IR::FinderDef_ptr IR::HomeDef::create_finder (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_finder (
      this,
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_HomeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f48), 
  ACE_NTOHL (0x6f6d6544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
  8,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x44656600),  // name = HomeDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_HomeDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_HomeDef),
    (char *) &_oc_IR_HomeDef,
    0,
    sizeof (IR::HomeDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDef, &_tc_TAO_tc_IR_HomeDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_HomeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x49522f48), 
  ACE_NTOHL (0x6f6d6544), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDescription:1.0
  16,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = HomeDescription
  12, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f49), 
    ACE_NTOHL (0x64656e74), 
    ACE_NTOHL (0x69666965), 
    ACE_NTOHL (0x723a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f56), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x6f6e5370), 
    ACE_NTOHL (0x65633a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  10,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f686f6d), 
  ACE_NTOHL (0x65000000),  // name = base_home
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  18,
  ACE_NTOHL (0x6d616e61), 
  ACE_NTOHL (0x6765645f), 
  ACE_NTOHL (0x636f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74000000),  // name = managed_component
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f52), 
    ACE_NTOHL (0x65706f73), 
    ACE_NTOHL (0x69746f72), 
    ACE_NTOHL (0x7949643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  16,
  ACE_NTOHL (0x7072696d), 
  ACE_NTOHL (0x6172795f), 
  ACE_NTOHL (0x6b65795f), 
  ACE_NTOHL (0x64656600),  // name = primary_key_def
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f50), 
    ACE_NTOHL (0x72696d61), 
    ACE_NTOHL (0x72794b65), 
    ACE_NTOHL (0x79446566), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
    14,
    ACE_NTOHL (0x5072696d), 
    ACE_NTOHL (0x6172794b), 
    ACE_NTOHL (0x65794465), 
    ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef

  10,
  ACE_NTOHL (0x66616374), 
  ACE_NTOHL (0x6f726965), 
  ACE_NTOHL (0x73000000),  // name = factories
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f46), 
    ACE_NTOHL (0x6163746f), 
    ACE_NTOHL (0x72794465), 
    ACE_NTOHL (0x66536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
    14,
    ACE_NTOHL (0x46616374), 
    ACE_NTOHL (0x6f727944), 
    ACE_NTOHL (0x65665365), 
    ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f46), 
        ACE_NTOHL (0x6163746f), 
        ACE_NTOHL (0x72794465), 
        ACE_NTOHL (0x663a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
        11,
        ACE_NTOHL (0x46616374), 
        ACE_NTOHL (0x6f727944), 
        ACE_NTOHL (0x65660000),  // name = FactoryDef

      0U,


  8,
  ACE_NTOHL (0x66696e64), 
  ACE_NTOHL (0x65727300),  // name = finders
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x49522f46), 
    ACE_NTOHL (0x696e6465), 
    ACE_NTOHL (0x72446566), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
    13,
    ACE_NTOHL (0x46696e64), 
    ACE_NTOHL (0x65724465), 
    ACE_NTOHL (0x66536571), 
    ACE_NTOHL (0x0),  // name = FinderDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x49522f46), 
        ACE_NTOHL (0x696e6465), 
        ACE_NTOHL (0x72446566), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
        10,
        ACE_NTOHL (0x46696e64), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x66000000),  // name = FinderDef

      0U,


  11,
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  1304, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_OpDescriptionSeq:1.0
    23,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65710000),  // name = CORBA_OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1220, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1204, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_OperationDescription:1.0
        27,
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e0000),  // name = CORBA_OperationDescription
        9, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_string, 
        0U, // string length
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_string, 
        0U, // string length
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_string, 
        0U, // string length
        7,
        ACE_NTOHL (0x72657375), 
        ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA_OperationMode:1.0
          20,
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f646500),  // name = CORBA_OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e), 
          ACE_NTOHL (0x4f524d41), 
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f), 
          ACE_NTOHL (0x4e455741), 
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9,
        ACE_NTOHL (0x636f6e74), 
        ACE_NTOHL (0x65787473), 
        ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        92, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_ContextIdSeq:1.0
          19,
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65710000),  // name = CORBA_ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          16, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_string, 
            0U, // string length
            0U,


        11,
        ACE_NTOHL (0x70617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        448, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA_ParDescriptionSeq:1.0
          24,
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x53657100),  // name = CORBA_ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          364, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            348, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x415f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_ParameterDescription:1.0
              27,
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x415f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e0000),  // name = CORBA_ParameterDescription
              4, // member count
              5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_string, 
              0U, // string length
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              60, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x415f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA_IDLType:1.0
                14,
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x415f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x65000000),  // name = CORBA_IDLType

              5,
              ACE_NTOHL (0x6d6f6465), 
              ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              120, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x415f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f64653a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA_ParameterMode:1.0
                20,
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x415f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f646500),  // name = CORBA_ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f4f55), 
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        284, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA_ExcDescriptionSeq:1.0
          24,
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x53657100),  // name = CORBA_ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          200, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            184, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x415f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_ExceptionDescription:1.0
              27,
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x415f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e0000),  // name = CORBA_ExceptionDescription
              5, // member count
              5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_string, 
              0U, // string length
              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_string, 
              0U, // string length
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_string, 
              0U, // string length
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_string, 
              0U, // string length
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  420, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f4174), 
    ACE_NTOHL (0x74724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA_AttrDescriptionSeq:1.0
    25,
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x415f4174), 
    ACE_NTOHL (0x74724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = CORBA_AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    328, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      312, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x75746544), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA_AttributeDescription:1.0
        27,
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x415f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x75746544), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e0000),  // name = CORBA_AttributeDescription
        6, // member count
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string, 
        0U, // string length
        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_string, 
        0U, // string length
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_string, 
        0U, // string length
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_string, 
        0U, // string length
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        108, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA_AttributeMode:1.0
          20,
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x415f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f646500),  // name = CORBA_AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  9,
  ACE_NTOHL (0x69735f62), 
  ACE_NTOHL (0x61736963), 
  ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_IR_HomeDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_HomeDescription),
    (char *) &_oc_IR_HomeDescription,
    0,
    sizeof (IR::HomeDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDescription, &_tc_TAO_tc_IR_HomeDescription)
TAO_NAMESPACE_END

void IR::HomeDescription::_tao_any_destructor (void *x)
{
  HomeDescription *tmp = ACE_static_cast (HomeDescription*,x);
  delete tmp;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::RepositoryIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_RepositoryIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::RepositoryIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_RepositoryIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::RepositoryIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::RepositoryIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::RepositoryIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::RepositoryIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_RepositoryIdSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::RepositoryIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::RepositoryIdSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_RepositoryIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::RepositoryIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ComponentDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ComponentDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ComponentDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ComponentDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ComponentDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ComponentDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ComponentDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ProvidesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ProvidesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UsesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UsesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::HomeDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::HomeDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::HomeDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::HomeDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_HomeDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::HomeDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::HomeDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::HomeDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::HomeDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::EmitsDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::EmitsDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EmitsDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EmitsDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::EmitsDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EmitsDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_EmitsDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EmitsDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EmitsDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::EmitsDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EmitsDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::EmitsDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::PublishesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::PublishesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PublishesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::PublishesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::PublishesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PublishesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_PublishesDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::PublishesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::PublishesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::PublishesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PublishesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::PublishesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ConsumesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConsumesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ConsumesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ConsumesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ConsumesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ConsumesDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ConsumesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ConsumesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ConsumesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ConsumesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ConsumesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::FactoryDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::FactoryDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FactoryDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::FactoryDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::FactoryDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FactoryDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_FactoryDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::FactoryDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::FactoryDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::FactoryDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FactoryDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::FactoryDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::FinderDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::FinderDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FinderDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::FinderDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::FinderDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FinderDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_FinderDefSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::FinderDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::FinderDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::FinderDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FinderDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::FinderDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentRepository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentRepository, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ComponentRepository::_duplicate (_tao_elem),
        IR::ComponentRepository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentRepository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ComponentRepository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentRepository, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentRepository,
          1,
          _tao_elem,
          IR::ComponentRepository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ComponentRepository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ComponentRepository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ProvidesDef::_duplicate (_tao_elem),
        IR::ProvidesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ProvidesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ProvidesDef,
          1,
          _tao_elem,
          IR::ProvidesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ProvidesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ProvidesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ProvidesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ProvidesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::UsesDef::_duplicate (_tao_elem),
        IR::UsesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::UsesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_UsesDef,
          1,
          _tao_elem,
          IR::UsesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::UsesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::UsesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::UsesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::UsesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ProvidesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ProvidesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDescSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UsesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UsesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDescSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::EventDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EventDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EventDef::_duplicate (_tao_elem),
        IR::EventDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EventDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_EventDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EventDef,
          1,
          _tao_elem,
          IR::EventDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EventDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EventDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::EventDef,IR::EventDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::EventDef,IR::EventDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::EventDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::EventDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EventDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::EventDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EventDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_EventDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EventDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EventDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::EventDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EventDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::EventDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::EmitsDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EmitsDef::_duplicate (_tao_elem),
        IR::EmitsDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EmitsDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_EmitsDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EmitsDef,
          1,
          _tao_elem,
          IR::EmitsDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EmitsDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EmitsDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::PublishesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PublishesDef::_duplicate (_tao_elem),
        IR::PublishesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PublishesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_PublishesDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PublishesDef,
          1,
          _tao_elem,
          IR::PublishesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PublishesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PublishesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ConsumesDef::_duplicate (_tao_elem),
        IR::ConsumesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ConsumesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ConsumesDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ConsumesDef,
          1,
          _tao_elem,
          IR::ConsumesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ConsumesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ConsumesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ComponentDef::_duplicate (_tao_elem),
        IR::ComponentDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ComponentDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentDef,
          1,
          _tao_elem,
          IR::ComponentDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ComponentDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ComponentDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ComponentDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ComponentDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ComponentDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ComponentDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ComponentDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ComponentDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ComponentDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PrimaryKeyDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PrimaryKeyDef::_duplicate (_tao_elem),
        IR::PrimaryKeyDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PrimaryKeyDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_PrimaryKeyDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PrimaryKeyDef,
          1,
          _tao_elem,
          IR::PrimaryKeyDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PrimaryKeyDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PrimaryKeyDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::PrimaryKeyDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::PrimaryKeyDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::PrimaryKeyDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PrimaryKeyDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_PrimaryKeyDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::PrimaryKeyDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::PrimaryKeyDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::PrimaryKeyDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PrimaryKeyDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::PrimaryKeyDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::FactoryDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FactoryDef::_duplicate (_tao_elem),
        IR::FactoryDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FactoryDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_FactoryDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FactoryDef,
          1,
          _tao_elem,
          IR::FactoryDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FactoryDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FactoryDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::FinderDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FinderDef::_duplicate (_tao_elem),
        IR::FinderDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FinderDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_FinderDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FinderDef,
          1,
          _tao_elem,
          IR::FinderDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FinderDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FinderDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::HomeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::HomeDef::_duplicate (_tao_elem),
        IR::HomeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::HomeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_HomeDef, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_HomeDef,
          1,
          _tao_elem,
          IR::HomeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::HomeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::HomeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::HomeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::HomeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::HomeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::HomeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (IR::_tc_HomeDescription, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::HomeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::HomeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::HomeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::HomeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::HomeDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::HomeDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EmitsDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EmitsDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PublishesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PublishesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ConsumesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ConsumesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FactoryDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FactoryDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FinderDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FinderDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentRepository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentRepository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ComponentRepository::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ProvidesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::UsesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EventDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EventDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::EventDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EmitsDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EmitsDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::EmitsDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PublishesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PublishesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::PublishesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ConsumesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ConsumesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ConsumesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ComponentDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PrimaryKeyDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PrimaryKeyDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::PrimaryKeyDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FactoryDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FactoryDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::FactoryDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FinderDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FinderDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::FinderDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::HomeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::HomeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::HomeDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

