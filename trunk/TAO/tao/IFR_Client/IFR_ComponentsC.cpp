// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "IFR_ComponentsC.h"

#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ComponentsC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_IR_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f49),
  ACE_NTOHL (0x64656e74),
  ACE_NTOHL (0x69666965),
  ACE_NTOHL (0x723a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
  11,
  ACE_NTOHL (0x4964656e),
  ACE_NTOHL (0x74696669),
  ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_string,
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_Identifier (
    CORBA::tk_alias,
    sizeof (_oc_IR_Identifier),
    (char *) &_oc_IR_Identifier,
    0,
    sizeof (IR::Identifier)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_IR_Identifier)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ScopedName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f53),
  ACE_NTOHL (0x636f7065),
  ACE_NTOHL (0x644e616d),
  ACE_NTOHL (0x653a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ScopedName:1.0
  11,
  ACE_NTOHL (0x53636f70),
  ACE_NTOHL (0x65644e61),
  ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_string,
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_ScopedName (
    CORBA::tk_alias,
    sizeof (_oc_IR_ScopedName),
    (char *) &_oc_IR_ScopedName,
    0,
    sizeof (IR::ScopedName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_IR_ScopedName)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f52),
  ACE_NTOHL (0x65706f73),
  ACE_NTOHL (0x69746f72),
  ACE_NTOHL (0x7949643a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
  13,
  ACE_NTOHL (0x5265706f),
  ACE_NTOHL (0x7369746f),
  ACE_NTOHL (0x72794964),
  ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_string,
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryId (
    CORBA::tk_alias,
    sizeof (_oc_IR_RepositoryId),
    (char *) &_oc_IR_RepositoryId,
    0,
    sizeof (IR::RepositoryId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_IR_RepositoryId)
TAO_NAMESPACE_END


#if !defined (_IR_REPOSITORYIDSEQ_CS_)
#define _IR_REPOSITORYIDSEQ_CS_

// *************************************************************
// IR::RepositoryIdSeq
// *************************************************************

IR::RepositoryIdSeq::RepositoryIdSeq (void)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::RepositoryIdSeq::RepositoryIdSeq (const RepositoryIdSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::RepositoryIdSeq::~RepositoryIdSeq (void) // dtor
{}
void IR::RepositoryIdSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  RepositoryIdSeq *tmp = ACE_static_cast (RepositoryIdSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_RepositoryIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f52),
  ACE_NTOHL (0x65706f73),
  ACE_NTOHL (0x69746f72),
  ACE_NTOHL (0x79496453),
  ACE_NTOHL (0x65713a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
  16,
  ACE_NTOHL (0x5265706f),
  ACE_NTOHL (0x7369746f),
  ACE_NTOHL (0x72794964),
  ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f52),
      ACE_NTOHL (0x65706f73),
      ACE_NTOHL (0x69746f72),
      ACE_NTOHL (0x7949643a),
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f),
      ACE_NTOHL (0x7369746f),
      ACE_NTOHL (0x72794964),
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string,
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryIdSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_RepositoryIdSeq),
    (char *) &_oc_IR_RepositoryIdSeq,
    0,
    sizeof (IR::RepositoryIdSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_IR_RepositoryIdSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_VersionSpec[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f56),
  ACE_NTOHL (0x65727369),
  ACE_NTOHL (0x6f6e5370),
  ACE_NTOHL (0x65633a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
  12,
  ACE_NTOHL (0x56657273),
  ACE_NTOHL (0x696f6e53),
  ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string,
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_IR_VersionSpec (
    CORBA::tk_alias,
    sizeof (_oc_IR_VersionSpec),
    (char *) &_oc_IR_VersionSpec,
    0,
    sizeof (IR::VersionSpec)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_VersionSpec, &_tc_TAO_tc_IR_VersionSpec)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::ComponentDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::ComponentDef **old = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::ComponentDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ComponentDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ComponentDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, target);
  *tmp = IR::ComponentDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_upcast (void *src) const
{
  IR::ComponentDef **tmp = ACE_static_cast (IR::ComponentDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_COMPONENTDEFSEQ_CS_)
#define _IR_COMPONENTDEFSEQ_CS_

// *************************************************************
// IR::ComponentDefSeq
// *************************************************************

IR::ComponentDefSeq::ComponentDefSeq (void)
{}
IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::ComponentDefSeq::ComponentDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ComponentDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::ComponentDefSeq::ComponentDefSeq (const ComponentDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ComponentDef,IR::ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::ComponentDefSeq::~ComponentDefSeq (void) // dtor
{}
void IR::ComponentDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentDefSeq *tmp = ACE_static_cast (ComponentDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ComponentDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f43),
  ACE_NTOHL (0x6f6d706f),
  ACE_NTOHL (0x6e656e74),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65713a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentDefSeq:1.0
  16,
  ACE_NTOHL (0x436f6d70),
  ACE_NTOHL (0x6f6e656e),
  ACE_NTOHL (0x74446566),
  ACE_NTOHL (0x53657100),  // name = ComponentDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f43),
      ACE_NTOHL (0x6f6d706f),
      ACE_NTOHL (0x6e656e74),
      ACE_NTOHL (0x4465663a),
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
      13,
      ACE_NTOHL (0x436f6d70),
      ACE_NTOHL (0x6f6e656e),
      ACE_NTOHL (0x74446566),
      ACE_NTOHL (0x0),  // name = ComponentDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ComponentDefSeq),
    (char *) &_oc_IR_ComponentDefSeq,
    0,
    sizeof (IR::ComponentDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDefSeq, &_tc_TAO_tc_IR_ComponentDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::ProvidesDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::ProvidesDef **old = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::ProvidesDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ProvidesDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ProvidesDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, target);
  *tmp = IR::ProvidesDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_upcast (void *src) const
{
  IR::ProvidesDef **tmp = ACE_static_cast (IR::ProvidesDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_PROVIDESDEFSEQ_CS_)
#define _IR_PROVIDESDEFSEQ_CS_

// *************************************************************
// IR::ProvidesDefSeq
// *************************************************************

IR::ProvidesDefSeq::ProvidesDefSeq (void)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::ProvidesDefSeq::ProvidesDefSeq (const ProvidesDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::ProvidesDefSeq::~ProvidesDefSeq (void) // dtor
{}
void IR::ProvidesDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDefSeq *tmp = ACE_static_cast (ProvidesDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ProvidesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x726f7669),
  ACE_NTOHL (0x64657344),
  ACE_NTOHL (0x65665365),
  ACE_NTOHL (0x713a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
  15,
  ACE_NTOHL (0x50726f76),
  ACE_NTOHL (0x69646573),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f50),
      ACE_NTOHL (0x726f7669),
      ACE_NTOHL (0x64657344),
      ACE_NTOHL (0x65663a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
      12,
      ACE_NTOHL (0x50726f76),
      ACE_NTOHL (0x69646573),
      ACE_NTOHL (0x44656600),  // name = ProvidesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ProvidesDefSeq),
    (char *) &_oc_IR_ProvidesDefSeq,
    0,
    sizeof (IR::ProvidesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDefSeq, &_tc_TAO_tc_IR_ProvidesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::UsesDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::UsesDef **old = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::UsesDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::UsesDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::UsesDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, target);
  *tmp = IR::UsesDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_upcast (void *src) const
{
  IR::UsesDef **tmp = ACE_static_cast (IR::UsesDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_USESDEFSEQ_CS_)
#define _IR_USESDEFSEQ_CS_

// *************************************************************
// IR::UsesDefSeq
// *************************************************************

IR::UsesDefSeq::UsesDefSeq (void)
{}
IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::UsesDefSeq::UsesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::UsesDefSeq::UsesDefSeq (const UsesDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::UsesDef,IR::UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::UsesDefSeq::~UsesDefSeq (void) // dtor
{}
void IR::UsesDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDefSeq *tmp = ACE_static_cast (UsesDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UsesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f55),
  ACE_NTOHL (0x73657344),
  ACE_NTOHL (0x65665365),
  ACE_NTOHL (0x713a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
  11,
  ACE_NTOHL (0x55736573),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65710000),  // name = UsesDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f55),
      ACE_NTOHL (0x73657344),
      ACE_NTOHL (0x65663a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
      8,
      ACE_NTOHL (0x55736573),
      ACE_NTOHL (0x44656600),  // name = UsesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_UsesDefSeq),
    (char *) &_oc_IR_UsesDefSeq,
    0,
    sizeof (IR::UsesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDefSeq, &_tc_TAO_tc_IR_UsesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::HomeDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::HomeDef **old = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::HomeDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::HomeDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::HomeDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, target);
  *tmp = IR::HomeDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_upcast (void *src) const
{
  IR::HomeDef **tmp = ACE_static_cast (IR::HomeDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_HOMEDEFSEQ_CS_)
#define _IR_HOMEDEFSEQ_CS_

// *************************************************************
// IR::HomeDefSeq
// *************************************************************

IR::HomeDefSeq::HomeDefSeq (void)
{}
IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::HomeDefSeq::HomeDefSeq (CORBA::ULong max, CORBA::ULong length, IR::HomeDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::HomeDefSeq::HomeDefSeq (const HomeDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::HomeDef,IR::HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::HomeDefSeq::~HomeDefSeq (void) // dtor
{}
void IR::HomeDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeDefSeq *tmp = ACE_static_cast (HomeDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_HomeDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f48),
  ACE_NTOHL (0x6f6d6544),
  ACE_NTOHL (0x65665365),
  ACE_NTOHL (0x713a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/HomeDefSeq:1.0
  11,
  ACE_NTOHL (0x486f6d65),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65710000),  // name = HomeDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f48),
      ACE_NTOHL (0x6f6d6544),
      ACE_NTOHL (0x65663a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
      8,
      ACE_NTOHL (0x486f6d65),
      ACE_NTOHL (0x44656600),  // name = HomeDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_HomeDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_HomeDefSeq),
    (char *) &_oc_IR_HomeDefSeq,
    0,
    sizeof (IR::HomeDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDefSeq, &_tc_TAO_tc_IR_HomeDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::EmitsDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::EmitsDef **old = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::EmitsDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::EmitsDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::EmitsDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, target);
  *tmp = IR::EmitsDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_upcast (void *src) const
{
  IR::EmitsDef **tmp = ACE_static_cast (IR::EmitsDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_EMITSDEFSEQ_CS_)
#define _IR_EMITSDEFSEQ_CS_

// *************************************************************
// IR::EmitsDefSeq
// *************************************************************

IR::EmitsDefSeq::EmitsDefSeq (void)
{}
IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::EmitsDefSeq::EmitsDefSeq (CORBA::ULong max, CORBA::ULong length, IR::EmitsDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::EmitsDefSeq::EmitsDefSeq (const EmitsDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::EmitsDef,IR::EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::EmitsDefSeq::~EmitsDefSeq (void) // dtor
{}
void IR::EmitsDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitsDefSeq *tmp = ACE_static_cast (EmitsDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_EmitsDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f45),
  ACE_NTOHL (0x6d697473),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65713a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
  12,
  ACE_NTOHL (0x456d6974),
  ACE_NTOHL (0x73446566),
  ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f45),
      ACE_NTOHL (0x6d697473),
      ACE_NTOHL (0x4465663a),
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
      9,
      ACE_NTOHL (0x456d6974),
      ACE_NTOHL (0x73446566),
      ACE_NTOHL (0x0),  // name = EmitsDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_EmitsDefSeq),
    (char *) &_oc_IR_EmitsDefSeq,
    0,
    sizeof (IR::EmitsDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDefSeq, &_tc_TAO_tc_IR_EmitsDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::PublishesDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::PublishesDef **old = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::PublishesDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::PublishesDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::PublishesDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, target);
  *tmp = IR::PublishesDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_upcast (void *src) const
{
  IR::PublishesDef **tmp = ACE_static_cast (IR::PublishesDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_PUBLISHESDEFSEQ_CS_)
#define _IR_PUBLISHESDEFSEQ_CS_

// *************************************************************
// IR::PublishesDefSeq
// *************************************************************

IR::PublishesDefSeq::PublishesDefSeq (void)
{}
IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::PublishesDefSeq::PublishesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::PublishesDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::PublishesDefSeq::PublishesDefSeq (const PublishesDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::PublishesDef,IR::PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::PublishesDefSeq::~PublishesDefSeq (void) // dtor
{}
void IR::PublishesDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  PublishesDefSeq *tmp = ACE_static_cast (PublishesDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_PublishesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x75626c69),
  ACE_NTOHL (0x73686573),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65713a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
  16,
  ACE_NTOHL (0x5075626c),
  ACE_NTOHL (0x69736865),
  ACE_NTOHL (0x73446566),
  ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f50),
      ACE_NTOHL (0x75626c69),
      ACE_NTOHL (0x73686573),
      ACE_NTOHL (0x4465663a),
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
      13,
      ACE_NTOHL (0x5075626c),
      ACE_NTOHL (0x69736865),
      ACE_NTOHL (0x73446566),
      ACE_NTOHL (0x0),  // name = PublishesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_PublishesDefSeq),
    (char *) &_oc_IR_PublishesDefSeq,
    0,
    sizeof (IR::PublishesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDefSeq, &_tc_TAO_tc_IR_PublishesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::ConsumesDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::ConsumesDef **old = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::ConsumesDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ConsumesDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ConsumesDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, target);
  *tmp = IR::ConsumesDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_upcast (void *src) const
{
  IR::ConsumesDef **tmp = ACE_static_cast (IR::ConsumesDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_CONSUMESDEFSEQ_CS_)
#define _IR_CONSUMESDEFSEQ_CS_

// *************************************************************
// IR::ConsumesDefSeq
// *************************************************************

IR::ConsumesDefSeq::ConsumesDefSeq (void)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (CORBA::ULong max, CORBA::ULong length, IR::ConsumesDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::ConsumesDefSeq::ConsumesDefSeq (const ConsumesDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::ConsumesDefSeq::~ConsumesDefSeq (void) // dtor
{}
void IR::ConsumesDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumesDefSeq *tmp = ACE_static_cast (ConsumesDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ConsumesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f43),
  ACE_NTOHL (0x6f6e7375),
  ACE_NTOHL (0x6d657344),
  ACE_NTOHL (0x65665365),
  ACE_NTOHL (0x713a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
  15,
  ACE_NTOHL (0x436f6e73),
  ACE_NTOHL (0x756d6573),
  ACE_NTOHL (0x44656653),
  ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f43),
      ACE_NTOHL (0x6f6e7375),
      ACE_NTOHL (0x6d657344),
      ACE_NTOHL (0x65663a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
      12,
      ACE_NTOHL (0x436f6e73),
      ACE_NTOHL (0x756d6573),
      ACE_NTOHL (0x44656600),  // name = ConsumesDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ConsumesDefSeq),
    (char *) &_oc_IR_ConsumesDefSeq,
    0,
    sizeof (IR::ConsumesDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDefSeq, &_tc_TAO_tc_IR_ConsumesDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::FactoryDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::FactoryDef **old = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::FactoryDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FactoryDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FactoryDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, target);
  *tmp = IR::FactoryDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_upcast (void *src) const
{
  IR::FactoryDef **tmp = ACE_static_cast (IR::FactoryDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_FACTORYDEFSEQ_CS_)
#define _IR_FACTORYDEFSEQ_CS_

// *************************************************************
// IR::FactoryDefSeq
// *************************************************************

IR::FactoryDefSeq::FactoryDefSeq (void)
{}
IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::FactoryDefSeq::FactoryDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FactoryDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::FactoryDefSeq::FactoryDefSeq (const FactoryDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::FactoryDef,IR::FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::FactoryDefSeq::~FactoryDefSeq (void) // dtor
{}
void IR::FactoryDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  FactoryDefSeq *tmp = ACE_static_cast (FactoryDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_FactoryDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f46),
  ACE_NTOHL (0x6163746f),
  ACE_NTOHL (0x72794465),
  ACE_NTOHL (0x66536571),
  ACE_NTOHL (0x3a312e30),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
  14,
  ACE_NTOHL (0x46616374),
  ACE_NTOHL (0x6f727944),
  ACE_NTOHL (0x65665365),
  ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f46),
      ACE_NTOHL (0x6163746f),
      ACE_NTOHL (0x72794465),
      ACE_NTOHL (0x663a312e),
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
      11,
      ACE_NTOHL (0x46616374),
      ACE_NTOHL (0x6f727944),
      ACE_NTOHL (0x65660000),  // name = FactoryDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_FactoryDefSeq),
    (char *) &_oc_IR_FactoryDefSeq,
    0,
    sizeof (IR::FactoryDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDefSeq, &_tc_TAO_tc_IR_FactoryDefSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::FinderDef **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::FinderDef **old = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = IR::FinderDef::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }

    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);

  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FinderDef::_nil ();
    }

  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
{
  this->_deallocate_buffer ();
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);

  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FinderDef::_nil ();
    }
}

void
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, target);
  *tmp = IR::FinderDef::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_upcast (void *src) const
{
  IR::FinderDef **tmp = ACE_static_cast (IR::FinderDef**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_FINDERDEFSEQ_CS_)
#define _IR_FINDERDEFSEQ_CS_

// *************************************************************
// IR::FinderDefSeq
// *************************************************************

IR::FinderDefSeq::FinderDefSeq (void)
{}
IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::FinderDefSeq::FinderDefSeq (CORBA::ULong max, CORBA::ULong length, IR::FinderDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::FinderDefSeq::FinderDefSeq (const FinderDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<IR::FinderDef,IR::FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::FinderDefSeq::~FinderDefSeq (void) // dtor
{}
void IR::FinderDefSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  FinderDefSeq *tmp = ACE_static_cast (FinderDefSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_FinderDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f46),
  ACE_NTOHL (0x696e6465),
  ACE_NTOHL (0x72446566),
  ACE_NTOHL (0x5365713a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
  13,
  ACE_NTOHL (0x46696e64),
  ACE_NTOHL (0x65724465),
  ACE_NTOHL (0x66536571),
  ACE_NTOHL (0x0),  // name = FinderDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f46),
      ACE_NTOHL (0x696e6465),
      ACE_NTOHL (0x72446566),
      ACE_NTOHL (0x3a312e30),
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
      10,
      ACE_NTOHL (0x46696e64),
      ACE_NTOHL (0x65724465),
      ACE_NTOHL (0x66000000),  // name = FinderDef

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_FinderDefSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_FinderDefSeq),
    (char *) &_oc_IR_FinderDefSeq,
    0,
    sizeof (IR::FinderDefSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDefSeq, &_tc_TAO_tc_IR_FinderDefSeq)
TAO_NAMESPACE_END

IR::ComponentRepository_ptr
tao_IR_ComponentRepository_duplicate (
    IR::ComponentRepository_ptr p
  )
{
  return IR::ComponentRepository::_duplicate (p);
}

void
tao_IR_ComponentRepository_release (
    IR::ComponentRepository_ptr p
  )
{
  CORBA::release (p);
}

IR::ComponentRepository_ptr
tao_IR_ComponentRepository_nil (
    void
  )
{
  return IR::ComponentRepository::_nil ();
}

IR::ComponentRepository_ptr
tao_IR_ComponentRepository_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::ComponentRepository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_ComponentRepository_upcast (
    void *src
  )
{
  IR::ComponentRepository **tmp =
    ACE_static_cast (IR::ComponentRepository **, src);
  return *tmp;
}

int IR::ComponentRepository::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::ComponentRepository_var
// *************************************************************

IR::ComponentRepository_var::ComponentRepository_var (void) // default constructor
  : ptr_ (ComponentRepository::_nil ())
{}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::ptr (void) const
{
  return this->ptr_;
}

IR::ComponentRepository_var::ComponentRepository_var (const ::IR::ComponentRepository_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentRepository::_duplicate (p.ptr ()))
{}

IR::ComponentRepository_var::~ComponentRepository_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ComponentRepository_var &
IR::ComponentRepository_var::operator= (ComponentRepository_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ComponentRepository_var &
IR::ComponentRepository_var::operator= (const ::IR::ComponentRepository_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ComponentRepository::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ComponentRepository_var::operator const ::IR::ComponentRepository_ptr &() const // cast
{
  return this->ptr_;
}

IR::ComponentRepository_var::operator ::IR::ComponentRepository_ptr &() // cast
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::in (void) const
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr &
IR::ComponentRepository_var::inout (void)
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr &
IR::ComponentRepository_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentRepository::_nil ();
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ComponentRepository_ptr val = this->ptr_;
  this->ptr_ = ::IR::ComponentRepository::_nil ();
  return val;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::tao_duplicate (ComponentRepository_ptr p)
{
  return ::IR::ComponentRepository::_duplicate (p);
}

void
IR::ComponentRepository_var::tao_release (ComponentRepository_ptr p)
{
  CORBA::release (p);
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::tao_nil (void)
{
  return ::IR::ComponentRepository::_nil ();
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::ComponentRepository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::ComponentRepository_var::tao_upcast (void *src)
{
  ComponentRepository **tmp =
    ACE_static_cast (ComponentRepository **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ComponentRepository_out
// *************************************************************

IR::ComponentRepository_out::ComponentRepository_out (ComponentRepository_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ComponentRepository::_nil ();
}

IR::ComponentRepository_out::ComponentRepository_out (ComponentRepository_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentRepository::_nil ();
}

IR::ComponentRepository_out::ComponentRepository_out (const ::IR::ComponentRepository_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentRepository_out &, p).ptr_)
{}

::IR::ComponentRepository_out &
IR::ComponentRepository_out::operator= (const ::IR::ComponentRepository_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentRepository_out&, p).ptr_;
  return *this;
}

IR::ComponentRepository_out &
IR::ComponentRepository_out::operator= (const ::IR::ComponentRepository_var &p)
{
  this->ptr_ = ::IR::ComponentRepository::_duplicate (p.ptr ());
  return *this;
}

IR::ComponentRepository_out &
IR::ComponentRepository_out::operator= (ComponentRepository_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ComponentRepository_out::operator ::IR::ComponentRepository_ptr &() // cast
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr &
IR::ComponentRepository_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ComponentRepository_ptr
IR::ComponentRepository_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_ComponentRepository_create_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      IR::ComponentDef_ptr base_component,
      const CORBA_InterfaceDefSeq & supports_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_component (const TAO_ClientRequestInfo_IR_ComponentRepository_create_component &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentRepository_create_component &);

  const char * id_;
  const char * name_;
  const char * version_;
  IR::ComponentDef_ptr base_component_;
  const CORBA_InterfaceDefSeq & supports_interfaces_;
  IR::ComponentDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentRepository_create_component::TAO_ClientRequestInfo_IR_ComponentRepository_create_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_component_ (base_component),
    supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->supports_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (IR::ComponentDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentRepository_create_home : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      IR::HomeDef_ptr base_home,
      IR::ComponentDef_ptr managed_component,
      CORBA_ValueDef_ptr primary_key
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentRepository_create_home (const TAO_ClientRequestInfo_IR_ComponentRepository_create_home &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentRepository_create_home &);

  const char * id_;
  const char * name_;
  const char * version_;
  IR::HomeDef_ptr base_home_;
  IR::ComponentDef_ptr managed_component_;
  CORBA_ValueDef_ptr primary_key_;
  IR::HomeDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentRepository_create_home::TAO_ClientRequestInfo_IR_ComponentRepository_create_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_home_ (base_home),
    managed_component_ (managed_component),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (6);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_home_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->managed_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->primary_key_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (IR::HomeDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_ComponentRepository_Proxy_Impl::_TAO_ComponentRepository_Proxy_Impl (void)
{}

IR::_TAO_ComponentRepository_Remote_Proxy_Impl::_TAO_ComponentRepository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR::ComponentDef_ptr IR::_TAO_ComponentRepository_Remote_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentRepository_create_component ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_component,
        supports_interfaces
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_component) &&
              (_tao_out << supports_interfaces)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::HomeDef_ptr IR::_TAO_ComponentRepository_Remote_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
  IR::HomeDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_home",
      11,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentRepository_create_home ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_home) &&
              (_tao_out << managed_component) &&
              (_tao_out << primary_key)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ComponentRepository_Proxy_Broker::_TAO_ComponentRepository_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Proxy_Broker::~_TAO_ComponentRepository_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Proxy_Broker * (*IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ComponentRepository_Remote_Proxy_Broker *
IR::_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ComponentRepository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ComponentRepository_Remote_Proxy_Broker::_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Remote_Proxy_Broker::~_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentRepository_Proxy_Impl&
IR::_TAO_ComponentRepository_Remote_Proxy_Broker::select_proxy (
  ::IR::ComponentRepository *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ComponentRepository::ComponentRepository (int collocated)
{
  this->IR_ComponentRepository_setup_collocation (collocated);
}

// destructor
IR::ComponentRepository::~ComponentRepository (void)
{}

void
IR::ComponentRepository::IR_ComponentRepository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentRepository_Proxy_Broker_ =
      ::IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentRepository_Proxy_Broker_ =
      ::IR::_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker ();

  this->CORBA_Repository_setup_collocation (collocated);
}

void IR::ComponentRepository::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentRepository *tmp = ACE_static_cast (ComponentRepository*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::ComponentRepository_ptr IR::ComponentRepository::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ComponentRepository::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentRepository:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ComponentRepository::_nil ());
      if (is_a == 0)
        return ComponentRepository::_nil ();
    }
  return ComponentRepository::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::ComponentRepository_ptr IR::ComponentRepository::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ComponentRepository::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ComponentRepository_ptr default_proxy = ComponentRepository::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ComponentRepository (
            stub,
            1,
            obj->_servant ()),

          ComponentRepository::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ComponentRepository (stub, 0, obj->_servant ()), ComponentRepository::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            ComponentRepository_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ComponentRepository::_tao_class_id
                    )
                )
          );
}

IR::ComponentRepository_ptr
IR::ComponentRepository::_duplicate (ComponentRepository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ComponentRepository::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::ComponentRepository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ComponentRepository)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Repository::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Repository_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentDef_ptr IR::ComponentRepository::create_component (
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentRepository_Proxy_Impl &proxy =
    this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_component (
      this,
      id,
      name,
      version,
      base_component,
      supports_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

IR::HomeDef_ptr IR::ComponentRepository::create_home (
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentRepository_Proxy_Impl &proxy =
    this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_home (
      this,
      id,
      name,
      version,
      base_home,
      managed_component,
      primary_key
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_ComponentRepository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f43),
  ACE_NTOHL (0x6f6d706f),
  ACE_NTOHL (0x6e656e74),
  ACE_NTOHL (0x5265706f),
  ACE_NTOHL (0x7369746f),
  ACE_NTOHL (0x72793a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentRepository:1.0
  20,
  ACE_NTOHL (0x436f6d70),
  ACE_NTOHL (0x6f6e656e),
  ACE_NTOHL (0x74526570),
  ACE_NTOHL (0x6f736974),
  ACE_NTOHL (0x6f727900),  // name = ComponentRepository
};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentRepository (
    CORBA::tk_objref,
    sizeof (_oc_IR_ComponentRepository),
    (char *) &_oc_IR_ComponentRepository,
    0,
    sizeof (IR::ComponentRepository)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentRepository, &_tc_TAO_tc_IR_ComponentRepository)
TAO_NAMESPACE_END

IR::ProvidesDef_ptr
tao_IR_ProvidesDef_duplicate (
    IR::ProvidesDef_ptr p
  )
{
  return IR::ProvidesDef::_duplicate (p);
}

void
tao_IR_ProvidesDef_release (
    IR::ProvidesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::ProvidesDef_ptr
tao_IR_ProvidesDef_nil (
    void
  )
{
  return IR::ProvidesDef::_nil ();
}

IR::ProvidesDef_ptr
tao_IR_ProvidesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::ProvidesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_ProvidesDef_upcast (
    void *src
  )
{
  IR::ProvidesDef **tmp =
    ACE_static_cast (IR::ProvidesDef **, src);
  return *tmp;
}

int IR::ProvidesDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::ProvidesDef_var
// *************************************************************

IR::ProvidesDef_var::ProvidesDef_var (void) // default constructor
  : ptr_ (ProvidesDef::_nil ())
{}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::ProvidesDef_var::ProvidesDef_var (const ::IR::ProvidesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ProvidesDef::_duplicate (p.ptr ()))
{}

IR::ProvidesDef_var::~ProvidesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ProvidesDef_var &
IR::ProvidesDef_var::operator= (ProvidesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ProvidesDef_var &
IR::ProvidesDef_var::operator= (const ::IR::ProvidesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ProvidesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ProvidesDef_var::operator const ::IR::ProvidesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::ProvidesDef_var::operator ::IR::ProvidesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr &
IR::ProvidesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr &
IR::ProvidesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ProvidesDef::_nil ();
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ProvidesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::ProvidesDef::_nil ();
  return val;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::tao_duplicate (ProvidesDef_ptr p)
{
  return ::IR::ProvidesDef::_duplicate (p);
}

void
IR::ProvidesDef_var::tao_release (ProvidesDef_ptr p)
{
  CORBA::release (p);
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::tao_nil (void)
{
  return ::IR::ProvidesDef::_nil ();
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::ProvidesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::ProvidesDef_var::tao_upcast (void *src)
{
  ProvidesDef **tmp =
    ACE_static_cast (ProvidesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ProvidesDef_out
// *************************************************************

IR::ProvidesDef_out::ProvidesDef_out (ProvidesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ProvidesDef::_nil ();
}

IR::ProvidesDef_out::ProvidesDef_out (ProvidesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ProvidesDef::_nil ();
}

IR::ProvidesDef_out::ProvidesDef_out (const ::IR::ProvidesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ProvidesDef_out &, p).ptr_)
{}

::IR::ProvidesDef_out &
IR::ProvidesDef_out::operator= (const ::IR::ProvidesDef_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDef_out&, p).ptr_;
  return *this;
}

IR::ProvidesDef_out &
IR::ProvidesDef_out::operator= (const ::IR::ProvidesDef_var &p)
{
  this->ptr_ = ::IR::ProvidesDef::_duplicate (p.ptr ());
  return *this;
}

IR::ProvidesDef_out &
IR::ProvidesDef_out::operator= (ProvidesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ProvidesDef_out::operator ::IR::ProvidesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr &
IR::ProvidesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ProvidesDef_ptr
IR::ProvidesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (const TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get &);

  CORBA_InterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_ProvidesDef_Proxy_Impl::_TAO_ProvidesDef_Proxy_Impl (void)
{}

IR::_TAO_ProvidesDef_Remote_Proxy_Impl::_TAO_ProvidesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr IR::_TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDef_ptr _tao_retval = CORBA_InterfaceDef::_nil ();
  CORBA_InterfaceDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ProvidesDef_Proxy_Broker::_TAO_ProvidesDef_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Proxy_Broker::~_TAO_ProvidesDef_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Proxy_Broker * (*IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ProvidesDef_Remote_Proxy_Broker *
IR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ProvidesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ProvidesDef_Remote_Proxy_Broker::_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Remote_Proxy_Broker::~_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ProvidesDef_Proxy_Impl&
IR::_TAO_ProvidesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::ProvidesDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ProvidesDef::ProvidesDef (int collocated)
{
  this->IR_ProvidesDef_setup_collocation (collocated);
}

// destructor
IR::ProvidesDef::~ProvidesDef (void)
{}

void
IR::ProvidesDef::IR_ProvidesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      ::IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      ::IR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::ProvidesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDef *tmp = ACE_static_cast (ProvidesDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::ProvidesDef_ptr IR::ProvidesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ProvidesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ProvidesDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ProvidesDef::_nil ());
      if (is_a == 0)
        return ProvidesDef::_nil ();
    }
  return ProvidesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::ProvidesDef_ptr IR::ProvidesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ProvidesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ProvidesDef_ptr default_proxy = ProvidesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ProvidesDef (
            stub,
            1,
            obj->_servant ()),

          ProvidesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ProvidesDef (stub, 0, obj->_servant ()), ProvidesDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            ProvidesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ProvidesDef::_tao_class_id
                    )
                )
          );
}

IR::ProvidesDef_ptr
IR::ProvidesDef::_duplicate (ProvidesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ProvidesDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::ProvidesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ProvidesDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

CORBA_InterfaceDef_ptr IR::ProvidesDef::interface_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ProvidesDef_Proxy_Impl &proxy =
    this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.interface_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_ProvidesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x726f7669),
  ACE_NTOHL (0x64657344),
  ACE_NTOHL (0x65663a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
  12,
  ACE_NTOHL (0x50726f76),
  ACE_NTOHL (0x69646573),
  ACE_NTOHL (0x44656600),  // name = ProvidesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_ProvidesDef),
    (char *) &_oc_IR_ProvidesDef,
    0,
    sizeof (IR::ProvidesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDef, &_tc_TAO_tc_IR_ProvidesDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ProvidesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x726f7669),
  ACE_NTOHL (0x64657344),
  ACE_NTOHL (0x65736372),
  ACE_NTOHL (0x69707469),
  ACE_NTOHL (0x6f6e3a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
  20,
  ACE_NTOHL (0x50726f76),
  ACE_NTOHL (0x69646573),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x72697074),
  ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f49),
    ACE_NTOHL (0x64656e74),
    ACE_NTOHL (0x69666965),
    ACE_NTOHL (0x723a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f56),
    ACE_NTOHL (0x65727369),
    ACE_NTOHL (0x6f6e5370),
    ACE_NTOHL (0x65633a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  15,
  ACE_NTOHL (0x696e7465),
  ACE_NTOHL (0x72666163),
  ACE_NTOHL (0x655f7479),
  ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f496e),
    ACE_NTOHL (0x74657266),
    ACE_NTOHL (0x61636544),
    ACE_NTOHL (0x65663a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
    13,
    ACE_NTOHL (0x496e7465),
    ACE_NTOHL (0x72666163),
    ACE_NTOHL (0x65446566),
    ACE_NTOHL (0x0),  // name = InterfaceDef

};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_ProvidesDescription),
    (char *) &_oc_IR_ProvidesDescription,
    0,
    sizeof (IR::ProvidesDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescription, &_tc_TAO_tc_IR_ProvidesDescription)
TAO_NAMESPACE_END

void IR::ProvidesDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDescription *tmp = ACE_static_cast (ProvidesDescription*, _tao_void_pointer);
  delete tmp;
}

IR::UsesDef_ptr
tao_IR_UsesDef_duplicate (
    IR::UsesDef_ptr p
  )
{
  return IR::UsesDef::_duplicate (p);
}

void
tao_IR_UsesDef_release (
    IR::UsesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::UsesDef_ptr
tao_IR_UsesDef_nil (
    void
  )
{
  return IR::UsesDef::_nil ();
}

IR::UsesDef_ptr
tao_IR_UsesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::UsesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_UsesDef_upcast (
    void *src
  )
{
  IR::UsesDef **tmp =
    ACE_static_cast (IR::UsesDef **, src);
  return *tmp;
}

int IR::UsesDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::UsesDef_var
// *************************************************************

IR::UsesDef_var::UsesDef_var (void) // default constructor
  : ptr_ (UsesDef::_nil ())
{}

::IR::UsesDef_ptr
IR::UsesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::UsesDef_var::UsesDef_var (const ::IR::UsesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (UsesDef::_duplicate (p.ptr ()))
{}

IR::UsesDef_var::~UsesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::UsesDef_var &
IR::UsesDef_var::operator= (UsesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::UsesDef_var &
IR::UsesDef_var::operator= (const ::IR::UsesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::UsesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::UsesDef_var::operator const ::IR::UsesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::UsesDef_var::operator ::IR::UsesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::UsesDef_ptr &
IR::UsesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::UsesDef_ptr &
IR::UsesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::UsesDef::_nil ();
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::UsesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::UsesDef::_nil ();
  return val;
}

::IR::UsesDef_ptr
IR::UsesDef_var::tao_duplicate (UsesDef_ptr p)
{
  return ::IR::UsesDef::_duplicate (p);
}

void
IR::UsesDef_var::tao_release (UsesDef_ptr p)
{
  CORBA::release (p);
}

::IR::UsesDef_ptr
IR::UsesDef_var::tao_nil (void)
{
  return ::IR::UsesDef::_nil ();
}

::IR::UsesDef_ptr
IR::UsesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::UsesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::UsesDef_var::tao_upcast (void *src)
{
  UsesDef **tmp =
    ACE_static_cast (UsesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::UsesDef_out
// *************************************************************

IR::UsesDef_out::UsesDef_out (UsesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::UsesDef::_nil ();
}

IR::UsesDef_out::UsesDef_out (UsesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::UsesDef::_nil ();
}

IR::UsesDef_out::UsesDef_out (const ::IR::UsesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UsesDef_out &, p).ptr_)
{}

::IR::UsesDef_out &
IR::UsesDef_out::operator= (const ::IR::UsesDef_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDef_out&, p).ptr_;
  return *this;
}

IR::UsesDef_out &
IR::UsesDef_out::operator= (const ::IR::UsesDef_var &p)
{
  this->ptr_ = ::IR::UsesDef::_duplicate (p.ptr ());
  return *this;
}

IR::UsesDef_out &
IR::UsesDef_out::operator= (UsesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::UsesDef_out::operator ::IR::UsesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::UsesDef_ptr &
IR::UsesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::UsesDef_ptr
IR::UsesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_UsesDef_interface_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (const TAO_ClientRequestInfo_IR_UsesDef_interface_type_get &);
  void operator= (const TAO_ClientRequestInfo_IR_UsesDef_interface_type_get &);

  CORBA_InterfaceDef_ptr _result;
};

TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (const TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get &);
  void operator= (const TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get &);

  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_UsesDef_Proxy_Impl::_TAO_UsesDef_Proxy_Impl (void)
{}

IR::_TAO_UsesDef_Remote_Proxy_Impl::_TAO_UsesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr IR::_TAO_UsesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDef_ptr _tao_retval = CORBA_InterfaceDef::_nil ();
  CORBA_InterfaceDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_UsesDef_interface_type_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::_TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_multiple",
      16,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_UsesDef_Proxy_Broker::_TAO_UsesDef_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Proxy_Broker::~_TAO_UsesDef_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Proxy_Broker * (*IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_UsesDef_Remote_Proxy_Broker *
IR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_UsesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_UsesDef_Remote_Proxy_Broker::_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Remote_Proxy_Broker::~_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_UsesDef_Proxy_Impl&
IR::_TAO_UsesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::UsesDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::UsesDef::UsesDef (int collocated)
{
  this->IR_UsesDef_setup_collocation (collocated);
}

// destructor
IR::UsesDef::~UsesDef (void)
{}

void
IR::UsesDef::IR_UsesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_UsesDef_Proxy_Broker_ =
      ::IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_UsesDef_Proxy_Broker_ =
      ::IR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::UsesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDef *tmp = ACE_static_cast (UsesDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::UsesDef_ptr IR::UsesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return UsesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UsesDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (UsesDef::_nil ());
      if (is_a == 0)
        return UsesDef::_nil ();
    }
  return UsesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::UsesDef_ptr IR::UsesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return UsesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      UsesDef_ptr default_proxy = UsesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::UsesDef (
            stub,
            1,
            obj->_servant ()),

          UsesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::UsesDef (stub, 0, obj->_servant ()), UsesDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            UsesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &UsesDef::_tao_class_id
                    )
                )
          );
}

IR::UsesDef_ptr
IR::UsesDef::_duplicate (UsesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::UsesDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::UsesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, UsesDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

CORBA_InterfaceDef_ptr IR::UsesDef::interface_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy =
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.interface_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::Boolean IR::UsesDef::is_multiple (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy =
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.is_multiple (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_UsesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f55),
  ACE_NTOHL (0x73657344),
  ACE_NTOHL (0x65663a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
  8,
  ACE_NTOHL (0x55736573),
  ACE_NTOHL (0x44656600),  // name = UsesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_UsesDef),
    (char *) &_oc_IR_UsesDef,
    0,
    sizeof (IR::UsesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDef, &_tc_TAO_tc_IR_UsesDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_UsesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f55),
  ACE_NTOHL (0x73657344),
  ACE_NTOHL (0x65736372),
  ACE_NTOHL (0x69707469),
  ACE_NTOHL (0x6f6e3a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
  16,
  ACE_NTOHL (0x55736573),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x72697074),
  ACE_NTOHL (0x696f6e00),  // name = UsesDescription
  6, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f49),
    ACE_NTOHL (0x64656e74),
    ACE_NTOHL (0x69666965),
    ACE_NTOHL (0x723a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f56),
    ACE_NTOHL (0x65727369),
    ACE_NTOHL (0x6f6e5370),
    ACE_NTOHL (0x65633a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  15,
  ACE_NTOHL (0x696e7465),
  ACE_NTOHL (0x72666163),
  ACE_NTOHL (0x655f7479),
  ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f496e),
    ACE_NTOHL (0x74657266),
    ACE_NTOHL (0x61636544),
    ACE_NTOHL (0x65663a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
    13,
    ACE_NTOHL (0x496e7465),
    ACE_NTOHL (0x72666163),
    ACE_NTOHL (0x65446566),
    ACE_NTOHL (0x0),  // name = InterfaceDef

  12,
  ACE_NTOHL (0x69735f6d),
  ACE_NTOHL (0x756c7469),
  ACE_NTOHL (0x706c6500),  // name = is_multiple
  CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_UsesDescription),
    (char *) &_oc_IR_UsesDescription,
    0,
    sizeof (IR::UsesDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescription, &_tc_TAO_tc_IR_UsesDescription)
TAO_NAMESPACE_END

void IR::UsesDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDescription *tmp = ACE_static_cast (UsesDescription*, _tao_void_pointer);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CS_

void
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::ProvidesDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::ProvidesDescription *old = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];

    if (this->release_)
      _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (old);

  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;

  IR::ProvidesDescription *tmp = ACE_reinterpret_cast (IR::ProvidesDescription *,this->buffer_);

  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_PROVIDESDESCSEQ_CS_)
#define _IR_PROVIDESDESCSEQ_CS_

// *************************************************************
// IR::ProvidesDescSeq
// *************************************************************

IR::ProvidesDescSeq::ProvidesDescSeq (void)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::ProvidesDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::ProvidesDescSeq::ProvidesDescSeq (const ProvidesDescSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<IR::ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::ProvidesDescSeq::~ProvidesDescSeq (void) // dtor
{}
void IR::ProvidesDescSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDescSeq *tmp = ACE_static_cast (ProvidesDescSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_ProvidesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x726f7669),
  ACE_NTOHL (0x64657344),
  ACE_NTOHL (0x65736353),
  ACE_NTOHL (0x65713a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescSeq:1.0
  16,
  ACE_NTOHL (0x50726f76),
  ACE_NTOHL (0x69646573),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x53657100),  // name = ProvidesDescSeq
  CORBA::tk_sequence, // typecode kind
  528, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    512, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f50),
      ACE_NTOHL (0x726f7669),
      ACE_NTOHL (0x64657344),
      ACE_NTOHL (0x65736372),
      ACE_NTOHL (0x69707469),
      ACE_NTOHL (0x6f6e3a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
      20,
      ACE_NTOHL (0x50726f76),
      ACE_NTOHL (0x69646573),
      ACE_NTOHL (0x44657363),
      ACE_NTOHL (0x72697074),
      ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
      5, // member count
      5,
      ACE_NTOHL (0x6e616d65),
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f49),
        ACE_NTOHL (0x64656e74),
        ACE_NTOHL (0x69666965),
        ACE_NTOHL (0x723a312e),
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11,
        ACE_NTOHL (0x4964656e),
        ACE_NTOHL (0x74696669),
        ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f52),
        ACE_NTOHL (0x65706f73),
        ACE_NTOHL (0x69746f72),
        ACE_NTOHL (0x7949643a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f),
        ACE_NTOHL (0x7369746f),
        ACE_NTOHL (0x72794964),
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      11,
      ACE_NTOHL (0x64656669),
      ACE_NTOHL (0x6e65645f),
      ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f52),
        ACE_NTOHL (0x65706f73),
        ACE_NTOHL (0x69746f72),
        ACE_NTOHL (0x7949643a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f),
        ACE_NTOHL (0x7369746f),
        ACE_NTOHL (0x72794964),
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      8,
      ACE_NTOHL (0x76657273),
      ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f56),
        ACE_NTOHL (0x65727369),
        ACE_NTOHL (0x6f6e5370),
        ACE_NTOHL (0x65633a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12,
        ACE_NTOHL (0x56657273),
        ACE_NTOHL (0x696f6e53),
        ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

      15,
      ACE_NTOHL (0x696e7465),
      ACE_NTOHL (0x72666163),
      ACE_NTOHL (0x655f7479),
      ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f496e),
        ACE_NTOHL (0x74657266),
        ACE_NTOHL (0x61636544),
        ACE_NTOHL (0x65663a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
        13,
        ACE_NTOHL (0x496e7465),
        ACE_NTOHL (0x72666163),
        ACE_NTOHL (0x65446566),
        ACE_NTOHL (0x0),  // name = InterfaceDef


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_ProvidesDescSeq),
    (char *) &_oc_IR_ProvidesDescSeq,
    0,
    sizeof (IR::ProvidesDescSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescSeq, &_tc_TAO_tc_IR_ProvidesDescSeq)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CS_

void
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_allocate_buffer (CORBA::ULong length)
{
  IR::UsesDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (length);

  if (this->buffer_ != 0)
  {
    IR::UsesDescription *old = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];

    if (this->release_)
      _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (old);

  }
  this->buffer_ = tmp;
}

void
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;

  IR::UsesDescription *tmp = ACE_reinterpret_cast (IR::UsesDescription *,this->buffer_);

  _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
  this->buffer_ = 0;
}

IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IR_USESDESCSEQ_CS_)
#define _IR_USESDESCSEQ_CS_

// *************************************************************
// IR::UsesDescSeq
// *************************************************************

IR::UsesDescSeq::UsesDescSeq (void)
{}
IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
IR::UsesDescSeq::UsesDescSeq (CORBA::ULong max, CORBA::ULong length, IR::UsesDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
IR::UsesDescSeq::UsesDescSeq (const UsesDescSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<IR::UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
IR::UsesDescSeq::~UsesDescSeq (void) // dtor
{}
void IR::UsesDescSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDescSeq *tmp = ACE_static_cast (UsesDescSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_IR_UsesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f55),
  ACE_NTOHL (0x73657344),
  ACE_NTOHL (0x65736353),
  ACE_NTOHL (0x65713a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescSeq:1.0
  12,
  ACE_NTOHL (0x55736573),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x53657100),  // name = UsesDescSeq
  CORBA::tk_sequence, // typecode kind
  540, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    524, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x49522f55),
      ACE_NTOHL (0x73657344),
      ACE_NTOHL (0x65736372),
      ACE_NTOHL (0x69707469),
      ACE_NTOHL (0x6f6e3a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
      16,
      ACE_NTOHL (0x55736573),
      ACE_NTOHL (0x44657363),
      ACE_NTOHL (0x72697074),
      ACE_NTOHL (0x696f6e00),  // name = UsesDescription
      6, // member count
      5,
      ACE_NTOHL (0x6e616d65),
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f49),
        ACE_NTOHL (0x64656e74),
        ACE_NTOHL (0x69666965),
        ACE_NTOHL (0x723a312e),
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11,
        ACE_NTOHL (0x4964656e),
        ACE_NTOHL (0x74696669),
        ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f52),
        ACE_NTOHL (0x65706f73),
        ACE_NTOHL (0x69746f72),
        ACE_NTOHL (0x7949643a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f),
        ACE_NTOHL (0x7369746f),
        ACE_NTOHL (0x72794964),
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      11,
      ACE_NTOHL (0x64656669),
      ACE_NTOHL (0x6e65645f),
      ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f52),
        ACE_NTOHL (0x65706f73),
        ACE_NTOHL (0x69746f72),
        ACE_NTOHL (0x7949643a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f),
        ACE_NTOHL (0x7369746f),
        ACE_NTOHL (0x72794964),
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      8,
      ACE_NTOHL (0x76657273),
      ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f56),
        ACE_NTOHL (0x65727369),
        ACE_NTOHL (0x6f6e5370),
        ACE_NTOHL (0x65633a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12,
        ACE_NTOHL (0x56657273),
        ACE_NTOHL (0x696f6e53),
        ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

      15,
      ACE_NTOHL (0x696e7465),
      ACE_NTOHL (0x72666163),
      ACE_NTOHL (0x655f7479),
      ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f496e),
        ACE_NTOHL (0x74657266),
        ACE_NTOHL (0x61636544),
        ACE_NTOHL (0x65663a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
        13,
        ACE_NTOHL (0x496e7465),
        ACE_NTOHL (0x72666163),
        ACE_NTOHL (0x65446566),
        ACE_NTOHL (0x0),  // name = InterfaceDef

      12,
      ACE_NTOHL (0x69735f6d),
      ACE_NTOHL (0x756c7469),
      ACE_NTOHL (0x706c6500),  // name = is_multiple
      CORBA::tk_boolean,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescSeq (
    CORBA::tk_alias,
    sizeof (_oc_IR_UsesDescSeq),
    (char *) &_oc_IR_UsesDescSeq,
    0,
    sizeof (IR::UsesDescSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescSeq, &_tc_TAO_tc_IR_UsesDescSeq)
TAO_NAMESPACE_END

IR::EventDef_ptr
tao_IR_EventDef_duplicate (
    IR::EventDef_ptr p
  )
{
  return IR::EventDef::_duplicate (p);
}

void
tao_IR_EventDef_release (
    IR::EventDef_ptr p
  )
{
  CORBA::release (p);
}

IR::EventDef_ptr
tao_IR_EventDef_nil (
    void
  )
{
  return IR::EventDef::_nil ();
}

IR::EventDef_ptr
tao_IR_EventDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::EventDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_EventDef_upcast (
    void *src
  )
{
  IR::EventDef **tmp =
    ACE_static_cast (IR::EventDef **, src);
  return *tmp;
}

int IR::EventDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::EventDef_var
// *************************************************************

IR::EventDef_var::EventDef_var (void) // default constructor
  : ptr_ (EventDef::_nil ())
{}

::IR::EventDef_ptr
IR::EventDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::EventDef_var::EventDef_var (const ::IR::EventDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EventDef::_duplicate (p.ptr ()))
{}

IR::EventDef_var::~EventDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::EventDef_var &
IR::EventDef_var::operator= (EventDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::EventDef_var &
IR::EventDef_var::operator= (const ::IR::EventDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::EventDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::EventDef_var::operator const ::IR::EventDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::EventDef_var::operator ::IR::EventDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_var::in (void) const
{
  return this->ptr_;
}

::IR::EventDef_ptr &
IR::EventDef_var::inout (void)
{
  return this->ptr_;
}

::IR::EventDef_ptr &
IR::EventDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EventDef::_nil ();
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::EventDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::EventDef::_nil ();
  return val;
}

::IR::EventDef_ptr
IR::EventDef_var::tao_duplicate (EventDef_ptr p)
{
  return ::IR::EventDef::_duplicate (p);
}

void
IR::EventDef_var::tao_release (EventDef_ptr p)
{
  CORBA::release (p);
}

::IR::EventDef_ptr
IR::EventDef_var::tao_nil (void)
{
  return ::IR::EventDef::_nil ();
}

::IR::EventDef_ptr
IR::EventDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::EventDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::EventDef_var::tao_upcast (void *src)
{
  EventDef **tmp =
    ACE_static_cast (EventDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::EventDef_out
// *************************************************************

IR::EventDef_out::EventDef_out (EventDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::EventDef::_nil ();
}

IR::EventDef_out::EventDef_out (EventDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EventDef::_nil ();
}

IR::EventDef_out::EventDef_out (const ::IR::EventDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EventDef_out &, p).ptr_)
{}

::IR::EventDef_out &
IR::EventDef_out::operator= (const ::IR::EventDef_out &p)
{
  this->ptr_ = ACE_const_cast (EventDef_out&, p).ptr_;
  return *this;
}

IR::EventDef_out &
IR::EventDef_out::operator= (const ::IR::EventDef_var &p)
{
  this->ptr_ = ::IR::EventDef::_duplicate (p.ptr ());
  return *this;
}

IR::EventDef_out &
IR::EventDef_out::operator= (EventDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::EventDef_out::operator ::IR::EventDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::EventDef_ptr &
IR::EventDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::EventDef_ptr
IR::EventDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_EventDef_is_a : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_EventDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * event_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_EventDef_is_a (const TAO_ClientRequestInfo_IR_EventDef_is_a &);
  void operator= (const TAO_ClientRequestInfo_IR_EventDef_is_a &);

  const char * event_id_;
  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_EventDef_is_a::TAO_ClientRequestInfo_IR_EventDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * event_id
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    event_id_ (event_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_EventDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= event_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_EventDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_EventDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_EventDef_event_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_EventDef_event_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_EventDef_event_get (const TAO_ClientRequestInfo_IR_EventDef_event_get &);
  void operator= (const TAO_ClientRequestInfo_IR_EventDef_event_get &);

  CORBA_ValueDef_ptr _result;
};

TAO_ClientRequestInfo_IR_EventDef_event_get::TAO_ClientRequestInfo_IR_EventDef_event_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_EventDef_event_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_EventDef_event_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_EventDef_event_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_EventDef_event_get::result (CORBA_ValueDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_EventDef_Proxy_Impl::_TAO_EventDef_Proxy_Impl (void)
{}

IR::_TAO_EventDef_Remote_Proxy_Impl::_TAO_EventDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Boolean IR::_TAO_EventDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_EventDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        event_id
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << event_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

CORBA_ValueDef_ptr IR::_TAO_EventDef_Remote_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueDef_ptr _tao_retval = CORBA_ValueDef::_nil ();
  CORBA_ValueDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_event",
      10,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_EventDef_event_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_EventDef_Proxy_Broker::_TAO_EventDef_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Proxy_Broker::~_TAO_EventDef_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Proxy_Broker * (*IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_EventDef_Remote_Proxy_Broker *
IR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_EventDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_EventDef_Remote_Proxy_Broker::_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Remote_Proxy_Broker::~_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EventDef_Proxy_Impl&
IR::_TAO_EventDef_Remote_Proxy_Broker::select_proxy (
  ::IR::EventDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::EventDef::EventDef (int collocated)
{
  this->IR_EventDef_setup_collocation (collocated);
}

// destructor
IR::EventDef::~EventDef (void)
{}

void
IR::EventDef::IR_EventDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventDef_Proxy_Broker_ =
      ::IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventDef_Proxy_Broker_ =
      ::IR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::EventDef::_tao_any_destructor (void *_tao_void_pointer)
{
  EventDef *tmp = ACE_static_cast (EventDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::EventDef_ptr IR::EventDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return EventDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EventDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (EventDef::_nil ());
      if (is_a == 0)
        return EventDef::_nil ();
    }
  return EventDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::EventDef_ptr IR::EventDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return EventDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      EventDef_ptr default_proxy = EventDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::EventDef (
            stub,
            1,
            obj->_servant ()),

          EventDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::EventDef (stub, 0, obj->_servant ()), EventDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            EventDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &EventDef::_tao_class_id
                    )
                )
          );
}

IR::EventDef_ptr
IR::EventDef::_duplicate (EventDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::EventDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::EventDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

CORBA::Boolean IR::EventDef::is_a (
    const char * event_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventDef_Proxy_Impl &proxy =
    this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.is_a (
      this,
      event_id
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ValueDef_ptr IR::EventDef::event (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventDef_Proxy_Impl &proxy =
    this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.event (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_EventDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f45),
  ACE_NTOHL (0x76656e74),
  ACE_NTOHL (0x4465663a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDef:1.0
  9,
  ACE_NTOHL (0x4576656e),
  ACE_NTOHL (0x74446566),
  ACE_NTOHL (0x0),  // name = EventDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_EventDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_EventDef),
    (char *) &_oc_IR_EventDef,
    0,
    sizeof (IR::EventDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDef, &_tc_TAO_tc_IR_EventDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_EventDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f45),
  ACE_NTOHL (0x76656e74),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x72697074),
  ACE_NTOHL (0x696f6e3a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDescription:1.0
  17,
  ACE_NTOHL (0x4576656e),
  ACE_NTOHL (0x74446573),
  ACE_NTOHL (0x63726970),
  ACE_NTOHL (0x74696f6e),
  ACE_NTOHL (0x0),  // name = EventDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f49),
    ACE_NTOHL (0x64656e74),
    ACE_NTOHL (0x69666965),
    ACE_NTOHL (0x723a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f56),
    ACE_NTOHL (0x65727369),
    ACE_NTOHL (0x6f6e5370),
    ACE_NTOHL (0x65633a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  6,
  ACE_NTOHL (0x76616c75),
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f5661),
    ACE_NTOHL (0x6c756544),
    ACE_NTOHL (0x65663a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
    9,
    ACE_NTOHL (0x56616c75),
    ACE_NTOHL (0x65446566),
    ACE_NTOHL (0x0),  // name = ValueDef

};

static CORBA::TypeCode _tc_TAO_tc_IR_EventDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_EventDescription),
    (char *) &_oc_IR_EventDescription,
    0,
    sizeof (IR::EventDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDescription, &_tc_TAO_tc_IR_EventDescription)
TAO_NAMESPACE_END

void IR::EventDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  EventDescription *tmp = ACE_static_cast (EventDescription*, _tao_void_pointer);
  delete tmp;
}

IR::EmitsDef_ptr
tao_IR_EmitsDef_duplicate (
    IR::EmitsDef_ptr p
  )
{
  return IR::EmitsDef::_duplicate (p);
}

void
tao_IR_EmitsDef_release (
    IR::EmitsDef_ptr p
  )
{
  CORBA::release (p);
}

IR::EmitsDef_ptr
tao_IR_EmitsDef_nil (
    void
  )
{
  return IR::EmitsDef::_nil ();
}

IR::EmitsDef_ptr
tao_IR_EmitsDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::EmitsDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_EmitsDef_upcast (
    void *src
  )
{
  IR::EmitsDef **tmp =
    ACE_static_cast (IR::EmitsDef **, src);
  return *tmp;
}

int IR::EmitsDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::EmitsDef_var
// *************************************************************

IR::EmitsDef_var::EmitsDef_var (void) // default constructor
  : ptr_ (EmitsDef::_nil ())
{}

::IR::EmitsDef_ptr
IR::EmitsDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::EmitsDef_var::EmitsDef_var (const ::IR::EmitsDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EmitsDef::_duplicate (p.ptr ()))
{}

IR::EmitsDef_var::~EmitsDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::EmitsDef_var &
IR::EmitsDef_var::operator= (EmitsDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::EmitsDef_var &
IR::EmitsDef_var::operator= (const ::IR::EmitsDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::EmitsDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::EmitsDef_var::operator const ::IR::EmitsDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::EmitsDef_var::operator ::IR::EmitsDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::in (void) const
{
  return this->ptr_;
}

::IR::EmitsDef_ptr &
IR::EmitsDef_var::inout (void)
{
  return this->ptr_;
}

::IR::EmitsDef_ptr &
IR::EmitsDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EmitsDef::_nil ();
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::EmitsDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::EmitsDef::_nil ();
  return val;
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::tao_duplicate (EmitsDef_ptr p)
{
  return ::IR::EmitsDef::_duplicate (p);
}

void
IR::EmitsDef_var::tao_release (EmitsDef_ptr p)
{
  CORBA::release (p);
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::tao_nil (void)
{
  return ::IR::EmitsDef::_nil ();
}

::IR::EmitsDef_ptr
IR::EmitsDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::EmitsDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::EmitsDef_var::tao_upcast (void *src)
{
  EmitsDef **tmp =
    ACE_static_cast (EmitsDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::EmitsDef_out
// *************************************************************

IR::EmitsDef_out::EmitsDef_out (EmitsDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::EmitsDef::_nil ();
}

IR::EmitsDef_out::EmitsDef_out (EmitsDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::EmitsDef::_nil ();
}

IR::EmitsDef_out::EmitsDef_out (const ::IR::EmitsDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EmitsDef_out &, p).ptr_)
{}

::IR::EmitsDef_out &
IR::EmitsDef_out::operator= (const ::IR::EmitsDef_out &p)
{
  this->ptr_ = ACE_const_cast (EmitsDef_out&, p).ptr_;
  return *this;
}

IR::EmitsDef_out &
IR::EmitsDef_out::operator= (const ::IR::EmitsDef_var &p)
{
  this->ptr_ = ::IR::EmitsDef::_duplicate (p.ptr ());
  return *this;
}

IR::EmitsDef_out &
IR::EmitsDef_out::operator= (EmitsDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::EmitsDef_out::operator ::IR::EmitsDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::EmitsDef_ptr &
IR::EmitsDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::EmitsDef_ptr
IR::EmitsDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_EmitsDef_Proxy_Impl::_TAO_EmitsDef_Proxy_Impl (void)
{}

IR::_TAO_EmitsDef_Remote_Proxy_Impl::_TAO_EmitsDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_EmitsDef_Proxy_Broker::_TAO_EmitsDef_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Proxy_Broker::~_TAO_EmitsDef_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Proxy_Broker * (*IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_EmitsDef_Remote_Proxy_Broker *
IR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_EmitsDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_EmitsDef_Remote_Proxy_Broker::_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Remote_Proxy_Broker::~_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_EmitsDef_Proxy_Impl&
IR::_TAO_EmitsDef_Remote_Proxy_Broker::select_proxy (
  ::IR::EmitsDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::EmitsDef::EmitsDef (int collocated)
{
  this->IR_EmitsDef_setup_collocation (collocated);
}

// destructor
IR::EmitsDef::~EmitsDef (void)
{}

void
IR::EmitsDef::IR_EmitsDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      ::IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      ::IR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker ();

  this->IR_EventDef_setup_collocation (collocated);
}

void IR::EmitsDef::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitsDef *tmp = ACE_static_cast (EmitsDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::EmitsDef_ptr IR::EmitsDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return EmitsDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EmitsDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (EmitsDef::_nil ());
      if (is_a == 0)
        return EmitsDef::_nil ();
    }
  return EmitsDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::EmitsDef_ptr IR::EmitsDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return EmitsDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      EmitsDef_ptr default_proxy = EmitsDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::EmitsDef (
            stub,
            1,
            obj->_servant ()),

          EmitsDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::EmitsDef (stub, 0, obj->_servant ()), EmitsDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            EmitsDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &EmitsDef::_tao_class_id
                    )
                )
          );
}

IR::EmitsDef_ptr
IR::EmitsDef::_duplicate (EmitsDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::EmitsDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::EmitsDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EmitsDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR::EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

static const CORBA::Long _oc_IR_EmitsDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f45),
  ACE_NTOHL (0x6d697473),
  ACE_NTOHL (0x4465663a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
  9,
  ACE_NTOHL (0x456d6974),
  ACE_NTOHL (0x73446566),
  ACE_NTOHL (0x0),  // name = EmitsDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_EmitsDef),
    (char *) &_oc_IR_EmitsDef,
    0,
    sizeof (IR::EmitsDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDef, &_tc_TAO_tc_IR_EmitsDef)
TAO_NAMESPACE_END

IR::PublishesDef_ptr
tao_IR_PublishesDef_duplicate (
    IR::PublishesDef_ptr p
  )
{
  return IR::PublishesDef::_duplicate (p);
}

void
tao_IR_PublishesDef_release (
    IR::PublishesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::PublishesDef_ptr
tao_IR_PublishesDef_nil (
    void
  )
{
  return IR::PublishesDef::_nil ();
}

IR::PublishesDef_ptr
tao_IR_PublishesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::PublishesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_PublishesDef_upcast (
    void *src
  )
{
  IR::PublishesDef **tmp =
    ACE_static_cast (IR::PublishesDef **, src);
  return *tmp;
}

int IR::PublishesDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::PublishesDef_var
// *************************************************************

IR::PublishesDef_var::PublishesDef_var (void) // default constructor
  : ptr_ (PublishesDef::_nil ())
{}

::IR::PublishesDef_ptr
IR::PublishesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::PublishesDef_var::PublishesDef_var (const ::IR::PublishesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (PublishesDef::_duplicate (p.ptr ()))
{}

IR::PublishesDef_var::~PublishesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::PublishesDef_var &
IR::PublishesDef_var::operator= (PublishesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::PublishesDef_var &
IR::PublishesDef_var::operator= (const ::IR::PublishesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::PublishesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::PublishesDef_var::operator const ::IR::PublishesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::PublishesDef_var::operator ::IR::PublishesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::PublishesDef_ptr &
IR::PublishesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::PublishesDef_ptr &
IR::PublishesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PublishesDef::_nil ();
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::PublishesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::PublishesDef::_nil ();
  return val;
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::tao_duplicate (PublishesDef_ptr p)
{
  return ::IR::PublishesDef::_duplicate (p);
}

void
IR::PublishesDef_var::tao_release (PublishesDef_ptr p)
{
  CORBA::release (p);
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::tao_nil (void)
{
  return ::IR::PublishesDef::_nil ();
}

::IR::PublishesDef_ptr
IR::PublishesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::PublishesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::PublishesDef_var::tao_upcast (void *src)
{
  PublishesDef **tmp =
    ACE_static_cast (PublishesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::PublishesDef_out
// *************************************************************

IR::PublishesDef_out::PublishesDef_out (PublishesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::PublishesDef::_nil ();
}

IR::PublishesDef_out::PublishesDef_out (PublishesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PublishesDef::_nil ();
}

IR::PublishesDef_out::PublishesDef_out (const ::IR::PublishesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PublishesDef_out &, p).ptr_)
{}

::IR::PublishesDef_out &
IR::PublishesDef_out::operator= (const ::IR::PublishesDef_out &p)
{
  this->ptr_ = ACE_const_cast (PublishesDef_out&, p).ptr_;
  return *this;
}

IR::PublishesDef_out &
IR::PublishesDef_out::operator= (const ::IR::PublishesDef_var &p)
{
  this->ptr_ = ::IR::PublishesDef::_duplicate (p.ptr ());
  return *this;
}

IR::PublishesDef_out &
IR::PublishesDef_out::operator= (PublishesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::PublishesDef_out::operator ::IR::PublishesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::PublishesDef_ptr &
IR::PublishesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::PublishesDef_ptr
IR::PublishesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_PublishesDef_Proxy_Impl::_TAO_PublishesDef_Proxy_Impl (void)
{}

IR::_TAO_PublishesDef_Remote_Proxy_Impl::_TAO_PublishesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_PublishesDef_Proxy_Broker::_TAO_PublishesDef_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Proxy_Broker::~_TAO_PublishesDef_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Proxy_Broker * (*IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_PublishesDef_Remote_Proxy_Broker *
IR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_PublishesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_PublishesDef_Remote_Proxy_Broker::_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Remote_Proxy_Broker::~_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PublishesDef_Proxy_Impl&
IR::_TAO_PublishesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::PublishesDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::PublishesDef::PublishesDef (int collocated)
{
  this->IR_PublishesDef_setup_collocation (collocated);
}

// destructor
IR::PublishesDef::~PublishesDef (void)
{}

void
IR::PublishesDef::IR_PublishesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      ::IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      ::IR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker ();

  this->IR_EventDef_setup_collocation (collocated);
}

void IR::PublishesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  PublishesDef *tmp = ACE_static_cast (PublishesDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::PublishesDef_ptr IR::PublishesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return PublishesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PublishesDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (PublishesDef::_nil ());
      if (is_a == 0)
        return PublishesDef::_nil ();
    }
  return PublishesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::PublishesDef_ptr IR::PublishesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return PublishesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      PublishesDef_ptr default_proxy = PublishesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::PublishesDef (
            stub,
            1,
            obj->_servant ()),

          PublishesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::PublishesDef (stub, 0, obj->_servant ()), PublishesDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            PublishesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &PublishesDef::_tao_class_id
                    )
                )
          );
}

IR::PublishesDef_ptr
IR::PublishesDef::_duplicate (PublishesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::PublishesDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::PublishesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, PublishesDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR::EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

static const CORBA::Long _oc_IR_PublishesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x75626c69),
  ACE_NTOHL (0x73686573),
  ACE_NTOHL (0x4465663a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
  13,
  ACE_NTOHL (0x5075626c),
  ACE_NTOHL (0x69736865),
  ACE_NTOHL (0x73446566),
  ACE_NTOHL (0x0),  // name = PublishesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_PublishesDef),
    (char *) &_oc_IR_PublishesDef,
    0,
    sizeof (IR::PublishesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDef, &_tc_TAO_tc_IR_PublishesDef)
TAO_NAMESPACE_END

IR::ConsumesDef_ptr
tao_IR_ConsumesDef_duplicate (
    IR::ConsumesDef_ptr p
  )
{
  return IR::ConsumesDef::_duplicate (p);
}

void
tao_IR_ConsumesDef_release (
    IR::ConsumesDef_ptr p
  )
{
  CORBA::release (p);
}

IR::ConsumesDef_ptr
tao_IR_ConsumesDef_nil (
    void
  )
{
  return IR::ConsumesDef::_nil ();
}

IR::ConsumesDef_ptr
tao_IR_ConsumesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::ConsumesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_ConsumesDef_upcast (
    void *src
  )
{
  IR::ConsumesDef **tmp =
    ACE_static_cast (IR::ConsumesDef **, src);
  return *tmp;
}

int IR::ConsumesDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::ConsumesDef_var
// *************************************************************

IR::ConsumesDef_var::ConsumesDef_var (void) // default constructor
  : ptr_ (ConsumesDef::_nil ())
{}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::ConsumesDef_var::ConsumesDef_var (const ::IR::ConsumesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ConsumesDef::_duplicate (p.ptr ()))
{}

IR::ConsumesDef_var::~ConsumesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ConsumesDef_var &
IR::ConsumesDef_var::operator= (ConsumesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ConsumesDef_var &
IR::ConsumesDef_var::operator= (const ::IR::ConsumesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ConsumesDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ConsumesDef_var::operator const ::IR::ConsumesDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::ConsumesDef_var::operator ::IR::ConsumesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::in (void) const
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr &
IR::ConsumesDef_var::inout (void)
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr &
IR::ConsumesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ConsumesDef::_nil ();
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ConsumesDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::ConsumesDef::_nil ();
  return val;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::tao_duplicate (ConsumesDef_ptr p)
{
  return ::IR::ConsumesDef::_duplicate (p);
}

void
IR::ConsumesDef_var::tao_release (ConsumesDef_ptr p)
{
  CORBA::release (p);
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::tao_nil (void)
{
  return ::IR::ConsumesDef::_nil ();
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::ConsumesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::ConsumesDef_var::tao_upcast (void *src)
{
  ConsumesDef **tmp =
    ACE_static_cast (ConsumesDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ConsumesDef_out
// *************************************************************

IR::ConsumesDef_out::ConsumesDef_out (ConsumesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ConsumesDef::_nil ();
}

IR::ConsumesDef_out::ConsumesDef_out (ConsumesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ConsumesDef::_nil ();
}

IR::ConsumesDef_out::ConsumesDef_out (const ::IR::ConsumesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConsumesDef_out &, p).ptr_)
{}

::IR::ConsumesDef_out &
IR::ConsumesDef_out::operator= (const ::IR::ConsumesDef_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumesDef_out&, p).ptr_;
  return *this;
}

IR::ConsumesDef_out &
IR::ConsumesDef_out::operator= (const ::IR::ConsumesDef_var &p)
{
  this->ptr_ = ::IR::ConsumesDef::_duplicate (p.ptr ());
  return *this;
}

IR::ConsumesDef_out &
IR::ConsumesDef_out::operator= (ConsumesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ConsumesDef_out::operator ::IR::ConsumesDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr &
IR::ConsumesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ConsumesDef_ptr
IR::ConsumesDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_ConsumesDef_Proxy_Impl::_TAO_ConsumesDef_Proxy_Impl (void)
{}

IR::_TAO_ConsumesDef_Remote_Proxy_Impl::_TAO_ConsumesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ConsumesDef_Proxy_Broker::_TAO_ConsumesDef_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Proxy_Broker::~_TAO_ConsumesDef_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Proxy_Broker * (*IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ConsumesDef_Remote_Proxy_Broker *
IR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ConsumesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ConsumesDef_Remote_Proxy_Broker::_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Remote_Proxy_Broker::~_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ConsumesDef_Proxy_Impl&
IR::_TAO_ConsumesDef_Remote_Proxy_Broker::select_proxy (
  ::IR::ConsumesDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ConsumesDef::ConsumesDef (int collocated)
{
  this->IR_ConsumesDef_setup_collocation (collocated);
}

// destructor
IR::ConsumesDef::~ConsumesDef (void)
{}

void
IR::ConsumesDef::IR_ConsumesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      ::IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      ::IR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker ();

  this->IR_EventDef_setup_collocation (collocated);
}

void IR::ConsumesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumesDef *tmp = ACE_static_cast (ConsumesDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::ConsumesDef_ptr IR::ConsumesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ConsumesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConsumesDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ConsumesDef::_nil ());
      if (is_a == 0)
        return ConsumesDef::_nil ();
    }
  return ConsumesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::ConsumesDef_ptr IR::ConsumesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ConsumesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ConsumesDef_ptr default_proxy = ConsumesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ConsumesDef (
            stub,
            1,
            obj->_servant ()),

          ConsumesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ConsumesDef (stub, 0, obj->_servant ()), ConsumesDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            ConsumesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ConsumesDef::_tao_class_id
                    )
                )
          );
}

IR::ConsumesDef_ptr
IR::ConsumesDef::_duplicate (ConsumesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ConsumesDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::ConsumesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ConsumesDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, EventDef)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR::EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

static const CORBA::Long _oc_IR_ConsumesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f43),
  ACE_NTOHL (0x6f6e7375),
  ACE_NTOHL (0x6d657344),
  ACE_NTOHL (0x65663a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
  12,
  ACE_NTOHL (0x436f6e73),
  ACE_NTOHL (0x756d6573),
  ACE_NTOHL (0x44656600),  // name = ConsumesDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_ConsumesDef),
    (char *) &_oc_IR_ConsumesDef,
    0,
    sizeof (IR::ConsumesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDef, &_tc_TAO_tc_IR_ConsumesDef)
TAO_NAMESPACE_END

IR::ComponentDef_ptr
tao_IR_ComponentDef_duplicate (
    IR::ComponentDef_ptr p
  )
{
  return IR::ComponentDef::_duplicate (p);
}

void
tao_IR_ComponentDef_release (
    IR::ComponentDef_ptr p
  )
{
  CORBA::release (p);
}

IR::ComponentDef_ptr
tao_IR_ComponentDef_nil (
    void
  )
{
  return IR::ComponentDef::_nil ();
}

IR::ComponentDef_ptr
tao_IR_ComponentDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::ComponentDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_ComponentDef_upcast (
    void *src
  )
{
  IR::ComponentDef **tmp =
    ACE_static_cast (IR::ComponentDef **, src);
  return *tmp;
}

int IR::ComponentDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::ComponentDef_var
// *************************************************************

IR::ComponentDef_var::ComponentDef_var (void) // default constructor
  : ptr_ (ComponentDef::_nil ())
{}

::IR::ComponentDef_ptr
IR::ComponentDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::ComponentDef_var::ComponentDef_var (const ::IR::ComponentDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentDef::_duplicate (p.ptr ()))
{}

IR::ComponentDef_var::~ComponentDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::ComponentDef_var &
IR::ComponentDef_var::operator= (ComponentDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::ComponentDef_var &
IR::ComponentDef_var::operator= (const ::IR::ComponentDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::ComponentDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::ComponentDef_var::operator const ::IR::ComponentDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::ComponentDef_var::operator ::IR::ComponentDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::in (void) const
{
  return this->ptr_;
}

::IR::ComponentDef_ptr &
IR::ComponentDef_var::inout (void)
{
  return this->ptr_;
}

::IR::ComponentDef_ptr &
IR::ComponentDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentDef::_nil ();
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::ComponentDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::ComponentDef::_nil ();
  return val;
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::tao_duplicate (ComponentDef_ptr p)
{
  return ::IR::ComponentDef::_duplicate (p);
}

void
IR::ComponentDef_var::tao_release (ComponentDef_ptr p)
{
  CORBA::release (p);
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::tao_nil (void)
{
  return ::IR::ComponentDef::_nil ();
}

::IR::ComponentDef_ptr
IR::ComponentDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::ComponentDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::ComponentDef_var::tao_upcast (void *src)
{
  ComponentDef **tmp =
    ACE_static_cast (ComponentDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::ComponentDef_out
// *************************************************************

IR::ComponentDef_out::ComponentDef_out (ComponentDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::ComponentDef::_nil ();
}

IR::ComponentDef_out::ComponentDef_out (ComponentDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::ComponentDef::_nil ();
}

IR::ComponentDef_out::ComponentDef_out (const ::IR::ComponentDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentDef_out &, p).ptr_)
{}

::IR::ComponentDef_out &
IR::ComponentDef_out::operator= (const ::IR::ComponentDef_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentDef_out&, p).ptr_;
  return *this;
}

IR::ComponentDef_out &
IR::ComponentDef_out::operator= (const ::IR::ComponentDef_var &p)
{
  this->ptr_ = ::IR::ComponentDef::_duplicate (p.ptr ());
  return *this;
}

IR::ComponentDef_out &
IR::ComponentDef_out::operator= (ComponentDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::ComponentDef_out::operator ::IR::ComponentDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::ComponentDef_ptr &
IR::ComponentDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::ComponentDef_ptr
IR::ComponentDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get &);

  CORBA_InterfaceDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA_InterfaceDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA_InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set &);

  const CORBA_InterfaceDefSeq & supported_interfaces_;

};

TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA_InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

class TAO_ClientRequestInfo_IR_ComponentDef_base_component_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (const TAO_ClientRequestInfo_IR_ComponentDef_base_component_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_base_component_get &);

  IR::ComponentDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (IR::ComponentDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (const TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get &);

  IR::ProvidesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR::ProvidesDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (const TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get &);

  IR::UsesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR::UsesDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (const TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get &);

  IR::EmitsDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (IR::EmitsDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (const TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get &);

  IR::PublishesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (IR::PublishesDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (const TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get &);

  IR::ConsumesDefSeq * _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (IR::ConsumesDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (const TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get &);

  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_provides : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_provides (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_provides (const TAO_ClientRequestInfo_IR_ComponentDef_create_provides &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_provides &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  IR::ProvidesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_provides::TAO_ClientRequestInfo_IR_ComponentDef_create_provides (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (IR::ProvidesDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_uses : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_uses (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_InterfaceDef_ptr interface_type,
      const CORBA::Boolean & is_multiple
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_uses (const TAO_ClientRequestInfo_IR_ComponentDef_create_uses &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_uses &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  const CORBA::Boolean & is_multiple_;
  IR::UsesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_uses::TAO_ClientRequestInfo_IR_ComponentDef_create_uses (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type),
    is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (IR::UsesDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_emits : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_emits (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_emits (const TAO_ClientRequestInfo_IR_ComponentDef_create_emits &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_emits &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::EmitsDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_emits::TAO_ClientRequestInfo_IR_ComponentDef_create_emits (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (IR::EmitsDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_publishes : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (const TAO_ClientRequestInfo_IR_ComponentDef_create_publishes &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_publishes &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::PublishesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (IR::PublishesDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_ComponentDef_create_consumes : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (const TAO_ClientRequestInfo_IR_ComponentDef_create_consumes &);
  void operator= (const TAO_ClientRequestInfo_IR_ComponentDef_create_consumes &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::ConsumesDef_ptr _result;
};

TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (IR::ConsumesDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_ComponentDef_Proxy_Impl::_TAO_ComponentDef_Proxy_Impl (void)
{}

IR::_TAO_ComponentDef_Remote_Proxy_Impl::_TAO_ComponentDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA_InterfaceDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, CORBA_InterfaceDefSeq, _tao_retval);
  CORBA_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

void IR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
        &_tao_call,
        _collocated_tao_target_,
        supported_interfaces
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << supported_interfaces)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }


#if TAO_HAS_INTERCEPTORS == 1

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }

}

IR::ComponentDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_component",
      19,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_base_component_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::ProvidesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ProvidesDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::ProvidesDefSeq, _tao_retval);
  IR::ProvidesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_provides_interfaces",
      24,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ProvidesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::UsesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::UsesDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::UsesDefSeq, _tao_retval);
  IR::UsesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_uses_interfaces",
      20,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::UsesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::EmitsDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::EmitsDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::EmitsDefSeq, _tao_retval);
  IR::EmitsDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_emits_events",
      17,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::EmitsDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::PublishesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::PublishesDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::PublishesDefSeq, _tao_retval);
  IR::PublishesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_publishes_events",
      21,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::PublishesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::ConsumesDefSeq * IR::_TAO_ComponentDef_Remote_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ConsumesDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::ConsumesDefSeq, _tao_retval);
  IR::ConsumesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_consumes_events",
      20,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ConsumesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::_TAO_ComponentDef_Remote_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

IR::ProvidesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ProvidesDef_ptr _tao_retval = IR::ProvidesDef::_nil ();
  IR::ProvidesDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_provides",
      15,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_provides ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        interface_type
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ProvidesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::UsesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::UsesDef_ptr _tao_retval = IR::UsesDef::_nil ();
  IR::UsesDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_uses",
      11,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_uses ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        interface_type,
        is_multiple
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type) &&
              (_tao_out << CORBA::Any::from_boolean (is_multiple))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::UsesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::EmitsDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::EmitsDef_ptr _tao_retval = IR::EmitsDef::_nil ();
  IR::EmitsDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_emits",
      12,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_emits ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::EmitsDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::PublishesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::PublishesDef_ptr _tao_retval = IR::PublishesDef::_nil ();
  IR::PublishesDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_publishes",
      16,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_publishes ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::PublishesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::ConsumesDef_ptr IR::_TAO_ComponentDef_Remote_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ConsumesDef_ptr _tao_retval = IR::ConsumesDef::_nil ();
  IR::ConsumesDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_consumes",
      15,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_ComponentDef_create_consumes ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ConsumesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_ComponentDef_Proxy_Broker::_TAO_ComponentDef_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Proxy_Broker::~_TAO_ComponentDef_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Proxy_Broker * (*IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_ComponentDef_Remote_Proxy_Broker *
IR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_ComponentDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_ComponentDef_Remote_Proxy_Broker::_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Remote_Proxy_Broker::~_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_ComponentDef_Proxy_Impl&
IR::_TAO_ComponentDef_Remote_Proxy_Broker::select_proxy (
  ::IR::ComponentDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::ComponentDef::ComponentDef (int collocated)
{
  this->IR_ComponentDef_setup_collocation (collocated);
}

// destructor
IR::ComponentDef::~ComponentDef (void)
{}

void
IR::ComponentDef::IR_ComponentDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      ::IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      ::IR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker ();

  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void IR::ComponentDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentDef *tmp = ACE_static_cast (ComponentDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::ComponentDef_ptr IR::ComponentDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ComponentDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ComponentDef::_nil ());
      if (is_a == 0)
        return ComponentDef::_nil ();
    }
  return ComponentDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::ComponentDef_ptr IR::ComponentDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ComponentDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ComponentDef_ptr default_proxy = ComponentDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::ComponentDef (
            stub,
            1,
            obj->_servant ()),

          ComponentDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::ComponentDef (stub, 0, obj->_servant ()), ComponentDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            ComponentDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ComponentDef::_tao_class_id
                    )
                )
          );
}

IR::ComponentDef_ptr
IR::ComponentDef::_duplicate (ComponentDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::ComponentDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::ComponentDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, ComponentDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

CORBA_InterfaceDefSeq * IR::ComponentDef::supported_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.supported_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

void IR::ComponentDef::supported_interfaces (
    const CORBA_InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  proxy.supported_interfaces (
      this,
      supported_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

IR::ComponentDef_ptr IR::ComponentDef::base_component (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.base_component (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::ProvidesDefSeq * IR::ComponentDef::provides_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.provides_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::UsesDefSeq * IR::ComponentDef::uses_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.uses_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::EmitsDefSeq * IR::ComponentDef::emits_events (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.emits_events (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::PublishesDefSeq * IR::ComponentDef::publishes_events (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.publishes_events (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::ConsumesDefSeq * IR::ComponentDef::consumes_events (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.consumes_events (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::Boolean IR::ComponentDef::is_basic (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.is_basic (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::ProvidesDef_ptr IR::ComponentDef::create_provides (
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_provides (
      this,
      id,
      name,
      version,
      interface_type
      ACE_ENV_ARG_PARAMETER
    );
}

IR::UsesDef_ptr IR::ComponentDef::create_uses (
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_uses (
      this,
      id,
      name,
      version,
      interface_type,
      is_multiple
      ACE_ENV_ARG_PARAMETER
    );
}

IR::EmitsDef_ptr IR::ComponentDef::create_emits (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_emits (
      this,
      id,
      name,
      version,
      value
      ACE_ENV_ARG_PARAMETER
    );
}

IR::PublishesDef_ptr IR::ComponentDef::create_publishes (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_publishes (
      this,
      id,
      name,
      version,
      value
      ACE_ENV_ARG_PARAMETER
    );
}

IR::ConsumesDef_ptr IR::ComponentDef::create_consumes (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy =
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_consumes (
      this,
      id,
      name,
      version,
      value
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_ComponentDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f43),
  ACE_NTOHL (0x6f6d706f),
  ACE_NTOHL (0x6e656e74),
  ACE_NTOHL (0x4465663a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
  13,
  ACE_NTOHL (0x436f6d70),
  ACE_NTOHL (0x6f6e656e),
  ACE_NTOHL (0x74446566),
  ACE_NTOHL (0x0),  // name = ComponentDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_ComponentDef),
    (char *) &_oc_IR_ComponentDef,
    0,
    sizeof (IR::ComponentDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDef, &_tc_TAO_tc_IR_ComponentDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ComponentDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f43),
  ACE_NTOHL (0x6f6d706f),
  ACE_NTOHL (0x6e656e74),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x72697074),
  ACE_NTOHL (0x696f6e3a),
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDescription:1.0
  21,
  ACE_NTOHL (0x436f6d70),
  ACE_NTOHL (0x6f6e656e),
  ACE_NTOHL (0x74446573),
  ACE_NTOHL (0x63726970),
  ACE_NTOHL (0x74696f6e),
  ACE_NTOHL (0x0),  // name = ComponentDescription
  13, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f49),
    ACE_NTOHL (0x64656e74),
    ACE_NTOHL (0x69666965),
    ACE_NTOHL (0x723a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f56),
    ACE_NTOHL (0x65727369),
    ACE_NTOHL (0x6f6e5370),
    ACE_NTOHL (0x65633a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  15,
  ACE_NTOHL (0x62617365),
  ACE_NTOHL (0x5f636f6d),
  ACE_NTOHL (0x706f6e65),
  ACE_NTOHL (0x6e740000),  // name = base_component
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  20,
  ACE_NTOHL (0x73757070),
  ACE_NTOHL (0x6f727473),
  ACE_NTOHL (0x5f696e74),
  ACE_NTOHL (0x65726661),
  ACE_NTOHL (0x63657300),  // name = supports_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x79496453),
    ACE_NTOHL (0x65713a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f52),
        ACE_NTOHL (0x65706f73),
        ACE_NTOHL (0x69746f72),
        ACE_NTOHL (0x7949643a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13,
        ACE_NTOHL (0x5265706f),
        ACE_NTOHL (0x7369746f),
        ACE_NTOHL (0x72794964),
        ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  20,
  ACE_NTOHL (0x70726f76),
  ACE_NTOHL (0x69646573),
  ACE_NTOHL (0x5f696e74),
  ACE_NTOHL (0x65726661),
  ACE_NTOHL (0x63657300),  // name = provides_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f50),
    ACE_NTOHL (0x726f7669),
    ACE_NTOHL (0x64657344),
    ACE_NTOHL (0x65665365),
    ACE_NTOHL (0x713a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
    15,
    ACE_NTOHL (0x50726f76),
    ACE_NTOHL (0x69646573),
    ACE_NTOHL (0x44656653),
    ACE_NTOHL (0x65710000),  // name = ProvidesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f50),
        ACE_NTOHL (0x726f7669),
        ACE_NTOHL (0x64657344),
        ACE_NTOHL (0x65663a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
        12,
        ACE_NTOHL (0x50726f76),
        ACE_NTOHL (0x69646573),
        ACE_NTOHL (0x44656600),  // name = ProvidesDef

      0U,


  16,
  ACE_NTOHL (0x75736573),
  ACE_NTOHL (0x5f696e74),
  ACE_NTOHL (0x65726661),
  ACE_NTOHL (0x63657300),  // name = uses_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  128, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f55),
    ACE_NTOHL (0x73657344),
    ACE_NTOHL (0x65665365),
    ACE_NTOHL (0x713a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
    11,
    ACE_NTOHL (0x55736573),
    ACE_NTOHL (0x44656653),
    ACE_NTOHL (0x65710000),  // name = UsesDefSeq
    CORBA::tk_sequence, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f55),
        ACE_NTOHL (0x73657344),
        ACE_NTOHL (0x65663a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
        8,
        ACE_NTOHL (0x55736573),
        ACE_NTOHL (0x44656600),  // name = UsesDef

      0U,


  11,
  ACE_NTOHL (0x61747472),
  ACE_NTOHL (0x69627574),
  ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  1852, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4174),
    ACE_NTOHL (0x74724465),
    ACE_NTOHL (0x73637269),
    ACE_NTOHL (0x7074696f),
    ACE_NTOHL (0x6e536571),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19,
    ACE_NTOHL (0x41747472),
    ACE_NTOHL (0x44657363),
    ACE_NTOHL (0x72697074),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1768, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1752, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f4174),
        ACE_NTOHL (0x74726962),
        ACE_NTOHL (0x75746544),
        ACE_NTOHL (0x65736372),
        ACE_NTOHL (0x69707469),
        ACE_NTOHL (0x6f6e3a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21,
        ACE_NTOHL (0x41747472),
        ACE_NTOHL (0x69627574),
        ACE_NTOHL (0x65446573),
        ACE_NTOHL (0x63726970),
        ACE_NTOHL (0x74696f6e),
        ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5,
        ACE_NTOHL (0x6e616d65),
        ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4964),
          ACE_NTOHL (0x656e7469),
          ACE_NTOHL (0x66696572),
          ACE_NTOHL (0x3a312e30),
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11,
          ACE_NTOHL (0x4964656e),
          ACE_NTOHL (0x74696669),
          ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

        11,
        ACE_NTOHL (0x64656669),
        ACE_NTOHL (0x6e65645f),
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

        8,
        ACE_NTOHL (0x76657273),
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5665),
          ACE_NTOHL (0x7273696f),
          ACE_NTOHL (0x6e537065),
          ACE_NTOHL (0x633a312e),
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12,
          ACE_NTOHL (0x56657273),
          ACE_NTOHL (0x696f6e53),
          ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

        5,
        ACE_NTOHL (0x74797065),
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465),
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4174),
          ACE_NTOHL (0x74726962),
          ACE_NTOHL (0x7574654d),
          ACE_NTOHL (0x6f64653a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472),
          ACE_NTOHL (0x69627574),
          ACE_NTOHL (0x654d6f64),
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452),
          ACE_NTOHL (0x5f4e4f52),
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452),
          ACE_NTOHL (0x5f524541),
          ACE_NTOHL (0x444f4e4c),
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15,
        ACE_NTOHL (0x6765745f),
        ACE_NTOHL (0x65786365),
        ACE_NTOHL (0x7074696f),
        ACE_NTOHL (0x6e730000),  // name = get_exceptions
  CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          40,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4578),
          ACE_NTOHL (0x63446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x45786344),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
              43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f4578),
              ACE_NTOHL (0x63657074),
              ACE_NTOHL (0x696f6e44),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21,
              ACE_NTOHL (0x45786365),
              ACE_NTOHL (0x7074696f),
              ACE_NTOHL (0x6e446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
                33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
                35,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              11,
              ACE_NTOHL (0x64656669),
              ACE_NTOHL (0x6e65645f),
              ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              8,
              ACE_NTOHL (0x76657273),
              ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5665),
                ACE_NTOHL (0x7273696f),
                ACE_NTOHL (0x6e537065),
                ACE_NTOHL (0x633a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
                ACE_NTOHL (0x56657273),
                ACE_NTOHL (0x696f6e53),
                ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string,
                0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15,
        ACE_NTOHL (0x7075745f),
        ACE_NTOHL (0x65786365),
        ACE_NTOHL (0x7074696f),
        ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4578),
          ACE_NTOHL (0x63446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x45786344),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f4578),
              ACE_NTOHL (0x63657074),
              ACE_NTOHL (0x696f6e44),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21,
              ACE_NTOHL (0x45786365),
              ACE_NTOHL (0x7074696f),
              ACE_NTOHL (0x6e446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              11,
              ACE_NTOHL (0x64656669),
              ACE_NTOHL (0x6e65645f),
              ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              8,
              ACE_NTOHL (0x76657273),
              ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5665),
                ACE_NTOHL (0x7273696f),
                ACE_NTOHL (0x6e537065),
                ACE_NTOHL (0x633a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
                ACE_NTOHL (0x56657273),
                ACE_NTOHL (0x696f6e53),
                ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string,
                0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  13,
  ACE_NTOHL (0x656d6974),
  ACE_NTOHL (0x735f6576),
  ACE_NTOHL (0x656e7473),
  ACE_NTOHL (0x0),  // name = emits_events
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f45),
    ACE_NTOHL (0x6d697473),
    ACE_NTOHL (0x44656653),
    ACE_NTOHL (0x65713a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
    12,
    ACE_NTOHL (0x456d6974),
    ACE_NTOHL (0x73446566),
    ACE_NTOHL (0x53657100),  // name = EmitsDefSeq
    CORBA::tk_sequence, // typecode kind
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        28,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f45),
        ACE_NTOHL (0x6d697473),
        ACE_NTOHL (0x4465663a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
        9,
        ACE_NTOHL (0x456d6974),
        ACE_NTOHL (0x73446566),
        ACE_NTOHL (0x0),  // name = EmitsDef

      0U,


  17,
  ACE_NTOHL (0x7075626c),
  ACE_NTOHL (0x69736865),
  ACE_NTOHL (0x735f6576),
  ACE_NTOHL (0x656e7473),
  ACE_NTOHL (0x0),  // name = publishes_events
  CORBA::tk_alias, // typecode kind for typedefs
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f50),
    ACE_NTOHL (0x75626c69),
    ACE_NTOHL (0x73686573),
    ACE_NTOHL (0x44656653),
    ACE_NTOHL (0x65713a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
    16,
    ACE_NTOHL (0x5075626c),
    ACE_NTOHL (0x69736865),
    ACE_NTOHL (0x73446566),
    ACE_NTOHL (0x53657100),  // name = PublishesDefSeq
    CORBA::tk_sequence, // typecode kind
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f50),
        ACE_NTOHL (0x75626c69),
        ACE_NTOHL (0x73686573),
        ACE_NTOHL (0x4465663a),
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
        13,
        ACE_NTOHL (0x5075626c),
        ACE_NTOHL (0x69736865),
        ACE_NTOHL (0x73446566),
        ACE_NTOHL (0x0),  // name = PublishesDef

      0U,


  16,
  ACE_NTOHL (0x636f6e73),
  ACE_NTOHL (0x756d6573),
  ACE_NTOHL (0x5f657665),
  ACE_NTOHL (0x6e747300),  // name = consumes_events
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f43),
    ACE_NTOHL (0x6f6e7375),
    ACE_NTOHL (0x6d657344),
    ACE_NTOHL (0x65665365),
    ACE_NTOHL (0x713a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
    15,
    ACE_NTOHL (0x436f6e73),
    ACE_NTOHL (0x756d6573),
    ACE_NTOHL (0x44656653),
    ACE_NTOHL (0x65710000),  // name = ConsumesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f43),
        ACE_NTOHL (0x6f6e7375),
        ACE_NTOHL (0x6d657344),
        ACE_NTOHL (0x65663a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
        12,
        ACE_NTOHL (0x436f6e73),
        ACE_NTOHL (0x756d6573),
        ACE_NTOHL (0x44656600),  // name = ConsumesDef

      0U,


  9,
  ACE_NTOHL (0x69735f62),
  ACE_NTOHL (0x61736963),
  ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_ComponentDescription),
    (char *) &_oc_IR_ComponentDescription,
    0,
    sizeof (IR::ComponentDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDescription, &_tc_TAO_tc_IR_ComponentDescription)
TAO_NAMESPACE_END

void IR::ComponentDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentDescription *tmp = ACE_static_cast (ComponentDescription*, _tao_void_pointer);
  delete tmp;
}

IR::PrimaryKeyDef_ptr
tao_IR_PrimaryKeyDef_duplicate (
    IR::PrimaryKeyDef_ptr p
  )
{
  return IR::PrimaryKeyDef::_duplicate (p);
}

void
tao_IR_PrimaryKeyDef_release (
    IR::PrimaryKeyDef_ptr p
  )
{
  CORBA::release (p);
}

IR::PrimaryKeyDef_ptr
tao_IR_PrimaryKeyDef_nil (
    void
  )
{
  return IR::PrimaryKeyDef::_nil ();
}

IR::PrimaryKeyDef_ptr
tao_IR_PrimaryKeyDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::PrimaryKeyDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_PrimaryKeyDef_upcast (
    void *src
  )
{
  IR::PrimaryKeyDef **tmp =
    ACE_static_cast (IR::PrimaryKeyDef **, src);
  return *tmp;
}

int IR::PrimaryKeyDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::PrimaryKeyDef_var
// *************************************************************

IR::PrimaryKeyDef_var::PrimaryKeyDef_var (void) // default constructor
  : ptr_ (PrimaryKeyDef::_nil ())
{}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::PrimaryKeyDef_var::PrimaryKeyDef_var (const ::IR::PrimaryKeyDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (PrimaryKeyDef::_duplicate (p.ptr ()))
{}

IR::PrimaryKeyDef_var::~PrimaryKeyDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::PrimaryKeyDef_var &
IR::PrimaryKeyDef_var::operator= (PrimaryKeyDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::PrimaryKeyDef_var &
IR::PrimaryKeyDef_var::operator= (const ::IR::PrimaryKeyDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::PrimaryKeyDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::PrimaryKeyDef_var::operator const ::IR::PrimaryKeyDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::PrimaryKeyDef_var::operator ::IR::PrimaryKeyDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::in (void) const
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr &
IR::PrimaryKeyDef_var::inout (void)
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr &
IR::PrimaryKeyDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::PrimaryKeyDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
  return val;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::tao_duplicate (PrimaryKeyDef_ptr p)
{
  return ::IR::PrimaryKeyDef::_duplicate (p);
}

void
IR::PrimaryKeyDef_var::tao_release (PrimaryKeyDef_ptr p)
{
  CORBA::release (p);
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::tao_nil (void)
{
  return ::IR::PrimaryKeyDef::_nil ();
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::PrimaryKeyDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::PrimaryKeyDef_var::tao_upcast (void *src)
{
  PrimaryKeyDef **tmp =
    ACE_static_cast (PrimaryKeyDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::PrimaryKeyDef_out
// *************************************************************

IR::PrimaryKeyDef_out::PrimaryKeyDef_out (PrimaryKeyDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
}

IR::PrimaryKeyDef_out::PrimaryKeyDef_out (PrimaryKeyDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::PrimaryKeyDef::_nil ();
}

IR::PrimaryKeyDef_out::PrimaryKeyDef_out (const ::IR::PrimaryKeyDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PrimaryKeyDef_out &, p).ptr_)
{}

::IR::PrimaryKeyDef_out &
IR::PrimaryKeyDef_out::operator= (const ::IR::PrimaryKeyDef_out &p)
{
  this->ptr_ = ACE_const_cast (PrimaryKeyDef_out&, p).ptr_;
  return *this;
}

IR::PrimaryKeyDef_out &
IR::PrimaryKeyDef_out::operator= (const ::IR::PrimaryKeyDef_var &p)
{
  this->ptr_ = ::IR::PrimaryKeyDef::_duplicate (p.ptr ());
  return *this;
}

IR::PrimaryKeyDef_out &
IR::PrimaryKeyDef_out::operator= (PrimaryKeyDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::PrimaryKeyDef_out::operator ::IR::PrimaryKeyDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr &
IR::PrimaryKeyDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * primary_key_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a &);
  void operator= (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a &);

  const char * primary_key_id_;
  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * primary_key_id
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    primary_key_id_ (primary_key_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= primary_key_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get &);
  void operator= (const TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get &);

  CORBA_ValueDef_ptr _result;
};

TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA_ValueDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_PrimaryKeyDef_Proxy_Impl::_TAO_PrimaryKeyDef_Proxy_Impl (void)
{}

IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Boolean IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        primary_key_id
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << primary_key_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

CORBA_ValueDef_ptr IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueDef_ptr _tao_retval = CORBA_ValueDef::_nil ();
  CORBA_ValueDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_PrimaryKeyDef_Proxy_Broker::_TAO_PrimaryKeyDef_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Proxy_Broker::~_TAO_PrimaryKeyDef_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Proxy_Broker * (*IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker *
IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_PrimaryKeyDef_Proxy_Impl&
IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::select_proxy (
  ::IR::PrimaryKeyDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::PrimaryKeyDef::PrimaryKeyDef (int collocated)
{
  this->IR_PrimaryKeyDef_setup_collocation (collocated);
}

// destructor
IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{}

void
IR::PrimaryKeyDef::IR_PrimaryKeyDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
      ::IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
      ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker ();

  this->CORBA_Contained_setup_collocation (collocated);
}

void IR::PrimaryKeyDef::_tao_any_destructor (void *_tao_void_pointer)
{
  PrimaryKeyDef *tmp = ACE_static_cast (PrimaryKeyDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return PrimaryKeyDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimaryKeyDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (PrimaryKeyDef::_nil ());
      if (is_a == 0)
        return PrimaryKeyDef::_nil ();
    }
  return PrimaryKeyDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::PrimaryKeyDef_ptr IR::PrimaryKeyDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return PrimaryKeyDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      PrimaryKeyDef_ptr default_proxy = PrimaryKeyDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::PrimaryKeyDef (
            stub,
            1,
            obj->_servant ()),

          PrimaryKeyDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::PrimaryKeyDef (stub, 0, obj->_servant ()), PrimaryKeyDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            PrimaryKeyDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &PrimaryKeyDef::_tao_class_id
                    )
                )
          );
}

IR::PrimaryKeyDef_ptr
IR::PrimaryKeyDef::_duplicate (PrimaryKeyDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::PrimaryKeyDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::PrimaryKeyDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, PrimaryKeyDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

CORBA::Boolean IR::PrimaryKeyDef::is_a (
    const char * primary_key_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_PrimaryKeyDef_Proxy_Impl &proxy =
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.is_a (
      this,
      primary_key_id
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA_ValueDef_ptr IR::PrimaryKeyDef::primary_key (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_PrimaryKeyDef_Proxy_Impl &proxy =
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.primary_key (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_PrimaryKeyDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x72696d61),
  ACE_NTOHL (0x72794b65),
  ACE_NTOHL (0x79446566),
  ACE_NTOHL (0x3a312e30),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
  14,
  ACE_NTOHL (0x5072696d),
  ACE_NTOHL (0x6172794b),
  ACE_NTOHL (0x65794465),
  ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_PrimaryKeyDef),
    (char *) &_oc_IR_PrimaryKeyDef,
    0,
    sizeof (IR::PrimaryKeyDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDef, &_tc_TAO_tc_IR_PrimaryKeyDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_PrimaryKeyDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f50),
  ACE_NTOHL (0x72696d61),
  ACE_NTOHL (0x72794b65),
  ACE_NTOHL (0x79446573),
  ACE_NTOHL (0x63726970),
  ACE_NTOHL (0x74696f6e),
  ACE_NTOHL (0x3a312e30),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDescription:1.0
  22,
  ACE_NTOHL (0x5072696d),
  ACE_NTOHL (0x6172794b),
  ACE_NTOHL (0x65794465),
  ACE_NTOHL (0x73637269),
  ACE_NTOHL (0x7074696f),
  ACE_NTOHL (0x6e000000),  // name = PrimaryKeyDescription
  5, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f49),
    ACE_NTOHL (0x64656e74),
    ACE_NTOHL (0x69666965),
    ACE_NTOHL (0x723a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f56),
    ACE_NTOHL (0x65727369),
    ACE_NTOHL (0x6f6e5370),
    ACE_NTOHL (0x65633a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  12,
  ACE_NTOHL (0x7072696d),
  ACE_NTOHL (0x6172795f),
  ACE_NTOHL (0x6b657900),  // name = primary_key
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f5661),
    ACE_NTOHL (0x6c756544),
    ACE_NTOHL (0x65663a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
    9,
    ACE_NTOHL (0x56616c75),
    ACE_NTOHL (0x65446566),
    ACE_NTOHL (0x0),  // name = ValueDef

};

static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_PrimaryKeyDescription),
    (char *) &_oc_IR_PrimaryKeyDescription,
    0,
    sizeof (IR::PrimaryKeyDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDescription, &_tc_TAO_tc_IR_PrimaryKeyDescription)
TAO_NAMESPACE_END

void IR::PrimaryKeyDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  PrimaryKeyDescription *tmp = ACE_static_cast (PrimaryKeyDescription*, _tao_void_pointer);
  delete tmp;
}

IR::FactoryDef_ptr
tao_IR_FactoryDef_duplicate (
    IR::FactoryDef_ptr p
  )
{
  return IR::FactoryDef::_duplicate (p);
}

void
tao_IR_FactoryDef_release (
    IR::FactoryDef_ptr p
  )
{
  CORBA::release (p);
}

IR::FactoryDef_ptr
tao_IR_FactoryDef_nil (
    void
  )
{
  return IR::FactoryDef::_nil ();
}

IR::FactoryDef_ptr
tao_IR_FactoryDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::FactoryDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_FactoryDef_upcast (
    void *src
  )
{
  IR::FactoryDef **tmp =
    ACE_static_cast (IR::FactoryDef **, src);
  return *tmp;
}

int IR::FactoryDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::FactoryDef_var
// *************************************************************

IR::FactoryDef_var::FactoryDef_var (void) // default constructor
  : ptr_ (FactoryDef::_nil ())
{}

::IR::FactoryDef_ptr
IR::FactoryDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::FactoryDef_var::FactoryDef_var (const ::IR::FactoryDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (FactoryDef::_duplicate (p.ptr ()))
{}

IR::FactoryDef_var::~FactoryDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::FactoryDef_var &
IR::FactoryDef_var::operator= (FactoryDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::FactoryDef_var &
IR::FactoryDef_var::operator= (const ::IR::FactoryDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::FactoryDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::FactoryDef_var::operator const ::IR::FactoryDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::FactoryDef_var::operator ::IR::FactoryDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::in (void) const
{
  return this->ptr_;
}

::IR::FactoryDef_ptr &
IR::FactoryDef_var::inout (void)
{
  return this->ptr_;
}

::IR::FactoryDef_ptr &
IR::FactoryDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FactoryDef::_nil ();
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::FactoryDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::FactoryDef::_nil ();
  return val;
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::tao_duplicate (FactoryDef_ptr p)
{
  return ::IR::FactoryDef::_duplicate (p);
}

void
IR::FactoryDef_var::tao_release (FactoryDef_ptr p)
{
  CORBA::release (p);
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::tao_nil (void)
{
  return ::IR::FactoryDef::_nil ();
}

::IR::FactoryDef_ptr
IR::FactoryDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::FactoryDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::FactoryDef_var::tao_upcast (void *src)
{
  FactoryDef **tmp =
    ACE_static_cast (FactoryDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::FactoryDef_out
// *************************************************************

IR::FactoryDef_out::FactoryDef_out (FactoryDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::FactoryDef::_nil ();
}

IR::FactoryDef_out::FactoryDef_out (FactoryDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FactoryDef::_nil ();
}

IR::FactoryDef_out::FactoryDef_out (const ::IR::FactoryDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FactoryDef_out &, p).ptr_)
{}

::IR::FactoryDef_out &
IR::FactoryDef_out::operator= (const ::IR::FactoryDef_out &p)
{
  this->ptr_ = ACE_const_cast (FactoryDef_out&, p).ptr_;
  return *this;
}

IR::FactoryDef_out &
IR::FactoryDef_out::operator= (const ::IR::FactoryDef_var &p)
{
  this->ptr_ = ::IR::FactoryDef::_duplicate (p.ptr ());
  return *this;
}

IR::FactoryDef_out &
IR::FactoryDef_out::operator= (FactoryDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::FactoryDef_out::operator ::IR::FactoryDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::FactoryDef_ptr &
IR::FactoryDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::FactoryDef_ptr
IR::FactoryDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_FactoryDef_Proxy_Impl::_TAO_FactoryDef_Proxy_Impl (void)
{}

IR::_TAO_FactoryDef_Remote_Proxy_Impl::_TAO_FactoryDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_FactoryDef_Proxy_Broker::_TAO_FactoryDef_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Proxy_Broker::~_TAO_FactoryDef_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Proxy_Broker * (*IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_FactoryDef_Remote_Proxy_Broker *
IR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_FactoryDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_FactoryDef_Remote_Proxy_Broker::_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Remote_Proxy_Broker::~_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FactoryDef_Proxy_Impl&
IR::_TAO_FactoryDef_Remote_Proxy_Broker::select_proxy (
  ::IR::FactoryDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::FactoryDef::FactoryDef (int collocated)
{
  this->IR_FactoryDef_setup_collocation (collocated);
}

// destructor
IR::FactoryDef::~FactoryDef (void)
{}

void
IR::FactoryDef::IR_FactoryDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      ::IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      ::IR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker ();

  this->CORBA_OperationDef_setup_collocation (collocated);
}

void IR::FactoryDef::_tao_any_destructor (void *_tao_void_pointer)
{
  FactoryDef *tmp = ACE_static_cast (FactoryDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::FactoryDef_ptr IR::FactoryDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return FactoryDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FactoryDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (FactoryDef::_nil ());
      if (is_a == 0)
        return FactoryDef::_nil ();
    }
  return FactoryDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::FactoryDef_ptr IR::FactoryDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return FactoryDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FactoryDef_ptr default_proxy = FactoryDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::FactoryDef (
            stub,
            1,
            obj->_servant ()),

          FactoryDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::FactoryDef (stub, 0, obj->_servant ()), FactoryDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            FactoryDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &FactoryDef::_tao_class_id
                    )
                )
          );
}

IR::FactoryDef_ptr
IR::FactoryDef::_duplicate (FactoryDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::FactoryDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::FactoryDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, FactoryDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_OperationDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_OperationDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

static const CORBA::Long _oc_IR_FactoryDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f46),
  ACE_NTOHL (0x6163746f),
  ACE_NTOHL (0x72794465),
  ACE_NTOHL (0x663a312e),
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
  11,
  ACE_NTOHL (0x46616374),
  ACE_NTOHL (0x6f727944),
  ACE_NTOHL (0x65660000),  // name = FactoryDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_FactoryDef),
    (char *) &_oc_IR_FactoryDef,
    0,
    sizeof (IR::FactoryDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDef, &_tc_TAO_tc_IR_FactoryDef)
TAO_NAMESPACE_END

IR::FinderDef_ptr
tao_IR_FinderDef_duplicate (
    IR::FinderDef_ptr p
  )
{
  return IR::FinderDef::_duplicate (p);
}

void
tao_IR_FinderDef_release (
    IR::FinderDef_ptr p
  )
{
  CORBA::release (p);
}

IR::FinderDef_ptr
tao_IR_FinderDef_nil (
    void
  )
{
  return IR::FinderDef::_nil ();
}

IR::FinderDef_ptr
tao_IR_FinderDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::FinderDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_FinderDef_upcast (
    void *src
  )
{
  IR::FinderDef **tmp =
    ACE_static_cast (IR::FinderDef **, src);
  return *tmp;
}

int IR::FinderDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::FinderDef_var
// *************************************************************

IR::FinderDef_var::FinderDef_var (void) // default constructor
  : ptr_ (FinderDef::_nil ())
{}

::IR::FinderDef_ptr
IR::FinderDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::FinderDef_var::FinderDef_var (const ::IR::FinderDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (FinderDef::_duplicate (p.ptr ()))
{}

IR::FinderDef_var::~FinderDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::FinderDef_var &
IR::FinderDef_var::operator= (FinderDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::FinderDef_var &
IR::FinderDef_var::operator= (const ::IR::FinderDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::FinderDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::FinderDef_var::operator const ::IR::FinderDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::FinderDef_var::operator ::IR::FinderDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_var::in (void) const
{
  return this->ptr_;
}

::IR::FinderDef_ptr &
IR::FinderDef_var::inout (void)
{
  return this->ptr_;
}

::IR::FinderDef_ptr &
IR::FinderDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FinderDef::_nil ();
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::FinderDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::FinderDef::_nil ();
  return val;
}

::IR::FinderDef_ptr
IR::FinderDef_var::tao_duplicate (FinderDef_ptr p)
{
  return ::IR::FinderDef::_duplicate (p);
}

void
IR::FinderDef_var::tao_release (FinderDef_ptr p)
{
  CORBA::release (p);
}

::IR::FinderDef_ptr
IR::FinderDef_var::tao_nil (void)
{
  return ::IR::FinderDef::_nil ();
}

::IR::FinderDef_ptr
IR::FinderDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::FinderDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::FinderDef_var::tao_upcast (void *src)
{
  FinderDef **tmp =
    ACE_static_cast (FinderDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::FinderDef_out
// *************************************************************

IR::FinderDef_out::FinderDef_out (FinderDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::FinderDef::_nil ();
}

IR::FinderDef_out::FinderDef_out (FinderDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::FinderDef::_nil ();
}

IR::FinderDef_out::FinderDef_out (const ::IR::FinderDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FinderDef_out &, p).ptr_)
{}

::IR::FinderDef_out &
IR::FinderDef_out::operator= (const ::IR::FinderDef_out &p)
{
  this->ptr_ = ACE_const_cast (FinderDef_out&, p).ptr_;
  return *this;
}

IR::FinderDef_out &
IR::FinderDef_out::operator= (const ::IR::FinderDef_var &p)
{
  this->ptr_ = ::IR::FinderDef::_duplicate (p.ptr ());
  return *this;
}

IR::FinderDef_out &
IR::FinderDef_out::operator= (FinderDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::FinderDef_out::operator ::IR::FinderDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::FinderDef_ptr &
IR::FinderDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::FinderDef_ptr
IR::FinderDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_FinderDef_Proxy_Impl::_TAO_FinderDef_Proxy_Impl (void)
{}

IR::_TAO_FinderDef_Remote_Proxy_Impl::_TAO_FinderDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_FinderDef_Proxy_Broker::_TAO_FinderDef_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Proxy_Broker::~_TAO_FinderDef_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Proxy_Broker * (*IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_FinderDef_Remote_Proxy_Broker *
IR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_FinderDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_FinderDef_Remote_Proxy_Broker::_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Remote_Proxy_Broker::~_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_FinderDef_Proxy_Impl&
IR::_TAO_FinderDef_Remote_Proxy_Broker::select_proxy (
  ::IR::FinderDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::FinderDef::FinderDef (int collocated)
{
  this->IR_FinderDef_setup_collocation (collocated);
}

// destructor
IR::FinderDef::~FinderDef (void)
{}

void
IR::FinderDef::IR_FinderDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FinderDef_Proxy_Broker_ =
      ::IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FinderDef_Proxy_Broker_ =
      ::IR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker ();

  this->CORBA_OperationDef_setup_collocation (collocated);
}

void IR::FinderDef::_tao_any_destructor (void *_tao_void_pointer)
{
  FinderDef *tmp = ACE_static_cast (FinderDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::FinderDef_ptr IR::FinderDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return FinderDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FinderDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (FinderDef::_nil ());
      if (is_a == 0)
        return FinderDef::_nil ();
    }
  return FinderDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::FinderDef_ptr IR::FinderDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return FinderDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      FinderDef_ptr default_proxy = FinderDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::FinderDef (
            stub,
            1,
            obj->_servant ()),

          FinderDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::FinderDef (stub, 0, obj->_servant ()), FinderDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            FinderDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &FinderDef::_tao_class_id
                    )
                )
          );
}

IR::FinderDef_ptr
IR::FinderDef::_duplicate (FinderDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::FinderDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::FinderDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, FinderDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_OperationDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_OperationDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

static const CORBA::Long _oc_IR_FinderDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f46),
  ACE_NTOHL (0x696e6465),
  ACE_NTOHL (0x72446566),
  ACE_NTOHL (0x3a312e30),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
  10,
  ACE_NTOHL (0x46696e64),
  ACE_NTOHL (0x65724465),
  ACE_NTOHL (0x66000000),  // name = FinderDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_FinderDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_FinderDef),
    (char *) &_oc_IR_FinderDef,
    0,
    sizeof (IR::FinderDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDef, &_tc_TAO_tc_IR_FinderDef)
TAO_NAMESPACE_END

IR::HomeDef_ptr
tao_IR_HomeDef_duplicate (
    IR::HomeDef_ptr p
  )
{
  return IR::HomeDef::_duplicate (p);
}

void
tao_IR_HomeDef_release (
    IR::HomeDef_ptr p
  )
{
  CORBA::release (p);
}

IR::HomeDef_ptr
tao_IR_HomeDef_nil (
    void
  )
{
  return IR::HomeDef::_nil ();
}

IR::HomeDef_ptr
tao_IR_HomeDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return IR::HomeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_IR_HomeDef_upcast (
    void *src
  )
{
  IR::HomeDef **tmp =
    ACE_static_cast (IR::HomeDef **, src);
  return *tmp;
}

int IR::HomeDef::_tao_class_id = 0;

// *************************************************************
// Operations for class IR::HomeDef_var
// *************************************************************

IR::HomeDef_var::HomeDef_var (void) // default constructor
  : ptr_ (HomeDef::_nil ())
{}

::IR::HomeDef_ptr
IR::HomeDef_var::ptr (void) const
{
  return this->ptr_;
}

IR::HomeDef_var::HomeDef_var (const ::IR::HomeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (HomeDef::_duplicate (p.ptr ()))
{}

IR::HomeDef_var::~HomeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

IR::HomeDef_var &
IR::HomeDef_var::operator= (HomeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

IR::HomeDef_var &
IR::HomeDef_var::operator= (const ::IR::HomeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR::HomeDef::_duplicate (p.ptr ());
  }
  return *this;
}

IR::HomeDef_var::operator const ::IR::HomeDef_ptr &() const // cast
{
  return this->ptr_;
}

IR::HomeDef_var::operator ::IR::HomeDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_var::operator-> (void) const
{
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_var::in (void) const
{
  return this->ptr_;
}

::IR::HomeDef_ptr &
IR::HomeDef_var::inout (void)
{
  return this->ptr_;
}

::IR::HomeDef_ptr &
IR::HomeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::HomeDef::_nil ();
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR::HomeDef_ptr val = this->ptr_;
  this->ptr_ = ::IR::HomeDef::_nil ();
  return val;
}

::IR::HomeDef_ptr
IR::HomeDef_var::tao_duplicate (HomeDef_ptr p)
{
  return ::IR::HomeDef::_duplicate (p);
}

void
IR::HomeDef_var::tao_release (HomeDef_ptr p)
{
  CORBA::release (p);
}

::IR::HomeDef_ptr
IR::HomeDef_var::tao_nil (void)
{
  return ::IR::HomeDef::_nil ();
}

::IR::HomeDef_ptr
IR::HomeDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::IR::HomeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
IR::HomeDef_var::tao_upcast (void *src)
{
  HomeDef **tmp =
    ACE_static_cast (HomeDef **, src);
  return *tmp;
}

// *************************************************************
// Operations for class IR::HomeDef_out
// *************************************************************

IR::HomeDef_out::HomeDef_out (HomeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR::HomeDef::_nil ();
}

IR::HomeDef_out::HomeDef_out (HomeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR::HomeDef::_nil ();
}

IR::HomeDef_out::HomeDef_out (const ::IR::HomeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeDef_out &, p).ptr_)
{}

::IR::HomeDef_out &
IR::HomeDef_out::operator= (const ::IR::HomeDef_out &p)
{
  this->ptr_ = ACE_const_cast (HomeDef_out&, p).ptr_;
  return *this;
}

IR::HomeDef_out &
IR::HomeDef_out::operator= (const ::IR::HomeDef_var &p)
{
  this->ptr_ = ::IR::HomeDef::_duplicate (p.ptr ());
  return *this;
}

IR::HomeDef_out &
IR::HomeDef_out::operator= (HomeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

IR::HomeDef_out::operator ::IR::HomeDef_ptr &() // cast
{
  return this->ptr_;
}

::IR::HomeDef_ptr &
IR::HomeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

::IR::HomeDef_ptr
IR::HomeDef_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_IR_HomeDef_base_home_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_base_home_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_base_home_get (const TAO_ClientRequestInfo_IR_HomeDef_base_home_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_base_home_get &);

  IR::HomeDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_base_home_get::TAO_ClientRequestInfo_IR_HomeDef_base_home_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (IR::HomeDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_managed_component_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (const TAO_ClientRequestInfo_IR_HomeDef_managed_component_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_managed_component_get &);

  IR::ComponentDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (IR::ComponentDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_primary_key_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (const TAO_ClientRequestInfo_IR_HomeDef_primary_key_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_primary_key_get &);

  IR::PrimaryKeyDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (IR::PrimaryKeyDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_factories_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_factories_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_factories_get (const TAO_ClientRequestInfo_IR_HomeDef_factories_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_factories_get &);

  IR::FactoryDefSeq * _result;
};

TAO_ClientRequestInfo_IR_HomeDef_factories_get::TAO_ClientRequestInfo_IR_HomeDef_factories_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_factories_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_factories_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (IR::FactoryDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_finders_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_finders_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDefSeq * result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_finders_get (const TAO_ClientRequestInfo_IR_HomeDef_finders_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_finders_get &);

  IR::FinderDefSeq * _result;
};

TAO_ClientRequestInfo_IR_HomeDef_finders_get::TAO_ClientRequestInfo_IR_HomeDef_finders_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_finders_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_finders_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (IR::FinderDefSeq * result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_is_basic_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (const TAO_ClientRequestInfo_IR_HomeDef_is_basic_get &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_is_basic_get &);

  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_create_primary_key : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA_ValueDef_ptr primary_key
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (const TAO_ClientRequestInfo_IR_HomeDef_create_primary_key &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_create_primary_key &);

  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr primary_key_;
  IR::PrimaryKeyDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->primary_key_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (IR::PrimaryKeyDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_create_factory : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_create_factory (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_create_factory (const TAO_ClientRequestInfo_IR_HomeDef_create_factory &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_create_factory &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FactoryDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_create_factory::TAO_ClientRequestInfo_IR_HomeDef_create_factory (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_create_factory::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_create_factory::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (IR::FactoryDef_ptr result)
{
  // update the result
  this->_result = result;
}

class TAO_ClientRequestInfo_IR_HomeDef_create_finder : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_IR_HomeDef_create_finder (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA_ParDescriptionSeq & params,
      const CORBA_ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDef_ptr result);

private:
  TAO_ClientRequestInfo_IR_HomeDef_create_finder (const TAO_ClientRequestInfo_IR_HomeDef_create_finder &);
  void operator= (const TAO_ClientRequestInfo_IR_HomeDef_create_finder &);

  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FinderDef_ptr _result;
};

TAO_ClientRequestInfo_IR_HomeDef_create_finder::TAO_ClientRequestInfo_IR_HomeDef_create_finder (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_IR_HomeDef_create_finder::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_IR_HomeDef_create_finder::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}


CORBA::Any *
TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void
TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (IR::FinderDef_ptr result)
{
  // update the result
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation.
//

IR::_TAO_HomeDef_Proxy_Impl::_TAO_HomeDef_Proxy_Impl (void)
{}

IR::_TAO_HomeDef_Remote_Proxy_Impl::_TAO_HomeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR::HomeDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::HomeDef_ptr _tao_retval = IR::HomeDef::_nil ();
  IR::HomeDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_home",
      14,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_base_home_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::ComponentDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::ComponentDef_ptr _tao_retval = IR::ComponentDef::_nil ();
  IR::ComponentDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_managed_component",
      22,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_managed_component_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::PrimaryKeyDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_primary_key_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::FactoryDefSeq * IR::_TAO_HomeDef_Remote_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::FactoryDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::FactoryDefSeq, _tao_retval);
  IR::FactoryDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_factories",
      14,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_factories_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::FactoryDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::FinderDefSeq * IR::_TAO_HomeDef_Remote_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::FinderDefSeq *_tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  ACE_NEW_RETURN (_tao_retval, IR::FinderDefSeq, _tao_retval);
  IR::FinderDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_finders",
      12,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_finders_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::FinderDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean IR::_TAO_HomeDef_Remote_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      0,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_is_basic_get ri (
        &_tao_call,
        _collocated_tao_target_
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN  (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          ri.result (_tao_retval_info);

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN  (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN  (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_retval;
}

IR::PrimaryKeyDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::PrimaryKeyDef_ptr _tao_retval = IR::PrimaryKeyDef::_nil ();
  IR::PrimaryKeyDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_primary_key",
      18,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_create_primary_key ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        primary_key
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << primary_key)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::FactoryDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::FactoryDef_ptr _tao_retval = IR::FactoryDef::_nil ();
  IR::FactoryDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_factory",
      14,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_create_factory ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        params,
        exceptions
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::FactoryDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}

IR::FinderDef_ptr IR::_TAO_HomeDef_Remote_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  IR::FinderDef_ptr _tao_retval = IR::FinderDef::_nil ();
  IR::FinderDef_var _tao_safe_retval (_tao_retval);


  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_finder",
      13,
      1,
      istub->orb_core ()
    );

  int _invoke_status;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );

#endif  /* TAO_HAS_INTERCEPTORS */

  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;

#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_IR_HomeDef_create_finder ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        params,
        exceptions
        ACE_ENV_ARG_PARAMETER
      );
      ACE_CHECK_RETURN (0);

#endif /* TAO_HAS_INTERCEPTORS */


      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (ri.response_expected (1));

#if TAO_HAS_INTERCEPTORS == 1

      ACE_TRY
        {
          _tao_vfr.send_request (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }

#endif /* TAO_HAS_INTERCEPTORS */

          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (0);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );

            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )

              continue;
            }

          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );

            }

#if TAO_HAS_INTERCEPTORS == 1
          IR::FinderDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
          ri.result (_tao_retval_info);
          _tao_safe_retval = _tao_retval_info;

          ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;

      }
    ACE_CATCHANY
      {
        ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;

        PortableInterceptor::ReplyStatus _tao_status =
          ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;

        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
    ACE_CHECK_RETURN (0);

    PortableInterceptor::ReplyStatus _tao_status =
      ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
    ACE_CHECK_RETURN (0);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;

#endif  /* TAO_HAS_INTERCEPTORS */

    break;
  }
return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation.
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

IR::_TAO_HomeDef_Proxy_Broker::_TAO_HomeDef_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Proxy_Broker::~_TAO_HomeDef_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Proxy_Broker * (*IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
IR::_TAO_HomeDef_Remote_Proxy_Broker *
IR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker (void)
{
  static ::IR::_TAO_HomeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

IR::_TAO_HomeDef_Remote_Proxy_Broker::_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Remote_Proxy_Broker::~_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

IR::_TAO_HomeDef_Proxy_Impl&
IR::_TAO_HomeDef_Remote_Proxy_Broker::select_proxy (
  ::IR::HomeDef *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR::HomeDef::HomeDef (int collocated)
{
  this->IR_HomeDef_setup_collocation (collocated);
}

// destructor
IR::HomeDef::~HomeDef (void)
{}

void
IR::HomeDef::IR_HomeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeDef_Proxy_Broker_ =
      ::IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeDef_Proxy_Broker_ =
      ::IR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker ();

  this->CORBA_InterfaceDef_setup_collocation (collocated);
}

void IR::HomeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeDef *tmp = ACE_static_cast (HomeDef*, _tao_void_pointer);
  CORBA::release (tmp);
}

IR::HomeDef_ptr IR::HomeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return HomeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/HomeDef:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (HomeDef::_nil ());
      if (is_a == 0)
        return HomeDef::_nil ();
    }
  return HomeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

IR::HomeDef_ptr IR::HomeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return HomeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      HomeDef_ptr default_proxy = HomeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR::HomeDef (
            stub,
            1,
            obj->_servant ()),

          HomeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR::HomeDef (stub, 0, obj->_servant ()), HomeDef::_nil ());
        return default_proxy;
      }
    else
      return
        ACE_reinterpret_cast
          (
            HomeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &HomeDef::_tao_class_id
                    )
                )
          );
}

IR::HomeDef_ptr
IR::HomeDef::_duplicate (HomeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR::HomeDef::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *IR::HomeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IR, HomeDef)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_InterfaceDef::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Container::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_Contained::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IDLType::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));

  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef_ptr IR::HomeDef::base_home (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.base_home (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::ComponentDef_ptr IR::HomeDef::managed_component (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.managed_component (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::PrimaryKeyDef_ptr IR::HomeDef::primary_key (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.primary_key (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::FactoryDefSeq * IR::HomeDef::factories (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.factories (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::FinderDefSeq * IR::HomeDef::finders (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.finders (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

CORBA::Boolean IR::HomeDef::is_basic (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.is_basic (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

IR::PrimaryKeyDef_ptr IR::HomeDef::create_primary_key (
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_primary_key (
      this,
      id,
      name,
      version,
      primary_key
      ACE_ENV_ARG_PARAMETER
    );
}

IR::FactoryDef_ptr IR::HomeDef::create_factory (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_factory (
      this,
      id,
      name,
      version,
      params,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

IR::FinderDef_ptr IR::HomeDef::create_finder (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy =
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return proxy.create_finder (
      this,
      id,
      name,
      version,
      params,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

static const CORBA::Long _oc_IR_HomeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f48),
  ACE_NTOHL (0x6f6d6544),
  ACE_NTOHL (0x65663a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
  8,
  ACE_NTOHL (0x486f6d65),
  ACE_NTOHL (0x44656600),  // name = HomeDef
};

static CORBA::TypeCode _tc_TAO_tc_IR_HomeDef (
    CORBA::tk_objref,
    sizeof (_oc_IR_HomeDef),
    (char *) &_oc_IR_HomeDef,
    0,
    sizeof (IR::HomeDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDef, &_tc_TAO_tc_IR_HomeDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_HomeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x49522f48),
  ACE_NTOHL (0x6f6d6544),
  ACE_NTOHL (0x65736372),
  ACE_NTOHL (0x69707469),
  ACE_NTOHL (0x6f6e3a31),
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDescription:1.0
  16,
  ACE_NTOHL (0x486f6d65),
  ACE_NTOHL (0x44657363),
  ACE_NTOHL (0x72697074),
  ACE_NTOHL (0x696f6e00),  // name = HomeDescription
  12, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f49),
    ACE_NTOHL (0x64656e74),
    ACE_NTOHL (0x69666965),
    ACE_NTOHL (0x723a312e),
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f56),
    ACE_NTOHL (0x65727369),
    ACE_NTOHL (0x6f6e5370),
    ACE_NTOHL (0x65633a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  10,
  ACE_NTOHL (0x62617365),
  ACE_NTOHL (0x5f686f6d),
  ACE_NTOHL (0x65000000),  // name = base_home
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  18,
  ACE_NTOHL (0x6d616e61),
  ACE_NTOHL (0x6765645f),
  ACE_NTOHL (0x636f6d70),
  ACE_NTOHL (0x6f6e656e),
  ACE_NTOHL (0x74000000),  // name = managed_component
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f52),
    ACE_NTOHL (0x65706f73),
    ACE_NTOHL (0x69746f72),
    ACE_NTOHL (0x7949643a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  16,
  ACE_NTOHL (0x7072696d),
  ACE_NTOHL (0x6172795f),
  ACE_NTOHL (0x6b65795f),
  ACE_NTOHL (0x64656600),  // name = primary_key_def
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f50),
    ACE_NTOHL (0x72696d61),
    ACE_NTOHL (0x72794b65),
    ACE_NTOHL (0x79446566),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
    14,
    ACE_NTOHL (0x5072696d),
    ACE_NTOHL (0x6172794b),
    ACE_NTOHL (0x65794465),
    ACE_NTOHL (0x66000000),  // name = PrimaryKeyDef

  10,
  ACE_NTOHL (0x66616374),
  ACE_NTOHL (0x6f726965),
  ACE_NTOHL (0x73000000),  // name = factories
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f46),
    ACE_NTOHL (0x6163746f),
    ACE_NTOHL (0x72794465),
    ACE_NTOHL (0x66536571),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
    14,
    ACE_NTOHL (0x46616374),
    ACE_NTOHL (0x6f727944),
    ACE_NTOHL (0x65665365),
    ACE_NTOHL (0x71000000),  // name = FactoryDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f46),
        ACE_NTOHL (0x6163746f),
        ACE_NTOHL (0x72794465),
        ACE_NTOHL (0x663a312e),
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
        11,
        ACE_NTOHL (0x46616374),
        ACE_NTOHL (0x6f727944),
        ACE_NTOHL (0x65660000),  // name = FactoryDef

      0U,


  8,
  ACE_NTOHL (0x66696e64),
  ACE_NTOHL (0x65727300),  // name = finders
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
  TAO_ENCAP_BYTE_ORDER, // byte order
    32,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x49522f46),
    ACE_NTOHL (0x696e6465),
    ACE_NTOHL (0x72446566),
    ACE_NTOHL (0x5365713a),
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
    13,
    ACE_NTOHL (0x46696e64),
    ACE_NTOHL (0x65724465),
    ACE_NTOHL (0x66536571),
    ACE_NTOHL (0x0),  // name = FinderDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x49522f46),
        ACE_NTOHL (0x696e6465),
        ACE_NTOHL (0x72446566),
        ACE_NTOHL (0x3a312e30),
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
        10,
        ACE_NTOHL (0x46696e64),
        ACE_NTOHL (0x65724465),
        ACE_NTOHL (0x66000000),  // name = FinderDef

      0U,


  11,
  ACE_NTOHL (0x6f706572),
  ACE_NTOHL (0x6174696f),
  ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2036, // encapsulation length
  TAO_ENCAP_BYTE_ORDER, // byte order
    39,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4f70),
    ACE_NTOHL (0x44657363),
    ACE_NTOHL (0x72697074),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x65713a31),
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17,
    ACE_NTOHL (0x4f704465),
    ACE_NTOHL (0x73637269),
    ACE_NTOHL (0x7074696f),
    ACE_NTOHL (0x6e536571),
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1956, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1940, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f4f70),
        ACE_NTOHL (0x65726174),
        ACE_NTOHL (0x696f6e44),
  ACE_NTOHL (0x65736372),
  ACE_NTOHL (0x69707469),
  ACE_NTOHL (0x6f6e3a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
        21,
        ACE_NTOHL (0x4f706572),
        ACE_NTOHL (0x6174696f),
        ACE_NTOHL (0x6e446573),
        ACE_NTOHL (0x63726970),
        ACE_NTOHL (0x74696f6e),
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
  5,
  ACE_NTOHL (0x6e616d65),
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4964),
          ACE_NTOHL (0x656e7469),
          ACE_NTOHL (0x66696572),
          ACE_NTOHL (0x3a312e30),
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11,
    ACE_NTOHL (0x4964656e),
    ACE_NTOHL (0x74696669),
    ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11,
  ACE_NTOHL (0x64656669),
  ACE_NTOHL (0x6e65645f),
  ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          35,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f),
    ACE_NTOHL (0x7369746f),
    ACE_NTOHL (0x72794964),
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8,
  ACE_NTOHL (0x76657273),
  ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          34,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5665),
          ACE_NTOHL (0x7273696f),
          ACE_NTOHL (0x6e537065),
          ACE_NTOHL (0x633a312e),
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12,
    ACE_NTOHL (0x56657273),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

        7,
        ACE_NTOHL (0x72657375),
        ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465),
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4f70),
          ACE_NTOHL (0x65726174),
          ACE_NTOHL (0x696f6e4d),
          ACE_NTOHL (0x6f64653a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572),
          ACE_NTOHL (0x6174696f),
          ACE_NTOHL (0x6e4d6f64),
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
  10,
          ACE_NTOHL (0x4f505f4e),
          ACE_NTOHL (0x4f524d41),
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f),
          ACE_NTOHL (0x4e455741),
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9,
        ACE_NTOHL (0x636f6e74),
        ACE_NTOHL (0x65787473),
        ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f436f),
          ACE_NTOHL (0x6e746578),
          ACE_NTOHL (0x74496453),
          ACE_NTOHL (0x65713a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
          13,
          ACE_NTOHL (0x436f6e74),
          ACE_NTOHL (0x65787449),
          ACE_NTOHL (0x64536571),
          ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          164, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            148, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f436f),
              ACE_NTOHL (0x6e746578),
              ACE_NTOHL (0x74496465),
              ACE_NTOHL (0x6e746966),
              ACE_NTOHL (0x6965723a),
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
              18,
              ACE_NTOHL (0x436f6e74),
              ACE_NTOHL (0x65787449),
              ACE_NTOHL (0x64656e74),
              ACE_NTOHL (0x69666965),
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
                33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length


            0U,


        11,
        ACE_NTOHL (0x70617261),
        ACE_NTOHL (0x6d657465),
        ACE_NTOHL (0x72730000),  // name = parameters
  CORBA::tk_alias, // typecode kind for typedefs
        496, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          40,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5061),
          ACE_NTOHL (0x72446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x50617244),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          416, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            400, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f5061),
              ACE_NTOHL (0x72616d65),
              ACE_NTOHL (0x74657244),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
              21,
              ACE_NTOHL (0x50617261),
              ACE_NTOHL (0x6d657465),
              ACE_NTOHL (0x72446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
    ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x5f646566),
              ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
                30,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4944),
                ACE_NTOHL (0x4c547970),
                ACE_NTOHL (0x653a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8,
                ACE_NTOHL (0x49444c54),
                ACE_NTOHL (0x79706500),  // name = IDLType

              5,
              ACE_NTOHL (0x6d6f6465),
              ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
                36,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5061),
                ACE_NTOHL (0x72616d65),
                ACE_NTOHL (0x7465724d),
                ACE_NTOHL (0x6f64653a),
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261),
                ACE_NTOHL (0x6d657465),
                ACE_NTOHL (0x724d6f64),
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241),
                ACE_NTOHL (0x4d5f494e),
                ACE_NTOHL (0x0),  // name = PARAM_IN
        10,
                ACE_NTOHL (0x50415241),
                ACE_NTOHL (0x4d5f4f55),
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241),
                ACE_NTOHL (0x4d5f494e),
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


      0U,


  11,
        ACE_NTOHL (0x65786365),
        ACE_NTOHL (0x7074696f),
        ACE_NTOHL (0x6e730000),  // name = exceptions
  CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          40,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4578),
          ACE_NTOHL (0x63446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x45786344),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
            460, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f4578),
              ACE_NTOHL (0x63657074),
        ACE_NTOHL (0x696f6e44),
        ACE_NTOHL (0x65736372),
        ACE_NTOHL (0x69707469),
        ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21,
              ACE_NTOHL (0x45786365),
              ACE_NTOHL (0x7074696f),
              ACE_NTOHL (0x6e446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
        5,
        ACE_NTOHL (0x6e616d65),
        ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

        3,
        ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

        11,
        ACE_NTOHL (0x64656669),
        ACE_NTOHL (0x6e65645f),
        ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
                35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              8,
              ACE_NTOHL (0x76657273),
              ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
                34,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5665),
                ACE_NTOHL (0x7273696f),
                ACE_NTOHL (0x6e537065),
                ACE_NTOHL (0x633a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
                ACE_NTOHL (0x56657273),
                ACE_NTOHL (0x696f6e53),
                ACE_NTOHL (0x70656300),  // name = VersionSpec
            CORBA::tk_string,
            0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



            0U,


        11,
  ACE_NTOHL (0x61747472),
  ACE_NTOHL (0x69627574),
  ACE_NTOHL (0x65730000),  // name = attributes
        CORBA::tk_alias, // typecode kind for typedefs
  1852, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
    41,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4174),
    ACE_NTOHL (0x74724465),
    ACE_NTOHL (0x73637269),
    ACE_NTOHL (0x7074696f),
    ACE_NTOHL (0x6e536571),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19,
    ACE_NTOHL (0x41747472),
    ACE_NTOHL (0x44657363),
    ACE_NTOHL (0x72697074),
    ACE_NTOHL (0x696f6e53),
    ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
          CORBA::tk_sequence, // typecode kind
    1768, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
      1752, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f4174),
        ACE_NTOHL (0x74726962),
        ACE_NTOHL (0x75746544),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21,
        ACE_NTOHL (0x41747472),
        ACE_NTOHL (0x69627574),
        ACE_NTOHL (0x65446573),
        ACE_NTOHL (0x63726970),
        ACE_NTOHL (0x74696f6e),
        ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4964),
          ACE_NTOHL (0x656e7469),
          ACE_NTOHL (0x66696572),
          ACE_NTOHL (0x3a312e30),
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11,
          ACE_NTOHL (0x4964656e),
          ACE_NTOHL (0x74696669),
          ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string,
              0U, // string length

        3,
        ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
          35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11,
        ACE_NTOHL (0x64656669),
        ACE_NTOHL (0x6e65645f),
        ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5265),
          ACE_NTOHL (0x706f7369),
          ACE_NTOHL (0x746f7279),
          ACE_NTOHL (0x49643a31),
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f),
          ACE_NTOHL (0x7369746f),
          ACE_NTOHL (0x72794964),
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8,
        ACE_NTOHL (0x76657273),
        ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
          34,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f5665),
          ACE_NTOHL (0x7273696f),
          ACE_NTOHL (0x6e537065),
          ACE_NTOHL (0x633a312e),
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
          ACE_NTOHL (0x56657273),
          ACE_NTOHL (0x696f6e53),
          ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        5,
        ACE_NTOHL (0x74797065),
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465),
        ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4174),
          ACE_NTOHL (0x74726962),
          ACE_NTOHL (0x7574654d),
          ACE_NTOHL (0x6f64653a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472),
          ACE_NTOHL (0x69627574),
          ACE_NTOHL (0x654d6f64),
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452),
          ACE_NTOHL (0x5f4e4f52),
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452),
          ACE_NTOHL (0x5f524541),
          ACE_NTOHL (0x444f4e4c),
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15,
        ACE_NTOHL (0x6765745f),
        ACE_NTOHL (0x65786365),
        ACE_NTOHL (0x7074696f),
        ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a),
          ACE_NTOHL (0x6f6d672e),
          ACE_NTOHL (0x6f72672f),
          ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4578),
          ACE_NTOHL (0x63446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x45786344),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a),
              ACE_NTOHL (0x6f6d672e),
              ACE_NTOHL (0x6f72672f),
              ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f4578),
              ACE_NTOHL (0x63657074),
              ACE_NTOHL (0x696f6e44),
              ACE_NTOHL (0x65736372),
              ACE_NTOHL (0x69707469),
              ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21,
              ACE_NTOHL (0x45786365),
              ACE_NTOHL (0x7074696f),
              ACE_NTOHL (0x6e446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5,
              ACE_NTOHL (0x6e616d65),
              ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string,
              0U, // string length

              3,
              ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string,
              0U, // string length

              11,
              ACE_NTOHL (0x64656669),
              ACE_NTOHL (0x6e65645f),
              ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string,
              0U, // string length

              8,
              ACE_NTOHL (0x76657273),
              ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5665),
                ACE_NTOHL (0x7273696f),
                ACE_NTOHL (0x6e537065),
                ACE_NTOHL (0x633a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
                ACE_NTOHL (0x56657273),
                ACE_NTOHL (0x696f6e53),
                ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string,
              0U, // string length

              5,
              ACE_NTOHL (0x74797065),
              ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15,
        ACE_NTOHL (0x7075745f),
        ACE_NTOHL (0x65786365),
        ACE_NTOHL (0x7074696f),
        ACE_NTOHL (0x6e730000),  // name = put_exceptions
  CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
          40,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
          ACE_NTOHL (0x412f4578),
          ACE_NTOHL (0x63446573),
          ACE_NTOHL (0x63726970),
          ACE_NTOHL (0x74696f6e),
          ACE_NTOHL (0x5365713a),
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18,
          ACE_NTOHL (0x45786344),
          ACE_NTOHL (0x65736372),
          ACE_NTOHL (0x69707469),
          ACE_NTOHL (0x6f6e5365),
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
            460, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
              ACE_NTOHL (0x412f4578),
              ACE_NTOHL (0x63657074),
              ACE_NTOHL (0x696f6e44),
        ACE_NTOHL (0x65736372),
        ACE_NTOHL (0x69707469),
        ACE_NTOHL (0x6f6e3a31),
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21,
              ACE_NTOHL (0x45786365),
              ACE_NTOHL (0x7074696f),
              ACE_NTOHL (0x6e446573),
              ACE_NTOHL (0x63726970),
              ACE_NTOHL (0x74696f6e),
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
        5,
        ACE_NTOHL (0x6e616d65),
        ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f4964),
                ACE_NTOHL (0x656e7469),
                ACE_NTOHL (0x66696572),
                ACE_NTOHL (0x3a312e30),
                ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
                ACE_NTOHL (0x4964656e),
                ACE_NTOHL (0x74696669),
                ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

        3,
        ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

        11,
        ACE_NTOHL (0x64656669),
        ACE_NTOHL (0x6e65645f),
        ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5265),
                ACE_NTOHL (0x706f7369),
                ACE_NTOHL (0x746f7279),
                ACE_NTOHL (0x49643a31),
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
                ACE_NTOHL (0x5265706f),
                ACE_NTOHL (0x7369746f),
                ACE_NTOHL (0x72794964),
                ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

        8,
        ACE_NTOHL (0x76657273),
        ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a),
                ACE_NTOHL (0x6f6d672e),
                ACE_NTOHL (0x6f72672f),
                ACE_NTOHL (0x434f5242),
                ACE_NTOHL (0x412f5665),
                ACE_NTOHL (0x7273696f),
                ACE_NTOHL (0x6e537065),
                ACE_NTOHL (0x633a312e),
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
                ACE_NTOHL (0x56657273),
                ACE_NTOHL (0x696f6e53),
                ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

        5,
        ACE_NTOHL (0x74797065),
        ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


            0U,



      0U,


  9,
  ACE_NTOHL (0x69735f62),
  ACE_NTOHL (0x61736963),
  ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_IR_HomeDescription (
    CORBA::tk_struct,
    sizeof (_oc_IR_HomeDescription),
    (char *) &_oc_IR_HomeDescription,
    0,
    sizeof (IR::HomeDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDescription, &_tc_TAO_tc_IR_HomeDescription)
TAO_NAMESPACE_END

void IR::HomeDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeDescription *tmp = ACE_static_cast (HomeDescription*, _tao_void_pointer);
  delete tmp;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::RepositoryIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_RepositoryIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::RepositoryIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_RepositoryIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::RepositoryIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::RepositoryIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::RepositoryIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::RepositoryIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_RepositoryIdSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::RepositoryIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::RepositoryIdSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_RepositoryIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::RepositoryIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ComponentDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ComponentDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ComponentDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ComponentDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ComponentDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ComponentDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ComponentDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ProvidesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ProvidesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UsesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UsesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::HomeDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::HomeDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::HomeDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::HomeDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_HomeDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::HomeDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::HomeDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::HomeDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::HomeDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::EmitsDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::EmitsDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EmitsDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EmitsDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::EmitsDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EmitsDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_EmitsDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EmitsDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EmitsDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::EmitsDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EmitsDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::EmitsDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::PublishesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::PublishesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PublishesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::PublishesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::PublishesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PublishesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_PublishesDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::PublishesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::PublishesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::PublishesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PublishesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::PublishesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ConsumesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConsumesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ConsumesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ConsumesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ConsumesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ConsumesDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ConsumesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ConsumesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ConsumesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ConsumesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ConsumesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::FactoryDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::FactoryDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FactoryDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::FactoryDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::FactoryDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FactoryDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_FactoryDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::FactoryDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::FactoryDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::FactoryDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FactoryDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::FactoryDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::FinderDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::FinderDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FinderDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::FinderDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::FinderDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::FinderDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_FinderDefSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::FinderDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::FinderDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::FinderDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FinderDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::FinderDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentRepository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentRepository,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ComponentRepository::_duplicate (_tao_elem),
        IR::ComponentRepository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentRepository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ComponentRepository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentRepository ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentRepository,
          1,
          _tao_elem,
          IR::ComponentRepository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ComponentRepository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ComponentRepository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ComponentRepository,IR::ComponentRepository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ProvidesDef::_duplicate (_tao_elem),
        IR::ProvidesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ProvidesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ProvidesDef,
          1,
          _tao_elem,
          IR::ProvidesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ProvidesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ProvidesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ProvidesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ProvidesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::UsesDef::_duplicate (_tao_elem),
        IR::UsesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::UsesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_UsesDef,
          1,
          _tao_elem,
          IR::UsesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::UsesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::UsesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::UsesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::UsesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::ProvidesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::ProvidesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ProvidesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ProvidesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::ProvidesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ProvidesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ProvidesDescSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ProvidesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ProvidesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::ProvidesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::ProvidesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR::UsesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR::UsesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::UsesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::UsesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR::UsesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::UsesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_UsesDescSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::UsesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::UsesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR::UsesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR::UsesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::EventDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EventDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EventDef::_duplicate (_tao_elem),
        IR::EventDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EventDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_EventDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EventDef,
          1,
          _tao_elem,
          IR::EventDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EventDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EventDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::EventDef,IR::EventDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::EventDef,IR::EventDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::EventDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::EventDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::EventDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EventDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::EventDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::EventDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_EventDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::EventDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::EventDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::EventDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EventDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::EventDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::EmitsDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::EmitsDef::_duplicate (_tao_elem),
        IR::EmitsDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::EmitsDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::EmitsDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_EmitsDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EmitsDef,
          1,
          _tao_elem,
          IR::EmitsDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::EmitsDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::EmitsDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::PublishesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PublishesDef::_duplicate (_tao_elem),
        IR::PublishesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PublishesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PublishesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_PublishesDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PublishesDef,
          1,
          _tao_elem,
          IR::PublishesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PublishesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PublishesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::ConsumesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ConsumesDef::_duplicate (_tao_elem),
        IR::ConsumesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ConsumesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ConsumesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ConsumesDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ConsumesDef,
          1,
          _tao_elem,
          IR::ConsumesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ConsumesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ConsumesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::ComponentDef::_duplicate (_tao_elem),
        IR::ComponentDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::ComponentDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentDef,
          1,
          _tao_elem,
          IR::ComponentDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::ComponentDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::ComponentDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::ComponentDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::ComponentDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::ComponentDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::ComponentDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::ComponentDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::ComponentDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_ComponentDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::ComponentDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::ComponentDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::ComponentDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::ComponentDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PrimaryKeyDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::PrimaryKeyDef::_duplicate (_tao_elem),
        IR::PrimaryKeyDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::PrimaryKeyDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_PrimaryKeyDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PrimaryKeyDef,
          1,
          _tao_elem,
          IR::PrimaryKeyDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::PrimaryKeyDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::PrimaryKeyDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::PrimaryKeyDef,IR::PrimaryKeyDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::PrimaryKeyDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::PrimaryKeyDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::PrimaryKeyDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::PrimaryKeyDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::PrimaryKeyDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::PrimaryKeyDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_PrimaryKeyDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::PrimaryKeyDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::PrimaryKeyDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::PrimaryKeyDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PrimaryKeyDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::PrimaryKeyDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR::FactoryDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FactoryDef::_duplicate (_tao_elem),
        IR::FactoryDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FactoryDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FactoryDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_FactoryDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FactoryDef,
          1,
          _tao_elem,
          IR::FactoryDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FactoryDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FactoryDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::FinderDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::FinderDef::_duplicate (_tao_elem),
        IR::FinderDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::FinderDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::FinderDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_FinderDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FinderDef,
          1,
          _tao_elem,
          IR::FinderDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::FinderDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::FinderDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR::HomeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDef,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR::HomeDef::_duplicate (_tao_elem),
        IR::HomeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR::HomeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_HomeDef ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_HomeDef,
          1,
          _tao_elem,
          IR::HomeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR::HomeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR::HomeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR::HomeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR::HomeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR::HomeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR::HomeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR::HomeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR::HomeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = type->equivalent (IR::_tc_HomeDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;

    if (!result)
      return 0; // not equivalent

    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR::HomeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR::HomeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR::HomeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR::HomeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::HomeDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::HomeDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EmitsDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EmitsDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PublishesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PublishesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ConsumesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ConsumesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FactoryDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FactoryDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FinderDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FinderDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentRepository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentRepository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ComponentRepository::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ProvidesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::UsesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ProvidesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ProvidesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::UsesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::UsesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EventDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EventDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::EventDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::EmitsDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::EmitsDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::EmitsDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PublishesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PublishesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::PublishesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ConsumesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ConsumesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ConsumesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::ComponentDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::ComponentDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::ComponentDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::PrimaryKeyDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::PrimaryKeyDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::PrimaryKeyDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FactoryDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FactoryDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::FactoryDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::FinderDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::FinderDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::FinderDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR::HomeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR::HomeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR::HomeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}
