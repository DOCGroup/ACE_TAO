// This may look like C, but it's really -*- C++ -*-

// ============================================================================
//
// = LIBRARY
//    TAO
// 
// = FILENAME
//    except.h
//
// = DESCRIPTION
//     This file defines way in which CORBA exceptions are reported.
//
// = AUTHOR
//     Copyright 1994-1995 by Sun Microsystems Inc.
// 
// ============================================================================

#if !defined (TAO_EXCEPT_H)
#  define TAO_EXCEPT_H

#if 0
#  include "ace/OS.h"    // WARNING! This MUST come before objbase.h on WIN32!
#  include "ace/Synch.h"
#  include <objbase.h>
#endif

class ACE_Svc_Export CORBA_Exception : public IUnknown
{
  // = TITLE
  // CORBA2-specified exception hierarchy.
  //
  // All exceptions have a type (represented by a TypeCode) and a widely
  // scoped type ID (in the TypeCode) that generated by any OMG-IDL compiler 
  // and available through the Interface Repositories.  Think of it as a
  // "globally scoped" name distinguishing each exception.
public:
  CORBA_Exception (const CORBA_Exception &src);
  CORBA_Exception &operator = (const CORBA_Exception &src);

  void *operator new (size_t, const void *p)
  { return (void *) p; }
  void *operator new (size_t s)
  { return ::operator new (s); }
  void operator delete (void *p)
  { ::operator delete (p); }

  TAO_CONST CORBA::String id (void) const;
  TAO_CONST CORBA::TypeCode_ptr type (void) const;

  // = Methods required for COM IUnknown support

  ULONG __stdcall AddRef (void);
  ULONG __stdcall Release (void);
  HRESULT __stdcall QueryInterface (REFIID riid,
				    void **ppv);

  CORBA_Exception (CORBA::TypeCode_ptr type);
  virtual ~CORBA_Exception (void);

private:
  CORBA::TypeCode_ptr _type;
  // Type of the Exception.

  u_int refcount_;
  // Reference count to avoid copying overhead.

  ACE_SYNCH_MUTEX lock_;
  // Serialize access to reference count.
};

class ACE_Svc_Export CORBA_UserException : public CORBA::Exception
{
  // = TITLE
  // User exceptions are those defined by application developers
  // using OMG-IDL.
public:
  CORBA_UserException (CORBA::TypeCode_ptr tc);
  ~CORBA_UserException (void);

protected:
  // Copy and assignment operators.
};

class ACE_Svc_Export CORBA_SystemException : public CORBA::Exception 
{
  // = TITLE
  // System exceptions are those defined in the CORBA spec; OMG-IDL
  // defines these.
public:
  // 94-9-14 also sez:  public copy constructor
  // and assignment operator.

  CORBA_SystemException (CORBA::TypeCode_ptr tc,
			 CORBA::ULong code,
			 CORBA::CompletionStatus	completed);

  ~CORBA_SystemException (void);

  CORBA::ULong minor (void) const { return _minor; }
  void minor (CORBA::ULong m) { _minor = m; }

  CORBA::CompletionStatus completion (void) const { return _completed; }

  void completion (CORBA::CompletionStatus c)
  { _completed = c; }

private:
  CORBA::ULong _minor;
  CORBA::CompletionStatus _completed;
};

// Declarations for all of the CORBA standard exceptions.
//
// XXX shouldn't have a default minor code, at least for code that's
// inside the ORB.  All minor codes should be symbolically catalogued.

//extern ACE_Svc_Export CORBA::TypeCode_ptr		_tc_CORBA_ ## name ; \
// this line was after #define and is commented as this has been moved into
// class CORBA

#define SYSEX(name) \
class ACE_Svc_Export CORBA_ ## name : public CORBA_SystemException { \
public: \
  CORBA_ ## name (CORBA::CompletionStatus completed, \
                  CORBA::ULong code = 0xffff0000L) \
    : CORBA_SystemException (CORBA::_tc_ ## name, code, completed) \
    { } \
}

SYSEX(UNKNOWN);
SYSEX(BAD_PARAM);
SYSEX(NO_MEMORY);
SYSEX(IMP_LIMIT);
SYSEX(COMM_FAILURE);
SYSEX(INV_OBJREF);
SYSEX(OBJECT_NOT_EXIST);
SYSEX(NO_PERMISSION);
SYSEX(INTERNAL);
SYSEX(MARSHAL);
SYSEX(INITIALIZE);
SYSEX(NO_IMPLEMENT);
SYSEX(BAD_TYPECODE);
SYSEX(BAD_OPERATION);
SYSEX(NO_RESOURCES);
SYSEX(NO_RESPONSE);
SYSEX(PERSIST_STORE);
SYSEX(BAD_INV_ORDER);
SYSEX(TRANSIENT);
SYSEX(FREE_MEM);
SYSEX(INV_IDENT);
SYSEX(INV_FLAG);
SYSEX(INTF_REPOS);
SYSEX(BAD_CONTEXT);
SYSEX(OBJ_ADAPTER);
SYSEX(DATA_CONVERSION);

#undef	SYSEX

class CORBA_Environment 
{
  // = TITLE
  // A CORBA_Environment is a way to automagically ensure that
  // exception data is freed -- the "var" class for Exceptions.  It
  // adds just a bit of convenience function support, helping classify
  // exceptions as well as reducing memory leakage.
public:
  CORBA_Environment (void) : _exception (0) { }
  ~CORBA_Environment (void) { clear (); }

  CORBA::Exception_ptr exception (void) const { return _exception; }

  void exception (CORBA::Exception *ex)
  { clear (); _exception = ex; }

  CORBA::ExceptionType exception_type (void) const;
  TAO_CONST CORBA::String exception_id (void) const;

  void clear (void)
  {
    if (_exception) 
      {
	_exception->Release ();
	_exception = 0;	// XXX
      }
  }

private:
  CORBA::Exception_ptr _exception;

  // = These are not provided.
  CORBA_Environment (const CORBA_Environment &src);
  CORBA_Environment &operator = (const CORBA_Environment &src);
};

#endif /* TAO_EXCEPT_H */
