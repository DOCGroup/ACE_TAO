// -*- C++ -*-
//
//$Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

ACE_INLINE
CORBA_IRObject::CORBA_IRObject (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class CORBA::IRObject_var
// *************************************************************

ACE_INLINE
CORBA::IRObject_var::IRObject_var (void) // default constructor
  : ptr_ (IRObject::_nil ())
{}

ACE_INLINE ::CORBA::IRObject_ptr
CORBA::IRObject_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
CORBA::IRObject_var::IRObject_var (const ::CORBA::IRObject_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IRObject::_duplicate (p.ptr ()))
{}

ACE_INLINE
CORBA::IRObject_var::~IRObject_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE CORBA::IRObject_var &
CORBA::IRObject_var::operator= (IRObject_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE CORBA::IRObject_var &
CORBA::IRObject_var::operator= (const ::CORBA::IRObject_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::IRObject::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
CORBA::IRObject_var::operator const ::CORBA::IRObject_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
CORBA::IRObject_var::operator ::CORBA::IRObject_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr
CORBA::IRObject_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr
CORBA::IRObject_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr &
CORBA::IRObject_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr &
CORBA::IRObject_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::IRObject::_nil ();
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr
CORBA::IRObject_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::IRObject_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::IRObject::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class CORBA::IRObject_out
// *************************************************************

ACE_INLINE
CORBA::IRObject_out::IRObject_out (IRObject_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::IRObject::_nil ();
}

ACE_INLINE
CORBA::IRObject_out::IRObject_out (IRObject_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::IRObject::_nil ();
}

ACE_INLINE
CORBA::IRObject_out::IRObject_out (const ::CORBA::IRObject_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IRObject_out &, p).ptr_)
{}

ACE_INLINE ::CORBA::IRObject_out &
CORBA::IRObject_out::operator= (const ::CORBA::IRObject_out &p)
{
  this->ptr_ = ACE_const_cast (CORBA_IRObject_out&, p).ptr_;
  return *this;
}

ACE_INLINE CORBA::IRObject_out &
CORBA::IRObject_out::operator= (const ::CORBA::IRObject_var &p)
{
  this->ptr_ = ::CORBA::IRObject::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE CORBA::IRObject_out &
CORBA::IRObject_out::operator= (IRObject_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
CORBA::IRObject_out::operator ::CORBA::IRObject_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr &
CORBA::IRObject_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::IRObject_ptr
CORBA::IRObject_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_Contained::IR_Contained (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_Contained_var
// *************************************************************

ACE_INLINE
IR_Contained_var::IR_Contained_var (void) // default constructor
  : ptr_ (IR_Contained::_nil ())
{}

ACE_INLINE IR_Contained_ptr 
IR_Contained_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_Contained_var::IR_Contained_var (const IR_Contained_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_Contained::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_Contained_var::~IR_Contained_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_Contained_var &
IR_Contained_var::operator= (IR_Contained_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_Contained_var &
IR_Contained_var::operator= (const IR_Contained_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_Contained::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_Contained_var::operator const IR_Contained_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_Contained_var::operator IR_Contained_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr 
IR_Contained_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr
IR_Contained_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr &
IR_Contained_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr &
IR_Contained_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_Contained::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr 
IR_Contained_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_Contained_ptr val = this->ptr_;
  this->ptr_ = IR_Contained::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_Contained_out
// *************************************************************

ACE_INLINE
IR_Contained_out::IR_Contained_out (IR_Contained_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_Contained::_nil ();
}

ACE_INLINE
IR_Contained_out::IR_Contained_out (IR_Contained_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_Contained::_nil ();
}

ACE_INLINE
IR_Contained_out::IR_Contained_out (const IR_Contained_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_Contained_out&,p).ptr_)
{}

ACE_INLINE IR_Contained_out &
IR_Contained_out::operator= (const IR_Contained_out &p)
{
  this->ptr_ = ACE_const_cast (IR_Contained_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_Contained_out &
IR_Contained_out::operator= (const IR_Contained_var &p)
{
  this->ptr_ = IR_Contained::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_Contained_out &
IR_Contained_out::operator= (IR_Contained_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Contained_out::operator IR_Contained_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr &
IR_Contained_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_Contained_ptr 
IR_Contained_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_Repository::IR_Repository (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_Repository_var
// *************************************************************

ACE_INLINE
IR_Repository_var::IR_Repository_var (void) // default constructor
  : ptr_ (IR_Repository::_nil ())
{}

ACE_INLINE IR_Repository_ptr 
IR_Repository_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_Repository_var::IR_Repository_var (const IR_Repository_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_Repository::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_Repository_var::~IR_Repository_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_Repository_var &
IR_Repository_var::operator= (IR_Repository_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_Repository_var &
IR_Repository_var::operator= (const IR_Repository_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_Repository::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_Repository_var::operator const IR_Repository_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_Repository_var::operator IR_Repository_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr 
IR_Repository_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr
IR_Repository_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr &
IR_Repository_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr &
IR_Repository_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_Repository::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr 
IR_Repository_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_Repository_ptr val = this->ptr_;
  this->ptr_ = IR_Repository::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_Repository_out
// *************************************************************

ACE_INLINE
IR_Repository_out::IR_Repository_out (IR_Repository_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_Repository::_nil ();
}

ACE_INLINE
IR_Repository_out::IR_Repository_out (IR_Repository_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_Repository::_nil ();
}

ACE_INLINE
IR_Repository_out::IR_Repository_out (const IR_Repository_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_Repository_out&,p).ptr_)
{}

ACE_INLINE IR_Repository_out &
IR_Repository_out::operator= (const IR_Repository_out &p)
{
  this->ptr_ = ACE_const_cast (IR_Repository_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_Repository_out &
IR_Repository_out::operator= (const IR_Repository_var &p)
{
  this->ptr_ = IR_Repository::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_Repository_out &
IR_Repository_out::operator= (IR_Repository_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Repository_out::operator IR_Repository_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr &
IR_Repository_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_Repository_ptr 
IR_Repository_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_Container::IR_Container (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_Container_var
// *************************************************************

ACE_INLINE
IR_Container_var::IR_Container_var (void) // default constructor
  : ptr_ (IR_Container::_nil ())
{}

ACE_INLINE IR_Container_ptr 
IR_Container_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_Container_var::IR_Container_var (const IR_Container_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_Container::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_Container_var::~IR_Container_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_Container_var &
IR_Container_var::operator= (IR_Container_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_Container_var &
IR_Container_var::operator= (const IR_Container_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_Container::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_Container_var::operator const IR_Container_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_Container_var::operator IR_Container_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr 
IR_Container_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr
IR_Container_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr &
IR_Container_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr &
IR_Container_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_Container::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr 
IR_Container_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_Container_ptr val = this->ptr_;
  this->ptr_ = IR_Container::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_Container_out
// *************************************************************

ACE_INLINE
IR_Container_out::IR_Container_out (IR_Container_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_Container::_nil ();
}

ACE_INLINE
IR_Container_out::IR_Container_out (IR_Container_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_Container::_nil ();
}

ACE_INLINE
IR_Container_out::IR_Container_out (const IR_Container_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_Container_out&,p).ptr_)
{}

ACE_INLINE IR_Container_out &
IR_Container_out::operator= (const IR_Container_out &p)
{
  this->ptr_ = ACE_const_cast (IR_Container_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_Container_out &
IR_Container_out::operator= (const IR_Container_var &p)
{
  this->ptr_ = IR_Container::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_Container_out &
IR_Container_out::operator= (IR_Container_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Container_out::operator IR_Container_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr &
IR_Container_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_Container_ptr 
IR_Container_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_Contained::Description_var
// *************************************************************

ACE_INLINE
IR_Contained::Description_var::Description_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_Contained::Description_var::Description_var (Description *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_Contained::Description_var::Description_var (const ::IR_Contained::Description_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_Contained::Description (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_Contained::Description_var::~Description_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_Contained::Description_var &
IR_Contained::Description_var::operator= (Description *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_Contained::Description_var &
IR_Contained::Description_var::operator= (const ::IR_Contained::Description_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_Contained::Description (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_Contained::Description *
IR_Contained::Description_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_Contained::Description *
IR_Contained::Description_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_Contained::Description_var::operator const ::IR_Contained::Description &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_Contained::Description_var::operator ::IR_Contained::Description &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_Contained::Description_var::operator ::IR_Contained::Description &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_Contained::Description_var::operator ::IR_Contained::Description *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_Contained::Description &
IR_Contained::Description_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_Contained::Description &
IR_Contained::Description_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_Contained::Description *&
IR_Contained::Description_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_Contained::Description *
IR_Contained::Description_var::_retn (void)
{
  ::IR_Contained::Description *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_Contained::Description *
IR_Contained::Description_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_Contained::Description_out
// *************************************************************

ACE_INLINE
IR_Contained::Description_out::Description_out (::IR_Contained::Description *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_Contained::Description_out::Description_out (Description_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_Contained::Description_out::Description_out (const ::IR_Contained::Description_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Description_out&, p).ptr_)
{}

ACE_INLINE IR_Contained::Description_out &
IR_Contained::Description_out::operator= (const ::IR_Contained::Description_out &p)
{
  this->ptr_ = ACE_const_cast (Description_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_Contained::Description_out &
IR_Contained::Description_out::operator= (Description *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Contained::Description_out::operator ::IR_Contained::Description *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_Contained::Description *&
IR_Contained::Description_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_Contained::Description *
IR_Contained::Description_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ModuleDef::IR_ModuleDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ModuleDef_var
// *************************************************************

ACE_INLINE
IR_ModuleDef_var::IR_ModuleDef_var (void) // default constructor
  : ptr_ (IR_ModuleDef::_nil ())
{}

ACE_INLINE IR_ModuleDef_ptr 
IR_ModuleDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ModuleDef_var::IR_ModuleDef_var (const IR_ModuleDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ModuleDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ModuleDef_var::~IR_ModuleDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ModuleDef_var &
IR_ModuleDef_var::operator= (IR_ModuleDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ModuleDef_var &
IR_ModuleDef_var::operator= (const IR_ModuleDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ModuleDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ModuleDef_var::operator const IR_ModuleDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ModuleDef_var::operator IR_ModuleDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr 
IR_ModuleDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr
IR_ModuleDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr &
IR_ModuleDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr &
IR_ModuleDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ModuleDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr 
IR_ModuleDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ModuleDef_ptr val = this->ptr_;
  this->ptr_ = IR_ModuleDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ModuleDef_out
// *************************************************************

ACE_INLINE
IR_ModuleDef_out::IR_ModuleDef_out (IR_ModuleDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ModuleDef::_nil ();
}

ACE_INLINE
IR_ModuleDef_out::IR_ModuleDef_out (IR_ModuleDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ModuleDef::_nil ();
}

ACE_INLINE
IR_ModuleDef_out::IR_ModuleDef_out (const IR_ModuleDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ModuleDef_out&,p).ptr_)
{}

ACE_INLINE IR_ModuleDef_out &
IR_ModuleDef_out::operator= (const IR_ModuleDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ModuleDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ModuleDef_out &
IR_ModuleDef_out::operator= (const IR_ModuleDef_var &p)
{
  this->ptr_ = IR_ModuleDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ModuleDef_out &
IR_ModuleDef_out::operator= (IR_ModuleDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ModuleDef_out::operator IR_ModuleDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr &
IR_ModuleDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ModuleDef_ptr 
IR_ModuleDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ConstantDef::IR_ConstantDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ConstantDef_var
// *************************************************************

ACE_INLINE
IR_ConstantDef_var::IR_ConstantDef_var (void) // default constructor
  : ptr_ (IR_ConstantDef::_nil ())
{}

ACE_INLINE IR_ConstantDef_ptr 
IR_ConstantDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ConstantDef_var::IR_ConstantDef_var (const IR_ConstantDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ConstantDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ConstantDef_var::~IR_ConstantDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ConstantDef_var &
IR_ConstantDef_var::operator= (IR_ConstantDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ConstantDef_var &
IR_ConstantDef_var::operator= (const IR_ConstantDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ConstantDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ConstantDef_var::operator const IR_ConstantDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ConstantDef_var::operator IR_ConstantDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr 
IR_ConstantDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr
IR_ConstantDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr &
IR_ConstantDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr &
IR_ConstantDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ConstantDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr 
IR_ConstantDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ConstantDef_ptr val = this->ptr_;
  this->ptr_ = IR_ConstantDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ConstantDef_out
// *************************************************************

ACE_INLINE
IR_ConstantDef_out::IR_ConstantDef_out (IR_ConstantDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ConstantDef::_nil ();
}

ACE_INLINE
IR_ConstantDef_out::IR_ConstantDef_out (IR_ConstantDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ConstantDef::_nil ();
}

ACE_INLINE
IR_ConstantDef_out::IR_ConstantDef_out (const IR_ConstantDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ConstantDef_out&,p).ptr_)
{}

ACE_INLINE IR_ConstantDef_out &
IR_ConstantDef_out::operator= (const IR_ConstantDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ConstantDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ConstantDef_out &
IR_ConstantDef_out::operator= (const IR_ConstantDef_var &p)
{
  this->ptr_ = IR_ConstantDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ConstantDef_out &
IR_ConstantDef_out::operator= (IR_ConstantDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ConstantDef_out::operator IR_ConstantDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr &
IR_ConstantDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ConstantDef_ptr 
IR_ConstantDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_IDLType::IR_IDLType (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_IDLType_var
// *************************************************************

ACE_INLINE
IR_IDLType_var::IR_IDLType_var (void) // default constructor
  : ptr_ (IR_IDLType::_nil ())
{}

ACE_INLINE IR_IDLType_ptr 
IR_IDLType_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_IDLType_var::IR_IDLType_var (const IR_IDLType_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_IDLType::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_IDLType_var::~IR_IDLType_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_IDLType_var &
IR_IDLType_var::operator= (IR_IDLType_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_IDLType_var &
IR_IDLType_var::operator= (const IR_IDLType_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_IDLType::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_IDLType_var::operator const IR_IDLType_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_IDLType_var::operator IR_IDLType_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr 
IR_IDLType_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr
IR_IDLType_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr &
IR_IDLType_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr &
IR_IDLType_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_IDLType::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr 
IR_IDLType_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_IDLType_ptr val = this->ptr_;
  this->ptr_ = IR_IDLType::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_IDLType_out
// *************************************************************

ACE_INLINE
IR_IDLType_out::IR_IDLType_out (IR_IDLType_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_IDLType::_nil ();
}

ACE_INLINE
IR_IDLType_out::IR_IDLType_out (IR_IDLType_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_IDLType::_nil ();
}

ACE_INLINE
IR_IDLType_out::IR_IDLType_out (const IR_IDLType_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_IDLType_out&,p).ptr_)
{}

ACE_INLINE IR_IDLType_out &
IR_IDLType_out::operator= (const IR_IDLType_out &p)
{
  this->ptr_ = ACE_const_cast (IR_IDLType_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_IDLType_out &
IR_IDLType_out::operator= (const IR_IDLType_var &p)
{
  this->ptr_ = IR_IDLType::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_IDLType_out &
IR_IDLType_out::operator= (IR_IDLType_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_IDLType_out::operator IR_IDLType_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr &
IR_IDLType_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_IDLType_ptr 
IR_IDLType_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_StructDef::IR_StructDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_StructDef_var
// *************************************************************

ACE_INLINE
IR_StructDef_var::IR_StructDef_var (void) // default constructor
  : ptr_ (IR_StructDef::_nil ())
{}

ACE_INLINE IR_StructDef_ptr 
IR_StructDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_StructDef_var::IR_StructDef_var (const IR_StructDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_StructDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_StructDef_var::~IR_StructDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_StructDef_var &
IR_StructDef_var::operator= (IR_StructDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_StructDef_var &
IR_StructDef_var::operator= (const IR_StructDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_StructDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_StructDef_var::operator const IR_StructDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_StructDef_var::operator IR_StructDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr 
IR_StructDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr
IR_StructDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr &
IR_StructDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr &
IR_StructDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_StructDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr 
IR_StructDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_StructDef_ptr val = this->ptr_;
  this->ptr_ = IR_StructDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_StructDef_out
// *************************************************************

ACE_INLINE
IR_StructDef_out::IR_StructDef_out (IR_StructDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_StructDef::_nil ();
}

ACE_INLINE
IR_StructDef_out::IR_StructDef_out (IR_StructDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_StructDef::_nil ();
}

ACE_INLINE
IR_StructDef_out::IR_StructDef_out (const IR_StructDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_StructDef_out&,p).ptr_)
{}

ACE_INLINE IR_StructDef_out &
IR_StructDef_out::operator= (const IR_StructDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_StructDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_StructDef_out &
IR_StructDef_out::operator= (const IR_StructDef_var &p)
{
  this->ptr_ = IR_StructDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_StructDef_out &
IR_StructDef_out::operator= (IR_StructDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_StructDef_out::operator IR_StructDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr &
IR_StructDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_StructDef_ptr 
IR_StructDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_UnionDef::IR_UnionDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_UnionDef_var
// *************************************************************

ACE_INLINE
IR_UnionDef_var::IR_UnionDef_var (void) // default constructor
  : ptr_ (IR_UnionDef::_nil ())
{}

ACE_INLINE IR_UnionDef_ptr 
IR_UnionDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_UnionDef_var::IR_UnionDef_var (const IR_UnionDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_UnionDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_UnionDef_var::~IR_UnionDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_UnionDef_var &
IR_UnionDef_var::operator= (IR_UnionDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_UnionDef_var &
IR_UnionDef_var::operator= (const IR_UnionDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_UnionDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_UnionDef_var::operator const IR_UnionDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_UnionDef_var::operator IR_UnionDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr 
IR_UnionDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr
IR_UnionDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr &
IR_UnionDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr &
IR_UnionDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_UnionDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr 
IR_UnionDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_UnionDef_ptr val = this->ptr_;
  this->ptr_ = IR_UnionDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_UnionDef_out
// *************************************************************

ACE_INLINE
IR_UnionDef_out::IR_UnionDef_out (IR_UnionDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_UnionDef::_nil ();
}

ACE_INLINE
IR_UnionDef_out::IR_UnionDef_out (IR_UnionDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_UnionDef::_nil ();
}

ACE_INLINE
IR_UnionDef_out::IR_UnionDef_out (const IR_UnionDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UnionDef_out&,p).ptr_)
{}

ACE_INLINE IR_UnionDef_out &
IR_UnionDef_out::operator= (const IR_UnionDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UnionDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_UnionDef_out &
IR_UnionDef_out::operator= (const IR_UnionDef_var &p)
{
  this->ptr_ = IR_UnionDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_UnionDef_out &
IR_UnionDef_out::operator= (IR_UnionDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UnionDef_out::operator IR_UnionDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr &
IR_UnionDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_UnionDef_ptr 
IR_UnionDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_EnumDef::IR_EnumDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_EnumDef_var
// *************************************************************

ACE_INLINE
IR_EnumDef_var::IR_EnumDef_var (void) // default constructor
  : ptr_ (IR_EnumDef::_nil ())
{}

ACE_INLINE IR_EnumDef_ptr 
IR_EnumDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_EnumDef_var::IR_EnumDef_var (const IR_EnumDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_EnumDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_EnumDef_var::~IR_EnumDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_EnumDef_var &
IR_EnumDef_var::operator= (IR_EnumDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_EnumDef_var &
IR_EnumDef_var::operator= (const IR_EnumDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_EnumDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_EnumDef_var::operator const IR_EnumDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_EnumDef_var::operator IR_EnumDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr 
IR_EnumDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr
IR_EnumDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr &
IR_EnumDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr &
IR_EnumDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_EnumDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr 
IR_EnumDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_EnumDef_ptr val = this->ptr_;
  this->ptr_ = IR_EnumDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_EnumDef_out
// *************************************************************

ACE_INLINE
IR_EnumDef_out::IR_EnumDef_out (IR_EnumDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_EnumDef::_nil ();
}

ACE_INLINE
IR_EnumDef_out::IR_EnumDef_out (IR_EnumDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_EnumDef::_nil ();
}

ACE_INLINE
IR_EnumDef_out::IR_EnumDef_out (const IR_EnumDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_EnumDef_out&,p).ptr_)
{}

ACE_INLINE IR_EnumDef_out &
IR_EnumDef_out::operator= (const IR_EnumDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_EnumDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_EnumDef_out &
IR_EnumDef_out::operator= (const IR_EnumDef_var &p)
{
  this->ptr_ = IR_EnumDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_EnumDef_out &
IR_EnumDef_out::operator= (IR_EnumDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_EnumDef_out::operator IR_EnumDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr &
IR_EnumDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_EnumDef_ptr 
IR_EnumDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_AliasDef::IR_AliasDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_AliasDef_var
// *************************************************************

ACE_INLINE
IR_AliasDef_var::IR_AliasDef_var (void) // default constructor
  : ptr_ (IR_AliasDef::_nil ())
{}

ACE_INLINE IR_AliasDef_ptr 
IR_AliasDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_AliasDef_var::IR_AliasDef_var (const IR_AliasDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_AliasDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_AliasDef_var::~IR_AliasDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_AliasDef_var &
IR_AliasDef_var::operator= (IR_AliasDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_AliasDef_var &
IR_AliasDef_var::operator= (const IR_AliasDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_AliasDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_AliasDef_var::operator const IR_AliasDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_AliasDef_var::operator IR_AliasDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr 
IR_AliasDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr
IR_AliasDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr &
IR_AliasDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr &
IR_AliasDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_AliasDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr 
IR_AliasDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_AliasDef_ptr val = this->ptr_;
  this->ptr_ = IR_AliasDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_AliasDef_out
// *************************************************************

ACE_INLINE
IR_AliasDef_out::IR_AliasDef_out (IR_AliasDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_AliasDef::_nil ();
}

ACE_INLINE
IR_AliasDef_out::IR_AliasDef_out (IR_AliasDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_AliasDef::_nil ();
}

ACE_INLINE
IR_AliasDef_out::IR_AliasDef_out (const IR_AliasDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_AliasDef_out&,p).ptr_)
{}

ACE_INLINE IR_AliasDef_out &
IR_AliasDef_out::operator= (const IR_AliasDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_AliasDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_AliasDef_out &
IR_AliasDef_out::operator= (const IR_AliasDef_var &p)
{
  this->ptr_ = IR_AliasDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_AliasDef_out &
IR_AliasDef_out::operator= (IR_AliasDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_AliasDef_out::operator IR_AliasDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr &
IR_AliasDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_AliasDef_ptr 
IR_AliasDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_InterfaceDef::IR_InterfaceDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_InterfaceDef_var
// *************************************************************

ACE_INLINE
IR_InterfaceDef_var::IR_InterfaceDef_var (void) // default constructor
  : ptr_ (IR_InterfaceDef::_nil ())
{}

ACE_INLINE IR_InterfaceDef_ptr 
IR_InterfaceDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_InterfaceDef_var::IR_InterfaceDef_var (const IR_InterfaceDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_InterfaceDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_InterfaceDef_var::~IR_InterfaceDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_InterfaceDef_var &
IR_InterfaceDef_var::operator= (IR_InterfaceDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_InterfaceDef_var &
IR_InterfaceDef_var::operator= (const IR_InterfaceDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_InterfaceDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_InterfaceDef_var::operator const IR_InterfaceDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_InterfaceDef_var::operator IR_InterfaceDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr 
IR_InterfaceDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr
IR_InterfaceDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr &
IR_InterfaceDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr &
IR_InterfaceDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_InterfaceDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr 
IR_InterfaceDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_InterfaceDef_ptr val = this->ptr_;
  this->ptr_ = IR_InterfaceDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_InterfaceDef_out
// *************************************************************

ACE_INLINE
IR_InterfaceDef_out::IR_InterfaceDef_out (IR_InterfaceDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_InterfaceDef::_nil ();
}

ACE_INLINE
IR_InterfaceDef_out::IR_InterfaceDef_out (IR_InterfaceDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_InterfaceDef::_nil ();
}

ACE_INLINE
IR_InterfaceDef_out::IR_InterfaceDef_out (const IR_InterfaceDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_InterfaceDef_out&,p).ptr_)
{}

ACE_INLINE IR_InterfaceDef_out &
IR_InterfaceDef_out::operator= (const IR_InterfaceDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_InterfaceDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_InterfaceDef_out &
IR_InterfaceDef_out::operator= (const IR_InterfaceDef_var &p)
{
  this->ptr_ = IR_InterfaceDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_InterfaceDef_out &
IR_InterfaceDef_out::operator= (IR_InterfaceDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_InterfaceDef_out::operator IR_InterfaceDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr &
IR_InterfaceDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_InterfaceDef_ptr 
IR_InterfaceDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ExceptionDef::IR_ExceptionDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ExceptionDef_var
// *************************************************************

ACE_INLINE
IR_ExceptionDef_var::IR_ExceptionDef_var (void) // default constructor
  : ptr_ (IR_ExceptionDef::_nil ())
{}

ACE_INLINE IR_ExceptionDef_ptr 
IR_ExceptionDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ExceptionDef_var::IR_ExceptionDef_var (const IR_ExceptionDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ExceptionDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ExceptionDef_var::~IR_ExceptionDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ExceptionDef_var &
IR_ExceptionDef_var::operator= (IR_ExceptionDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ExceptionDef_var &
IR_ExceptionDef_var::operator= (const IR_ExceptionDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ExceptionDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ExceptionDef_var::operator const IR_ExceptionDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ExceptionDef_var::operator IR_ExceptionDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr 
IR_ExceptionDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr
IR_ExceptionDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr &
IR_ExceptionDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr &
IR_ExceptionDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ExceptionDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr 
IR_ExceptionDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ExceptionDef_ptr val = this->ptr_;
  this->ptr_ = IR_ExceptionDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ExceptionDef_out
// *************************************************************

ACE_INLINE
IR_ExceptionDef_out::IR_ExceptionDef_out (IR_ExceptionDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ExceptionDef::_nil ();
}

ACE_INLINE
IR_ExceptionDef_out::IR_ExceptionDef_out (IR_ExceptionDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ExceptionDef::_nil ();
}

ACE_INLINE
IR_ExceptionDef_out::IR_ExceptionDef_out (const IR_ExceptionDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ExceptionDef_out&,p).ptr_)
{}

ACE_INLINE IR_ExceptionDef_out &
IR_ExceptionDef_out::operator= (const IR_ExceptionDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ExceptionDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ExceptionDef_out &
IR_ExceptionDef_out::operator= (const IR_ExceptionDef_var &p)
{
  this->ptr_ = IR_ExceptionDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ExceptionDef_out &
IR_ExceptionDef_out::operator= (IR_ExceptionDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ExceptionDef_out::operator IR_ExceptionDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr &
IR_ExceptionDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDef_ptr 
IR_ExceptionDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_NativeDef::IR_NativeDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_NativeDef_var
// *************************************************************

ACE_INLINE
IR_NativeDef_var::IR_NativeDef_var (void) // default constructor
  : ptr_ (IR_NativeDef::_nil ())
{}

ACE_INLINE IR_NativeDef_ptr 
IR_NativeDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_NativeDef_var::IR_NativeDef_var (const IR_NativeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_NativeDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_NativeDef_var::~IR_NativeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_NativeDef_var &
IR_NativeDef_var::operator= (IR_NativeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_NativeDef_var &
IR_NativeDef_var::operator= (const IR_NativeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_NativeDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_NativeDef_var::operator const IR_NativeDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_NativeDef_var::operator IR_NativeDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr 
IR_NativeDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr
IR_NativeDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr &
IR_NativeDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr &
IR_NativeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_NativeDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr 
IR_NativeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_NativeDef_ptr val = this->ptr_;
  this->ptr_ = IR_NativeDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_NativeDef_out
// *************************************************************

ACE_INLINE
IR_NativeDef_out::IR_NativeDef_out (IR_NativeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_NativeDef::_nil ();
}

ACE_INLINE
IR_NativeDef_out::IR_NativeDef_out (IR_NativeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_NativeDef::_nil ();
}

ACE_INLINE
IR_NativeDef_out::IR_NativeDef_out (const IR_NativeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_NativeDef_out&,p).ptr_)
{}

ACE_INLINE IR_NativeDef_out &
IR_NativeDef_out::operator= (const IR_NativeDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_NativeDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_NativeDef_out &
IR_NativeDef_out::operator= (const IR_NativeDef_var &p)
{
  this->ptr_ = IR_NativeDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_NativeDef_out &
IR_NativeDef_out::operator= (IR_NativeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_NativeDef_out::operator IR_NativeDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr &
IR_NativeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_NativeDef_ptr 
IR_NativeDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_InterfaceDef **
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_InterfaceDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_InterfaceDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_InterfaceDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::freebuf (IR_InterfaceDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_InterfaceDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq(const _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_InterfaceDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (this->maximum_);
      IR_InterfaceDef ** const tmp2 = ACE_reinterpret_cast (IR_InterfaceDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_InterfaceDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_InterfaceDef **tmp = ACE_reinterpret_cast (IR_InterfaceDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_InterfaceDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_InterfaceDef **tmp1 = ACE_reinterpret_cast (IR_InterfaceDef **, this->buffer_);
    IR_InterfaceDef ** const tmp2 = ACE_reinterpret_cast (IR_InterfaceDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_InterfaceDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_InterfaceDef ** const tmp = ACE_reinterpret_cast (IR_InterfaceDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_InterfaceDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_InterfaceDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_InterfaceDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_InterfaceDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_InterfaceDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_InterfaceDefSeq_var
// *************************************************************

ACE_INLINE
IR_InterfaceDefSeq_var::IR_InterfaceDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_InterfaceDefSeq_var::IR_InterfaceDefSeq_var (IR_InterfaceDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_InterfaceDefSeq_var::IR_InterfaceDefSeq_var (const ::IR_InterfaceDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_InterfaceDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_InterfaceDefSeq_var::~IR_InterfaceDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_InterfaceDefSeq_var &
IR_InterfaceDefSeq_var::operator= (IR_InterfaceDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_InterfaceDefSeq_var &
IR_InterfaceDefSeq_var::operator= (const ::IR_InterfaceDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_InterfaceDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_InterfaceDefSeq *
IR_InterfaceDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDefSeq *
IR_InterfaceDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_InterfaceDefSeq_var::operator const ::IR_InterfaceDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_InterfaceDefSeq_var::operator ::IR_InterfaceDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_InterfaceDefSeq_var::operator ::IR_InterfaceDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_InterfaceDefSeq_var::operator ::IR_InterfaceDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_InterfaceDef, IR_InterfaceDef_var>
IR_InterfaceDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_InterfaceDefSeq &
IR_InterfaceDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_InterfaceDefSeq &
IR_InterfaceDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_InterfaceDefSeq *&
IR_InterfaceDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDefSeq *
IR_InterfaceDefSeq_var::_retn (void)
{
  ::IR_InterfaceDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_InterfaceDefSeq *
IR_InterfaceDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_InterfaceDefSeq_out
// *************************************************************

ACE_INLINE
IR_InterfaceDefSeq_out::IR_InterfaceDefSeq_out (IR_InterfaceDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_InterfaceDefSeq_out::IR_InterfaceDefSeq_out (IR_InterfaceDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_InterfaceDefSeq_out::IR_InterfaceDefSeq_out (const ::IR_InterfaceDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_InterfaceDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_InterfaceDefSeq_out &
IR_InterfaceDefSeq_out::operator= (const ::IR_InterfaceDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_InterfaceDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_InterfaceDefSeq_out &
IR_InterfaceDefSeq_out::operator= (IR_InterfaceDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_InterfaceDefSeq_out::operator ::IR_InterfaceDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDefSeq *&
IR_InterfaceDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDefSeq *
IR_InterfaceDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_InterfaceDef, IR_InterfaceDef_var>
IR_InterfaceDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_ValueDef::IR_ValueDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ValueDef_var
// *************************************************************

ACE_INLINE
IR_ValueDef_var::IR_ValueDef_var (void) // default constructor
  : ptr_ (IR_ValueDef::_nil ())
{}

ACE_INLINE IR_ValueDef_ptr 
IR_ValueDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ValueDef_var::IR_ValueDef_var (const IR_ValueDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ValueDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ValueDef_var::~IR_ValueDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ValueDef_var &
IR_ValueDef_var::operator= (IR_ValueDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ValueDef_var &
IR_ValueDef_var::operator= (const IR_ValueDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ValueDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ValueDef_var::operator const IR_ValueDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ValueDef_var::operator IR_ValueDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr 
IR_ValueDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr
IR_ValueDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr &
IR_ValueDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr &
IR_ValueDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ValueDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr 
IR_ValueDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ValueDef_ptr val = this->ptr_;
  this->ptr_ = IR_ValueDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ValueDef_out
// *************************************************************

ACE_INLINE
IR_ValueDef_out::IR_ValueDef_out (IR_ValueDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ValueDef::_nil ();
}

ACE_INLINE
IR_ValueDef_out::IR_ValueDef_out (IR_ValueDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ValueDef::_nil ();
}

ACE_INLINE
IR_ValueDef_out::IR_ValueDef_out (const IR_ValueDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueDef_out&,p).ptr_)
{}

ACE_INLINE IR_ValueDef_out &
IR_ValueDef_out::operator= (const IR_ValueDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ValueDef_out &
IR_ValueDef_out::operator= (const IR_ValueDef_var &p)
{
  this->ptr_ = IR_ValueDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ValueDef_out &
IR_ValueDef_out::operator= (IR_ValueDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueDef_out::operator IR_ValueDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr &
IR_ValueDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ValueDef_ptr 
IR_ValueDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_ValueDef **
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_ValueDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_ValueDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_ValueDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::freebuf (IR_ValueDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ValueDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ValueDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (this->maximum_);
      IR_ValueDef ** const tmp2 = ACE_reinterpret_cast (IR_ValueDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_ValueDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_ValueDef **tmp = ACE_reinterpret_cast (IR_ValueDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_ValueDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ValueDef **tmp1 = ACE_reinterpret_cast (IR_ValueDef **, this->buffer_);
    IR_ValueDef ** const tmp2 = ACE_reinterpret_cast (IR_ValueDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_ValueDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_ValueDef ** const tmp = ACE_reinterpret_cast (IR_ValueDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_ValueDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ValueDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ValueDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ValueDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ValueDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ValueDefSeq_var
// *************************************************************

ACE_INLINE
IR_ValueDefSeq_var::IR_ValueDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ValueDefSeq_var::IR_ValueDefSeq_var (IR_ValueDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ValueDefSeq_var::IR_ValueDefSeq_var (const ::IR_ValueDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ValueDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ValueDefSeq_var::~IR_ValueDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ValueDefSeq_var &
IR_ValueDefSeq_var::operator= (IR_ValueDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ValueDefSeq_var &
IR_ValueDefSeq_var::operator= (const ::IR_ValueDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ValueDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ValueDefSeq *
IR_ValueDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDefSeq *
IR_ValueDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ValueDefSeq_var::operator const ::IR_ValueDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ValueDefSeq_var::operator ::IR_ValueDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ValueDefSeq_var::operator ::IR_ValueDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ValueDefSeq_var::operator ::IR_ValueDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ValueDef, IR_ValueDef_var>
IR_ValueDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ValueDefSeq &
IR_ValueDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ValueDefSeq &
IR_ValueDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ValueDefSeq *&
IR_ValueDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDefSeq *
IR_ValueDefSeq_var::_retn (void)
{
  ::IR_ValueDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ValueDefSeq *
IR_ValueDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ValueDefSeq_out
// *************************************************************

ACE_INLINE
IR_ValueDefSeq_out::IR_ValueDefSeq_out (IR_ValueDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueDefSeq_out::IR_ValueDefSeq_out (IR_ValueDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueDefSeq_out::IR_ValueDefSeq_out (const ::IR_ValueDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ValueDefSeq_out &
IR_ValueDefSeq_out::operator= (const ::IR_ValueDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ValueDefSeq_out &
IR_ValueDefSeq_out::operator= (IR_ValueDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueDefSeq_out::operator ::IR_ValueDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDefSeq *&
IR_ValueDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDefSeq *
IR_ValueDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ValueDef, IR_ValueDef_var>
IR_ValueDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_ValueBoxDef::IR_ValueBoxDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ValueBoxDef_var
// *************************************************************

ACE_INLINE
IR_ValueBoxDef_var::IR_ValueBoxDef_var (void) // default constructor
  : ptr_ (IR_ValueBoxDef::_nil ())
{}

ACE_INLINE IR_ValueBoxDef_ptr 
IR_ValueBoxDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ValueBoxDef_var::IR_ValueBoxDef_var (const IR_ValueBoxDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ValueBoxDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ValueBoxDef_var::~IR_ValueBoxDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ValueBoxDef_var &
IR_ValueBoxDef_var::operator= (IR_ValueBoxDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ValueBoxDef_var &
IR_ValueBoxDef_var::operator= (const IR_ValueBoxDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ValueBoxDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ValueBoxDef_var::operator const IR_ValueBoxDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ValueBoxDef_var::operator IR_ValueBoxDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr 
IR_ValueBoxDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr
IR_ValueBoxDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr &
IR_ValueBoxDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr &
IR_ValueBoxDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ValueBoxDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr 
IR_ValueBoxDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ValueBoxDef_ptr val = this->ptr_;
  this->ptr_ = IR_ValueBoxDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ValueBoxDef_out
// *************************************************************

ACE_INLINE
IR_ValueBoxDef_out::IR_ValueBoxDef_out (IR_ValueBoxDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ValueBoxDef::_nil ();
}

ACE_INLINE
IR_ValueBoxDef_out::IR_ValueBoxDef_out (IR_ValueBoxDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ValueBoxDef::_nil ();
}

ACE_INLINE
IR_ValueBoxDef_out::IR_ValueBoxDef_out (const IR_ValueBoxDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueBoxDef_out&,p).ptr_)
{}

ACE_INLINE IR_ValueBoxDef_out &
IR_ValueBoxDef_out::operator= (const IR_ValueBoxDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueBoxDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ValueBoxDef_out &
IR_ValueBoxDef_out::operator= (const IR_ValueBoxDef_var &p)
{
  this->ptr_ = IR_ValueBoxDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ValueBoxDef_out &
IR_ValueBoxDef_out::operator= (IR_ValueBoxDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueBoxDef_out::operator IR_ValueBoxDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr &
IR_ValueBoxDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ValueBoxDef_ptr 
IR_ValueBoxDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ComponentDef::IR_ComponentDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ComponentDef_var
// *************************************************************

ACE_INLINE
IR_ComponentDef_var::IR_ComponentDef_var (void) // default constructor
  : ptr_ (IR_ComponentDef::_nil ())
{}

ACE_INLINE IR_ComponentDef_ptr 
IR_ComponentDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ComponentDef_var::IR_ComponentDef_var (const IR_ComponentDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ComponentDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ComponentDef_var::~IR_ComponentDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ComponentDef_var &
IR_ComponentDef_var::operator= (IR_ComponentDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ComponentDef_var &
IR_ComponentDef_var::operator= (const IR_ComponentDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ComponentDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ComponentDef_var::operator const IR_ComponentDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ComponentDef_var::operator IR_ComponentDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr 
IR_ComponentDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr
IR_ComponentDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr &
IR_ComponentDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr &
IR_ComponentDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ComponentDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr 
IR_ComponentDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ComponentDef_ptr val = this->ptr_;
  this->ptr_ = IR_ComponentDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ComponentDef_out
// *************************************************************

ACE_INLINE
IR_ComponentDef_out::IR_ComponentDef_out (IR_ComponentDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ComponentDef::_nil ();
}

ACE_INLINE
IR_ComponentDef_out::IR_ComponentDef_out (IR_ComponentDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ComponentDef::_nil ();
}

ACE_INLINE
IR_ComponentDef_out::IR_ComponentDef_out (const IR_ComponentDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ComponentDef_out&,p).ptr_)
{}

ACE_INLINE IR_ComponentDef_out &
IR_ComponentDef_out::operator= (const IR_ComponentDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ComponentDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ComponentDef_out &
IR_ComponentDef_out::operator= (const IR_ComponentDef_var &p)
{
  this->ptr_ = IR_ComponentDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ComponentDef_out &
IR_ComponentDef_out::operator= (IR_ComponentDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ComponentDef_out::operator IR_ComponentDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr &
IR_ComponentDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ComponentDef_ptr 
IR_ComponentDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_ComponentDef **
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_ComponentDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_ComponentDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_ComponentDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (IR_ComponentDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ComponentDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ComponentDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (this->maximum_);
      IR_ComponentDef ** const tmp2 = ACE_reinterpret_cast (IR_ComponentDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_ComponentDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_ComponentDef **tmp = ACE_reinterpret_cast (IR_ComponentDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_ComponentDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ComponentDef **tmp1 = ACE_reinterpret_cast (IR_ComponentDef **, this->buffer_);
    IR_ComponentDef ** const tmp2 = ACE_reinterpret_cast (IR_ComponentDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_ComponentDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_ComponentDef ** const tmp = ACE_reinterpret_cast (IR_ComponentDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_ComponentDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ComponentDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ComponentDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ComponentDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ComponentDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ComponentDefSeq_var
// *************************************************************

ACE_INLINE
IR_ComponentDefSeq_var::IR_ComponentDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ComponentDefSeq_var::IR_ComponentDefSeq_var (IR_ComponentDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ComponentDefSeq_var::IR_ComponentDefSeq_var (const ::IR_ComponentDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ComponentDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ComponentDefSeq_var::~IR_ComponentDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ComponentDefSeq_var &
IR_ComponentDefSeq_var::operator= (IR_ComponentDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ComponentDefSeq_var &
IR_ComponentDefSeq_var::operator= (const ::IR_ComponentDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ComponentDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ComponentDefSeq *
IR_ComponentDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDefSeq *
IR_ComponentDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ComponentDefSeq_var::operator const ::IR_ComponentDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ComponentDefSeq_var::operator ::IR_ComponentDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ComponentDefSeq_var::operator ::IR_ComponentDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ComponentDefSeq_var::operator ::IR_ComponentDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ComponentDef, IR_ComponentDef_var>
IR_ComponentDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ComponentDefSeq &
IR_ComponentDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ComponentDefSeq &
IR_ComponentDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ComponentDefSeq *&
IR_ComponentDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDefSeq *
IR_ComponentDefSeq_var::_retn (void)
{
  ::IR_ComponentDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ComponentDefSeq *
IR_ComponentDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ComponentDefSeq_out
// *************************************************************

ACE_INLINE
IR_ComponentDefSeq_out::IR_ComponentDefSeq_out (IR_ComponentDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ComponentDefSeq_out::IR_ComponentDefSeq_out (IR_ComponentDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ComponentDefSeq_out::IR_ComponentDefSeq_out (const ::IR_ComponentDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ComponentDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ComponentDefSeq_out &
IR_ComponentDefSeq_out::operator= (const ::IR_ComponentDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ComponentDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ComponentDefSeq_out &
IR_ComponentDefSeq_out::operator= (IR_ComponentDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ComponentDefSeq_out::operator ::IR_ComponentDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDefSeq *&
IR_ComponentDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDefSeq *
IR_ComponentDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ComponentDef, IR_ComponentDef_var>
IR_ComponentDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_ProvidesDef::IR_ProvidesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ProvidesDef_var
// *************************************************************

ACE_INLINE
IR_ProvidesDef_var::IR_ProvidesDef_var (void) // default constructor
  : ptr_ (IR_ProvidesDef::_nil ())
{}

ACE_INLINE IR_ProvidesDef_ptr 
IR_ProvidesDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ProvidesDef_var::IR_ProvidesDef_var (const IR_ProvidesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ProvidesDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ProvidesDef_var::~IR_ProvidesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ProvidesDef_var &
IR_ProvidesDef_var::operator= (IR_ProvidesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ProvidesDef_var &
IR_ProvidesDef_var::operator= (const IR_ProvidesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ProvidesDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ProvidesDef_var::operator const IR_ProvidesDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ProvidesDef_var::operator IR_ProvidesDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr 
IR_ProvidesDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr
IR_ProvidesDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr &
IR_ProvidesDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr &
IR_ProvidesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ProvidesDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr 
IR_ProvidesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ProvidesDef_ptr val = this->ptr_;
  this->ptr_ = IR_ProvidesDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ProvidesDef_out
// *************************************************************

ACE_INLINE
IR_ProvidesDef_out::IR_ProvidesDef_out (IR_ProvidesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ProvidesDef::_nil ();
}

ACE_INLINE
IR_ProvidesDef_out::IR_ProvidesDef_out (IR_ProvidesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ProvidesDef::_nil ();
}

ACE_INLINE
IR_ProvidesDef_out::IR_ProvidesDef_out (const IR_ProvidesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ProvidesDef_out&,p).ptr_)
{}

ACE_INLINE IR_ProvidesDef_out &
IR_ProvidesDef_out::operator= (const IR_ProvidesDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ProvidesDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ProvidesDef_out &
IR_ProvidesDef_out::operator= (const IR_ProvidesDef_var &p)
{
  this->ptr_ = IR_ProvidesDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ProvidesDef_out &
IR_ProvidesDef_out::operator= (IR_ProvidesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ProvidesDef_out::operator IR_ProvidesDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr &
IR_ProvidesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDef_ptr 
IR_ProvidesDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_ProvidesDef **
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_ProvidesDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_ProvidesDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_ProvidesDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (IR_ProvidesDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ProvidesDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ProvidesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (this->maximum_);
      IR_ProvidesDef ** const tmp2 = ACE_reinterpret_cast (IR_ProvidesDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_ProvidesDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_ProvidesDef **tmp = ACE_reinterpret_cast (IR_ProvidesDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_ProvidesDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ProvidesDef **tmp1 = ACE_reinterpret_cast (IR_ProvidesDef **, this->buffer_);
    IR_ProvidesDef ** const tmp2 = ACE_reinterpret_cast (IR_ProvidesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_ProvidesDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_ProvidesDef ** const tmp = ACE_reinterpret_cast (IR_ProvidesDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_ProvidesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ProvidesDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ProvidesDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ProvidesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ProvidesDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ProvidesDefSeq_var
// *************************************************************

ACE_INLINE
IR_ProvidesDefSeq_var::IR_ProvidesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ProvidesDefSeq_var::IR_ProvidesDefSeq_var (IR_ProvidesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ProvidesDefSeq_var::IR_ProvidesDefSeq_var (const ::IR_ProvidesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ProvidesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDefSeq_var::~IR_ProvidesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ProvidesDefSeq_var &
IR_ProvidesDefSeq_var::operator= (IR_ProvidesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ProvidesDefSeq_var &
IR_ProvidesDefSeq_var::operator= (const ::IR_ProvidesDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ProvidesDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ProvidesDefSeq *
IR_ProvidesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDefSeq *
IR_ProvidesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ProvidesDefSeq_var::operator const ::IR_ProvidesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ProvidesDefSeq_var::operator ::IR_ProvidesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ProvidesDefSeq_var::operator ::IR_ProvidesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ProvidesDefSeq_var::operator ::IR_ProvidesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ProvidesDef, IR_ProvidesDef_var>
IR_ProvidesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ProvidesDefSeq &
IR_ProvidesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ProvidesDefSeq &
IR_ProvidesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ProvidesDefSeq *&
IR_ProvidesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDefSeq *
IR_ProvidesDefSeq_var::_retn (void)
{
  ::IR_ProvidesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ProvidesDefSeq *
IR_ProvidesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ProvidesDefSeq_out
// *************************************************************

ACE_INLINE
IR_ProvidesDefSeq_out::IR_ProvidesDefSeq_out (IR_ProvidesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDefSeq_out::IR_ProvidesDefSeq_out (IR_ProvidesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDefSeq_out::IR_ProvidesDefSeq_out (const ::IR_ProvidesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ProvidesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ProvidesDefSeq_out &
IR_ProvidesDefSeq_out::operator= (const ::IR_ProvidesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ProvidesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ProvidesDefSeq_out &
IR_ProvidesDefSeq_out::operator= (IR_ProvidesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ProvidesDefSeq_out::operator ::IR_ProvidesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDefSeq *&
IR_ProvidesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDefSeq *
IR_ProvidesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ProvidesDef, IR_ProvidesDef_var>
IR_ProvidesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_UsesDef::IR_UsesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_UsesDef_var
// *************************************************************

ACE_INLINE
IR_UsesDef_var::IR_UsesDef_var (void) // default constructor
  : ptr_ (IR_UsesDef::_nil ())
{}

ACE_INLINE IR_UsesDef_ptr 
IR_UsesDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_UsesDef_var::IR_UsesDef_var (const IR_UsesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_UsesDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_UsesDef_var::~IR_UsesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_UsesDef_var &
IR_UsesDef_var::operator= (IR_UsesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_UsesDef_var &
IR_UsesDef_var::operator= (const IR_UsesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_UsesDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_UsesDef_var::operator const IR_UsesDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_UsesDef_var::operator IR_UsesDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr 
IR_UsesDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr
IR_UsesDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr &
IR_UsesDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr &
IR_UsesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_UsesDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr 
IR_UsesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_UsesDef_ptr val = this->ptr_;
  this->ptr_ = IR_UsesDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_UsesDef_out
// *************************************************************

ACE_INLINE
IR_UsesDef_out::IR_UsesDef_out (IR_UsesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_UsesDef::_nil ();
}

ACE_INLINE
IR_UsesDef_out::IR_UsesDef_out (IR_UsesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_UsesDef::_nil ();
}

ACE_INLINE
IR_UsesDef_out::IR_UsesDef_out (const IR_UsesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UsesDef_out&,p).ptr_)
{}

ACE_INLINE IR_UsesDef_out &
IR_UsesDef_out::operator= (const IR_UsesDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UsesDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_UsesDef_out &
IR_UsesDef_out::operator= (const IR_UsesDef_var &p)
{
  this->ptr_ = IR_UsesDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_UsesDef_out &
IR_UsesDef_out::operator= (IR_UsesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UsesDef_out::operator IR_UsesDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr &
IR_UsesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDef_ptr 
IR_UsesDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_UsesDef **
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_UsesDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_UsesDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_UsesDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (IR_UsesDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_UsesDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_UsesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (this->maximum_);
      IR_UsesDef ** const tmp2 = ACE_reinterpret_cast (IR_UsesDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_UsesDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_UsesDef **tmp = ACE_reinterpret_cast (IR_UsesDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_UsesDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_UsesDef **tmp1 = ACE_reinterpret_cast (IR_UsesDef **, this->buffer_);
    IR_UsesDef ** const tmp2 = ACE_reinterpret_cast (IR_UsesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_UsesDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_UsesDef ** const tmp = ACE_reinterpret_cast (IR_UsesDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_UsesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_UsesDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_UsesDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_UsesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_UsesDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_UsesDefSeq_var
// *************************************************************

ACE_INLINE
IR_UsesDefSeq_var::IR_UsesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_UsesDefSeq_var::IR_UsesDefSeq_var (IR_UsesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_UsesDefSeq_var::IR_UsesDefSeq_var (const ::IR_UsesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_UsesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDefSeq_var::~IR_UsesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_UsesDefSeq_var &
IR_UsesDefSeq_var::operator= (IR_UsesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_UsesDefSeq_var &
IR_UsesDefSeq_var::operator= (const ::IR_UsesDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_UsesDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_UsesDefSeq *
IR_UsesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDefSeq *
IR_UsesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_UsesDefSeq_var::operator const ::IR_UsesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_UsesDefSeq_var::operator ::IR_UsesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_UsesDefSeq_var::operator ::IR_UsesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_UsesDefSeq_var::operator ::IR_UsesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_UsesDef, IR_UsesDef_var>
IR_UsesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_UsesDefSeq &
IR_UsesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_UsesDefSeq &
IR_UsesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_UsesDefSeq *&
IR_UsesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDefSeq *
IR_UsesDefSeq_var::_retn (void)
{
  ::IR_UsesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_UsesDefSeq *
IR_UsesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_UsesDefSeq_out
// *************************************************************

ACE_INLINE
IR_UsesDefSeq_out::IR_UsesDefSeq_out (IR_UsesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDefSeq_out::IR_UsesDefSeq_out (IR_UsesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDefSeq_out::IR_UsesDefSeq_out (const ::IR_UsesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UsesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_UsesDefSeq_out &
IR_UsesDefSeq_out::operator= (const ::IR_UsesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UsesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_UsesDefSeq_out &
IR_UsesDefSeq_out::operator= (IR_UsesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UsesDefSeq_out::operator ::IR_UsesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDefSeq *&
IR_UsesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDefSeq *
IR_UsesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_UsesDef, IR_UsesDef_var>
IR_UsesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_HomeDef::IR_HomeDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_HomeDef_var
// *************************************************************

ACE_INLINE
IR_HomeDef_var::IR_HomeDef_var (void) // default constructor
  : ptr_ (IR_HomeDef::_nil ())
{}

ACE_INLINE IR_HomeDef_ptr 
IR_HomeDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_HomeDef_var::IR_HomeDef_var (const IR_HomeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_HomeDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_HomeDef_var::~IR_HomeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_HomeDef_var &
IR_HomeDef_var::operator= (IR_HomeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_HomeDef_var &
IR_HomeDef_var::operator= (const IR_HomeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_HomeDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_HomeDef_var::operator const IR_HomeDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_HomeDef_var::operator IR_HomeDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr 
IR_HomeDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr
IR_HomeDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr &
IR_HomeDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr &
IR_HomeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_HomeDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr 
IR_HomeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_HomeDef_ptr val = this->ptr_;
  this->ptr_ = IR_HomeDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_HomeDef_out
// *************************************************************

ACE_INLINE
IR_HomeDef_out::IR_HomeDef_out (IR_HomeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_HomeDef::_nil ();
}

ACE_INLINE
IR_HomeDef_out::IR_HomeDef_out (IR_HomeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_HomeDef::_nil ();
}

ACE_INLINE
IR_HomeDef_out::IR_HomeDef_out (const IR_HomeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_HomeDef_out&,p).ptr_)
{}

ACE_INLINE IR_HomeDef_out &
IR_HomeDef_out::operator= (const IR_HomeDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_HomeDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_HomeDef_out &
IR_HomeDef_out::operator= (const IR_HomeDef_var &p)
{
  this->ptr_ = IR_HomeDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_HomeDef_out &
IR_HomeDef_out::operator= (IR_HomeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_HomeDef_out::operator IR_HomeDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr &
IR_HomeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_HomeDef_ptr 
IR_HomeDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_HomeDef **
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_HomeDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_HomeDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_HomeDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (IR_HomeDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_HomeDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq(const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_HomeDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (this->maximum_);
      IR_HomeDef ** const tmp2 = ACE_reinterpret_cast (IR_HomeDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_HomeDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_HomeDef **tmp = ACE_reinterpret_cast (IR_HomeDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_HomeDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_HomeDef **tmp1 = ACE_reinterpret_cast (IR_HomeDef **, this->buffer_);
    IR_HomeDef ** const tmp2 = ACE_reinterpret_cast (IR_HomeDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_HomeDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_HomeDef ** const tmp = ACE_reinterpret_cast (IR_HomeDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_HomeDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_HomeDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_HomeDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_HomeDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_HomeDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_HomeDefSeq_var
// *************************************************************

ACE_INLINE
IR_HomeDefSeq_var::IR_HomeDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_HomeDefSeq_var::IR_HomeDefSeq_var (IR_HomeDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_HomeDefSeq_var::IR_HomeDefSeq_var (const ::IR_HomeDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_HomeDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_HomeDefSeq_var::~IR_HomeDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_HomeDefSeq_var &
IR_HomeDefSeq_var::operator= (IR_HomeDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_HomeDefSeq_var &
IR_HomeDefSeq_var::operator= (const ::IR_HomeDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_HomeDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_HomeDefSeq *
IR_HomeDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDefSeq *
IR_HomeDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_HomeDefSeq_var::operator const ::IR_HomeDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_HomeDefSeq_var::operator ::IR_HomeDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_HomeDefSeq_var::operator ::IR_HomeDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_HomeDefSeq_var::operator ::IR_HomeDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_HomeDef, IR_HomeDef_var>
IR_HomeDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_HomeDefSeq &
IR_HomeDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_HomeDefSeq &
IR_HomeDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_HomeDefSeq *&
IR_HomeDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDefSeq *
IR_HomeDefSeq_var::_retn (void)
{
  ::IR_HomeDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_HomeDefSeq *
IR_HomeDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_HomeDefSeq_out
// *************************************************************

ACE_INLINE
IR_HomeDefSeq_out::IR_HomeDefSeq_out (IR_HomeDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_HomeDefSeq_out::IR_HomeDefSeq_out (IR_HomeDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_HomeDefSeq_out::IR_HomeDefSeq_out (const ::IR_HomeDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_HomeDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_HomeDefSeq_out &
IR_HomeDefSeq_out::operator= (const ::IR_HomeDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_HomeDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_HomeDefSeq_out &
IR_HomeDefSeq_out::operator= (IR_HomeDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_HomeDefSeq_out::operator ::IR_HomeDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDefSeq *&
IR_HomeDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDefSeq *
IR_HomeDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_HomeDef, IR_HomeDef_var>
IR_HomeDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_EventDef::IR_EventDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_EventDef_var
// *************************************************************

ACE_INLINE
IR_EventDef_var::IR_EventDef_var (void) // default constructor
  : ptr_ (IR_EventDef::_nil ())
{}

ACE_INLINE IR_EventDef_ptr 
IR_EventDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_EventDef_var::IR_EventDef_var (const IR_EventDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_EventDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_EventDef_var::~IR_EventDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_EventDef_var &
IR_EventDef_var::operator= (IR_EventDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_EventDef_var &
IR_EventDef_var::operator= (const IR_EventDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_EventDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_EventDef_var::operator const IR_EventDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_EventDef_var::operator IR_EventDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr 
IR_EventDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr
IR_EventDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr &
IR_EventDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr &
IR_EventDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_EventDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr 
IR_EventDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_EventDef_ptr val = this->ptr_;
  this->ptr_ = IR_EventDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_EventDef_out
// *************************************************************

ACE_INLINE
IR_EventDef_out::IR_EventDef_out (IR_EventDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_EventDef::_nil ();
}

ACE_INLINE
IR_EventDef_out::IR_EventDef_out (IR_EventDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_EventDef::_nil ();
}

ACE_INLINE
IR_EventDef_out::IR_EventDef_out (const IR_EventDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_EventDef_out&,p).ptr_)
{}

ACE_INLINE IR_EventDef_out &
IR_EventDef_out::operator= (const IR_EventDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_EventDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_EventDef_out &
IR_EventDef_out::operator= (const IR_EventDef_var &p)
{
  this->ptr_ = IR_EventDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_EventDef_out &
IR_EventDef_out::operator= (IR_EventDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_EventDef_out::operator IR_EventDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr &
IR_EventDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_EventDef_ptr 
IR_EventDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_EmitsDef::IR_EmitsDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_EmitsDef_var
// *************************************************************

ACE_INLINE
IR_EmitsDef_var::IR_EmitsDef_var (void) // default constructor
  : ptr_ (IR_EmitsDef::_nil ())
{}

ACE_INLINE IR_EmitsDef_ptr 
IR_EmitsDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_EmitsDef_var::IR_EmitsDef_var (const IR_EmitsDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_EmitsDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_EmitsDef_var::~IR_EmitsDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_EmitsDef_var &
IR_EmitsDef_var::operator= (IR_EmitsDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_EmitsDef_var &
IR_EmitsDef_var::operator= (const IR_EmitsDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_EmitsDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_EmitsDef_var::operator const IR_EmitsDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_EmitsDef_var::operator IR_EmitsDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr 
IR_EmitsDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr
IR_EmitsDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr &
IR_EmitsDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr &
IR_EmitsDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_EmitsDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr 
IR_EmitsDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_EmitsDef_ptr val = this->ptr_;
  this->ptr_ = IR_EmitsDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_EmitsDef_out
// *************************************************************

ACE_INLINE
IR_EmitsDef_out::IR_EmitsDef_out (IR_EmitsDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_EmitsDef::_nil ();
}

ACE_INLINE
IR_EmitsDef_out::IR_EmitsDef_out (IR_EmitsDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_EmitsDef::_nil ();
}

ACE_INLINE
IR_EmitsDef_out::IR_EmitsDef_out (const IR_EmitsDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_EmitsDef_out&,p).ptr_)
{}

ACE_INLINE IR_EmitsDef_out &
IR_EmitsDef_out::operator= (const IR_EmitsDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_EmitsDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_EmitsDef_out &
IR_EmitsDef_out::operator= (const IR_EmitsDef_var &p)
{
  this->ptr_ = IR_EmitsDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_EmitsDef_out &
IR_EmitsDef_out::operator= (IR_EmitsDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_EmitsDef_out::operator IR_EmitsDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr &
IR_EmitsDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_EmitsDef_ptr 
IR_EmitsDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_EmitsDef **
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_EmitsDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_EmitsDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_EmitsDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (IR_EmitsDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_EmitsDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq(const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_EmitsDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (this->maximum_);
      IR_EmitsDef ** const tmp2 = ACE_reinterpret_cast (IR_EmitsDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_EmitsDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_EmitsDef **tmp = ACE_reinterpret_cast (IR_EmitsDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_EmitsDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_EmitsDef **tmp1 = ACE_reinterpret_cast (IR_EmitsDef **, this->buffer_);
    IR_EmitsDef ** const tmp2 = ACE_reinterpret_cast (IR_EmitsDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_EmitsDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_EmitsDef ** const tmp = ACE_reinterpret_cast (IR_EmitsDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_EmitsDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_EmitsDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_EmitsDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_EmitsDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_EmitsDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_EmitsDefSeq_var
// *************************************************************

ACE_INLINE
IR_EmitsDefSeq_var::IR_EmitsDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_EmitsDefSeq_var::IR_EmitsDefSeq_var (IR_EmitsDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_EmitsDefSeq_var::IR_EmitsDefSeq_var (const ::IR_EmitsDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_EmitsDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_EmitsDefSeq_var::~IR_EmitsDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_EmitsDefSeq_var &
IR_EmitsDefSeq_var::operator= (IR_EmitsDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_EmitsDefSeq_var &
IR_EmitsDefSeq_var::operator= (const ::IR_EmitsDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_EmitsDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_EmitsDefSeq *
IR_EmitsDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_EmitsDefSeq *
IR_EmitsDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_EmitsDefSeq_var::operator const ::IR_EmitsDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_EmitsDefSeq_var::operator ::IR_EmitsDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_EmitsDefSeq_var::operator ::IR_EmitsDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_EmitsDefSeq_var::operator ::IR_EmitsDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_EmitsDef, IR_EmitsDef_var>
IR_EmitsDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_EmitsDefSeq &
IR_EmitsDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_EmitsDefSeq &
IR_EmitsDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_EmitsDefSeq *&
IR_EmitsDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_EmitsDefSeq *
IR_EmitsDefSeq_var::_retn (void)
{
  ::IR_EmitsDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_EmitsDefSeq *
IR_EmitsDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_EmitsDefSeq_out
// *************************************************************

ACE_INLINE
IR_EmitsDefSeq_out::IR_EmitsDefSeq_out (IR_EmitsDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_EmitsDefSeq_out::IR_EmitsDefSeq_out (IR_EmitsDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_EmitsDefSeq_out::IR_EmitsDefSeq_out (const ::IR_EmitsDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_EmitsDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_EmitsDefSeq_out &
IR_EmitsDefSeq_out::operator= (const ::IR_EmitsDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_EmitsDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_EmitsDefSeq_out &
IR_EmitsDefSeq_out::operator= (IR_EmitsDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_EmitsDefSeq_out::operator ::IR_EmitsDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_EmitsDefSeq *&
IR_EmitsDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_EmitsDefSeq *
IR_EmitsDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_EmitsDef, IR_EmitsDef_var>
IR_EmitsDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_PublishesDef::IR_PublishesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_PublishesDef_var
// *************************************************************

ACE_INLINE
IR_PublishesDef_var::IR_PublishesDef_var (void) // default constructor
  : ptr_ (IR_PublishesDef::_nil ())
{}

ACE_INLINE IR_PublishesDef_ptr 
IR_PublishesDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_PublishesDef_var::IR_PublishesDef_var (const IR_PublishesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_PublishesDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_PublishesDef_var::~IR_PublishesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_PublishesDef_var &
IR_PublishesDef_var::operator= (IR_PublishesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_PublishesDef_var &
IR_PublishesDef_var::operator= (const IR_PublishesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_PublishesDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_PublishesDef_var::operator const IR_PublishesDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_PublishesDef_var::operator IR_PublishesDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr 
IR_PublishesDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr
IR_PublishesDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr &
IR_PublishesDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr &
IR_PublishesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_PublishesDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr 
IR_PublishesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_PublishesDef_ptr val = this->ptr_;
  this->ptr_ = IR_PublishesDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_PublishesDef_out
// *************************************************************

ACE_INLINE
IR_PublishesDef_out::IR_PublishesDef_out (IR_PublishesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_PublishesDef::_nil ();
}

ACE_INLINE
IR_PublishesDef_out::IR_PublishesDef_out (IR_PublishesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_PublishesDef::_nil ();
}

ACE_INLINE
IR_PublishesDef_out::IR_PublishesDef_out (const IR_PublishesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_PublishesDef_out&,p).ptr_)
{}

ACE_INLINE IR_PublishesDef_out &
IR_PublishesDef_out::operator= (const IR_PublishesDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_PublishesDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_PublishesDef_out &
IR_PublishesDef_out::operator= (const IR_PublishesDef_var &p)
{
  this->ptr_ = IR_PublishesDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_PublishesDef_out &
IR_PublishesDef_out::operator= (IR_PublishesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_PublishesDef_out::operator IR_PublishesDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr &
IR_PublishesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_PublishesDef_ptr 
IR_PublishesDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_PublishesDef **
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_PublishesDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_PublishesDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_PublishesDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (IR_PublishesDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_PublishesDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_PublishesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (this->maximum_);
      IR_PublishesDef ** const tmp2 = ACE_reinterpret_cast (IR_PublishesDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_PublishesDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_PublishesDef **tmp = ACE_reinterpret_cast (IR_PublishesDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_PublishesDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_PublishesDef **tmp1 = ACE_reinterpret_cast (IR_PublishesDef **, this->buffer_);
    IR_PublishesDef ** const tmp2 = ACE_reinterpret_cast (IR_PublishesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_PublishesDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_PublishesDef ** const tmp = ACE_reinterpret_cast (IR_PublishesDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_PublishesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_PublishesDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_PublishesDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_PublishesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_PublishesDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_PublishesDefSeq_var
// *************************************************************

ACE_INLINE
IR_PublishesDefSeq_var::IR_PublishesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_PublishesDefSeq_var::IR_PublishesDefSeq_var (IR_PublishesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_PublishesDefSeq_var::IR_PublishesDefSeq_var (const ::IR_PublishesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_PublishesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_PublishesDefSeq_var::~IR_PublishesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_PublishesDefSeq_var &
IR_PublishesDefSeq_var::operator= (IR_PublishesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_PublishesDefSeq_var &
IR_PublishesDefSeq_var::operator= (const ::IR_PublishesDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_PublishesDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_PublishesDefSeq *
IR_PublishesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_PublishesDefSeq *
IR_PublishesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_PublishesDefSeq_var::operator const ::IR_PublishesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_PublishesDefSeq_var::operator ::IR_PublishesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_PublishesDefSeq_var::operator ::IR_PublishesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_PublishesDefSeq_var::operator ::IR_PublishesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_PublishesDef, IR_PublishesDef_var>
IR_PublishesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_PublishesDefSeq &
IR_PublishesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_PublishesDefSeq &
IR_PublishesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_PublishesDefSeq *&
IR_PublishesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_PublishesDefSeq *
IR_PublishesDefSeq_var::_retn (void)
{
  ::IR_PublishesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_PublishesDefSeq *
IR_PublishesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_PublishesDefSeq_out
// *************************************************************

ACE_INLINE
IR_PublishesDefSeq_out::IR_PublishesDefSeq_out (IR_PublishesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_PublishesDefSeq_out::IR_PublishesDefSeq_out (IR_PublishesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_PublishesDefSeq_out::IR_PublishesDefSeq_out (const ::IR_PublishesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_PublishesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_PublishesDefSeq_out &
IR_PublishesDefSeq_out::operator= (const ::IR_PublishesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_PublishesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_PublishesDefSeq_out &
IR_PublishesDefSeq_out::operator= (IR_PublishesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_PublishesDefSeq_out::operator ::IR_PublishesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_PublishesDefSeq *&
IR_PublishesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_PublishesDefSeq *
IR_PublishesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_PublishesDef, IR_PublishesDef_var>
IR_PublishesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_ConsumesDef::IR_ConsumesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ConsumesDef_var
// *************************************************************

ACE_INLINE
IR_ConsumesDef_var::IR_ConsumesDef_var (void) // default constructor
  : ptr_ (IR_ConsumesDef::_nil ())
{}

ACE_INLINE IR_ConsumesDef_ptr 
IR_ConsumesDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ConsumesDef_var::IR_ConsumesDef_var (const IR_ConsumesDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ConsumesDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ConsumesDef_var::~IR_ConsumesDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ConsumesDef_var &
IR_ConsumesDef_var::operator= (IR_ConsumesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ConsumesDef_var &
IR_ConsumesDef_var::operator= (const IR_ConsumesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ConsumesDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ConsumesDef_var::operator const IR_ConsumesDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ConsumesDef_var::operator IR_ConsumesDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr 
IR_ConsumesDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr
IR_ConsumesDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr &
IR_ConsumesDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr &
IR_ConsumesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ConsumesDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr 
IR_ConsumesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ConsumesDef_ptr val = this->ptr_;
  this->ptr_ = IR_ConsumesDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ConsumesDef_out
// *************************************************************

ACE_INLINE
IR_ConsumesDef_out::IR_ConsumesDef_out (IR_ConsumesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ConsumesDef::_nil ();
}

ACE_INLINE
IR_ConsumesDef_out::IR_ConsumesDef_out (IR_ConsumesDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ConsumesDef::_nil ();
}

ACE_INLINE
IR_ConsumesDef_out::IR_ConsumesDef_out (const IR_ConsumesDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ConsumesDef_out&,p).ptr_)
{}

ACE_INLINE IR_ConsumesDef_out &
IR_ConsumesDef_out::operator= (const IR_ConsumesDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ConsumesDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ConsumesDef_out &
IR_ConsumesDef_out::operator= (const IR_ConsumesDef_var &p)
{
  this->ptr_ = IR_ConsumesDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ConsumesDef_out &
IR_ConsumesDef_out::operator= (IR_ConsumesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ConsumesDef_out::operator IR_ConsumesDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr &
IR_ConsumesDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ConsumesDef_ptr 
IR_ConsumesDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_ConsumesDef **
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_ConsumesDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_ConsumesDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_ConsumesDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (IR_ConsumesDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ConsumesDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ConsumesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (this->maximum_);
      IR_ConsumesDef ** const tmp2 = ACE_reinterpret_cast (IR_ConsumesDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_ConsumesDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_ConsumesDef **tmp = ACE_reinterpret_cast (IR_ConsumesDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_ConsumesDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ConsumesDef **tmp1 = ACE_reinterpret_cast (IR_ConsumesDef **, this->buffer_);
    IR_ConsumesDef ** const tmp2 = ACE_reinterpret_cast (IR_ConsumesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_ConsumesDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_ConsumesDef ** const tmp = ACE_reinterpret_cast (IR_ConsumesDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_ConsumesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ConsumesDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ConsumesDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ConsumesDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ConsumesDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ConsumesDefSeq_var
// *************************************************************

ACE_INLINE
IR_ConsumesDefSeq_var::IR_ConsumesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ConsumesDefSeq_var::IR_ConsumesDefSeq_var (IR_ConsumesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ConsumesDefSeq_var::IR_ConsumesDefSeq_var (const ::IR_ConsumesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ConsumesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ConsumesDefSeq_var::~IR_ConsumesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ConsumesDefSeq_var &
IR_ConsumesDefSeq_var::operator= (IR_ConsumesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ConsumesDefSeq_var &
IR_ConsumesDefSeq_var::operator= (const ::IR_ConsumesDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ConsumesDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ConsumesDefSeq *
IR_ConsumesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ConsumesDefSeq *
IR_ConsumesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ConsumesDefSeq_var::operator const ::IR_ConsumesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ConsumesDefSeq_var::operator ::IR_ConsumesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ConsumesDefSeq_var::operator ::IR_ConsumesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ConsumesDefSeq_var::operator ::IR_ConsumesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ConsumesDef, IR_ConsumesDef_var>
IR_ConsumesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ConsumesDefSeq &
IR_ConsumesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ConsumesDefSeq &
IR_ConsumesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ConsumesDefSeq *&
IR_ConsumesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ConsumesDefSeq *
IR_ConsumesDefSeq_var::_retn (void)
{
  ::IR_ConsumesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ConsumesDefSeq *
IR_ConsumesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ConsumesDefSeq_out
// *************************************************************

ACE_INLINE
IR_ConsumesDefSeq_out::IR_ConsumesDefSeq_out (IR_ConsumesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ConsumesDefSeq_out::IR_ConsumesDefSeq_out (IR_ConsumesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ConsumesDefSeq_out::IR_ConsumesDefSeq_out (const ::IR_ConsumesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ConsumesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ConsumesDefSeq_out &
IR_ConsumesDefSeq_out::operator= (const ::IR_ConsumesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ConsumesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ConsumesDefSeq_out &
IR_ConsumesDefSeq_out::operator= (IR_ConsumesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ConsumesDefSeq_out::operator ::IR_ConsumesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ConsumesDefSeq *&
IR_ConsumesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ConsumesDefSeq *
IR_ConsumesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ConsumesDef, IR_ConsumesDef_var>
IR_ConsumesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_FactoryDef::IR_FactoryDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_FactoryDef_var
// *************************************************************

ACE_INLINE
IR_FactoryDef_var::IR_FactoryDef_var (void) // default constructor
  : ptr_ (IR_FactoryDef::_nil ())
{}

ACE_INLINE IR_FactoryDef_ptr 
IR_FactoryDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_FactoryDef_var::IR_FactoryDef_var (const IR_FactoryDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_FactoryDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_FactoryDef_var::~IR_FactoryDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_FactoryDef_var &
IR_FactoryDef_var::operator= (IR_FactoryDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_FactoryDef_var &
IR_FactoryDef_var::operator= (const IR_FactoryDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_FactoryDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_FactoryDef_var::operator const IR_FactoryDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_FactoryDef_var::operator IR_FactoryDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr 
IR_FactoryDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr
IR_FactoryDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr &
IR_FactoryDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr &
IR_FactoryDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_FactoryDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr 
IR_FactoryDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_FactoryDef_ptr val = this->ptr_;
  this->ptr_ = IR_FactoryDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_FactoryDef_out
// *************************************************************

ACE_INLINE
IR_FactoryDef_out::IR_FactoryDef_out (IR_FactoryDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_FactoryDef::_nil ();
}

ACE_INLINE
IR_FactoryDef_out::IR_FactoryDef_out (IR_FactoryDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_FactoryDef::_nil ();
}

ACE_INLINE
IR_FactoryDef_out::IR_FactoryDef_out (const IR_FactoryDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_FactoryDef_out&,p).ptr_)
{}

ACE_INLINE IR_FactoryDef_out &
IR_FactoryDef_out::operator= (const IR_FactoryDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_FactoryDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_FactoryDef_out &
IR_FactoryDef_out::operator= (const IR_FactoryDef_var &p)
{
  this->ptr_ = IR_FactoryDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_FactoryDef_out &
IR_FactoryDef_out::operator= (IR_FactoryDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_FactoryDef_out::operator IR_FactoryDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr &
IR_FactoryDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_FactoryDef_ptr 
IR_FactoryDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_FactoryDef **
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_FactoryDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_FactoryDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_FactoryDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (IR_FactoryDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_FactoryDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq(const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_FactoryDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (this->maximum_);
      IR_FactoryDef ** const tmp2 = ACE_reinterpret_cast (IR_FactoryDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_FactoryDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_FactoryDef **tmp = ACE_reinterpret_cast (IR_FactoryDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_FactoryDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_FactoryDef **tmp1 = ACE_reinterpret_cast (IR_FactoryDef **, this->buffer_);
    IR_FactoryDef ** const tmp2 = ACE_reinterpret_cast (IR_FactoryDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_FactoryDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_FactoryDef ** const tmp = ACE_reinterpret_cast (IR_FactoryDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_FactoryDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_FactoryDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_FactoryDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_FactoryDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_FactoryDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_FactoryDefSeq_var
// *************************************************************

ACE_INLINE
IR_FactoryDefSeq_var::IR_FactoryDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_FactoryDefSeq_var::IR_FactoryDefSeq_var (IR_FactoryDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_FactoryDefSeq_var::IR_FactoryDefSeq_var (const ::IR_FactoryDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_FactoryDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_FactoryDefSeq_var::~IR_FactoryDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_FactoryDefSeq_var &
IR_FactoryDefSeq_var::operator= (IR_FactoryDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_FactoryDefSeq_var &
IR_FactoryDefSeq_var::operator= (const ::IR_FactoryDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_FactoryDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_FactoryDefSeq *
IR_FactoryDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_FactoryDefSeq *
IR_FactoryDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_FactoryDefSeq_var::operator const ::IR_FactoryDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_FactoryDefSeq_var::operator ::IR_FactoryDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_FactoryDefSeq_var::operator ::IR_FactoryDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_FactoryDefSeq_var::operator ::IR_FactoryDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_FactoryDef, IR_FactoryDef_var>
IR_FactoryDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_FactoryDefSeq &
IR_FactoryDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_FactoryDefSeq &
IR_FactoryDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_FactoryDefSeq *&
IR_FactoryDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_FactoryDefSeq *
IR_FactoryDefSeq_var::_retn (void)
{
  ::IR_FactoryDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_FactoryDefSeq *
IR_FactoryDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_FactoryDefSeq_out
// *************************************************************

ACE_INLINE
IR_FactoryDefSeq_out::IR_FactoryDefSeq_out (IR_FactoryDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_FactoryDefSeq_out::IR_FactoryDefSeq_out (IR_FactoryDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_FactoryDefSeq_out::IR_FactoryDefSeq_out (const ::IR_FactoryDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_FactoryDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_FactoryDefSeq_out &
IR_FactoryDefSeq_out::operator= (const ::IR_FactoryDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_FactoryDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_FactoryDefSeq_out &
IR_FactoryDefSeq_out::operator= (IR_FactoryDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_FactoryDefSeq_out::operator ::IR_FactoryDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_FactoryDefSeq *&
IR_FactoryDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_FactoryDefSeq *
IR_FactoryDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_FactoryDef, IR_FactoryDef_var>
IR_FactoryDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_FinderDef::IR_FinderDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_FinderDef_var
// *************************************************************

ACE_INLINE
IR_FinderDef_var::IR_FinderDef_var (void) // default constructor
  : ptr_ (IR_FinderDef::_nil ())
{}

ACE_INLINE IR_FinderDef_ptr 
IR_FinderDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_FinderDef_var::IR_FinderDef_var (const IR_FinderDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_FinderDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_FinderDef_var::~IR_FinderDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_FinderDef_var &
IR_FinderDef_var::operator= (IR_FinderDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_FinderDef_var &
IR_FinderDef_var::operator= (const IR_FinderDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_FinderDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_FinderDef_var::operator const IR_FinderDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_FinderDef_var::operator IR_FinderDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr 
IR_FinderDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr
IR_FinderDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr &
IR_FinderDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr &
IR_FinderDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_FinderDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr 
IR_FinderDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_FinderDef_ptr val = this->ptr_;
  this->ptr_ = IR_FinderDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_FinderDef_out
// *************************************************************

ACE_INLINE
IR_FinderDef_out::IR_FinderDef_out (IR_FinderDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_FinderDef::_nil ();
}

ACE_INLINE
IR_FinderDef_out::IR_FinderDef_out (IR_FinderDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_FinderDef::_nil ();
}

ACE_INLINE
IR_FinderDef_out::IR_FinderDef_out (const IR_FinderDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_FinderDef_out&,p).ptr_)
{}

ACE_INLINE IR_FinderDef_out &
IR_FinderDef_out::operator= (const IR_FinderDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_FinderDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_FinderDef_out &
IR_FinderDef_out::operator= (const IR_FinderDef_var &p)
{
  this->ptr_ = IR_FinderDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_FinderDef_out &
IR_FinderDef_out::operator= (IR_FinderDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_FinderDef_out::operator IR_FinderDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr &
IR_FinderDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_FinderDef_ptr 
IR_FinderDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_FinderDef **
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_FinderDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_FinderDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_FinderDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (IR_FinderDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_FinderDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq(const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_FinderDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (this->maximum_);
      IR_FinderDef ** const tmp2 = ACE_reinterpret_cast (IR_FinderDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_FinderDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_FinderDef **tmp = ACE_reinterpret_cast (IR_FinderDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_FinderDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_FinderDef **tmp1 = ACE_reinterpret_cast (IR_FinderDef **, this->buffer_);
    IR_FinderDef ** const tmp2 = ACE_reinterpret_cast (IR_FinderDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_FinderDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_FinderDef ** const tmp = ACE_reinterpret_cast (IR_FinderDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_FinderDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_FinderDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_FinderDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_FinderDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_FinderDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_FinderDefSeq_var
// *************************************************************

ACE_INLINE
IR_FinderDefSeq_var::IR_FinderDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_FinderDefSeq_var::IR_FinderDefSeq_var (IR_FinderDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_FinderDefSeq_var::IR_FinderDefSeq_var (const ::IR_FinderDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_FinderDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_FinderDefSeq_var::~IR_FinderDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_FinderDefSeq_var &
IR_FinderDefSeq_var::operator= (IR_FinderDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_FinderDefSeq_var &
IR_FinderDefSeq_var::operator= (const ::IR_FinderDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_FinderDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_FinderDefSeq *
IR_FinderDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_FinderDefSeq *
IR_FinderDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_FinderDefSeq_var::operator const ::IR_FinderDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_FinderDefSeq_var::operator ::IR_FinderDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_FinderDefSeq_var::operator ::IR_FinderDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_FinderDefSeq_var::operator ::IR_FinderDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_FinderDef, IR_FinderDef_var>
IR_FinderDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_FinderDefSeq &
IR_FinderDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_FinderDefSeq &
IR_FinderDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_FinderDefSeq *&
IR_FinderDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_FinderDefSeq *
IR_FinderDefSeq_var::_retn (void)
{
  ::IR_FinderDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_FinderDefSeq *
IR_FinderDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_FinderDefSeq_out
// *************************************************************

ACE_INLINE
IR_FinderDefSeq_out::IR_FinderDefSeq_out (IR_FinderDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_FinderDefSeq_out::IR_FinderDefSeq_out (IR_FinderDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_FinderDefSeq_out::IR_FinderDefSeq_out (const ::IR_FinderDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_FinderDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_FinderDefSeq_out &
IR_FinderDefSeq_out::operator= (const ::IR_FinderDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_FinderDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_FinderDefSeq_out &
IR_FinderDefSeq_out::operator= (IR_FinderDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_FinderDefSeq_out::operator ::IR_FinderDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_FinderDefSeq *&
IR_FinderDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_FinderDefSeq *
IR_FinderDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_FinderDef, IR_FinderDef_var>
IR_FinderDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_PrimaryKeyDef::IR_PrimaryKeyDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_PrimaryKeyDef_var
// *************************************************************

ACE_INLINE
IR_PrimaryKeyDef_var::IR_PrimaryKeyDef_var (void) // default constructor
  : ptr_ (IR_PrimaryKeyDef::_nil ())
{}

ACE_INLINE IR_PrimaryKeyDef_ptr 
IR_PrimaryKeyDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_PrimaryKeyDef_var::IR_PrimaryKeyDef_var (const IR_PrimaryKeyDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_PrimaryKeyDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_PrimaryKeyDef_var::~IR_PrimaryKeyDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_PrimaryKeyDef_var &
IR_PrimaryKeyDef_var::operator= (IR_PrimaryKeyDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_PrimaryKeyDef_var &
IR_PrimaryKeyDef_var::operator= (const IR_PrimaryKeyDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_PrimaryKeyDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_PrimaryKeyDef_var::operator const IR_PrimaryKeyDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_PrimaryKeyDef_var::operator IR_PrimaryKeyDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr 
IR_PrimaryKeyDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr
IR_PrimaryKeyDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr &
IR_PrimaryKeyDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr &
IR_PrimaryKeyDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_PrimaryKeyDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr 
IR_PrimaryKeyDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_PrimaryKeyDef_ptr val = this->ptr_;
  this->ptr_ = IR_PrimaryKeyDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_PrimaryKeyDef_out
// *************************************************************

ACE_INLINE
IR_PrimaryKeyDef_out::IR_PrimaryKeyDef_out (IR_PrimaryKeyDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_PrimaryKeyDef::_nil ();
}

ACE_INLINE
IR_PrimaryKeyDef_out::IR_PrimaryKeyDef_out (IR_PrimaryKeyDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_PrimaryKeyDef::_nil ();
}

ACE_INLINE
IR_PrimaryKeyDef_out::IR_PrimaryKeyDef_out (const IR_PrimaryKeyDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_PrimaryKeyDef_out&,p).ptr_)
{}

ACE_INLINE IR_PrimaryKeyDef_out &
IR_PrimaryKeyDef_out::operator= (const IR_PrimaryKeyDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_PrimaryKeyDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_PrimaryKeyDef_out &
IR_PrimaryKeyDef_out::operator= (const IR_PrimaryKeyDef_var &p)
{
  this->ptr_ = IR_PrimaryKeyDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_PrimaryKeyDef_out &
IR_PrimaryKeyDef_out::operator= (IR_PrimaryKeyDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_PrimaryKeyDef_out::operator IR_PrimaryKeyDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr &
IR_PrimaryKeyDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDef_ptr 
IR_PrimaryKeyDef_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_Contained **
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_Contained **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_Contained*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_Contained::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::freebuf (IR_Contained **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_Contained* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_TAO_Unbounded_Object_Sequence_IR_ContainedSeq(const _TAO_Unbounded_Object_Sequence_IR_ContainedSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_Contained **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (this->maximum_);
      IR_Contained ** const tmp2 = ACE_reinterpret_cast (IR_Contained ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_Contained::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ContainedSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_Contained **tmp = ACE_reinterpret_cast (IR_Contained **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_Contained::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_Contained **tmp1 = ACE_reinterpret_cast (IR_Contained **, this->buffer_);
    IR_Contained ** const tmp2 = ACE_reinterpret_cast (IR_Contained ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_Contained::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_Contained,IR_Contained_var>
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_Contained ** const tmp = ACE_reinterpret_cast (IR_Contained ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_Contained,IR_Contained_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_Contained* *
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_Contained **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_Contained**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_Contained* *
  IR__TAO_Unbounded_Object_Sequence_IR_ContainedSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_Contained ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ContainedSeq_var
// *************************************************************

ACE_INLINE
IR_ContainedSeq_var::IR_ContainedSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ContainedSeq_var::IR_ContainedSeq_var (IR_ContainedSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ContainedSeq_var::IR_ContainedSeq_var (const ::IR_ContainedSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ContainedSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ContainedSeq_var::~IR_ContainedSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ContainedSeq_var &
IR_ContainedSeq_var::operator= (IR_ContainedSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ContainedSeq_var &
IR_ContainedSeq_var::operator= (const ::IR_ContainedSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ContainedSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ContainedSeq *
IR_ContainedSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ContainedSeq *
IR_ContainedSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ContainedSeq_var::operator const ::IR_ContainedSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ContainedSeq_var::operator ::IR_ContainedSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ContainedSeq_var::operator ::IR_ContainedSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ContainedSeq_var::operator ::IR_ContainedSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_Contained, IR_Contained_var>
IR_ContainedSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ContainedSeq &
IR_ContainedSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ContainedSeq &
IR_ContainedSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ContainedSeq *&
IR_ContainedSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ContainedSeq *
IR_ContainedSeq_var::_retn (void)
{
  ::IR_ContainedSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ContainedSeq *
IR_ContainedSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ContainedSeq_out
// *************************************************************

ACE_INLINE
IR_ContainedSeq_out::IR_ContainedSeq_out (IR_ContainedSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ContainedSeq_out::IR_ContainedSeq_out (IR_ContainedSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ContainedSeq_out::IR_ContainedSeq_out (const ::IR_ContainedSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ContainedSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ContainedSeq_out &
IR_ContainedSeq_out::operator= (const ::IR_ContainedSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ContainedSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ContainedSeq_out &
IR_ContainedSeq_out::operator= (IR_ContainedSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ContainedSeq_out::operator ::IR_ContainedSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ContainedSeq *&
IR_ContainedSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ContainedSeq *
IR_ContainedSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_Contained, IR_Contained_var>
IR_ContainedSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_StructMember_var
// *************************************************************

ACE_INLINE
IR_StructMember_var::IR_StructMember_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_StructMember_var::IR_StructMember_var (IR_StructMember *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_StructMember_var::IR_StructMember_var (const ::IR_StructMember_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_StructMember (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_StructMember_var::~IR_StructMember_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_StructMember_var &
IR_StructMember_var::operator= (IR_StructMember *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_StructMember_var &
IR_StructMember_var::operator= (const ::IR_StructMember_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_StructMember (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_StructMember *
IR_StructMember_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_StructMember *
IR_StructMember_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_StructMember_var::operator const ::IR_StructMember &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_StructMember_var::operator ::IR_StructMember &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_StructMember_var::operator ::IR_StructMember &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_StructMember_var::operator ::IR_StructMember *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_StructMember &
IR_StructMember_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_StructMember &
IR_StructMember_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_StructMember *&
IR_StructMember_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_StructMember *
IR_StructMember_var::_retn (void)
{
  ::IR_StructMember *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_StructMember *
IR_StructMember_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_StructMember_out
// *************************************************************

ACE_INLINE
IR_StructMember_out::IR_StructMember_out (::IR_StructMember *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_StructMember_out::IR_StructMember_out (IR_StructMember_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_StructMember_out::IR_StructMember_out (const ::IR_StructMember_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_StructMember_out&, p).ptr_)
{}

ACE_INLINE IR_StructMember_out &
IR_StructMember_out::operator= (const ::IR_StructMember_out &p)
{
  this->ptr_ = ACE_const_cast (IR_StructMember_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_StructMember_out &
IR_StructMember_out::operator= (IR_StructMember *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_StructMember_out::operator ::IR_StructMember *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_StructMember *&
IR_StructMember_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_StructMember *
IR_StructMember_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_StructMember *
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_StructMember *retval = 0;
    ACE_NEW_RETURN (retval, IR_StructMember[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (IR_StructMember *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::_TAO_Unbounded_Sequence_IR_StructMemberSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::_TAO_Unbounded_Sequence_IR_StructMemberSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::_TAO_Unbounded_Sequence_IR_StructMemberSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_StructMember *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::_TAO_Unbounded_Sequence_IR_StructMemberSeq (const _TAO_Unbounded_Sequence_IR_StructMemberSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_StructMember *tmp1 = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (this->maximum_);
      IR_StructMember * const tmp2 = ACE_reinterpret_cast (IR_StructMember * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_StructMemberSeq &
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::operator= (const _TAO_Unbounded_Sequence_IR_StructMemberSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_StructMember *tmp = ACE_reinterpret_cast (IR_StructMember *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_StructMember *tmp1 = ACE_reinterpret_cast (IR_StructMember *, this->buffer_);
    IR_StructMember * const tmp2 = ACE_reinterpret_cast (IR_StructMember * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_StructMember &
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_StructMember* tmp = ACE_reinterpret_cast(IR_StructMember*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_StructMember &
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_StructMember * const tmp = ACE_reinterpret_cast (IR_StructMember* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_StructMember *
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_StructMember *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_StructMember*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_StructMember*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_StructMember *
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_StructMember * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_StructMemberSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_StructMember *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_StructMember *tmp = ACE_reinterpret_cast(IR_StructMember*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_StructMemberSeq_var
// *************************************************************

ACE_INLINE
IR_StructMemberSeq_var::IR_StructMemberSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_StructMemberSeq_var::IR_StructMemberSeq_var (IR_StructMemberSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_StructMemberSeq_var::IR_StructMemberSeq_var (const ::IR_StructMemberSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_StructMemberSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_StructMemberSeq_var::~IR_StructMemberSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_StructMemberSeq_var &
IR_StructMemberSeq_var::operator= (IR_StructMemberSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_StructMemberSeq_var &
IR_StructMemberSeq_var::operator= (const ::IR_StructMemberSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_StructMemberSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_StructMemberSeq *
IR_StructMemberSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_StructMemberSeq *
IR_StructMemberSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_StructMemberSeq_var::operator const ::IR_StructMemberSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_StructMemberSeq_var::operator ::IR_StructMemberSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_StructMemberSeq_var::operator ::IR_StructMemberSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_StructMemberSeq_var::operator ::IR_StructMemberSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_StructMember &
IR_StructMemberSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_StructMember &
IR_StructMemberSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_StructMember &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_StructMemberSeq &
IR_StructMemberSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_StructMemberSeq &
IR_StructMemberSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_StructMemberSeq *&
IR_StructMemberSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_StructMemberSeq *
IR_StructMemberSeq_var::_retn (void)
{
  ::IR_StructMemberSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_StructMemberSeq *
IR_StructMemberSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_StructMemberSeq_out
// *************************************************************

ACE_INLINE
IR_StructMemberSeq_out::IR_StructMemberSeq_out (IR_StructMemberSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_StructMemberSeq_out::IR_StructMemberSeq_out (IR_StructMemberSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_StructMemberSeq_out::IR_StructMemberSeq_out (const ::IR_StructMemberSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_StructMemberSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_StructMemberSeq_out &
IR_StructMemberSeq_out::operator= (const ::IR_StructMemberSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_StructMemberSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_StructMemberSeq_out &
IR_StructMemberSeq_out::operator= (IR_StructMemberSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_StructMemberSeq_out::operator ::IR_StructMemberSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_StructMemberSeq *&
IR_StructMemberSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_StructMemberSeq *
IR_StructMemberSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_StructMember &
IR_StructMemberSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_Initializer_var
// *************************************************************

ACE_INLINE
IR_Initializer_var::IR_Initializer_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_Initializer_var::IR_Initializer_var (IR_Initializer *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_Initializer_var::IR_Initializer_var (const ::IR_Initializer_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_Initializer (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_Initializer_var::~IR_Initializer_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_Initializer_var &
IR_Initializer_var::operator= (IR_Initializer *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_Initializer_var &
IR_Initializer_var::operator= (const ::IR_Initializer_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_Initializer (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_Initializer *
IR_Initializer_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_Initializer *
IR_Initializer_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_Initializer_var::operator const ::IR_Initializer &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_Initializer_var::operator ::IR_Initializer &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_Initializer_var::operator ::IR_Initializer &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_Initializer_var::operator ::IR_Initializer *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_Initializer &
IR_Initializer_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_Initializer &
IR_Initializer_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_Initializer *&
IR_Initializer_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_Initializer *
IR_Initializer_var::_retn (void)
{
  ::IR_Initializer *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_Initializer *
IR_Initializer_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_Initializer_out
// *************************************************************

ACE_INLINE
IR_Initializer_out::IR_Initializer_out (::IR_Initializer *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_Initializer_out::IR_Initializer_out (IR_Initializer_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_Initializer_out::IR_Initializer_out (const ::IR_Initializer_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_Initializer_out&, p).ptr_)
{}

ACE_INLINE IR_Initializer_out &
IR_Initializer_out::operator= (const ::IR_Initializer_out &p)
{
  this->ptr_ = ACE_const_cast (IR_Initializer_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_Initializer_out &
IR_Initializer_out::operator= (IR_Initializer *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Initializer_out::operator ::IR_Initializer *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_Initializer *&
IR_Initializer_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_Initializer *
IR_Initializer_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_Initializer *
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_Initializer *retval = 0;
    ACE_NEW_RETURN (retval, IR_Initializer[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (IR_Initializer *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::_TAO_Unbounded_Sequence_IR_InitializerSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::_TAO_Unbounded_Sequence_IR_InitializerSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::_TAO_Unbounded_Sequence_IR_InitializerSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_Initializer *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::_TAO_Unbounded_Sequence_IR_InitializerSeq (const _TAO_Unbounded_Sequence_IR_InitializerSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_Initializer *tmp1 = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (this->maximum_);
      IR_Initializer * const tmp2 = ACE_reinterpret_cast (IR_Initializer * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_InitializerSeq &
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::operator= (const _TAO_Unbounded_Sequence_IR_InitializerSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_Initializer *tmp = ACE_reinterpret_cast (IR_Initializer *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_Initializer *tmp1 = ACE_reinterpret_cast (IR_Initializer *, this->buffer_);
    IR_Initializer * const tmp2 = ACE_reinterpret_cast (IR_Initializer * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_Initializer &
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_Initializer* tmp = ACE_reinterpret_cast(IR_Initializer*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_Initializer &
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_Initializer * const tmp = ACE_reinterpret_cast (IR_Initializer* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_Initializer *
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_Initializer *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_Initializer*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_Initializer*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_Initializer *
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_Initializer * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_InitializerSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_Initializer *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_Initializer *tmp = ACE_reinterpret_cast(IR_Initializer*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_InitializerSeq_var
// *************************************************************

ACE_INLINE
IR_InitializerSeq_var::IR_InitializerSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_InitializerSeq_var::IR_InitializerSeq_var (IR_InitializerSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_InitializerSeq_var::IR_InitializerSeq_var (const ::IR_InitializerSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_InitializerSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_InitializerSeq_var::~IR_InitializerSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_InitializerSeq_var &
IR_InitializerSeq_var::operator= (IR_InitializerSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_InitializerSeq_var &
IR_InitializerSeq_var::operator= (const ::IR_InitializerSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_InitializerSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_InitializerSeq *
IR_InitializerSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_InitializerSeq *
IR_InitializerSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_InitializerSeq_var::operator const ::IR_InitializerSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_InitializerSeq_var::operator ::IR_InitializerSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_InitializerSeq_var::operator ::IR_InitializerSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_InitializerSeq_var::operator ::IR_InitializerSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_Initializer &
IR_InitializerSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_Initializer &
IR_InitializerSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_Initializer &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_InitializerSeq &
IR_InitializerSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_InitializerSeq &
IR_InitializerSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_InitializerSeq *&
IR_InitializerSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_InitializerSeq *
IR_InitializerSeq_var::_retn (void)
{
  ::IR_InitializerSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_InitializerSeq *
IR_InitializerSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_InitializerSeq_out
// *************************************************************

ACE_INLINE
IR_InitializerSeq_out::IR_InitializerSeq_out (IR_InitializerSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_InitializerSeq_out::IR_InitializerSeq_out (IR_InitializerSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_InitializerSeq_out::IR_InitializerSeq_out (const ::IR_InitializerSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_InitializerSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_InitializerSeq_out &
IR_InitializerSeq_out::operator= (const ::IR_InitializerSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_InitializerSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_InitializerSeq_out &
IR_InitializerSeq_out::operator= (IR_InitializerSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_InitializerSeq_out::operator ::IR_InitializerSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_InitializerSeq *&
IR_InitializerSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_InitializerSeq *
IR_InitializerSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_Initializer &
IR_InitializerSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_UnionMember_var
// *************************************************************

ACE_INLINE
IR_UnionMember_var::IR_UnionMember_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_UnionMember_var::IR_UnionMember_var (IR_UnionMember *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_UnionMember_var::IR_UnionMember_var (const ::IR_UnionMember_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_UnionMember (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_UnionMember_var::~IR_UnionMember_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_UnionMember_var &
IR_UnionMember_var::operator= (IR_UnionMember *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_UnionMember_var &
IR_UnionMember_var::operator= (const ::IR_UnionMember_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_UnionMember (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_UnionMember *
IR_UnionMember_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMember *
IR_UnionMember_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_UnionMember_var::operator const ::IR_UnionMember &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_UnionMember_var::operator ::IR_UnionMember &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_UnionMember_var::operator ::IR_UnionMember &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_UnionMember_var::operator ::IR_UnionMember *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_UnionMember &
IR_UnionMember_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_UnionMember &
IR_UnionMember_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_UnionMember *&
IR_UnionMember_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMember *
IR_UnionMember_var::_retn (void)
{
  ::IR_UnionMember *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_UnionMember *
IR_UnionMember_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_UnionMember_out
// *************************************************************

ACE_INLINE
IR_UnionMember_out::IR_UnionMember_out (::IR_UnionMember *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_UnionMember_out::IR_UnionMember_out (IR_UnionMember_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_UnionMember_out::IR_UnionMember_out (const ::IR_UnionMember_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UnionMember_out&, p).ptr_)
{}

ACE_INLINE IR_UnionMember_out &
IR_UnionMember_out::operator= (const ::IR_UnionMember_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UnionMember_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_UnionMember_out &
IR_UnionMember_out::operator= (IR_UnionMember *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UnionMember_out::operator ::IR_UnionMember *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMember *&
IR_UnionMember_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMember *
IR_UnionMember_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_UnionMember *
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_UnionMember *retval = 0;
    ACE_NEW_RETURN (retval, IR_UnionMember[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (IR_UnionMember *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::_TAO_Unbounded_Sequence_IR_UnionMemberSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::_TAO_Unbounded_Sequence_IR_UnionMemberSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::_TAO_Unbounded_Sequence_IR_UnionMemberSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_UnionMember *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::_TAO_Unbounded_Sequence_IR_UnionMemberSeq (const _TAO_Unbounded_Sequence_IR_UnionMemberSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_UnionMember *tmp1 = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (this->maximum_);
      IR_UnionMember * const tmp2 = ACE_reinterpret_cast (IR_UnionMember * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq &
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::operator= (const _TAO_Unbounded_Sequence_IR_UnionMemberSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_UnionMember *tmp = ACE_reinterpret_cast (IR_UnionMember *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_UnionMember *tmp1 = ACE_reinterpret_cast (IR_UnionMember *, this->buffer_);
    IR_UnionMember * const tmp2 = ACE_reinterpret_cast (IR_UnionMember * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_UnionMember &
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_UnionMember* tmp = ACE_reinterpret_cast(IR_UnionMember*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_UnionMember &
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_UnionMember * const tmp = ACE_reinterpret_cast (IR_UnionMember* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_UnionMember *
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_UnionMember *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_UnionMember*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_UnionMember*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_UnionMember *
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_UnionMember * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_UnionMemberSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_UnionMember *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_UnionMember *tmp = ACE_reinterpret_cast(IR_UnionMember*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_UnionMemberSeq_var
// *************************************************************

ACE_INLINE
IR_UnionMemberSeq_var::IR_UnionMemberSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_UnionMemberSeq_var::IR_UnionMemberSeq_var (IR_UnionMemberSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_UnionMemberSeq_var::IR_UnionMemberSeq_var (const ::IR_UnionMemberSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_UnionMemberSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_UnionMemberSeq_var::~IR_UnionMemberSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_UnionMemberSeq_var &
IR_UnionMemberSeq_var::operator= (IR_UnionMemberSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_UnionMemberSeq_var &
IR_UnionMemberSeq_var::operator= (const ::IR_UnionMemberSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_UnionMemberSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_UnionMemberSeq *
IR_UnionMemberSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMemberSeq *
IR_UnionMemberSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_UnionMemberSeq_var::operator const ::IR_UnionMemberSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_UnionMemberSeq_var::operator ::IR_UnionMemberSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_UnionMemberSeq_var::operator ::IR_UnionMemberSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_UnionMemberSeq_var::operator ::IR_UnionMemberSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_UnionMember &
IR_UnionMemberSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_UnionMember &
IR_UnionMemberSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_UnionMember &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_UnionMemberSeq &
IR_UnionMemberSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_UnionMemberSeq &
IR_UnionMemberSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_UnionMemberSeq *&
IR_UnionMemberSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMemberSeq *
IR_UnionMemberSeq_var::_retn (void)
{
  ::IR_UnionMemberSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_UnionMemberSeq *
IR_UnionMemberSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_UnionMemberSeq_out
// *************************************************************

ACE_INLINE
IR_UnionMemberSeq_out::IR_UnionMemberSeq_out (IR_UnionMemberSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_UnionMemberSeq_out::IR_UnionMemberSeq_out (IR_UnionMemberSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_UnionMemberSeq_out::IR_UnionMemberSeq_out (const ::IR_UnionMemberSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UnionMemberSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_UnionMemberSeq_out &
IR_UnionMemberSeq_out::operator= (const ::IR_UnionMemberSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UnionMemberSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_UnionMemberSeq_out &
IR_UnionMemberSeq_out::operator= (IR_UnionMemberSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UnionMemberSeq_out::operator ::IR_UnionMemberSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMemberSeq *&
IR_UnionMemberSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_UnionMemberSeq *
IR_UnionMemberSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_UnionMember &
IR_UnionMemberSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_EnumMemberSeq_var
// *************************************************************

ACE_INLINE
IR_EnumMemberSeq_var::IR_EnumMemberSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_EnumMemberSeq_var::IR_EnumMemberSeq_var (IR_EnumMemberSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_EnumMemberSeq_var::IR_EnumMemberSeq_var (const ::IR_EnumMemberSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_EnumMemberSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_EnumMemberSeq_var::~IR_EnumMemberSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_EnumMemberSeq_var &
IR_EnumMemberSeq_var::operator= (IR_EnumMemberSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_EnumMemberSeq_var &
IR_EnumMemberSeq_var::operator= (const ::IR_EnumMemberSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_EnumMemberSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_EnumMemberSeq *
IR_EnumMemberSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_EnumMemberSeq *
IR_EnumMemberSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_EnumMemberSeq_var::operator const ::IR_EnumMemberSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_EnumMemberSeq_var::operator ::IR_EnumMemberSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_EnumMemberSeq_var::operator ::IR_EnumMemberSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_EnumMemberSeq_var::operator ::IR_EnumMemberSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR_EnumMemberSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_EnumMemberSeq &
IR_EnumMemberSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_EnumMemberSeq &
IR_EnumMemberSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_EnumMemberSeq *&
IR_EnumMemberSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_EnumMemberSeq *
IR_EnumMemberSeq_var::_retn (void)
{
  ::IR_EnumMemberSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_EnumMemberSeq *
IR_EnumMemberSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_EnumMemberSeq_out
// *************************************************************

ACE_INLINE
IR_EnumMemberSeq_out::IR_EnumMemberSeq_out (IR_EnumMemberSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_EnumMemberSeq_out::IR_EnumMemberSeq_out (IR_EnumMemberSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_EnumMemberSeq_out::IR_EnumMemberSeq_out (const ::IR_EnumMemberSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_EnumMemberSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_EnumMemberSeq_out &
IR_EnumMemberSeq_out::operator= (const ::IR_EnumMemberSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_EnumMemberSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_EnumMemberSeq_out &
IR_EnumMemberSeq_out::operator= (IR_EnumMemberSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_EnumMemberSeq_out::operator ::IR_EnumMemberSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_EnumMemberSeq *&
IR_EnumMemberSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_EnumMemberSeq *
IR_EnumMemberSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR_EnumMemberSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_Container::Description_var
// *************************************************************

ACE_INLINE
IR_Container::Description_var::Description_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_Container::Description_var::Description_var (Description *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_Container::Description_var::Description_var (const ::IR_Container::Description_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_Container::Description (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_Container::Description_var::~Description_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_Container::Description_var &
IR_Container::Description_var::operator= (Description *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_Container::Description_var &
IR_Container::Description_var::operator= (const ::IR_Container::Description_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_Container::Description (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_Container::Description *
IR_Container::Description_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_Container::Description *
IR_Container::Description_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_Container::Description_var::operator const ::IR_Container::Description &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_Container::Description_var::operator ::IR_Container::Description &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_Container::Description_var::operator ::IR_Container::Description &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_Container::Description_var::operator ::IR_Container::Description *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_Container::Description &
IR_Container::Description_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_Container::Description &
IR_Container::Description_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_Container::Description *&
IR_Container::Description_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_Container::Description *
IR_Container::Description_var::_retn (void)
{
  ::IR_Container::Description *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_Container::Description *
IR_Container::Description_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_Container::Description_out
// *************************************************************

ACE_INLINE
IR_Container::Description_out::Description_out (::IR_Container::Description *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_Container::Description_out::Description_out (Description_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_Container::Description_out::Description_out (const ::IR_Container::Description_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Description_out&, p).ptr_)
{}

ACE_INLINE IR_Container::Description_out &
IR_Container::Description_out::operator= (const ::IR_Container::Description_out &p)
{
  this->ptr_ = ACE_const_cast (Description_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_Container::Description_out &
IR_Container::Description_out::operator= (Description *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Container::Description_out::operator ::IR_Container::Description *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_Container::Description *&
IR_Container::Description_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_Container::Description *
IR_Container::Description_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_Container::Description *
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_Container::Description *retval = 0;
    ACE_NEW_RETURN (retval, IR_Container::Description[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (IR_Container::Description *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_Container::Description *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (const _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_Container::Description *tmp1 = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (this->maximum_);
      IR_Container::Description * const tmp2 = ACE_reinterpret_cast (IR_Container::Description * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq &
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::operator= (const _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_Container::Description *tmp = ACE_reinterpret_cast (IR_Container::Description *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_Container::Description *tmp1 = ACE_reinterpret_cast (IR_Container::Description *, this->buffer_);
    IR_Container::Description * const tmp2 = ACE_reinterpret_cast (IR_Container::Description * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_Container::Description &
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_Container::Description* tmp = ACE_reinterpret_cast(IR_Container::Description*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_Container::Description &
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_Container::Description * const tmp = ACE_reinterpret_cast (IR_Container::Description* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_Container::Description *
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_Container::Description *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_Container::Description*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_Container::Description*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_Container::Description *
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_Container::Description * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_Container::Description *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_Container::Description *tmp = ACE_reinterpret_cast(IR_Container::Description*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_Container::DescriptionSeq_var
// *************************************************************

ACE_INLINE
IR_Container::DescriptionSeq_var::DescriptionSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_Container::DescriptionSeq_var::DescriptionSeq_var (DescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_Container::DescriptionSeq_var::DescriptionSeq_var (const ::IR_Container::DescriptionSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_Container::DescriptionSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_Container::DescriptionSeq_var::~DescriptionSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_Container::DescriptionSeq_var &
IR_Container::DescriptionSeq_var::operator= (DescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_Container::DescriptionSeq_var &
IR_Container::DescriptionSeq_var::operator= (const ::IR_Container::DescriptionSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_Container::DescriptionSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_Container::DescriptionSeq *
IR_Container::DescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_Container::DescriptionSeq *
IR_Container::DescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_Container::DescriptionSeq_var::operator const ::IR_Container::DescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_Container::DescriptionSeq_var::operator ::IR_Container::DescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_Container::DescriptionSeq_var::operator ::IR_Container::DescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_Container::DescriptionSeq_var::operator ::IR_Container::DescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_Container::Description &
IR_Container::DescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_Container::Description &
IR_Container::DescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_Container::Description &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_Container::DescriptionSeq &
IR_Container::DescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_Container::DescriptionSeq &
IR_Container::DescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_Container::DescriptionSeq *&
IR_Container::DescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_Container::DescriptionSeq *
IR_Container::DescriptionSeq_var::_retn (void)
{
  ::IR_Container::DescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_Container::DescriptionSeq *
IR_Container::DescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_Container::DescriptionSeq_out
// *************************************************************

ACE_INLINE
IR_Container::DescriptionSeq_out::DescriptionSeq_out (DescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_Container::DescriptionSeq_out::DescriptionSeq_out (DescriptionSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_Container::DescriptionSeq_out::DescriptionSeq_out (const ::IR_Container::DescriptionSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_Container::DescriptionSeq_out &
IR_Container::DescriptionSeq_out::operator= (const ::IR_Container::DescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (DescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_Container::DescriptionSeq_out &
IR_Container::DescriptionSeq_out::operator= (DescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_Container::DescriptionSeq_out::operator ::IR_Container::DescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_Container::DescriptionSeq *&
IR_Container::DescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_Container::DescriptionSeq *
IR_Container::DescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_Container::Description &
IR_Container::DescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_PrimitiveDef::IR_PrimitiveDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_PrimitiveDef_var
// *************************************************************

ACE_INLINE
IR_PrimitiveDef_var::IR_PrimitiveDef_var (void) // default constructor
  : ptr_ (IR_PrimitiveDef::_nil ())
{}

ACE_INLINE IR_PrimitiveDef_ptr 
IR_PrimitiveDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_PrimitiveDef_var::IR_PrimitiveDef_var (const IR_PrimitiveDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_PrimitiveDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_PrimitiveDef_var::~IR_PrimitiveDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_PrimitiveDef_var &
IR_PrimitiveDef_var::operator= (IR_PrimitiveDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_PrimitiveDef_var &
IR_PrimitiveDef_var::operator= (const IR_PrimitiveDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_PrimitiveDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_PrimitiveDef_var::operator const IR_PrimitiveDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_PrimitiveDef_var::operator IR_PrimitiveDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr 
IR_PrimitiveDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr
IR_PrimitiveDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr &
IR_PrimitiveDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr &
IR_PrimitiveDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_PrimitiveDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr 
IR_PrimitiveDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_PrimitiveDef_ptr val = this->ptr_;
  this->ptr_ = IR_PrimitiveDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_PrimitiveDef_out
// *************************************************************

ACE_INLINE
IR_PrimitiveDef_out::IR_PrimitiveDef_out (IR_PrimitiveDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_PrimitiveDef::_nil ();
}

ACE_INLINE
IR_PrimitiveDef_out::IR_PrimitiveDef_out (IR_PrimitiveDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_PrimitiveDef::_nil ();
}

ACE_INLINE
IR_PrimitiveDef_out::IR_PrimitiveDef_out (const IR_PrimitiveDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_PrimitiveDef_out&,p).ptr_)
{}

ACE_INLINE IR_PrimitiveDef_out &
IR_PrimitiveDef_out::operator= (const IR_PrimitiveDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_PrimitiveDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_PrimitiveDef_out &
IR_PrimitiveDef_out::operator= (const IR_PrimitiveDef_var &p)
{
  this->ptr_ = IR_PrimitiveDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_PrimitiveDef_out &
IR_PrimitiveDef_out::operator= (IR_PrimitiveDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_PrimitiveDef_out::operator IR_PrimitiveDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr &
IR_PrimitiveDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_PrimitiveDef_ptr 
IR_PrimitiveDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_StringDef::IR_StringDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_StringDef_var
// *************************************************************

ACE_INLINE
IR_StringDef_var::IR_StringDef_var (void) // default constructor
  : ptr_ (IR_StringDef::_nil ())
{}

ACE_INLINE IR_StringDef_ptr 
IR_StringDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_StringDef_var::IR_StringDef_var (const IR_StringDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_StringDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_StringDef_var::~IR_StringDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_StringDef_var &
IR_StringDef_var::operator= (IR_StringDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_StringDef_var &
IR_StringDef_var::operator= (const IR_StringDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_StringDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_StringDef_var::operator const IR_StringDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_StringDef_var::operator IR_StringDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr 
IR_StringDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr
IR_StringDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr &
IR_StringDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr &
IR_StringDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_StringDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr 
IR_StringDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_StringDef_ptr val = this->ptr_;
  this->ptr_ = IR_StringDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_StringDef_out
// *************************************************************

ACE_INLINE
IR_StringDef_out::IR_StringDef_out (IR_StringDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_StringDef::_nil ();
}

ACE_INLINE
IR_StringDef_out::IR_StringDef_out (IR_StringDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_StringDef::_nil ();
}

ACE_INLINE
IR_StringDef_out::IR_StringDef_out (const IR_StringDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_StringDef_out&,p).ptr_)
{}

ACE_INLINE IR_StringDef_out &
IR_StringDef_out::operator= (const IR_StringDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_StringDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_StringDef_out &
IR_StringDef_out::operator= (const IR_StringDef_var &p)
{
  this->ptr_ = IR_StringDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_StringDef_out &
IR_StringDef_out::operator= (IR_StringDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_StringDef_out::operator IR_StringDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr &
IR_StringDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_StringDef_ptr 
IR_StringDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_SequenceDef::IR_SequenceDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_SequenceDef_var
// *************************************************************

ACE_INLINE
IR_SequenceDef_var::IR_SequenceDef_var (void) // default constructor
  : ptr_ (IR_SequenceDef::_nil ())
{}

ACE_INLINE IR_SequenceDef_ptr 
IR_SequenceDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_SequenceDef_var::IR_SequenceDef_var (const IR_SequenceDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_SequenceDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_SequenceDef_var::~IR_SequenceDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_SequenceDef_var &
IR_SequenceDef_var::operator= (IR_SequenceDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_SequenceDef_var &
IR_SequenceDef_var::operator= (const IR_SequenceDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_SequenceDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_SequenceDef_var::operator const IR_SequenceDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_SequenceDef_var::operator IR_SequenceDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr 
IR_SequenceDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr
IR_SequenceDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr &
IR_SequenceDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr &
IR_SequenceDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_SequenceDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr 
IR_SequenceDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_SequenceDef_ptr val = this->ptr_;
  this->ptr_ = IR_SequenceDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_SequenceDef_out
// *************************************************************

ACE_INLINE
IR_SequenceDef_out::IR_SequenceDef_out (IR_SequenceDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_SequenceDef::_nil ();
}

ACE_INLINE
IR_SequenceDef_out::IR_SequenceDef_out (IR_SequenceDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_SequenceDef::_nil ();
}

ACE_INLINE
IR_SequenceDef_out::IR_SequenceDef_out (const IR_SequenceDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_SequenceDef_out&,p).ptr_)
{}

ACE_INLINE IR_SequenceDef_out &
IR_SequenceDef_out::operator= (const IR_SequenceDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_SequenceDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_SequenceDef_out &
IR_SequenceDef_out::operator= (const IR_SequenceDef_var &p)
{
  this->ptr_ = IR_SequenceDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_SequenceDef_out &
IR_SequenceDef_out::operator= (IR_SequenceDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_SequenceDef_out::operator IR_SequenceDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr &
IR_SequenceDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_SequenceDef_ptr 
IR_SequenceDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ArrayDef::IR_ArrayDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ArrayDef_var
// *************************************************************

ACE_INLINE
IR_ArrayDef_var::IR_ArrayDef_var (void) // default constructor
  : ptr_ (IR_ArrayDef::_nil ())
{}

ACE_INLINE IR_ArrayDef_ptr 
IR_ArrayDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ArrayDef_var::IR_ArrayDef_var (const IR_ArrayDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ArrayDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ArrayDef_var::~IR_ArrayDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ArrayDef_var &
IR_ArrayDef_var::operator= (IR_ArrayDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ArrayDef_var &
IR_ArrayDef_var::operator= (const IR_ArrayDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_ArrayDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ArrayDef_var::operator const IR_ArrayDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ArrayDef_var::operator IR_ArrayDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr 
IR_ArrayDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr
IR_ArrayDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr &
IR_ArrayDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr &
IR_ArrayDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ArrayDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr 
IR_ArrayDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_ArrayDef_ptr val = this->ptr_;
  this->ptr_ = IR_ArrayDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ArrayDef_out
// *************************************************************

ACE_INLINE
IR_ArrayDef_out::IR_ArrayDef_out (IR_ArrayDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_ArrayDef::_nil ();
}

ACE_INLINE
IR_ArrayDef_out::IR_ArrayDef_out (IR_ArrayDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_ArrayDef::_nil ();
}

ACE_INLINE
IR_ArrayDef_out::IR_ArrayDef_out (const IR_ArrayDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ArrayDef_out&,p).ptr_)
{}

ACE_INLINE IR_ArrayDef_out &
IR_ArrayDef_out::operator= (const IR_ArrayDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ArrayDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_ArrayDef_out &
IR_ArrayDef_out::operator= (const IR_ArrayDef_var &p)
{
  this->ptr_ = IR_ArrayDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ArrayDef_out &
IR_ArrayDef_out::operator= (IR_ArrayDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ArrayDef_out::operator IR_ArrayDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr &
IR_ArrayDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_ArrayDef_ptr 
IR_ArrayDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_WstringDef::IR_WstringDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_WstringDef_var
// *************************************************************

ACE_INLINE
IR_WstringDef_var::IR_WstringDef_var (void) // default constructor
  : ptr_ (IR_WstringDef::_nil ())
{}

ACE_INLINE IR_WstringDef_ptr 
IR_WstringDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_WstringDef_var::IR_WstringDef_var (const IR_WstringDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_WstringDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_WstringDef_var::~IR_WstringDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_WstringDef_var &
IR_WstringDef_var::operator= (IR_WstringDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_WstringDef_var &
IR_WstringDef_var::operator= (const IR_WstringDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_WstringDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_WstringDef_var::operator const IR_WstringDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_WstringDef_var::operator IR_WstringDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr 
IR_WstringDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr
IR_WstringDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr &
IR_WstringDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr &
IR_WstringDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_WstringDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr 
IR_WstringDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_WstringDef_ptr val = this->ptr_;
  this->ptr_ = IR_WstringDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_WstringDef_out
// *************************************************************

ACE_INLINE
IR_WstringDef_out::IR_WstringDef_out (IR_WstringDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_WstringDef::_nil ();
}

ACE_INLINE
IR_WstringDef_out::IR_WstringDef_out (IR_WstringDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_WstringDef::_nil ();
}

ACE_INLINE
IR_WstringDef_out::IR_WstringDef_out (const IR_WstringDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_WstringDef_out&,p).ptr_)
{}

ACE_INLINE IR_WstringDef_out &
IR_WstringDef_out::operator= (const IR_WstringDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_WstringDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_WstringDef_out &
IR_WstringDef_out::operator= (const IR_WstringDef_var &p)
{
  this->ptr_ = IR_WstringDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_WstringDef_out &
IR_WstringDef_out::operator= (IR_WstringDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_WstringDef_out::operator IR_WstringDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr &
IR_WstringDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_WstringDef_ptr 
IR_WstringDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_FixedDef::IR_FixedDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_FixedDef_var
// *************************************************************

ACE_INLINE
IR_FixedDef_var::IR_FixedDef_var (void) // default constructor
  : ptr_ (IR_FixedDef::_nil ())
{}

ACE_INLINE IR_FixedDef_ptr 
IR_FixedDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_FixedDef_var::IR_FixedDef_var (const IR_FixedDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_FixedDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_FixedDef_var::~IR_FixedDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_FixedDef_var &
IR_FixedDef_var::operator= (IR_FixedDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_FixedDef_var &
IR_FixedDef_var::operator= (const IR_FixedDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = IR_FixedDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_FixedDef_var::operator const IR_FixedDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_FixedDef_var::operator IR_FixedDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr 
IR_FixedDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr
IR_FixedDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr &
IR_FixedDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr &
IR_FixedDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_FixedDef::_nil ();
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr 
IR_FixedDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  IR_FixedDef_ptr val = this->ptr_;
  this->ptr_ = IR_FixedDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_FixedDef_out
// *************************************************************

ACE_INLINE
IR_FixedDef_out::IR_FixedDef_out (IR_FixedDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = IR_FixedDef::_nil ();
}

ACE_INLINE
IR_FixedDef_out::IR_FixedDef_out (IR_FixedDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = IR_FixedDef::_nil ();
}

ACE_INLINE
IR_FixedDef_out::IR_FixedDef_out (const IR_FixedDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_FixedDef_out&,p).ptr_)
{}

ACE_INLINE IR_FixedDef_out &
IR_FixedDef_out::operator= (const IR_FixedDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_FixedDef_out&,p).ptr_;
  return *this;
}

ACE_INLINE IR_FixedDef_out &
IR_FixedDef_out::operator= (const IR_FixedDef_var &p)
{
  this->ptr_ = IR_FixedDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_FixedDef_out &
IR_FixedDef_out::operator= (IR_FixedDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_FixedDef_out::operator IR_FixedDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr &
IR_FixedDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE IR_FixedDef_ptr 
IR_FixedDef_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ComponentRepository::IR_ComponentRepository (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ComponentRepository_var
// *************************************************************

ACE_INLINE
IR_ComponentRepository_var::IR_ComponentRepository_var (void) // default constructor
  : ptr_ (IR_ComponentRepository::_nil ())
{}

ACE_INLINE ::IR_ComponentRepository_ptr
IR_ComponentRepository_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ComponentRepository_var::IR_ComponentRepository_var (const ::IR_ComponentRepository_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ComponentRepository::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ComponentRepository_var::~IR_ComponentRepository_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ComponentRepository_var &
IR_ComponentRepository_var::operator= (IR_ComponentRepository_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ComponentRepository_var &
IR_ComponentRepository_var::operator= (const ::IR_ComponentRepository_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR_ComponentRepository::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ComponentRepository_var::operator const ::IR_ComponentRepository_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ComponentRepository_var::operator ::IR_ComponentRepository_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr
IR_ComponentRepository_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr
IR_ComponentRepository_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr &
IR_ComponentRepository_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr &
IR_ComponentRepository_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_ComponentRepository::_nil ();
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr
IR_ComponentRepository_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR_ComponentRepository_ptr val = this->ptr_;
  this->ptr_ = ::IR_ComponentRepository::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ComponentRepository_out
// *************************************************************

ACE_INLINE
IR_ComponentRepository_out::IR_ComponentRepository_out (IR_ComponentRepository_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR_ComponentRepository::_nil ();
}

ACE_INLINE
IR_ComponentRepository_out::IR_ComponentRepository_out (IR_ComponentRepository_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_ComponentRepository::_nil ();
}

ACE_INLINE
IR_ComponentRepository_out::IR_ComponentRepository_out (const ::IR_ComponentRepository_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ComponentRepository_out &, p).ptr_)
{}

ACE_INLINE ::IR_ComponentRepository_out &
IR_ComponentRepository_out::operator= (const ::IR_ComponentRepository_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ComponentRepository_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ComponentRepository_out &
IR_ComponentRepository_out::operator= (const ::IR_ComponentRepository_var &p)
{
  this->ptr_ = ::IR_ComponentRepository::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ComponentRepository_out &
IR_ComponentRepository_out::operator= (IR_ComponentRepository_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ComponentRepository_out::operator ::IR_ComponentRepository_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr &
IR_ComponentRepository_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentRepository_ptr
IR_ComponentRepository_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ModuleDescription_var
// *************************************************************

ACE_INLINE
IR_ModuleDescription_var::IR_ModuleDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ModuleDescription_var::IR_ModuleDescription_var (IR_ModuleDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ModuleDescription_var::IR_ModuleDescription_var (const ::IR_ModuleDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ModuleDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ModuleDescription_var::~IR_ModuleDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ModuleDescription_var &
IR_ModuleDescription_var::operator= (IR_ModuleDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ModuleDescription_var &
IR_ModuleDescription_var::operator= (const ::IR_ModuleDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ModuleDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ModuleDescription *
IR_ModuleDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ModuleDescription *
IR_ModuleDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ModuleDescription_var::operator const ::IR_ModuleDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ModuleDescription_var::operator ::IR_ModuleDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ModuleDescription_var::operator ::IR_ModuleDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ModuleDescription_var::operator ::IR_ModuleDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ModuleDescription &
IR_ModuleDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ModuleDescription &
IR_ModuleDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ModuleDescription *&
IR_ModuleDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ModuleDescription *
IR_ModuleDescription_var::_retn (void)
{
  ::IR_ModuleDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ModuleDescription *
IR_ModuleDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ModuleDescription_out
// *************************************************************

ACE_INLINE
IR_ModuleDescription_out::IR_ModuleDescription_out (::IR_ModuleDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ModuleDescription_out::IR_ModuleDescription_out (IR_ModuleDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ModuleDescription_out::IR_ModuleDescription_out (const ::IR_ModuleDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ModuleDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ModuleDescription_out &
IR_ModuleDescription_out::operator= (const ::IR_ModuleDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ModuleDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ModuleDescription_out &
IR_ModuleDescription_out::operator= (IR_ModuleDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ModuleDescription_out::operator ::IR_ModuleDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ModuleDescription *&
IR_ModuleDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ModuleDescription *
IR_ModuleDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ConstantDescription_var
// *************************************************************

ACE_INLINE
IR_ConstantDescription_var::IR_ConstantDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ConstantDescription_var::IR_ConstantDescription_var (IR_ConstantDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ConstantDescription_var::IR_ConstantDescription_var (const ::IR_ConstantDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ConstantDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ConstantDescription_var::~IR_ConstantDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ConstantDescription_var &
IR_ConstantDescription_var::operator= (IR_ConstantDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ConstantDescription_var &
IR_ConstantDescription_var::operator= (const ::IR_ConstantDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ConstantDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ConstantDescription *
IR_ConstantDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ConstantDescription *
IR_ConstantDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ConstantDescription_var::operator const ::IR_ConstantDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ConstantDescription_var::operator ::IR_ConstantDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ConstantDescription_var::operator ::IR_ConstantDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ConstantDescription_var::operator ::IR_ConstantDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ConstantDescription &
IR_ConstantDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ConstantDescription &
IR_ConstantDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ConstantDescription *&
IR_ConstantDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ConstantDescription *
IR_ConstantDescription_var::_retn (void)
{
  ::IR_ConstantDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ConstantDescription *
IR_ConstantDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ConstantDescription_out
// *************************************************************

ACE_INLINE
IR_ConstantDescription_out::IR_ConstantDescription_out (::IR_ConstantDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ConstantDescription_out::IR_ConstantDescription_out (IR_ConstantDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ConstantDescription_out::IR_ConstantDescription_out (const ::IR_ConstantDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ConstantDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ConstantDescription_out &
IR_ConstantDescription_out::operator= (const ::IR_ConstantDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ConstantDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ConstantDescription_out &
IR_ConstantDescription_out::operator= (IR_ConstantDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ConstantDescription_out::operator ::IR_ConstantDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ConstantDescription *&
IR_ConstantDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ConstantDescription *
IR_ConstantDescription_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_TypedefDef::IR_TypedefDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_TypedefDef_var
// *************************************************************

ACE_INLINE
IR_TypedefDef_var::IR_TypedefDef_var (void) // default constructor
  : ptr_ (IR_TypedefDef::_nil ())
{}

ACE_INLINE ::IR_TypedefDef_ptr
IR_TypedefDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_TypedefDef_var::IR_TypedefDef_var (const ::IR_TypedefDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_TypedefDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_TypedefDef_var::~IR_TypedefDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_TypedefDef_var &
IR_TypedefDef_var::operator= (IR_TypedefDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_TypedefDef_var &
IR_TypedefDef_var::operator= (const ::IR_TypedefDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR_TypedefDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_TypedefDef_var::operator const ::IR_TypedefDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_TypedefDef_var::operator ::IR_TypedefDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr
IR_TypedefDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr
IR_TypedefDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr &
IR_TypedefDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr &
IR_TypedefDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_TypedefDef::_nil ();
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr
IR_TypedefDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR_TypedefDef_ptr val = this->ptr_;
  this->ptr_ = ::IR_TypedefDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_TypedefDef_out
// *************************************************************

ACE_INLINE
IR_TypedefDef_out::IR_TypedefDef_out (IR_TypedefDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR_TypedefDef::_nil ();
}

ACE_INLINE
IR_TypedefDef_out::IR_TypedefDef_out (IR_TypedefDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_TypedefDef::_nil ();
}

ACE_INLINE
IR_TypedefDef_out::IR_TypedefDef_out (const ::IR_TypedefDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_TypedefDef_out &, p).ptr_)
{}

ACE_INLINE ::IR_TypedefDef_out &
IR_TypedefDef_out::operator= (const ::IR_TypedefDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_TypedefDef_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_TypedefDef_out &
IR_TypedefDef_out::operator= (const ::IR_TypedefDef_var &p)
{
  this->ptr_ = ::IR_TypedefDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_TypedefDef_out &
IR_TypedefDef_out::operator= (IR_TypedefDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_TypedefDef_out::operator ::IR_TypedefDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr &
IR_TypedefDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypedefDef_ptr
IR_TypedefDef_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_TypeDescription_var
// *************************************************************

ACE_INLINE
IR_TypeDescription_var::IR_TypeDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_TypeDescription_var::IR_TypeDescription_var (IR_TypeDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_TypeDescription_var::IR_TypeDescription_var (const ::IR_TypeDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_TypeDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_TypeDescription_var::~IR_TypeDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_TypeDescription_var &
IR_TypeDescription_var::operator= (IR_TypeDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_TypeDescription_var &
IR_TypeDescription_var::operator= (const ::IR_TypeDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_TypeDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_TypeDescription *
IR_TypeDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypeDescription *
IR_TypeDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_TypeDescription_var::operator const ::IR_TypeDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_TypeDescription_var::operator ::IR_TypeDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_TypeDescription_var::operator ::IR_TypeDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_TypeDescription_var::operator ::IR_TypeDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_TypeDescription &
IR_TypeDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_TypeDescription &
IR_TypeDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_TypeDescription *&
IR_TypeDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_TypeDescription *
IR_TypeDescription_var::_retn (void)
{
  ::IR_TypeDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_TypeDescription *
IR_TypeDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_TypeDescription_out
// *************************************************************

ACE_INLINE
IR_TypeDescription_out::IR_TypeDescription_out (::IR_TypeDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_TypeDescription_out::IR_TypeDescription_out (IR_TypeDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_TypeDescription_out::IR_TypeDescription_out (const ::IR_TypeDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_TypeDescription_out&, p).ptr_)
{}

ACE_INLINE IR_TypeDescription_out &
IR_TypeDescription_out::operator= (const ::IR_TypeDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_TypeDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_TypeDescription_out &
IR_TypeDescription_out::operator= (IR_TypeDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_TypeDescription_out::operator ::IR_TypeDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypeDescription *&
IR_TypeDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_TypeDescription *
IR_TypeDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ExceptionDescription_var
// *************************************************************

ACE_INLINE
IR_ExceptionDescription_var::IR_ExceptionDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ExceptionDescription_var::IR_ExceptionDescription_var (IR_ExceptionDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ExceptionDescription_var::IR_ExceptionDescription_var (const ::IR_ExceptionDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ExceptionDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ExceptionDescription_var::~IR_ExceptionDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ExceptionDescription_var &
IR_ExceptionDescription_var::operator= (IR_ExceptionDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ExceptionDescription_var &
IR_ExceptionDescription_var::operator= (const ::IR_ExceptionDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ExceptionDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ExceptionDescription *
IR_ExceptionDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDescription *
IR_ExceptionDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ExceptionDescription_var::operator const ::IR_ExceptionDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ExceptionDescription_var::operator ::IR_ExceptionDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ExceptionDescription_var::operator ::IR_ExceptionDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ExceptionDescription_var::operator ::IR_ExceptionDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ExceptionDescription &
IR_ExceptionDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ExceptionDescription &
IR_ExceptionDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ExceptionDescription *&
IR_ExceptionDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDescription *
IR_ExceptionDescription_var::_retn (void)
{
  ::IR_ExceptionDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ExceptionDescription *
IR_ExceptionDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ExceptionDescription_out
// *************************************************************

ACE_INLINE
IR_ExceptionDescription_out::IR_ExceptionDescription_out (::IR_ExceptionDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ExceptionDescription_out::IR_ExceptionDescription_out (IR_ExceptionDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ExceptionDescription_out::IR_ExceptionDescription_out (const ::IR_ExceptionDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ExceptionDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ExceptionDescription_out &
IR_ExceptionDescription_out::operator= (const ::IR_ExceptionDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ExceptionDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ExceptionDescription_out &
IR_ExceptionDescription_out::operator= (IR_ExceptionDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ExceptionDescription_out::operator ::IR_ExceptionDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDescription *&
IR_ExceptionDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDescription *
IR_ExceptionDescription_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  ACE_INLINE IR_ExceptionDef **
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (CORBA::ULong nelems)
  {
    IR_ExceptionDef **buf = 0;
    
    ACE_NEW_RETURN (buf, IR_ExceptionDef*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = IR_ExceptionDef::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::freebuf (IR_ExceptionDef **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ExceptionDef* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ExceptionDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (this->maximum_);
      IR_ExceptionDef ** const tmp2 = ACE_reinterpret_cast (IR_ExceptionDef ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = IR_ExceptionDef::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq &
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      IR_ExceptionDef **tmp = ACE_reinterpret_cast (IR_ExceptionDef **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = IR_ExceptionDef::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ExceptionDef **tmp1 = ACE_reinterpret_cast (IR_ExceptionDef **, this->buffer_);
    IR_ExceptionDef ** const tmp2 = ACE_reinterpret_cast (IR_ExceptionDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = IR_ExceptionDef::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var>
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    IR_ExceptionDef ** const tmp = ACE_reinterpret_cast (IR_ExceptionDef ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE IR_ExceptionDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ExceptionDef **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ExceptionDef**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ExceptionDef* *
  IR__TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ExceptionDef ** ACE_CAST_CONST, this->buffer_);
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ExceptionDefSeq_var
// *************************************************************

ACE_INLINE
IR_ExceptionDefSeq_var::IR_ExceptionDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ExceptionDefSeq_var::IR_ExceptionDefSeq_var (IR_ExceptionDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ExceptionDefSeq_var::IR_ExceptionDefSeq_var (const ::IR_ExceptionDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ExceptionDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ExceptionDefSeq_var::~IR_ExceptionDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ExceptionDefSeq_var &
IR_ExceptionDefSeq_var::operator= (IR_ExceptionDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ExceptionDefSeq_var &
IR_ExceptionDefSeq_var::operator= (const ::IR_ExceptionDefSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ExceptionDefSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ExceptionDefSeq *
IR_ExceptionDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDefSeq *
IR_ExceptionDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ExceptionDefSeq_var::operator const ::IR_ExceptionDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ExceptionDefSeq_var::operator ::IR_ExceptionDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ExceptionDefSeq_var::operator ::IR_ExceptionDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ExceptionDefSeq_var::operator ::IR_ExceptionDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ExceptionDef, IR_ExceptionDef_var>
IR_ExceptionDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ExceptionDefSeq &
IR_ExceptionDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ExceptionDefSeq &
IR_ExceptionDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ExceptionDefSeq *&
IR_ExceptionDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDefSeq *
IR_ExceptionDefSeq_var::_retn (void)
{
  ::IR_ExceptionDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ExceptionDefSeq *
IR_ExceptionDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ExceptionDefSeq_out
// *************************************************************

ACE_INLINE
IR_ExceptionDefSeq_out::IR_ExceptionDefSeq_out (IR_ExceptionDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ExceptionDefSeq_out::IR_ExceptionDefSeq_out (IR_ExceptionDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ExceptionDefSeq_out::IR_ExceptionDefSeq_out (const ::IR_ExceptionDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ExceptionDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ExceptionDefSeq_out &
IR_ExceptionDefSeq_out::operator= (const ::IR_ExceptionDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ExceptionDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ExceptionDefSeq_out &
IR_ExceptionDefSeq_out::operator= (IR_ExceptionDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ExceptionDefSeq_out::operator ::IR_ExceptionDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDefSeq *&
IR_ExceptionDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExceptionDefSeq *
IR_ExceptionDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR_ExceptionDef, IR_ExceptionDef_var>
IR_ExceptionDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_ExceptionDescription *
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_ExceptionDescription *retval = 0;
    ACE_NEW_RETURN (retval, IR_ExceptionDescription[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (IR_ExceptionDescription *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ExceptionDescription *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (const _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ExceptionDescription *tmp1 = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (this->maximum_);
      IR_ExceptionDescription * const tmp2 = ACE_reinterpret_cast (IR_ExceptionDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq &
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::operator= (const _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_ExceptionDescription *tmp = ACE_reinterpret_cast (IR_ExceptionDescription *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ExceptionDescription *tmp1 = ACE_reinterpret_cast (IR_ExceptionDescription *, this->buffer_);
    IR_ExceptionDescription * const tmp2 = ACE_reinterpret_cast (IR_ExceptionDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_ExceptionDescription &
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ExceptionDescription* tmp = ACE_reinterpret_cast(IR_ExceptionDescription*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_ExceptionDescription &
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ExceptionDescription * const tmp = ACE_reinterpret_cast (IR_ExceptionDescription* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_ExceptionDescription *
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ExceptionDescription *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ExceptionDescription*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ExceptionDescription*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ExceptionDescription *
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ExceptionDescription * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_ExceptionDescription *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_ExceptionDescription *tmp = ACE_reinterpret_cast(IR_ExceptionDescription*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ExcDescriptionSeq_var
// *************************************************************

ACE_INLINE
IR_ExcDescriptionSeq_var::IR_ExcDescriptionSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ExcDescriptionSeq_var::IR_ExcDescriptionSeq_var (IR_ExcDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ExcDescriptionSeq_var::IR_ExcDescriptionSeq_var (const ::IR_ExcDescriptionSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ExcDescriptionSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ExcDescriptionSeq_var::~IR_ExcDescriptionSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ExcDescriptionSeq_var &
IR_ExcDescriptionSeq_var::operator= (IR_ExcDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ExcDescriptionSeq_var &
IR_ExcDescriptionSeq_var::operator= (const ::IR_ExcDescriptionSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ExcDescriptionSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ExcDescriptionSeq *
IR_ExcDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExcDescriptionSeq *
IR_ExcDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ExcDescriptionSeq_var::operator const ::IR_ExcDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ExcDescriptionSeq_var::operator ::IR_ExcDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ExcDescriptionSeq_var::operator ::IR_ExcDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ExcDescriptionSeq_var::operator ::IR_ExcDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDescription &
IR_ExcDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_ExceptionDescription &
IR_ExcDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_ExceptionDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_ExcDescriptionSeq &
IR_ExcDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ExcDescriptionSeq &
IR_ExcDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ExcDescriptionSeq *&
IR_ExcDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ExcDescriptionSeq *
IR_ExcDescriptionSeq_var::_retn (void)
{
  ::IR_ExcDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ExcDescriptionSeq *
IR_ExcDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ExcDescriptionSeq_out
// *************************************************************

ACE_INLINE
IR_ExcDescriptionSeq_out::IR_ExcDescriptionSeq_out (IR_ExcDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ExcDescriptionSeq_out::IR_ExcDescriptionSeq_out (IR_ExcDescriptionSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ExcDescriptionSeq_out::IR_ExcDescriptionSeq_out (const ::IR_ExcDescriptionSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ExcDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ExcDescriptionSeq_out &
IR_ExcDescriptionSeq_out::operator= (const ::IR_ExcDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ExcDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ExcDescriptionSeq_out &
IR_ExcDescriptionSeq_out::operator= (IR_ExcDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ExcDescriptionSeq_out::operator ::IR_ExcDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExcDescriptionSeq *&
IR_ExcDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ExcDescriptionSeq *
IR_ExcDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ExceptionDescription &
IR_ExcDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_AttributeDef::IR_AttributeDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_AttributeDef_var
// *************************************************************

ACE_INLINE
IR_AttributeDef_var::IR_AttributeDef_var (void) // default constructor
  : ptr_ (IR_AttributeDef::_nil ())
{}

ACE_INLINE ::IR_AttributeDef_ptr
IR_AttributeDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_AttributeDef_var::IR_AttributeDef_var (const ::IR_AttributeDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_AttributeDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_AttributeDef_var::~IR_AttributeDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_AttributeDef_var &
IR_AttributeDef_var::operator= (IR_AttributeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_AttributeDef_var &
IR_AttributeDef_var::operator= (const ::IR_AttributeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR_AttributeDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_AttributeDef_var::operator const ::IR_AttributeDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_AttributeDef_var::operator ::IR_AttributeDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr
IR_AttributeDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr
IR_AttributeDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr &
IR_AttributeDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr &
IR_AttributeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_AttributeDef::_nil ();
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr
IR_AttributeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR_AttributeDef_ptr val = this->ptr_;
  this->ptr_ = ::IR_AttributeDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_AttributeDef_out
// *************************************************************

ACE_INLINE
IR_AttributeDef_out::IR_AttributeDef_out (IR_AttributeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR_AttributeDef::_nil ();
}

ACE_INLINE
IR_AttributeDef_out::IR_AttributeDef_out (IR_AttributeDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_AttributeDef::_nil ();
}

ACE_INLINE
IR_AttributeDef_out::IR_AttributeDef_out (const ::IR_AttributeDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_AttributeDef_out &, p).ptr_)
{}

ACE_INLINE ::IR_AttributeDef_out &
IR_AttributeDef_out::operator= (const ::IR_AttributeDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_AttributeDef_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_AttributeDef_out &
IR_AttributeDef_out::operator= (const ::IR_AttributeDef_var &p)
{
  this->ptr_ = ::IR_AttributeDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_AttributeDef_out &
IR_AttributeDef_out::operator= (IR_AttributeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_AttributeDef_out::operator ::IR_AttributeDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr &
IR_AttributeDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDef_ptr
IR_AttributeDef_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_AttributeDescription_var
// *************************************************************

ACE_INLINE
IR_AttributeDescription_var::IR_AttributeDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_AttributeDescription_var::IR_AttributeDescription_var (IR_AttributeDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_AttributeDescription_var::IR_AttributeDescription_var (const ::IR_AttributeDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_AttributeDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_AttributeDescription_var::~IR_AttributeDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_AttributeDescription_var &
IR_AttributeDescription_var::operator= (IR_AttributeDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_AttributeDescription_var &
IR_AttributeDescription_var::operator= (const ::IR_AttributeDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_AttributeDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_AttributeDescription *
IR_AttributeDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDescription *
IR_AttributeDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_AttributeDescription_var::operator const ::IR_AttributeDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_AttributeDescription_var::operator ::IR_AttributeDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_AttributeDescription_var::operator ::IR_AttributeDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_AttributeDescription_var::operator ::IR_AttributeDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_AttributeDescription &
IR_AttributeDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_AttributeDescription &
IR_AttributeDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_AttributeDescription *&
IR_AttributeDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDescription *
IR_AttributeDescription_var::_retn (void)
{
  ::IR_AttributeDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_AttributeDescription *
IR_AttributeDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_AttributeDescription_out
// *************************************************************

ACE_INLINE
IR_AttributeDescription_out::IR_AttributeDescription_out (::IR_AttributeDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_AttributeDescription_out::IR_AttributeDescription_out (IR_AttributeDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_AttributeDescription_out::IR_AttributeDescription_out (const ::IR_AttributeDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_AttributeDescription_out&, p).ptr_)
{}

ACE_INLINE IR_AttributeDescription_out &
IR_AttributeDescription_out::operator= (const ::IR_AttributeDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_AttributeDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_AttributeDescription_out &
IR_AttributeDescription_out::operator= (IR_AttributeDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_AttributeDescription_out::operator ::IR_AttributeDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDescription *&
IR_AttributeDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttributeDescription *
IR_AttributeDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ParameterDescription_var
// *************************************************************

ACE_INLINE
IR_ParameterDescription_var::IR_ParameterDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ParameterDescription_var::IR_ParameterDescription_var (IR_ParameterDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ParameterDescription_var::IR_ParameterDescription_var (const ::IR_ParameterDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ParameterDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ParameterDescription_var::~IR_ParameterDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ParameterDescription_var &
IR_ParameterDescription_var::operator= (IR_ParameterDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ParameterDescription_var &
IR_ParameterDescription_var::operator= (const ::IR_ParameterDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ParameterDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ParameterDescription *
IR_ParameterDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ParameterDescription *
IR_ParameterDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ParameterDescription_var::operator const ::IR_ParameterDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ParameterDescription_var::operator ::IR_ParameterDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ParameterDescription_var::operator ::IR_ParameterDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ParameterDescription_var::operator ::IR_ParameterDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ParameterDescription &
IR_ParameterDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ParameterDescription &
IR_ParameterDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ParameterDescription *&
IR_ParameterDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ParameterDescription *
IR_ParameterDescription_var::_retn (void)
{
  ::IR_ParameterDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ParameterDescription *
IR_ParameterDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ParameterDescription_out
// *************************************************************

ACE_INLINE
IR_ParameterDescription_out::IR_ParameterDescription_out (::IR_ParameterDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ParameterDescription_out::IR_ParameterDescription_out (IR_ParameterDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ParameterDescription_out::IR_ParameterDescription_out (const ::IR_ParameterDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ParameterDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ParameterDescription_out &
IR_ParameterDescription_out::operator= (const ::IR_ParameterDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ParameterDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ParameterDescription_out &
IR_ParameterDescription_out::operator= (IR_ParameterDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ParameterDescription_out::operator ::IR_ParameterDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ParameterDescription *&
IR_ParameterDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ParameterDescription *
IR_ParameterDescription_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_ParameterDescription *
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_ParameterDescription *retval = 0;
    ACE_NEW_RETURN (retval, IR_ParameterDescription[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (IR_ParameterDescription *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ParameterDescription *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (const _TAO_Unbounded_Sequence_IR_ParDescriptionSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ParameterDescription *tmp1 = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (this->maximum_);
      IR_ParameterDescription * const tmp2 = ACE_reinterpret_cast (IR_ParameterDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq &
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::operator= (const _TAO_Unbounded_Sequence_IR_ParDescriptionSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_ParameterDescription *tmp = ACE_reinterpret_cast (IR_ParameterDescription *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ParameterDescription *tmp1 = ACE_reinterpret_cast (IR_ParameterDescription *, this->buffer_);
    IR_ParameterDescription * const tmp2 = ACE_reinterpret_cast (IR_ParameterDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_ParameterDescription &
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ParameterDescription* tmp = ACE_reinterpret_cast(IR_ParameterDescription*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_ParameterDescription &
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ParameterDescription * const tmp = ACE_reinterpret_cast (IR_ParameterDescription* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_ParameterDescription *
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ParameterDescription *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ParameterDescription*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ParameterDescription*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ParameterDescription *
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ParameterDescription * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_ParDescriptionSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_ParameterDescription *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_ParameterDescription *tmp = ACE_reinterpret_cast(IR_ParameterDescription*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ParDescriptionSeq_var
// *************************************************************

ACE_INLINE
IR_ParDescriptionSeq_var::IR_ParDescriptionSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ParDescriptionSeq_var::IR_ParDescriptionSeq_var (IR_ParDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ParDescriptionSeq_var::IR_ParDescriptionSeq_var (const ::IR_ParDescriptionSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ParDescriptionSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ParDescriptionSeq_var::~IR_ParDescriptionSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ParDescriptionSeq_var &
IR_ParDescriptionSeq_var::operator= (IR_ParDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ParDescriptionSeq_var &
IR_ParDescriptionSeq_var::operator= (const ::IR_ParDescriptionSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ParDescriptionSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ParDescriptionSeq *
IR_ParDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ParDescriptionSeq *
IR_ParDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ParDescriptionSeq_var::operator const ::IR_ParDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ParDescriptionSeq_var::operator ::IR_ParDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ParDescriptionSeq_var::operator ::IR_ParDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ParDescriptionSeq_var::operator ::IR_ParDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ParameterDescription &
IR_ParDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_ParameterDescription &
IR_ParDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_ParameterDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_ParDescriptionSeq &
IR_ParDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ParDescriptionSeq &
IR_ParDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ParDescriptionSeq *&
IR_ParDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ParDescriptionSeq *
IR_ParDescriptionSeq_var::_retn (void)
{
  ::IR_ParDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ParDescriptionSeq *
IR_ParDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ParDescriptionSeq_out
// *************************************************************

ACE_INLINE
IR_ParDescriptionSeq_out::IR_ParDescriptionSeq_out (IR_ParDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ParDescriptionSeq_out::IR_ParDescriptionSeq_out (IR_ParDescriptionSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ParDescriptionSeq_out::IR_ParDescriptionSeq_out (const ::IR_ParDescriptionSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ParDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ParDescriptionSeq_out &
IR_ParDescriptionSeq_out::operator= (const ::IR_ParDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ParDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ParDescriptionSeq_out &
IR_ParDescriptionSeq_out::operator= (IR_ParDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ParDescriptionSeq_out::operator ::IR_ParDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ParDescriptionSeq *&
IR_ParDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ParDescriptionSeq *
IR_ParDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ParameterDescription &
IR_ParDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_ContextIdSeq_var
// *************************************************************

ACE_INLINE
IR_ContextIdSeq_var::IR_ContextIdSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ContextIdSeq_var::IR_ContextIdSeq_var (IR_ContextIdSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ContextIdSeq_var::IR_ContextIdSeq_var (const ::IR_ContextIdSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ContextIdSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ContextIdSeq_var::~IR_ContextIdSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ContextIdSeq_var &
IR_ContextIdSeq_var::operator= (IR_ContextIdSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ContextIdSeq_var &
IR_ContextIdSeq_var::operator= (const ::IR_ContextIdSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ContextIdSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ContextIdSeq *
IR_ContextIdSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ContextIdSeq *
IR_ContextIdSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ContextIdSeq_var::operator const ::IR_ContextIdSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ContextIdSeq_var::operator ::IR_ContextIdSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ContextIdSeq_var::operator ::IR_ContextIdSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ContextIdSeq_var::operator ::IR_ContextIdSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR_ContextIdSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_ContextIdSeq &
IR_ContextIdSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ContextIdSeq &
IR_ContextIdSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ContextIdSeq *&
IR_ContextIdSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ContextIdSeq *
IR_ContextIdSeq_var::_retn (void)
{
  ::IR_ContextIdSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ContextIdSeq *
IR_ContextIdSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ContextIdSeq_out
// *************************************************************

ACE_INLINE
IR_ContextIdSeq_out::IR_ContextIdSeq_out (IR_ContextIdSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ContextIdSeq_out::IR_ContextIdSeq_out (IR_ContextIdSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ContextIdSeq_out::IR_ContextIdSeq_out (const ::IR_ContextIdSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ContextIdSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ContextIdSeq_out &
IR_ContextIdSeq_out::operator= (const ::IR_ContextIdSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ContextIdSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ContextIdSeq_out &
IR_ContextIdSeq_out::operator= (IR_ContextIdSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ContextIdSeq_out::operator ::IR_ContextIdSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ContextIdSeq *&
IR_ContextIdSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ContextIdSeq *
IR_ContextIdSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR_ContextIdSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_OperationDef::IR_OperationDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_OperationDef_var
// *************************************************************

ACE_INLINE
IR_OperationDef_var::IR_OperationDef_var (void) // default constructor
  : ptr_ (IR_OperationDef::_nil ())
{}

ACE_INLINE ::IR_OperationDef_ptr
IR_OperationDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_OperationDef_var::IR_OperationDef_var (const ::IR_OperationDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_OperationDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_OperationDef_var::~IR_OperationDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_OperationDef_var &
IR_OperationDef_var::operator= (IR_OperationDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_OperationDef_var &
IR_OperationDef_var::operator= (const ::IR_OperationDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR_OperationDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_OperationDef_var::operator const ::IR_OperationDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_OperationDef_var::operator ::IR_OperationDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr
IR_OperationDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr
IR_OperationDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr &
IR_OperationDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr &
IR_OperationDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_OperationDef::_nil ();
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr
IR_OperationDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR_OperationDef_ptr val = this->ptr_;
  this->ptr_ = ::IR_OperationDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_OperationDef_out
// *************************************************************

ACE_INLINE
IR_OperationDef_out::IR_OperationDef_out (IR_OperationDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR_OperationDef::_nil ();
}

ACE_INLINE
IR_OperationDef_out::IR_OperationDef_out (IR_OperationDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_OperationDef::_nil ();
}

ACE_INLINE
IR_OperationDef_out::IR_OperationDef_out (const ::IR_OperationDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_OperationDef_out &, p).ptr_)
{}

ACE_INLINE ::IR_OperationDef_out &
IR_OperationDef_out::operator= (const ::IR_OperationDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_OperationDef_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_OperationDef_out &
IR_OperationDef_out::operator= (const ::IR_OperationDef_var &p)
{
  this->ptr_ = ::IR_OperationDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_OperationDef_out &
IR_OperationDef_out::operator= (IR_OperationDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_OperationDef_out::operator ::IR_OperationDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr &
IR_OperationDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDef_ptr
IR_OperationDef_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_OperationDescription_var
// *************************************************************

ACE_INLINE
IR_OperationDescription_var::IR_OperationDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_OperationDescription_var::IR_OperationDescription_var (IR_OperationDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_OperationDescription_var::IR_OperationDescription_var (const ::IR_OperationDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_OperationDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_OperationDescription_var::~IR_OperationDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_OperationDescription_var &
IR_OperationDescription_var::operator= (IR_OperationDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_OperationDescription_var &
IR_OperationDescription_var::operator= (const ::IR_OperationDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_OperationDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_OperationDescription *
IR_OperationDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDescription *
IR_OperationDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_OperationDescription_var::operator const ::IR_OperationDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_OperationDescription_var::operator ::IR_OperationDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_OperationDescription_var::operator ::IR_OperationDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_OperationDescription_var::operator ::IR_OperationDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_OperationDescription &
IR_OperationDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_OperationDescription &
IR_OperationDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_OperationDescription *&
IR_OperationDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDescription *
IR_OperationDescription_var::_retn (void)
{
  ::IR_OperationDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_OperationDescription *
IR_OperationDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_OperationDescription_out
// *************************************************************

ACE_INLINE
IR_OperationDescription_out::IR_OperationDescription_out (::IR_OperationDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_OperationDescription_out::IR_OperationDescription_out (IR_OperationDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_OperationDescription_out::IR_OperationDescription_out (const ::IR_OperationDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_OperationDescription_out&, p).ptr_)
{}

ACE_INLINE IR_OperationDescription_out &
IR_OperationDescription_out::operator= (const ::IR_OperationDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_OperationDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_OperationDescription_out &
IR_OperationDescription_out::operator= (IR_OperationDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_OperationDescription_out::operator ::IR_OperationDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDescription *&
IR_OperationDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_OperationDescription *
IR_OperationDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_RepositoryIdSeq_var
// *************************************************************

ACE_INLINE
IR_RepositoryIdSeq_var::IR_RepositoryIdSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_RepositoryIdSeq_var::IR_RepositoryIdSeq_var (IR_RepositoryIdSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_RepositoryIdSeq_var::IR_RepositoryIdSeq_var (const ::IR_RepositoryIdSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_RepositoryIdSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_RepositoryIdSeq_var::~IR_RepositoryIdSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_RepositoryIdSeq_var &
IR_RepositoryIdSeq_var::operator= (IR_RepositoryIdSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_RepositoryIdSeq_var &
IR_RepositoryIdSeq_var::operator= (const ::IR_RepositoryIdSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_RepositoryIdSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_RepositoryIdSeq *
IR_RepositoryIdSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_RepositoryIdSeq *
IR_RepositoryIdSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_RepositoryIdSeq_var::operator const ::IR_RepositoryIdSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_RepositoryIdSeq_var::operator ::IR_RepositoryIdSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_RepositoryIdSeq_var::operator ::IR_RepositoryIdSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_RepositoryIdSeq_var::operator ::IR_RepositoryIdSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR_RepositoryIdSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR_RepositoryIdSeq &
IR_RepositoryIdSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_RepositoryIdSeq &
IR_RepositoryIdSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_RepositoryIdSeq *&
IR_RepositoryIdSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_RepositoryIdSeq *
IR_RepositoryIdSeq_var::_retn (void)
{
  ::IR_RepositoryIdSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_RepositoryIdSeq *
IR_RepositoryIdSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_RepositoryIdSeq_out
// *************************************************************

ACE_INLINE
IR_RepositoryIdSeq_out::IR_RepositoryIdSeq_out (IR_RepositoryIdSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_RepositoryIdSeq_out::IR_RepositoryIdSeq_out (IR_RepositoryIdSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_RepositoryIdSeq_out::IR_RepositoryIdSeq_out (const ::IR_RepositoryIdSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_RepositoryIdSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_RepositoryIdSeq_out &
IR_RepositoryIdSeq_out::operator= (const ::IR_RepositoryIdSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_RepositoryIdSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_RepositoryIdSeq_out &
IR_RepositoryIdSeq_out::operator= (IR_RepositoryIdSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_RepositoryIdSeq_out::operator ::IR_RepositoryIdSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_RepositoryIdSeq *&
IR_RepositoryIdSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_RepositoryIdSeq *
IR_RepositoryIdSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR_RepositoryIdSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_OperationDescription *
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_OperationDescription *retval = 0;
    ACE_NEW_RETURN (retval, IR_OperationDescription[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (IR_OperationDescription *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_OperationDescription *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (const _TAO_Unbounded_Sequence_IR_OpDescriptionSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_OperationDescription *tmp1 = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (this->maximum_);
      IR_OperationDescription * const tmp2 = ACE_reinterpret_cast (IR_OperationDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq &
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::operator= (const _TAO_Unbounded_Sequence_IR_OpDescriptionSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_OperationDescription *tmp = ACE_reinterpret_cast (IR_OperationDescription *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_OperationDescription *tmp1 = ACE_reinterpret_cast (IR_OperationDescription *, this->buffer_);
    IR_OperationDescription * const tmp2 = ACE_reinterpret_cast (IR_OperationDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_OperationDescription &
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_OperationDescription* tmp = ACE_reinterpret_cast(IR_OperationDescription*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_OperationDescription &
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_OperationDescription * const tmp = ACE_reinterpret_cast (IR_OperationDescription* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_OperationDescription *
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_OperationDescription *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_OperationDescription*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_OperationDescription*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_OperationDescription *
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_OperationDescription * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_OpDescriptionSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_OperationDescription *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_OperationDescription *tmp = ACE_reinterpret_cast(IR_OperationDescription*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_OpDescriptionSeq_var
// *************************************************************

ACE_INLINE
IR_OpDescriptionSeq_var::IR_OpDescriptionSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_OpDescriptionSeq_var::IR_OpDescriptionSeq_var (IR_OpDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_OpDescriptionSeq_var::IR_OpDescriptionSeq_var (const ::IR_OpDescriptionSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_OpDescriptionSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_OpDescriptionSeq_var::~IR_OpDescriptionSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_OpDescriptionSeq_var &
IR_OpDescriptionSeq_var::operator= (IR_OpDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_OpDescriptionSeq_var &
IR_OpDescriptionSeq_var::operator= (const ::IR_OpDescriptionSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_OpDescriptionSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_OpDescriptionSeq *
IR_OpDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_OpDescriptionSeq *
IR_OpDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_OpDescriptionSeq_var::operator const ::IR_OpDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_OpDescriptionSeq_var::operator ::IR_OpDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_OpDescriptionSeq_var::operator ::IR_OpDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_OpDescriptionSeq_var::operator ::IR_OpDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_OperationDescription &
IR_OpDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_OperationDescription &
IR_OpDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_OperationDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_OpDescriptionSeq &
IR_OpDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_OpDescriptionSeq &
IR_OpDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_OpDescriptionSeq *&
IR_OpDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_OpDescriptionSeq *
IR_OpDescriptionSeq_var::_retn (void)
{
  ::IR_OpDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_OpDescriptionSeq *
IR_OpDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_OpDescriptionSeq_out
// *************************************************************

ACE_INLINE
IR_OpDescriptionSeq_out::IR_OpDescriptionSeq_out (IR_OpDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_OpDescriptionSeq_out::IR_OpDescriptionSeq_out (IR_OpDescriptionSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_OpDescriptionSeq_out::IR_OpDescriptionSeq_out (const ::IR_OpDescriptionSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_OpDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_OpDescriptionSeq_out &
IR_OpDescriptionSeq_out::operator= (const ::IR_OpDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_OpDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_OpDescriptionSeq_out &
IR_OpDescriptionSeq_out::operator= (IR_OpDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_OpDescriptionSeq_out::operator ::IR_OpDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_OpDescriptionSeq *&
IR_OpDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_OpDescriptionSeq *
IR_OpDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_OperationDescription &
IR_OpDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_AttributeDescription *
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_AttributeDescription *retval = 0;
    ACE_NEW_RETURN (retval, IR_AttributeDescription[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (IR_AttributeDescription *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_AttributeDescription *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (const _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_AttributeDescription *tmp1 = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (this->maximum_);
      IR_AttributeDescription * const tmp2 = ACE_reinterpret_cast (IR_AttributeDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq &
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::operator= (const _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_AttributeDescription *tmp = ACE_reinterpret_cast (IR_AttributeDescription *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_AttributeDescription *tmp1 = ACE_reinterpret_cast (IR_AttributeDescription *, this->buffer_);
    IR_AttributeDescription * const tmp2 = ACE_reinterpret_cast (IR_AttributeDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_AttributeDescription &
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_AttributeDescription* tmp = ACE_reinterpret_cast(IR_AttributeDescription*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_AttributeDescription &
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_AttributeDescription * const tmp = ACE_reinterpret_cast (IR_AttributeDescription* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_AttributeDescription *
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_AttributeDescription *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_AttributeDescription*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_AttributeDescription*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_AttributeDescription *
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_AttributeDescription * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_AttributeDescription *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_AttributeDescription *tmp = ACE_reinterpret_cast(IR_AttributeDescription*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_AttrDescriptionSeq_var
// *************************************************************

ACE_INLINE
IR_AttrDescriptionSeq_var::IR_AttrDescriptionSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_AttrDescriptionSeq_var::IR_AttrDescriptionSeq_var (IR_AttrDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_AttrDescriptionSeq_var::IR_AttrDescriptionSeq_var (const ::IR_AttrDescriptionSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_AttrDescriptionSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_AttrDescriptionSeq_var::~IR_AttrDescriptionSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_AttrDescriptionSeq_var &
IR_AttrDescriptionSeq_var::operator= (IR_AttrDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_AttrDescriptionSeq_var &
IR_AttrDescriptionSeq_var::operator= (const ::IR_AttrDescriptionSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_AttrDescriptionSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_AttrDescriptionSeq *
IR_AttrDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttrDescriptionSeq *
IR_AttrDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_AttrDescriptionSeq_var::operator const ::IR_AttrDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_AttrDescriptionSeq_var::operator ::IR_AttrDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_AttrDescriptionSeq_var::operator ::IR_AttrDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_AttrDescriptionSeq_var::operator ::IR_AttrDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_AttributeDescription &
IR_AttrDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_AttributeDescription &
IR_AttrDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_AttributeDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_AttrDescriptionSeq &
IR_AttrDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_AttrDescriptionSeq &
IR_AttrDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_AttrDescriptionSeq *&
IR_AttrDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_AttrDescriptionSeq *
IR_AttrDescriptionSeq_var::_retn (void)
{
  ::IR_AttrDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_AttrDescriptionSeq *
IR_AttrDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_AttrDescriptionSeq_out
// *************************************************************

ACE_INLINE
IR_AttrDescriptionSeq_out::IR_AttrDescriptionSeq_out (IR_AttrDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_AttrDescriptionSeq_out::IR_AttrDescriptionSeq_out (IR_AttrDescriptionSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_AttrDescriptionSeq_out::IR_AttrDescriptionSeq_out (const ::IR_AttrDescriptionSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_AttrDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_AttrDescriptionSeq_out &
IR_AttrDescriptionSeq_out::operator= (const ::IR_AttrDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_AttrDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_AttrDescriptionSeq_out &
IR_AttrDescriptionSeq_out::operator= (IR_AttrDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_AttrDescriptionSeq_out::operator ::IR_AttrDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttrDescriptionSeq *&
IR_AttrDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_AttrDescriptionSeq *
IR_AttrDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_AttributeDescription &
IR_AttrDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_InterfaceDescription_var
// *************************************************************

ACE_INLINE
IR_InterfaceDescription_var::IR_InterfaceDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_InterfaceDescription_var::IR_InterfaceDescription_var (IR_InterfaceDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_InterfaceDescription_var::IR_InterfaceDescription_var (const ::IR_InterfaceDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_InterfaceDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_InterfaceDescription_var::~IR_InterfaceDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_InterfaceDescription_var &
IR_InterfaceDescription_var::operator= (IR_InterfaceDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_InterfaceDescription_var &
IR_InterfaceDescription_var::operator= (const ::IR_InterfaceDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_InterfaceDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_InterfaceDescription *
IR_InterfaceDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDescription *
IR_InterfaceDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_InterfaceDescription_var::operator const ::IR_InterfaceDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_InterfaceDescription_var::operator ::IR_InterfaceDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_InterfaceDescription_var::operator ::IR_InterfaceDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_InterfaceDescription_var::operator ::IR_InterfaceDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_InterfaceDescription &
IR_InterfaceDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_InterfaceDescription &
IR_InterfaceDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_InterfaceDescription *&
IR_InterfaceDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDescription *
IR_InterfaceDescription_var::_retn (void)
{
  ::IR_InterfaceDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_InterfaceDescription *
IR_InterfaceDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_InterfaceDescription_out
// *************************************************************

ACE_INLINE
IR_InterfaceDescription_out::IR_InterfaceDescription_out (::IR_InterfaceDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_InterfaceDescription_out::IR_InterfaceDescription_out (IR_InterfaceDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_InterfaceDescription_out::IR_InterfaceDescription_out (const ::IR_InterfaceDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_InterfaceDescription_out&, p).ptr_)
{}

ACE_INLINE IR_InterfaceDescription_out &
IR_InterfaceDescription_out::operator= (const ::IR_InterfaceDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_InterfaceDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_InterfaceDescription_out &
IR_InterfaceDescription_out::operator= (IR_InterfaceDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_InterfaceDescription_out::operator ::IR_InterfaceDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDescription *&
IR_InterfaceDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_InterfaceDescription *
IR_InterfaceDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ValueMember_var
// *************************************************************

ACE_INLINE
IR_ValueMember_var::IR_ValueMember_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ValueMember_var::IR_ValueMember_var (IR_ValueMember *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ValueMember_var::IR_ValueMember_var (const ::IR_ValueMember_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ValueMember (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ValueMember_var::~IR_ValueMember_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ValueMember_var &
IR_ValueMember_var::operator= (IR_ValueMember *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ValueMember_var &
IR_ValueMember_var::operator= (const ::IR_ValueMember_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ValueMember (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ValueMember *
IR_ValueMember_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMember *
IR_ValueMember_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ValueMember_var::operator const ::IR_ValueMember &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ValueMember_var::operator ::IR_ValueMember &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ValueMember_var::operator ::IR_ValueMember &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ValueMember_var::operator ::IR_ValueMember *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ValueMember &
IR_ValueMember_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ValueMember &
IR_ValueMember_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ValueMember *&
IR_ValueMember_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMember *
IR_ValueMember_var::_retn (void)
{
  ::IR_ValueMember *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ValueMember *
IR_ValueMember_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ValueMember_out
// *************************************************************

ACE_INLINE
IR_ValueMember_out::IR_ValueMember_out (::IR_ValueMember *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueMember_out::IR_ValueMember_out (IR_ValueMember_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueMember_out::IR_ValueMember_out (const ::IR_ValueMember_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueMember_out&, p).ptr_)
{}

ACE_INLINE IR_ValueMember_out &
IR_ValueMember_out::operator= (const ::IR_ValueMember_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueMember_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ValueMember_out &
IR_ValueMember_out::operator= (IR_ValueMember *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueMember_out::operator ::IR_ValueMember *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMember *&
IR_ValueMember_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMember *
IR_ValueMember_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_ValueMember *
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_ValueMember *retval = 0;
    ACE_NEW_RETURN (retval, IR_ValueMember[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (IR_ValueMember *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::_TAO_Unbounded_Sequence_IR_ValueMemberSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::_TAO_Unbounded_Sequence_IR_ValueMemberSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::_TAO_Unbounded_Sequence_IR_ValueMemberSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ValueMember *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::_TAO_Unbounded_Sequence_IR_ValueMemberSeq (const _TAO_Unbounded_Sequence_IR_ValueMemberSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ValueMember *tmp1 = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (this->maximum_);
      IR_ValueMember * const tmp2 = ACE_reinterpret_cast (IR_ValueMember * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq &
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::operator= (const _TAO_Unbounded_Sequence_IR_ValueMemberSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_ValueMember *tmp = ACE_reinterpret_cast (IR_ValueMember *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ValueMember *tmp1 = ACE_reinterpret_cast (IR_ValueMember *, this->buffer_);
    IR_ValueMember * const tmp2 = ACE_reinterpret_cast (IR_ValueMember * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_ValueMember &
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ValueMember* tmp = ACE_reinterpret_cast(IR_ValueMember*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_ValueMember &
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ValueMember * const tmp = ACE_reinterpret_cast (IR_ValueMember* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_ValueMember *
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ValueMember *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ValueMember*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ValueMember*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ValueMember *
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ValueMember * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_ValueMemberSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_ValueMember *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_ValueMember *tmp = ACE_reinterpret_cast(IR_ValueMember*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ValueMemberSeq_var
// *************************************************************

ACE_INLINE
IR_ValueMemberSeq_var::IR_ValueMemberSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ValueMemberSeq_var::IR_ValueMemberSeq_var (IR_ValueMemberSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ValueMemberSeq_var::IR_ValueMemberSeq_var (const ::IR_ValueMemberSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ValueMemberSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ValueMemberSeq_var::~IR_ValueMemberSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ValueMemberSeq_var &
IR_ValueMemberSeq_var::operator= (IR_ValueMemberSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ValueMemberSeq_var &
IR_ValueMemberSeq_var::operator= (const ::IR_ValueMemberSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ValueMemberSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ValueMemberSeq *
IR_ValueMemberSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberSeq *
IR_ValueMemberSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ValueMemberSeq_var::operator const ::IR_ValueMemberSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ValueMemberSeq_var::operator ::IR_ValueMemberSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ValueMemberSeq_var::operator ::IR_ValueMemberSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ValueMemberSeq_var::operator ::IR_ValueMemberSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ValueMember &
IR_ValueMemberSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_ValueMember &
IR_ValueMemberSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_ValueMember &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_ValueMemberSeq &
IR_ValueMemberSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ValueMemberSeq &
IR_ValueMemberSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ValueMemberSeq *&
IR_ValueMemberSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberSeq *
IR_ValueMemberSeq_var::_retn (void)
{
  ::IR_ValueMemberSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ValueMemberSeq *
IR_ValueMemberSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ValueMemberSeq_out
// *************************************************************

ACE_INLINE
IR_ValueMemberSeq_out::IR_ValueMemberSeq_out (IR_ValueMemberSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueMemberSeq_out::IR_ValueMemberSeq_out (IR_ValueMemberSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueMemberSeq_out::IR_ValueMemberSeq_out (const ::IR_ValueMemberSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueMemberSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ValueMemberSeq_out &
IR_ValueMemberSeq_out::operator= (const ::IR_ValueMemberSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueMemberSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ValueMemberSeq_out &
IR_ValueMemberSeq_out::operator= (IR_ValueMemberSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueMemberSeq_out::operator ::IR_ValueMemberSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberSeq *&
IR_ValueMemberSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberSeq *
IR_ValueMemberSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ValueMember &
IR_ValueMemberSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
IR_ValueMemberDef::IR_ValueMemberDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->_tao_setup_collocation (_tao_collocated);
}

// *************************************************************
// Inline operations for class IR_ValueMemberDef_var
// *************************************************************

ACE_INLINE
IR_ValueMemberDef_var::IR_ValueMemberDef_var (void) // default constructor
  : ptr_ (IR_ValueMemberDef::_nil ())
{}

ACE_INLINE ::IR_ValueMemberDef_ptr
IR_ValueMemberDef_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
IR_ValueMemberDef_var::IR_ValueMemberDef_var (const ::IR_ValueMemberDef_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IR_ValueMemberDef::_duplicate (p.ptr ()))
{}

ACE_INLINE
IR_ValueMemberDef_var::~IR_ValueMemberDef_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE IR_ValueMemberDef_var &
IR_ValueMemberDef_var::operator= (IR_ValueMemberDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ValueMemberDef_var &
IR_ValueMemberDef_var::operator= (const ::IR_ValueMemberDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::IR_ValueMemberDef::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
IR_ValueMemberDef_var::operator const ::IR_ValueMemberDef_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
IR_ValueMemberDef_var::operator ::IR_ValueMemberDef_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr
IR_ValueMemberDef_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr
IR_ValueMemberDef_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr &
IR_ValueMemberDef_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr &
IR_ValueMemberDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_ValueMemberDef::_nil ();
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr
IR_ValueMemberDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::IR_ValueMemberDef_ptr val = this->ptr_;
  this->ptr_ = ::IR_ValueMemberDef::_nil ();
  return val;
}

// *************************************************************
// Inline operations for class IR_ValueMemberDef_out
// *************************************************************

ACE_INLINE
IR_ValueMemberDef_out::IR_ValueMemberDef_out (IR_ValueMemberDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::IR_ValueMemberDef::_nil ();
}

ACE_INLINE
IR_ValueMemberDef_out::IR_ValueMemberDef_out (IR_ValueMemberDef_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::IR_ValueMemberDef::_nil ();
}

ACE_INLINE
IR_ValueMemberDef_out::IR_ValueMemberDef_out (const ::IR_ValueMemberDef_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueMemberDef_out &, p).ptr_)
{}

ACE_INLINE ::IR_ValueMemberDef_out &
IR_ValueMemberDef_out::operator= (const ::IR_ValueMemberDef_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueMemberDef_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ValueMemberDef_out &
IR_ValueMemberDef_out::operator= (const ::IR_ValueMemberDef_var &p)
{
  this->ptr_ = ::IR_ValueMemberDef::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE IR_ValueMemberDef_out &
IR_ValueMemberDef_out::operator= (IR_ValueMemberDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueMemberDef_out::operator ::IR_ValueMemberDef_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr &
IR_ValueMemberDef_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueMemberDef_ptr
IR_ValueMemberDef_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ValueDescription_var
// *************************************************************

ACE_INLINE
IR_ValueDescription_var::IR_ValueDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ValueDescription_var::IR_ValueDescription_var (IR_ValueDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ValueDescription_var::IR_ValueDescription_var (const ::IR_ValueDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ValueDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ValueDescription_var::~IR_ValueDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ValueDescription_var &
IR_ValueDescription_var::operator= (IR_ValueDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ValueDescription_var &
IR_ValueDescription_var::operator= (const ::IR_ValueDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ValueDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ValueDescription *
IR_ValueDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDescription *
IR_ValueDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ValueDescription_var::operator const ::IR_ValueDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ValueDescription_var::operator ::IR_ValueDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ValueDescription_var::operator ::IR_ValueDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ValueDescription_var::operator ::IR_ValueDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ValueDescription &
IR_ValueDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ValueDescription &
IR_ValueDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ValueDescription *&
IR_ValueDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDescription *
IR_ValueDescription_var::_retn (void)
{
  ::IR_ValueDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ValueDescription *
IR_ValueDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ValueDescription_out
// *************************************************************

ACE_INLINE
IR_ValueDescription_out::IR_ValueDescription_out (::IR_ValueDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueDescription_out::IR_ValueDescription_out (IR_ValueDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ValueDescription_out::IR_ValueDescription_out (const ::IR_ValueDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ValueDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ValueDescription_out &
IR_ValueDescription_out::operator= (const ::IR_ValueDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ValueDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ValueDescription_out &
IR_ValueDescription_out::operator= (IR_ValueDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ValueDescription_out::operator ::IR_ValueDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDescription *&
IR_ValueDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ValueDescription *
IR_ValueDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ProvidesDescription_var
// *************************************************************

ACE_INLINE
IR_ProvidesDescription_var::IR_ProvidesDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ProvidesDescription_var::IR_ProvidesDescription_var (IR_ProvidesDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ProvidesDescription_var::IR_ProvidesDescription_var (const ::IR_ProvidesDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ProvidesDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDescription_var::~IR_ProvidesDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ProvidesDescription_var &
IR_ProvidesDescription_var::operator= (IR_ProvidesDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ProvidesDescription_var &
IR_ProvidesDescription_var::operator= (const ::IR_ProvidesDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ProvidesDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ProvidesDescription *
IR_ProvidesDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescription *
IR_ProvidesDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ProvidesDescription_var::operator const ::IR_ProvidesDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ProvidesDescription_var::operator ::IR_ProvidesDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ProvidesDescription_var::operator ::IR_ProvidesDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ProvidesDescription_var::operator ::IR_ProvidesDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ProvidesDescription &
IR_ProvidesDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescription &
IR_ProvidesDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ProvidesDescription *&
IR_ProvidesDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescription *
IR_ProvidesDescription_var::_retn (void)
{
  ::IR_ProvidesDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ProvidesDescription *
IR_ProvidesDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ProvidesDescription_out
// *************************************************************

ACE_INLINE
IR_ProvidesDescription_out::IR_ProvidesDescription_out (::IR_ProvidesDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDescription_out::IR_ProvidesDescription_out (IR_ProvidesDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDescription_out::IR_ProvidesDescription_out (const ::IR_ProvidesDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ProvidesDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ProvidesDescription_out &
IR_ProvidesDescription_out::operator= (const ::IR_ProvidesDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ProvidesDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ProvidesDescription_out &
IR_ProvidesDescription_out::operator= (IR_ProvidesDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ProvidesDescription_out::operator ::IR_ProvidesDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescription *&
IR_ProvidesDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescription *
IR_ProvidesDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_UsesDescription_var
// *************************************************************

ACE_INLINE
IR_UsesDescription_var::IR_UsesDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_UsesDescription_var::IR_UsesDescription_var (IR_UsesDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_UsesDescription_var::IR_UsesDescription_var (const ::IR_UsesDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_UsesDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDescription_var::~IR_UsesDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_UsesDescription_var &
IR_UsesDescription_var::operator= (IR_UsesDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_UsesDescription_var &
IR_UsesDescription_var::operator= (const ::IR_UsesDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_UsesDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_UsesDescription *
IR_UsesDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescription *
IR_UsesDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_UsesDescription_var::operator const ::IR_UsesDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_UsesDescription_var::operator ::IR_UsesDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_UsesDescription_var::operator ::IR_UsesDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_UsesDescription_var::operator ::IR_UsesDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_UsesDescription &
IR_UsesDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_UsesDescription &
IR_UsesDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_UsesDescription *&
IR_UsesDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescription *
IR_UsesDescription_var::_retn (void)
{
  ::IR_UsesDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_UsesDescription *
IR_UsesDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_UsesDescription_out
// *************************************************************

ACE_INLINE
IR_UsesDescription_out::IR_UsesDescription_out (::IR_UsesDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDescription_out::IR_UsesDescription_out (IR_UsesDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDescription_out::IR_UsesDescription_out (const ::IR_UsesDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UsesDescription_out&, p).ptr_)
{}

ACE_INLINE IR_UsesDescription_out &
IR_UsesDescription_out::operator= (const ::IR_UsesDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UsesDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_UsesDescription_out &
IR_UsesDescription_out::operator= (IR_UsesDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UsesDescription_out::operator ::IR_UsesDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescription *&
IR_UsesDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescription *
IR_UsesDescription_out::operator-> (void)
{
  return this->ptr_;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_ProvidesDescription *
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_ProvidesDescription *retval = 0;
    ACE_NEW_RETURN (retval, IR_ProvidesDescription[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (IR_ProvidesDescription *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_ProvidesDescription *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_ProvidesDescription *tmp1 = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (this->maximum_);
      IR_ProvidesDescription * const tmp2 = ACE_reinterpret_cast (IR_ProvidesDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq &
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::operator= (const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_ProvidesDescription *tmp = ACE_reinterpret_cast (IR_ProvidesDescription *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_ProvidesDescription *tmp1 = ACE_reinterpret_cast (IR_ProvidesDescription *, this->buffer_);
    IR_ProvidesDescription * const tmp2 = ACE_reinterpret_cast (IR_ProvidesDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_ProvidesDescription &
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ProvidesDescription* tmp = ACE_reinterpret_cast(IR_ProvidesDescription*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_ProvidesDescription &
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_ProvidesDescription * const tmp = ACE_reinterpret_cast (IR_ProvidesDescription* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_ProvidesDescription *
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_ProvidesDescription *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_ProvidesDescription*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_ProvidesDescription*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_ProvidesDescription *
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_ProvidesDescription * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_ProvidesDescSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_ProvidesDescription *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_ProvidesDescription *tmp = ACE_reinterpret_cast(IR_ProvidesDescription*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_ProvidesDescSeq_var
// *************************************************************

ACE_INLINE
IR_ProvidesDescSeq_var::IR_ProvidesDescSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ProvidesDescSeq_var::IR_ProvidesDescSeq_var (IR_ProvidesDescSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ProvidesDescSeq_var::IR_ProvidesDescSeq_var (const ::IR_ProvidesDescSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ProvidesDescSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDescSeq_var::~IR_ProvidesDescSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ProvidesDescSeq_var &
IR_ProvidesDescSeq_var::operator= (IR_ProvidesDescSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_ProvidesDescSeq_var &
IR_ProvidesDescSeq_var::operator= (const ::IR_ProvidesDescSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ProvidesDescSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ProvidesDescSeq *
IR_ProvidesDescSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescSeq *
IR_ProvidesDescSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_ProvidesDescSeq_var::operator const ::IR_ProvidesDescSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ProvidesDescSeq_var::operator ::IR_ProvidesDescSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_ProvidesDescSeq_var::operator ::IR_ProvidesDescSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ProvidesDescSeq_var::operator ::IR_ProvidesDescSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDescription &
IR_ProvidesDescSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_ProvidesDescription &
IR_ProvidesDescSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_ProvidesDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_ProvidesDescSeq &
IR_ProvidesDescSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescSeq &
IR_ProvidesDescSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ProvidesDescSeq *&
IR_ProvidesDescSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescSeq *
IR_ProvidesDescSeq_var::_retn (void)
{
  ::IR_ProvidesDescSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ProvidesDescSeq *
IR_ProvidesDescSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ProvidesDescSeq_out
// *************************************************************

ACE_INLINE
IR_ProvidesDescSeq_out::IR_ProvidesDescSeq_out (IR_ProvidesDescSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDescSeq_out::IR_ProvidesDescSeq_out (IR_ProvidesDescSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ProvidesDescSeq_out::IR_ProvidesDescSeq_out (const ::IR_ProvidesDescSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ProvidesDescSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_ProvidesDescSeq_out &
IR_ProvidesDescSeq_out::operator= (const ::IR_ProvidesDescSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ProvidesDescSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_ProvidesDescSeq_out &
IR_ProvidesDescSeq_out::operator= (IR_ProvidesDescSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ProvidesDescSeq_out::operator ::IR_ProvidesDescSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescSeq *&
IR_ProvidesDescSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ProvidesDescSeq *
IR_ProvidesDescSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_ProvidesDescription &
IR_ProvidesDescSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // = Static operations.
  ACE_INLINE IR_UsesDescription *
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    IR_UsesDescription *retval = 0;
    ACE_NEW_RETURN (retval, IR_UsesDescription[size], 0);
    return retval;
  }
  
  ACE_INLINE void IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (IR_UsesDescription *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    IR_UsesDescription *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      IR_UsesDescription *tmp1 = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (this->maximum_);
      IR_UsesDescription * const tmp2 = ACE_reinterpret_cast (IR_UsesDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE IR__TAO_Unbounded_Sequence_IR_UsesDescSeq &
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::operator= (const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        IR_UsesDescription *tmp = ACE_reinterpret_cast (IR_UsesDescription *, this->buffer_);
        _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    IR_UsesDescription *tmp1 = ACE_reinterpret_cast (IR_UsesDescription *, this->buffer_);
    IR_UsesDescription * const tmp2 = ACE_reinterpret_cast (IR_UsesDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE IR_UsesDescription &
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_UsesDescription* tmp = ACE_reinterpret_cast(IR_UsesDescription*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const IR_UsesDescription &
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    IR_UsesDescription * const tmp = ACE_reinterpret_cast (IR_UsesDescription* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE IR_UsesDescription *
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::get_buffer (CORBA::Boolean orphan)
  {
    IR_UsesDescription *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (IR_UsesDescription*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(IR_UsesDescription*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const IR_UsesDescription *
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const IR_UsesDescription * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  IR__TAO_Unbounded_Sequence_IR_UsesDescSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  IR_UsesDescription *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      IR_UsesDescription *tmp = ACE_reinterpret_cast(IR_UsesDescription*,this->buffer_);
      _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// Inline operations for class IR_UsesDescSeq_var
// *************************************************************

ACE_INLINE
IR_UsesDescSeq_var::IR_UsesDescSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_UsesDescSeq_var::IR_UsesDescSeq_var (IR_UsesDescSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_UsesDescSeq_var::IR_UsesDescSeq_var (const ::IR_UsesDescSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_UsesDescSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDescSeq_var::~IR_UsesDescSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_UsesDescSeq_var &
IR_UsesDescSeq_var::operator= (IR_UsesDescSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE IR_UsesDescSeq_var &
IR_UsesDescSeq_var::operator= (const ::IR_UsesDescSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_UsesDescSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_UsesDescSeq *
IR_UsesDescSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescSeq *
IR_UsesDescSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR_UsesDescSeq_var::operator const ::IR_UsesDescSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR_UsesDescSeq_var::operator ::IR_UsesDescSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR_UsesDescSeq_var::operator ::IR_UsesDescSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_UsesDescSeq_var::operator ::IR_UsesDescSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDescription &
IR_UsesDescSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR_UsesDescription &
IR_UsesDescSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR_UsesDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR_UsesDescSeq &
IR_UsesDescSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_UsesDescSeq &
IR_UsesDescSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_UsesDescSeq *&
IR_UsesDescSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescSeq *
IR_UsesDescSeq_var::_retn (void)
{
  ::IR_UsesDescSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_UsesDescSeq *
IR_UsesDescSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_UsesDescSeq_out
// *************************************************************

ACE_INLINE
IR_UsesDescSeq_out::IR_UsesDescSeq_out (IR_UsesDescSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDescSeq_out::IR_UsesDescSeq_out (IR_UsesDescSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_UsesDescSeq_out::IR_UsesDescSeq_out (const ::IR_UsesDescSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_UsesDescSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR_UsesDescSeq_out &
IR_UsesDescSeq_out::operator= (const ::IR_UsesDescSeq_out &p)
{
  this->ptr_ = ACE_const_cast (IR_UsesDescSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR_UsesDescSeq_out &
IR_UsesDescSeq_out::operator= (IR_UsesDescSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_UsesDescSeq_out::operator ::IR_UsesDescSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescSeq *&
IR_UsesDescSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_UsesDescSeq *
IR_UsesDescSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR_UsesDescription &
IR_UsesDescSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

// *************************************************************
// Inline operations for class IR_EventDescription_var
// *************************************************************

ACE_INLINE
IR_EventDescription_var::IR_EventDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_EventDescription_var::IR_EventDescription_var (IR_EventDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_EventDescription_var::IR_EventDescription_var (const ::IR_EventDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_EventDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_EventDescription_var::~IR_EventDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_EventDescription_var &
IR_EventDescription_var::operator= (IR_EventDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_EventDescription_var &
IR_EventDescription_var::operator= (const ::IR_EventDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_EventDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_EventDescription *
IR_EventDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_EventDescription *
IR_EventDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_EventDescription_var::operator const ::IR_EventDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_EventDescription_var::operator ::IR_EventDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_EventDescription_var::operator ::IR_EventDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_EventDescription_var::operator ::IR_EventDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_EventDescription &
IR_EventDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_EventDescription &
IR_EventDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_EventDescription *&
IR_EventDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_EventDescription *
IR_EventDescription_var::_retn (void)
{
  ::IR_EventDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_EventDescription *
IR_EventDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_EventDescription_out
// *************************************************************

ACE_INLINE
IR_EventDescription_out::IR_EventDescription_out (::IR_EventDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_EventDescription_out::IR_EventDescription_out (IR_EventDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_EventDescription_out::IR_EventDescription_out (const ::IR_EventDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_EventDescription_out&, p).ptr_)
{}

ACE_INLINE IR_EventDescription_out &
IR_EventDescription_out::operator= (const ::IR_EventDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_EventDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_EventDescription_out &
IR_EventDescription_out::operator= (IR_EventDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_EventDescription_out::operator ::IR_EventDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_EventDescription *&
IR_EventDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_EventDescription *
IR_EventDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ComponentDescription_var
// *************************************************************

ACE_INLINE
IR_ComponentDescription_var::IR_ComponentDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_ComponentDescription_var::IR_ComponentDescription_var (IR_ComponentDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_ComponentDescription_var::IR_ComponentDescription_var (const ::IR_ComponentDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_ComponentDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_ComponentDescription_var::~IR_ComponentDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_ComponentDescription_var &
IR_ComponentDescription_var::operator= (IR_ComponentDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_ComponentDescription_var &
IR_ComponentDescription_var::operator= (const ::IR_ComponentDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_ComponentDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_ComponentDescription *
IR_ComponentDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDescription *
IR_ComponentDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_ComponentDescription_var::operator const ::IR_ComponentDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_ComponentDescription_var::operator ::IR_ComponentDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_ComponentDescription_var::operator ::IR_ComponentDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_ComponentDescription_var::operator ::IR_ComponentDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_ComponentDescription &
IR_ComponentDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_ComponentDescription &
IR_ComponentDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_ComponentDescription *&
IR_ComponentDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDescription *
IR_ComponentDescription_var::_retn (void)
{
  ::IR_ComponentDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_ComponentDescription *
IR_ComponentDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_ComponentDescription_out
// *************************************************************

ACE_INLINE
IR_ComponentDescription_out::IR_ComponentDescription_out (::IR_ComponentDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_ComponentDescription_out::IR_ComponentDescription_out (IR_ComponentDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_ComponentDescription_out::IR_ComponentDescription_out (const ::IR_ComponentDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_ComponentDescription_out&, p).ptr_)
{}

ACE_INLINE IR_ComponentDescription_out &
IR_ComponentDescription_out::operator= (const ::IR_ComponentDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_ComponentDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_ComponentDescription_out &
IR_ComponentDescription_out::operator= (IR_ComponentDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_ComponentDescription_out::operator ::IR_ComponentDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDescription *&
IR_ComponentDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_ComponentDescription *
IR_ComponentDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_PrimaryKeyDescription_var
// *************************************************************

ACE_INLINE
IR_PrimaryKeyDescription_var::IR_PrimaryKeyDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_PrimaryKeyDescription_var::IR_PrimaryKeyDescription_var (IR_PrimaryKeyDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_PrimaryKeyDescription_var::IR_PrimaryKeyDescription_var (const ::IR_PrimaryKeyDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_PrimaryKeyDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_PrimaryKeyDescription_var::~IR_PrimaryKeyDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_PrimaryKeyDescription_var &
IR_PrimaryKeyDescription_var::operator= (IR_PrimaryKeyDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_PrimaryKeyDescription_var &
IR_PrimaryKeyDescription_var::operator= (const ::IR_PrimaryKeyDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_PrimaryKeyDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_PrimaryKeyDescription *
IR_PrimaryKeyDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_PrimaryKeyDescription *
IR_PrimaryKeyDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_PrimaryKeyDescription_var::operator const ::IR_PrimaryKeyDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_PrimaryKeyDescription_var::operator ::IR_PrimaryKeyDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_PrimaryKeyDescription_var::operator ::IR_PrimaryKeyDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_PrimaryKeyDescription_var::operator ::IR_PrimaryKeyDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_PrimaryKeyDescription &
IR_PrimaryKeyDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_PrimaryKeyDescription &
IR_PrimaryKeyDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_PrimaryKeyDescription *&
IR_PrimaryKeyDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_PrimaryKeyDescription *
IR_PrimaryKeyDescription_var::_retn (void)
{
  ::IR_PrimaryKeyDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_PrimaryKeyDescription *
IR_PrimaryKeyDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_PrimaryKeyDescription_out
// *************************************************************

ACE_INLINE
IR_PrimaryKeyDescription_out::IR_PrimaryKeyDescription_out (::IR_PrimaryKeyDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_PrimaryKeyDescription_out::IR_PrimaryKeyDescription_out (IR_PrimaryKeyDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_PrimaryKeyDescription_out::IR_PrimaryKeyDescription_out (const ::IR_PrimaryKeyDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_PrimaryKeyDescription_out&, p).ptr_)
{}

ACE_INLINE IR_PrimaryKeyDescription_out &
IR_PrimaryKeyDescription_out::operator= (const ::IR_PrimaryKeyDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_PrimaryKeyDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_PrimaryKeyDescription_out &
IR_PrimaryKeyDescription_out::operator= (IR_PrimaryKeyDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_PrimaryKeyDescription_out::operator ::IR_PrimaryKeyDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_PrimaryKeyDescription *&
IR_PrimaryKeyDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_PrimaryKeyDescription *
IR_PrimaryKeyDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_HomeDescription_var
// *************************************************************

ACE_INLINE
IR_HomeDescription_var::IR_HomeDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR_HomeDescription_var::IR_HomeDescription_var (IR_HomeDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR_HomeDescription_var::IR_HomeDescription_var (const ::IR_HomeDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR_HomeDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR_HomeDescription_var::~IR_HomeDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR_HomeDescription_var &
IR_HomeDescription_var::operator= (IR_HomeDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR_HomeDescription_var &
IR_HomeDescription_var::operator= (const ::IR_HomeDescription_var &p)
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::IR_HomeDescription (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::IR_HomeDescription *
IR_HomeDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDescription *
IR_HomeDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR_HomeDescription_var::operator const ::IR_HomeDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR_HomeDescription_var::operator ::IR_HomeDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR_HomeDescription_var::operator ::IR_HomeDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR_HomeDescription_var::operator ::IR_HomeDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR_HomeDescription &
IR_HomeDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR_HomeDescription &
IR_HomeDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR_HomeDescription *&
IR_HomeDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDescription *
IR_HomeDescription_var::_retn (void)
{
  ::IR_HomeDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR_HomeDescription *
IR_HomeDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR_HomeDescription_out
// *************************************************************

ACE_INLINE
IR_HomeDescription_out::IR_HomeDescription_out (::IR_HomeDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR_HomeDescription_out::IR_HomeDescription_out (IR_HomeDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR_HomeDescription_out::IR_HomeDescription_out (const ::IR_HomeDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IR_HomeDescription_out&, p).ptr_)
{}

ACE_INLINE IR_HomeDescription_out &
IR_HomeDescription_out::operator= (const ::IR_HomeDescription_out &p)
{
  this->ptr_ = ACE_const_cast (IR_HomeDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR_HomeDescription_out &
IR_HomeDescription_out::operator= (IR_HomeDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR_HomeDescription_out::operator ::IR_HomeDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDescription *&
IR_HomeDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR_HomeDescription *
IR_HomeDescription_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_DefinitionKind &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_DefinitionKind &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (IR_DefinitionKind, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const CORBA::IRObject_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    CORBA::IRObject_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const CORBA::IRObject_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    CORBA::IRObject_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      CORBA::IRObject::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_Contained_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_Contained_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_Repository_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_Repository_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_Container_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_Container_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_Contained_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_Contained_ptr &
  );

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_Contained::Description &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.kind) &&
    (strm << _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_Contained::Description &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.kind) &&
    (strm >> _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_Contained_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_Contained_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_Contained::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ModuleDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ModuleDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ConstantDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ConstantDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_IDLType_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_IDLType_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_StructDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_StructDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_UnionDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_UnionDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_EnumDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_EnumDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_AliasDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_AliasDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_InterfaceDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_InterfaceDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ExceptionDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ExceptionDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_NativeDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_NativeDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_InterfaceDefSeq_I_
#define _TAO_CDR_OP_IR_InterfaceDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_InterfaceDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_InterfaceDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_InterfaceDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ValueDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ValueDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_ValueDefSeq_I_
#define _TAO_CDR_OP_IR_ValueDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ValueDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ValueDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ValueDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ValueBoxDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ValueBoxDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ComponentDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ComponentDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_ComponentDefSeq_I_
#define _TAO_CDR_OP_IR_ComponentDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ComponentDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ComponentDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ComponentDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ProvidesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ProvidesDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_ProvidesDefSeq_I_
#define _TAO_CDR_OP_IR_ProvidesDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ProvidesDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ProvidesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ProvidesDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_UsesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_UsesDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_UsesDefSeq_I_
#define _TAO_CDR_OP_IR_UsesDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_UsesDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_UsesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_UsesDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_HomeDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_HomeDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_HomeDefSeq_I_
#define _TAO_CDR_OP_IR_HomeDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_HomeDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_HomeDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_HomeDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_EventDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_EventDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_EmitsDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_EmitsDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_EmitsDefSeq_I_
#define _TAO_CDR_OP_IR_EmitsDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_EmitsDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_EmitsDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_EmitsDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_PublishesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_PublishesDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_PublishesDefSeq_I_
#define _TAO_CDR_OP_IR_PublishesDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_PublishesDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_PublishesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_PublishesDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ConsumesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ConsumesDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_ConsumesDefSeq_I_
#define _TAO_CDR_OP_IR_ConsumesDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ConsumesDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ConsumesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ConsumesDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_FactoryDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_FactoryDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_FactoryDefSeq_I_
#define _TAO_CDR_OP_IR_FactoryDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_FactoryDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_FactoryDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_FactoryDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_FinderDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_FinderDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_FinderDefSeq_I_
#define _TAO_CDR_OP_IR_FinderDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_FinderDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_FinderDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_FinderDefSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_PrimaryKeyDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_PrimaryKeyDef_ptr &
  );

#if !defined _TAO_CDR_OP_IR_ContainedSeq_I_
#define _TAO_CDR_OP_IR_ContainedSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ContainedSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ContainedSeq &
  );

#endif /* _TAO_CDR_OP_IR_ContainedSeq_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_StructMember &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.type_def.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_StructMember &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.type_def.out ())
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_StructMemberSeq_I_
#define _TAO_CDR_OP_IR_StructMemberSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_StructMemberSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_StructMemberSeq &
  );

#endif /* _TAO_CDR_OP_IR_StructMemberSeq_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_Initializer &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.members) &&
    (strm << _tao_aggregate.name.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_Initializer &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.members) &&
    (strm >> _tao_aggregate.name.out ())
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_InitializerSeq_I_
#define _TAO_CDR_OP_IR_InitializerSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_InitializerSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_InitializerSeq &
  );

#endif /* _TAO_CDR_OP_IR_InitializerSeq_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_UnionMember &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.label) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.type_def.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_UnionMember &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.label) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.type_def.out ())
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_UnionMemberSeq_I_
#define _TAO_CDR_OP_IR_UnionMemberSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_UnionMemberSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_UnionMemberSeq &
  );

#endif /* _TAO_CDR_OP_IR_UnionMemberSeq_I_ */


#if !defined _TAO_CDR_OP_IR_EnumMemberSeq_I_
#define _TAO_CDR_OP_IR_EnumMemberSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_EnumMemberSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_EnumMemberSeq &
  );

#endif /* _TAO_CDR_OP_IR_EnumMemberSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_Container_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_Container_ptr &
  );

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_Container::Description &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.contained_object.in ()) &&
    (strm << _tao_aggregate.kind) &&
    (strm << _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_Container::Description &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.contained_object.out ()) &&
    (strm >> _tao_aggregate.kind) &&
    (strm >> _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_Container_DescriptionSeq_I_
#define _TAO_CDR_OP_IR_Container_DescriptionSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_Container::DescriptionSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_Container::DescriptionSeq &
  );

#endif /* _TAO_CDR_OP_IR_Container_DescriptionSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_Container_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_Container_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_Container::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_IDLType_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_IDLType_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_IDLType_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_IDLType_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_IDLType::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_PrimitiveDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_PrimitiveDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_StringDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_StringDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_SequenceDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_SequenceDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ArrayDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ArrayDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_WstringDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_WstringDef_ptr &
  );
ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_FixedDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_FixedDef_ptr &
  );
ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_PrimitiveKind &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_PrimitiveKind &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (IR_PrimitiveKind, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_Repository_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_Repository_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_Repository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_Repository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_Repository::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ComponentRepository_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ComponentRepository_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ComponentRepository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ComponentRepository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ComponentRepository::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ModuleDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ModuleDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ModuleDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ModuleDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ModuleDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ModuleDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ModuleDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ConstantDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ConstantDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ConstantDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ConstantDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ConstantDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ConstantDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ConstantDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_TypedefDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_TypedefDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_TypedefDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_TypedefDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_TypedefDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_TypeDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.type.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_TypeDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.type.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_StructDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_StructDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_StructDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_StructDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_StructDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_UnionDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_UnionDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_UnionDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_UnionDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_UnionDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_EnumDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_EnumDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_EnumDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_EnumDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_EnumDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_AliasDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_AliasDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_AliasDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_AliasDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_AliasDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_NativeDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_NativeDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_NativeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_NativeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_NativeDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_PrimitiveDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_PrimitiveDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_PrimitiveDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_PrimitiveDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_PrimitiveDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_StringDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_StringDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_StringDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_StringDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_StringDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_WstringDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_WstringDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_WstringDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_WstringDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_WstringDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_FixedDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_FixedDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_FixedDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_FixedDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_FixedDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_SequenceDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_SequenceDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_SequenceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_SequenceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_SequenceDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ArrayDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ArrayDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ArrayDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ArrayDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ArrayDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ExceptionDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ExceptionDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ExceptionDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ExceptionDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ExceptionDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ExceptionDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.type.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ExceptionDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.type.out ())
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_ExceptionDefSeq_I_
#define _TAO_CDR_OP_IR_ExceptionDefSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ExceptionDefSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ExceptionDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ExceptionDefSeq_I_ */


#if !defined _TAO_CDR_OP_IR_ExcDescriptionSeq_I_
#define _TAO_CDR_OP_IR_ExcDescriptionSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ExcDescriptionSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ExcDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_IR_ExcDescriptionSeq_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_AttributeMode &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_AttributeMode &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (IR_AttributeMode, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_AttributeDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_AttributeDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_AttributeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_AttributeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_AttributeDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_AttributeDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.mode) &&
    (strm << _tao_aggregate.get_exceptions) &&
    (strm << _tao_aggregate.put_exceptions)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_AttributeDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.mode) &&
    (strm >> _tao_aggregate.get_exceptions) &&
    (strm >> _tao_aggregate.put_exceptions)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_OperationMode &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_OperationMode &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (IR_OperationMode, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ParameterMode &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ParameterMode &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (IR_ParameterMode, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ParameterDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.type_def.in ()) &&
    (strm << _tao_aggregate.mode)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ParameterDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.type_def.out ()) &&
    (strm >> _tao_aggregate.mode)
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_ParDescriptionSeq_I_
#define _TAO_CDR_OP_IR_ParDescriptionSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ParDescriptionSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ParDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_IR_ParDescriptionSeq_I_ */


#if !defined _TAO_CDR_OP_IR_ContextIdSeq_I_
#define _TAO_CDR_OP_IR_ContextIdSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ContextIdSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ContextIdSeq &
  );

#endif /* _TAO_CDR_OP_IR_ContextIdSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_OperationDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_OperationDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_OperationDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_OperationDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_OperationDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_OperationDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.result.in ()) &&
    (strm << _tao_aggregate.mode) &&
    (strm << _tao_aggregate.contexts) &&
    (strm << _tao_aggregate.parameters) &&
    (strm << _tao_aggregate.exceptions)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_OperationDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.result.out ()) &&
    (strm >> _tao_aggregate.mode) &&
    (strm >> _tao_aggregate.contexts) &&
    (strm >> _tao_aggregate.parameters) &&
    (strm >> _tao_aggregate.exceptions)
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_RepositoryIdSeq_I_
#define _TAO_CDR_OP_IR_RepositoryIdSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_RepositoryIdSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_RepositoryIdSeq &
  );

#endif /* _TAO_CDR_OP_IR_RepositoryIdSeq_I_ */


#if !defined _TAO_CDR_OP_IR_OpDescriptionSeq_I_
#define _TAO_CDR_OP_IR_OpDescriptionSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_OpDescriptionSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_OpDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_IR_OpDescriptionSeq_I_ */


#if !defined _TAO_CDR_OP_IR_AttrDescriptionSeq_I_
#define _TAO_CDR_OP_IR_AttrDescriptionSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_AttrDescriptionSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_AttrDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_IR_AttrDescriptionSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_InterfaceDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_InterfaceDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_InterfaceDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_InterfaceDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_InterfaceDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_InterfaceDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.operations) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << _tao_aggregate.base_interfaces) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_abstract)) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_local))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_InterfaceDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.operations) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> _tao_aggregate.base_interfaces) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_abstract)) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_local))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ValueMember &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.type.in ()) &&
    (strm << _tao_aggregate.type_def.in ()) &&
    (strm << _tao_aggregate.access)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ValueMember &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.type.out ()) &&
    (strm >> _tao_aggregate.type_def.out ()) &&
    (strm >> _tao_aggregate.access)
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_ValueMemberSeq_I_
#define _TAO_CDR_OP_IR_ValueMemberSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ValueMemberSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ValueMemberSeq &
  );

#endif /* _TAO_CDR_OP_IR_ValueMemberSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ValueMemberDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ValueMemberDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ValueMemberDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ValueMemberDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ValueMemberDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ValueDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ValueDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ValueDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ValueDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ValueDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ValueDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_abstract)) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_custom)) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.operations) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << _tao_aggregate.members) &&
    (strm << _tao_aggregate.initializers) &&
    (strm << _tao_aggregate.supported_interfaces) &&
    (strm << _tao_aggregate.abstract_base_values) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_truncatable)) &&
    (strm << _tao_aggregate.base_value.in ()) &&
    (strm << _tao_aggregate.type.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ValueDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_abstract)) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_custom)) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.operations) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> _tao_aggregate.members) &&
    (strm >> _tao_aggregate.initializers) &&
    (strm >> _tao_aggregate.supported_interfaces) &&
    (strm >> _tao_aggregate.abstract_base_values) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_truncatable)) &&
    (strm >> _tao_aggregate.base_value.out ()) &&
    (strm >> _tao_aggregate.type.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ValueBoxDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ValueBoxDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ValueBoxDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ValueBoxDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ValueBoxDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ProvidesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ProvidesDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ProvidesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ProvidesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ProvidesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ProvidesDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.interface_type.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ProvidesDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.interface_type.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_UsesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_UsesDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_UsesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_UsesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_UsesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_UsesDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.interface_type.in ()) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_multiple))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_UsesDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.interface_type.out ()) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_multiple))
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_ProvidesDescSeq_I_
#define _TAO_CDR_OP_IR_ProvidesDescSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_ProvidesDescSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_ProvidesDescSeq &
  );

#endif /* _TAO_CDR_OP_IR_ProvidesDescSeq_I_ */


#if !defined _TAO_CDR_OP_IR_UsesDescSeq_I_
#define _TAO_CDR_OP_IR_UsesDescSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const IR_UsesDescSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    IR_UsesDescSeq &
  );

#endif /* _TAO_CDR_OP_IR_UsesDescSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_EventDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_EventDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_EventDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_EventDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_EventDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_EventDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.value.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_EventDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.value.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_EmitsDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_EmitsDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_EmitsDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_EmitsDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_EmitsDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_PublishesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_PublishesDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_PublishesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_PublishesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_PublishesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ConsumesDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ConsumesDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ConsumesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ConsumesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ConsumesDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_ComponentDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_ComponentDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_ComponentDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_ComponentDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_ComponentDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_ComponentDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.base_component.in ()) &&
    (strm << _tao_aggregate.supports_interfaces) &&
    (strm << _tao_aggregate.provides_interfaces) &&
    (strm << _tao_aggregate.uses_interfaces) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << _tao_aggregate.emits_events) &&
    (strm << _tao_aggregate.publishes_events) &&
    (strm << _tao_aggregate.consumes_events) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_ComponentDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.base_component.out ()) &&
    (strm >> _tao_aggregate.supports_interfaces) &&
    (strm >> _tao_aggregate.provides_interfaces) &&
    (strm >> _tao_aggregate.uses_interfaces) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> _tao_aggregate.emits_events) &&
    (strm >> _tao_aggregate.publishes_events) &&
    (strm >> _tao_aggregate.consumes_events) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_PrimaryKeyDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_PrimaryKeyDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_PrimaryKeyDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_PrimaryKeyDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_PrimaryKeyDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_PrimaryKeyDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.primary_key.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_PrimaryKeyDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.primary_key.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_FactoryDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_FactoryDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_FactoryDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_FactoryDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_FactoryDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_FinderDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_FinderDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_FinderDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_FinderDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_FinderDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const IR_HomeDef_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    IR_HomeDef_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const IR_HomeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    IR_HomeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      IR_HomeDef::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR_HomeDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.base_home.in ()) &&
    (strm << _tao_aggregate.managed_component.in ()) &&
    (strm << _tao_aggregate.primary_key_def.in ()) &&
    (strm << _tao_aggregate.factories) &&
    (strm << _tao_aggregate.finders) &&
    (strm << _tao_aggregate.operations) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR_HomeDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.base_home.out ()) &&
    (strm >> _tao_aggregate.managed_component.out ()) &&
    (strm >> _tao_aggregate.primary_key_def.out ()) &&
    (strm >> _tao_aggregate.factories) &&
    (strm >> _tao_aggregate.finders) &&
    (strm >> _tao_aggregate.operations) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

