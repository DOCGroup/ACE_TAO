/* -*- C++ -*- */
// $Id$
// ======================================================================
//
// = LIBRARY
//    TAO
//
// = FILENAME
//    InconsistentTypeCode.cpp
//
// = AUTHOR
//
// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html
//
//
// Modified by Jeff Parsons <jp4@cs.wustl.edu>
//
// ======================================================================

#include "tao/InconsistentTypeCodeC.h"

#if (TAO_HAS_MINIMUM_CORBA == 0)

#include "tao/ORB.h"

ACE_RCSID(tao, InconsistentTypeCodeC, "$Id$")

// default constructor
CORBA_ORB_InconsistentTypeCode::CORBA_ORB_InconsistentTypeCode (void)
  : CORBA_UserException ("IDL:omg.org/CORBA/ORB/InconsistentTypeCode:1.0")
{
}

// destructor - all members are of self managing types
CORBA_ORB_InconsistentTypeCode::~CORBA_ORB_InconsistentTypeCode (void)
{
}

// copy constructor
CORBA_ORB_InconsistentTypeCode::CORBA_ORB_InconsistentTypeCode (
    const CORBA_ORB_InconsistentTypeCode &_tao_excp
  )
  : CORBA_UserException (_tao_excp._id ())
{
}

// assignment operator
CORBA_ORB_InconsistentTypeCode&
CORBA_ORB_InconsistentTypeCode::operator= (
    const CORBA_ORB_InconsistentTypeCode &_tao_excp
  )
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
CORBA_ORB_InconsistentTypeCode*
CORBA_ORB_InconsistentTypeCode::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/CORBA/ORB/InconsistentTypeCode:1.0",
                       exc->_id ())) // same type
    return ACE_dynamic_cast (CORBA_ORB_InconsistentTypeCode*,
                             exc);
  else
    return 0;
}


void CORBA_ORB_InconsistentTypeCode::_raise ()
{
  TAO_RAISE(*this);
}

void CORBA_ORB_InconsistentTypeCode::_tao_encode (TAO_OutputCDR &cdr,
                                                  CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << this->_id ())
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

void CORBA_ORB_InconsistentTypeCode::_tao_decode (TAO_InputCDR &,
                                                  CORBA::Environment &)
{
}

// TAO extension - the _alloc method
CORBA::Exception *CORBA_ORB_InconsistentTypeCode::_alloc (void)
{
  CORBA::Exception *retval = 0;

  ACE_NEW_RETURN (retval,
                  CORBA_ORB_InconsistentTypeCode,
                  0);

  return retval;
}

#endif /* TAO_HAS_MINIMUM_CORBA */
