/* -*- C++ -*- $Id$ */

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// *************************************************************
// Inline operations for exception DynamicAny::DynAny::InvalidValue
// *************************************************************

// *************************************************************
// Inline operations for exception DynamicAny::DynAny::TypeMismatch
// *************************************************************


#if !defined (_DYNAMICANY_DYNANY___VAR_CI_)
#define _DYNAMICANY_DYNANY___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynAny_var
// *************************************************************

ACE_INLINE
DynamicAny::DynAny_var::DynAny_var (void) // default constructor
  : ptr_ (DynAny::_nil ())
{}

ACE_INLINE ::DynamicAny::DynAny_ptr
DynamicAny::DynAny_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynAny_var::DynAny_var (const ::DynamicAny::DynAny_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynAny::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynAny_var::~DynAny_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynAny_var &
DynamicAny::DynAny_var::operator= (DynAny_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynAny_var &
DynamicAny::DynAny_var::operator= (const ::DynamicAny::DynAny_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynAny::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynAny_var::operator const ::DynamicAny::DynAny_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynAny_var::operator ::DynamicAny::DynAny_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr
DynamicAny::DynAny_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr
DynamicAny::DynAny_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr &
DynamicAny::DynAny_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr &
DynamicAny::DynAny_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynAny::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr
DynamicAny::DynAny_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynAny_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynAny::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNANY___OUT_CI_)
#define _DYNAMICANY_DYNANY___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynAny_out
// *************************************************************

ACE_INLINE
DynamicAny::DynAny_out::DynAny_out (DynAny_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynAny::_nil ();
}

ACE_INLINE
DynamicAny::DynAny_out::DynAny_out (DynAny_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynAny::_nil ();
}

ACE_INLINE
DynamicAny::DynAny_out::DynAny_out (const ::DynamicAny::DynAny_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynAny_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynAny_out &
DynamicAny::DynAny_out::operator= (const ::DynamicAny::DynAny_out &p)
{
  this->ptr_ = ACE_const_cast (DynAny_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynAny_out &
DynamicAny::DynAny_out::operator= (const ::DynamicAny::DynAny_var &p)
{
  this->ptr_ = ::DynamicAny::DynAny::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynAny_out &
DynamicAny::DynAny_out::operator= (DynAny_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynAny_out::operator ::DynamicAny::DynAny_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr &
DynamicAny::DynAny_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAny_ptr
DynamicAny::DynAny_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNFIXED___VAR_CI_)
#define _DYNAMICANY_DYNFIXED___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynFixed_var
// *************************************************************

ACE_INLINE
DynamicAny::DynFixed_var::DynFixed_var (void) // default constructor
  : ptr_ (DynFixed::_nil ())
{}

ACE_INLINE ::DynamicAny::DynFixed_ptr
DynamicAny::DynFixed_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynFixed_var::DynFixed_var (const ::DynamicAny::DynFixed_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynFixed::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynFixed_var::~DynFixed_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynFixed_var &
DynamicAny::DynFixed_var::operator= (DynFixed_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynFixed_var &
DynamicAny::DynFixed_var::operator= (const ::DynamicAny::DynFixed_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynFixed::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynFixed_var::operator const ::DynamicAny::DynFixed_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynFixed_var::operator ::DynamicAny::DynFixed_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr
DynamicAny::DynFixed_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr
DynamicAny::DynFixed_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr &
DynamicAny::DynFixed_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr &
DynamicAny::DynFixed_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynFixed::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr
DynamicAny::DynFixed_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynFixed_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynFixed::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNFIXED___OUT_CI_)
#define _DYNAMICANY_DYNFIXED___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynFixed_out
// *************************************************************

ACE_INLINE
DynamicAny::DynFixed_out::DynFixed_out (DynFixed_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynFixed::_nil ();
}

ACE_INLINE
DynamicAny::DynFixed_out::DynFixed_out (DynFixed_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynFixed::_nil ();
}

ACE_INLINE
DynamicAny::DynFixed_out::DynFixed_out (const ::DynamicAny::DynFixed_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynFixed_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynFixed_out &
DynamicAny::DynFixed_out::operator= (const ::DynamicAny::DynFixed_out &p)
{
  this->ptr_ = ACE_const_cast (DynFixed_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynFixed_out &
DynamicAny::DynFixed_out::operator= (const ::DynamicAny::DynFixed_var &p)
{
  this->ptr_ = ::DynamicAny::DynFixed::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynFixed_out &
DynamicAny::DynFixed_out::operator= (DynFixed_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynFixed_out::operator ::DynamicAny::DynFixed_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr &
DynamicAny::DynFixed_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynFixed_ptr
DynamicAny::DynFixed_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNENUM___VAR_CI_)
#define _DYNAMICANY_DYNENUM___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynEnum_var
// *************************************************************

ACE_INLINE
DynamicAny::DynEnum_var::DynEnum_var (void) // default constructor
  : ptr_ (DynEnum::_nil ())
{}

ACE_INLINE ::DynamicAny::DynEnum_ptr
DynamicAny::DynEnum_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynEnum_var::DynEnum_var (const ::DynamicAny::DynEnum_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynEnum::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynEnum_var::~DynEnum_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynEnum_var &
DynamicAny::DynEnum_var::operator= (DynEnum_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynEnum_var &
DynamicAny::DynEnum_var::operator= (const ::DynamicAny::DynEnum_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynEnum::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynEnum_var::operator const ::DynamicAny::DynEnum_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynEnum_var::operator ::DynamicAny::DynEnum_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr
DynamicAny::DynEnum_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr
DynamicAny::DynEnum_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr &
DynamicAny::DynEnum_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr &
DynamicAny::DynEnum_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynEnum::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr
DynamicAny::DynEnum_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynEnum_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynEnum::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNENUM___OUT_CI_)
#define _DYNAMICANY_DYNENUM___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynEnum_out
// *************************************************************

ACE_INLINE
DynamicAny::DynEnum_out::DynEnum_out (DynEnum_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynEnum::_nil ();
}

ACE_INLINE
DynamicAny::DynEnum_out::DynEnum_out (DynEnum_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynEnum::_nil ();
}

ACE_INLINE
DynamicAny::DynEnum_out::DynEnum_out (const ::DynamicAny::DynEnum_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynEnum_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynEnum_out &
DynamicAny::DynEnum_out::operator= (const ::DynamicAny::DynEnum_out &p)
{
  this->ptr_ = ACE_const_cast (DynEnum_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynEnum_out &
DynamicAny::DynEnum_out::operator= (const ::DynamicAny::DynEnum_var &p)
{
  this->ptr_ = ::DynamicAny::DynEnum::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynEnum_out &
DynamicAny::DynEnum_out::operator= (DynEnum_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynEnum_out::operator ::DynamicAny::DynEnum_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr &
DynamicAny::DynEnum_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynEnum_ptr
DynamicAny::DynEnum_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class DynamicAny::NameValuePair_var
// *************************************************************

ACE_INLINE
DynamicAny::NameValuePair_var::NameValuePair_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
DynamicAny::NameValuePair_var::NameValuePair_var (NameValuePair *p)
  : ptr_ (p)
{}

ACE_INLINE
DynamicAny::NameValuePair_var::NameValuePair_var (const ::DynamicAny::NameValuePair_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::DynamicAny::NameValuePair (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameValuePair_var::~NameValuePair_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE DynamicAny::NameValuePair_var &
DynamicAny::NameValuePair_var::operator= (NameValuePair *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::DynamicAny::NameValuePair_var &
DynamicAny::NameValuePair_var::operator= (const ::DynamicAny::NameValuePair_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          DynamicAny::NameValuePair *deep_copy = 
            new DynamicAny::NameValuePair (*p.ptr_);
          
          if (deep_copy != 0)
            {
              DynamicAny::NameValuePair *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::DynamicAny::NameValuePair *
DynamicAny::NameValuePair_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePair *
DynamicAny::NameValuePair_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::NameValuePair_var::operator const ::DynamicAny::NameValuePair &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
DynamicAny::NameValuePair_var::operator ::DynamicAny::NameValuePair &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
DynamicAny::NameValuePair_var::operator ::DynamicAny::NameValuePair &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
DynamicAny::NameValuePair_var::operator ::DynamicAny::NameValuePair *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::DynamicAny::NameValuePair &
DynamicAny::NameValuePair_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePair &
DynamicAny::NameValuePair_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::DynamicAny::NameValuePair *&
DynamicAny::NameValuePair_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePair *
DynamicAny::NameValuePair_var::_retn (void)
{
  ::DynamicAny::NameValuePair *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::DynamicAny::NameValuePair *
DynamicAny::NameValuePair_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class DynamicAny::NameValuePair_out
// *************************************************************

ACE_INLINE
DynamicAny::NameValuePair_out::NameValuePair_out (::DynamicAny::NameValuePair *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameValuePair_out::NameValuePair_out (NameValuePair_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameValuePair_out::NameValuePair_out (const ::DynamicAny::NameValuePair_out &p) // copy constructor
  : ptr_ (ACE_const_cast (NameValuePair_out&, p).ptr_)
{}

ACE_INLINE DynamicAny::NameValuePair_out &
DynamicAny::NameValuePair_out::operator= (const ::DynamicAny::NameValuePair_out &p)
{
  this->ptr_ = ACE_const_cast (NameValuePair_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::NameValuePair_out &
DynamicAny::NameValuePair_out::operator= (NameValuePair *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::NameValuePair_out::operator ::DynamicAny::NameValuePair *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePair *&
DynamicAny::NameValuePair_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePair *
DynamicAny::NameValuePair_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEVALUEPAIRSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEVALUEPAIRSEQ_CI_

  // = Static operations.
  ACE_INLINE DynamicAny::NameValuePair *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    DynamicAny::NameValuePair *retval = 0;
    ACE_NEW_RETURN (retval, DynamicAny::NameValuePair[size], 0);
    return retval;
  }
  
  ACE_INLINE void DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::freebuf (DynamicAny::NameValuePair *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    DynamicAny::NameValuePair *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq (const _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      DynamicAny::NameValuePair *tmp1 = _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (this->maximum_);
      DynamicAny::NameValuePair * const tmp2 = ACE_reinterpret_cast (DynamicAny::NameValuePair * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::operator= (const _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        DynamicAny::NameValuePair *tmp = ACE_reinterpret_cast (DynamicAny::NameValuePair *, this->buffer_);
        _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    DynamicAny::NameValuePair *tmp1 = ACE_reinterpret_cast (DynamicAny::NameValuePair *, this->buffer_);
    DynamicAny::NameValuePair * const tmp2 = ACE_reinterpret_cast (DynamicAny::NameValuePair * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE DynamicAny::NameValuePair &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    DynamicAny::NameValuePair* tmp = ACE_reinterpret_cast(DynamicAny::NameValuePair*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const DynamicAny::NameValuePair &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    DynamicAny::NameValuePair * const tmp = ACE_reinterpret_cast (DynamicAny::NameValuePair* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE DynamicAny::NameValuePair *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::get_buffer (CORBA::Boolean orphan)
  {
    DynamicAny::NameValuePair *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (DynamicAny::NameValuePair*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(DynamicAny::NameValuePair*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const DynamicAny::NameValuePair *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const DynamicAny::NameValuePair * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  DynamicAny::NameValuePair *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      DynamicAny::NameValuePair *tmp = ACE_reinterpret_cast(DynamicAny::NameValuePair*,this->buffer_);
      _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_NAMEVALUEPAIRSEQ_CI_)
#define _DYNAMICANY_NAMEVALUEPAIRSEQ_CI_

// *************************************************************
// Inline operations for class DynamicAny::NameValuePairSeq_var
// *************************************************************

ACE_INLINE
DynamicAny::NameValuePairSeq_var::NameValuePairSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
DynamicAny::NameValuePairSeq_var::NameValuePairSeq_var (NameValuePairSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
DynamicAny::NameValuePairSeq_var::NameValuePairSeq_var (const ::DynamicAny::NameValuePairSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::DynamicAny::NameValuePairSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameValuePairSeq_var::~NameValuePairSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE DynamicAny::NameValuePairSeq_var &
DynamicAny::NameValuePairSeq_var::operator= (NameValuePairSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::NameValuePairSeq_var &
DynamicAny::NameValuePairSeq_var::operator= (const ::DynamicAny::NameValuePairSeq_var &p) // deep copy
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          DynamicAny::NameValuePairSeq *deep_copy = 
            new DynamicAny::NameValuePairSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              DynamicAny::NameValuePairSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::DynamicAny::NameValuePairSeq *
DynamicAny::NameValuePairSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq *
DynamicAny::NameValuePairSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::NameValuePairSeq_var::operator const ::DynamicAny::NameValuePairSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::NameValuePairSeq_var::operator ::DynamicAny::NameValuePairSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::NameValuePairSeq_var::operator ::DynamicAny::NameValuePairSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
DynamicAny::NameValuePairSeq_var::operator ::DynamicAny::NameValuePairSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE DynamicAny::NameValuePair &
DynamicAny::NameValuePairSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const DynamicAny::NameValuePair &
DynamicAny::NameValuePairSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const DynamicAny::NameValuePair &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::DynamicAny::NameValuePairSeq &
DynamicAny::NameValuePairSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq &
DynamicAny::NameValuePairSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::DynamicAny::NameValuePairSeq *&
DynamicAny::NameValuePairSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq *
DynamicAny::NameValuePairSeq_var::_retn (void)
{
  ::DynamicAny::NameValuePairSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq *
DynamicAny::NameValuePairSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class DynamicAny::NameValuePairSeq_out
// *************************************************************

ACE_INLINE
DynamicAny::NameValuePairSeq_out::NameValuePairSeq_out (NameValuePairSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameValuePairSeq_out::NameValuePairSeq_out (NameValuePairSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameValuePairSeq_out::NameValuePairSeq_out (const ::DynamicAny::NameValuePairSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (NameValuePairSeq_out&, p).ptr_)
{}

ACE_INLINE ::DynamicAny::NameValuePairSeq_out &
DynamicAny::NameValuePairSeq_out::operator= (const ::DynamicAny::NameValuePairSeq_out &p)
{
  this->ptr_ = ACE_const_cast (NameValuePairSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq_out &
DynamicAny::NameValuePairSeq_out::operator= (NameValuePairSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::NameValuePairSeq_out::operator ::DynamicAny::NameValuePairSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq *&
DynamicAny::NameValuePairSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameValuePairSeq *
DynamicAny::NameValuePairSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE DynamicAny::NameValuePair &
DynamicAny::NameValuePairSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class DynamicAny::NameDynAnyPair_var
// *************************************************************

ACE_INLINE
DynamicAny::NameDynAnyPair_var::NameDynAnyPair_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
DynamicAny::NameDynAnyPair_var::NameDynAnyPair_var (NameDynAnyPair *p)
  : ptr_ (p)
{}

ACE_INLINE
DynamicAny::NameDynAnyPair_var::NameDynAnyPair_var (const ::DynamicAny::NameDynAnyPair_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::DynamicAny::NameDynAnyPair (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameDynAnyPair_var::~NameDynAnyPair_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE DynamicAny::NameDynAnyPair_var &
DynamicAny::NameDynAnyPair_var::operator= (NameDynAnyPair *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair_var &
DynamicAny::NameDynAnyPair_var::operator= (const ::DynamicAny::NameDynAnyPair_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          DynamicAny::NameDynAnyPair *deep_copy = 
            new DynamicAny::NameDynAnyPair (*p.ptr_);
          
          if (deep_copy != 0)
            {
              DynamicAny::NameDynAnyPair *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::DynamicAny::NameDynAnyPair *
DynamicAny::NameDynAnyPair_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair *
DynamicAny::NameDynAnyPair_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::NameDynAnyPair_var::operator const ::DynamicAny::NameDynAnyPair &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
DynamicAny::NameDynAnyPair_var::operator ::DynamicAny::NameDynAnyPair &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
DynamicAny::NameDynAnyPair_var::operator ::DynamicAny::NameDynAnyPair &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
DynamicAny::NameDynAnyPair_var::operator ::DynamicAny::NameDynAnyPair *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::DynamicAny::NameDynAnyPair &
DynamicAny::NameDynAnyPair_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair &
DynamicAny::NameDynAnyPair_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::DynamicAny::NameDynAnyPair *&
DynamicAny::NameDynAnyPair_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair *
DynamicAny::NameDynAnyPair_var::_retn (void)
{
  ::DynamicAny::NameDynAnyPair *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair *
DynamicAny::NameDynAnyPair_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class DynamicAny::NameDynAnyPair_out
// *************************************************************

ACE_INLINE
DynamicAny::NameDynAnyPair_out::NameDynAnyPair_out (::DynamicAny::NameDynAnyPair *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameDynAnyPair_out::NameDynAnyPair_out (NameDynAnyPair_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameDynAnyPair_out::NameDynAnyPair_out (const ::DynamicAny::NameDynAnyPair_out &p) // copy constructor
  : ptr_ (ACE_const_cast (NameDynAnyPair_out&, p).ptr_)
{}

ACE_INLINE DynamicAny::NameDynAnyPair_out &
DynamicAny::NameDynAnyPair_out::operator= (const ::DynamicAny::NameDynAnyPair_out &p)
{
  this->ptr_ = ACE_const_cast (NameDynAnyPair_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::NameDynAnyPair_out &
DynamicAny::NameDynAnyPair_out::operator= (NameDynAnyPair *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::NameDynAnyPair_out::operator ::DynamicAny::NameDynAnyPair *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair *&
DynamicAny::NameDynAnyPair_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPair *
DynamicAny::NameDynAnyPair_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEDYNANYPAIRSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEDYNANYPAIRSEQ_CI_

  // = Static operations.
  ACE_INLINE DynamicAny::NameDynAnyPair *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    DynamicAny::NameDynAnyPair *retval = 0;
    ACE_NEW_RETURN (retval, DynamicAny::NameDynAnyPair[size], 0);
    return retval;
  }
  
  ACE_INLINE void DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::freebuf (DynamicAny::NameDynAnyPair *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    DynamicAny::NameDynAnyPair *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq (const _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      DynamicAny::NameDynAnyPair *tmp1 = _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (this->maximum_);
      DynamicAny::NameDynAnyPair * const tmp2 = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::operator= (const _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        DynamicAny::NameDynAnyPair *tmp = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair *, this->buffer_);
        _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    DynamicAny::NameDynAnyPair *tmp1 = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair *, this->buffer_);
    DynamicAny::NameDynAnyPair * const tmp2 = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE DynamicAny::NameDynAnyPair &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    DynamicAny::NameDynAnyPair* tmp = ACE_reinterpret_cast(DynamicAny::NameDynAnyPair*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const DynamicAny::NameDynAnyPair &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    DynamicAny::NameDynAnyPair * const tmp = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE DynamicAny::NameDynAnyPair *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::get_buffer (CORBA::Boolean orphan)
  {
    DynamicAny::NameDynAnyPair *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(DynamicAny::NameDynAnyPair*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const DynamicAny::NameDynAnyPair *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const DynamicAny::NameDynAnyPair * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  DynamicAny::NameDynAnyPair *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      DynamicAny::NameDynAnyPair *tmp = ACE_reinterpret_cast(DynamicAny::NameDynAnyPair*,this->buffer_);
      _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_NAMEDYNANYPAIRSEQ_CI_)
#define _DYNAMICANY_NAMEDYNANYPAIRSEQ_CI_

// *************************************************************
// Inline operations for class DynamicAny::NameDynAnyPairSeq_var
// *************************************************************

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_var::NameDynAnyPairSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_var::NameDynAnyPairSeq_var (NameDynAnyPairSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_var::NameDynAnyPairSeq_var (const ::DynamicAny::NameDynAnyPairSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::DynamicAny::NameDynAnyPairSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_var::~NameDynAnyPairSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE DynamicAny::NameDynAnyPairSeq_var &
DynamicAny::NameDynAnyPairSeq_var::operator= (NameDynAnyPairSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::NameDynAnyPairSeq_var &
DynamicAny::NameDynAnyPairSeq_var::operator= (const ::DynamicAny::NameDynAnyPairSeq_var &p) // deep copy
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          DynamicAny::NameDynAnyPairSeq *deep_copy = 
            new DynamicAny::NameDynAnyPairSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              DynamicAny::NameDynAnyPairSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::DynamicAny::NameDynAnyPairSeq *
DynamicAny::NameDynAnyPairSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq *
DynamicAny::NameDynAnyPairSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::NameDynAnyPairSeq_var::operator const ::DynamicAny::NameDynAnyPairSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::NameDynAnyPairSeq_var::operator ::DynamicAny::NameDynAnyPairSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::NameDynAnyPairSeq_var::operator ::DynamicAny::NameDynAnyPairSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
DynamicAny::NameDynAnyPairSeq_var::operator ::DynamicAny::NameDynAnyPairSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE DynamicAny::NameDynAnyPair &
DynamicAny::NameDynAnyPairSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const DynamicAny::NameDynAnyPair &
DynamicAny::NameDynAnyPairSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const DynamicAny::NameDynAnyPair &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::DynamicAny::NameDynAnyPairSeq &
DynamicAny::NameDynAnyPairSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq &
DynamicAny::NameDynAnyPairSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::DynamicAny::NameDynAnyPairSeq *&
DynamicAny::NameDynAnyPairSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq *
DynamicAny::NameDynAnyPairSeq_var::_retn (void)
{
  ::DynamicAny::NameDynAnyPairSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq *
DynamicAny::NameDynAnyPairSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class DynamicAny::NameDynAnyPairSeq_out
// *************************************************************

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_out::NameDynAnyPairSeq_out (NameDynAnyPairSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_out::NameDynAnyPairSeq_out (NameDynAnyPairSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::NameDynAnyPairSeq_out::NameDynAnyPairSeq_out (const ::DynamicAny::NameDynAnyPairSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (NameDynAnyPairSeq_out&, p).ptr_)
{}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq_out &
DynamicAny::NameDynAnyPairSeq_out::operator= (const ::DynamicAny::NameDynAnyPairSeq_out &p)
{
  this->ptr_ = ACE_const_cast (NameDynAnyPairSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq_out &
DynamicAny::NameDynAnyPairSeq_out::operator= (NameDynAnyPairSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::NameDynAnyPairSeq_out::operator ::DynamicAny::NameDynAnyPairSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq *&
DynamicAny::NameDynAnyPairSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::NameDynAnyPairSeq *
DynamicAny::NameDynAnyPairSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE DynamicAny::NameDynAnyPair &
DynamicAny::NameDynAnyPairSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNSTRUCT___VAR_CI_)
#define _DYNAMICANY_DYNSTRUCT___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynStruct_var
// *************************************************************

ACE_INLINE
DynamicAny::DynStruct_var::DynStruct_var (void) // default constructor
  : ptr_ (DynStruct::_nil ())
{}

ACE_INLINE ::DynamicAny::DynStruct_ptr
DynamicAny::DynStruct_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynStruct_var::DynStruct_var (const ::DynamicAny::DynStruct_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynStruct::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynStruct_var::~DynStruct_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynStruct_var &
DynamicAny::DynStruct_var::operator= (DynStruct_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynStruct_var &
DynamicAny::DynStruct_var::operator= (const ::DynamicAny::DynStruct_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynStruct::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynStruct_var::operator const ::DynamicAny::DynStruct_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynStruct_var::operator ::DynamicAny::DynStruct_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr
DynamicAny::DynStruct_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr
DynamicAny::DynStruct_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr &
DynamicAny::DynStruct_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr &
DynamicAny::DynStruct_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynStruct::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr
DynamicAny::DynStruct_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynStruct_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynStruct::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNSTRUCT___OUT_CI_)
#define _DYNAMICANY_DYNSTRUCT___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynStruct_out
// *************************************************************

ACE_INLINE
DynamicAny::DynStruct_out::DynStruct_out (DynStruct_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynStruct::_nil ();
}

ACE_INLINE
DynamicAny::DynStruct_out::DynStruct_out (DynStruct_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynStruct::_nil ();
}

ACE_INLINE
DynamicAny::DynStruct_out::DynStruct_out (const ::DynamicAny::DynStruct_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynStruct_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynStruct_out &
DynamicAny::DynStruct_out::operator= (const ::DynamicAny::DynStruct_out &p)
{
  this->ptr_ = ACE_const_cast (DynStruct_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynStruct_out &
DynamicAny::DynStruct_out::operator= (const ::DynamicAny::DynStruct_var &p)
{
  this->ptr_ = ::DynamicAny::DynStruct::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynStruct_out &
DynamicAny::DynStruct_out::operator= (DynStruct_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynStruct_out::operator ::DynamicAny::DynStruct_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr &
DynamicAny::DynStruct_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynStruct_ptr
DynamicAny::DynStruct_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNUNION___VAR_CI_)
#define _DYNAMICANY_DYNUNION___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynUnion_var
// *************************************************************

ACE_INLINE
DynamicAny::DynUnion_var::DynUnion_var (void) // default constructor
  : ptr_ (DynUnion::_nil ())
{}

ACE_INLINE ::DynamicAny::DynUnion_ptr
DynamicAny::DynUnion_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynUnion_var::DynUnion_var (const ::DynamicAny::DynUnion_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynUnion::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynUnion_var::~DynUnion_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynUnion_var &
DynamicAny::DynUnion_var::operator= (DynUnion_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynUnion_var &
DynamicAny::DynUnion_var::operator= (const ::DynamicAny::DynUnion_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynUnion::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynUnion_var::operator const ::DynamicAny::DynUnion_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynUnion_var::operator ::DynamicAny::DynUnion_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr
DynamicAny::DynUnion_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr
DynamicAny::DynUnion_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr &
DynamicAny::DynUnion_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr &
DynamicAny::DynUnion_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynUnion::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr
DynamicAny::DynUnion_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynUnion_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynUnion::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNUNION___OUT_CI_)
#define _DYNAMICANY_DYNUNION___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynUnion_out
// *************************************************************

ACE_INLINE
DynamicAny::DynUnion_out::DynUnion_out (DynUnion_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynUnion::_nil ();
}

ACE_INLINE
DynamicAny::DynUnion_out::DynUnion_out (DynUnion_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynUnion::_nil ();
}

ACE_INLINE
DynamicAny::DynUnion_out::DynUnion_out (const ::DynamicAny::DynUnion_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynUnion_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynUnion_out &
DynamicAny::DynUnion_out::operator= (const ::DynamicAny::DynUnion_out &p)
{
  this->ptr_ = ACE_const_cast (DynUnion_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynUnion_out &
DynamicAny::DynUnion_out::operator= (const ::DynamicAny::DynUnion_var &p)
{
  this->ptr_ = ::DynamicAny::DynUnion::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynUnion_out &
DynamicAny::DynUnion_out::operator= (DynUnion_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynUnion_out::operator ::DynamicAny::DynUnion_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr &
DynamicAny::DynUnion_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynUnion_ptr
DynamicAny::DynUnion_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_ANYSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_ANYSEQ_CI_

  // = Static operations.
  ACE_INLINE CORBA::Any *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    CORBA::Any *retval = 0;
    ACE_NEW_RETURN (retval, CORBA::Any[size], 0);
    return retval;
  }
  
  ACE_INLINE void DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::freebuf (CORBA::Any *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::_TAO_Unbounded_Sequence_DynamicAny_AnySeq (void) // Default constructor.
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::_TAO_Unbounded_Sequence_DynamicAny_AnySeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::_TAO_Unbounded_Sequence_DynamicAny_AnySeq (CORBA::ULong maximum,
    CORBA::ULong length,
    CORBA::Any *data,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::_TAO_Unbounded_Sequence_DynamicAny_AnySeq (const _TAO_Unbounded_Sequence_DynamicAny_AnySeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      CORBA::Any *tmp1 = _TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (this->maximum_);
      CORBA::Any * const tmp2 = ACE_reinterpret_cast (CORBA::Any * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp1[i] = tmp2[i];
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::operator= (const _TAO_Unbounded_Sequence_DynamicAny_AnySeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        CORBA::Any *tmp = ACE_reinterpret_cast (CORBA::Any *, this->buffer_);
        _TAO_Unbounded_Sequence_DynamicAny_AnySeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    CORBA::Any *tmp1 = ACE_reinterpret_cast (CORBA::Any *, this->buffer_);
    CORBA::Any * const tmp2 = ACE_reinterpret_cast (CORBA::Any * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    return *this;
  }
  
  // = Accessors.
  ACE_INLINE CORBA::Any &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    CORBA::Any* tmp = ACE_reinterpret_cast(CORBA::Any*,this->buffer_);
    return tmp[i];
  }
  
  ACE_INLINE const CORBA::Any &
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    CORBA::Any * const tmp = ACE_reinterpret_cast (CORBA::Any* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }
  
  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  
  ACE_INLINE CORBA::Any *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::get_buffer (CORBA::Boolean orphan)
  {
    CORBA::Any *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (this->length_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (CORBA::Any*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(CORBA::Any*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const CORBA::Any *
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const CORBA::Any * ACE_CAST_CONST, this->buffer_);
  }
  
  ACE_INLINE void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::replace (CORBA::ULong max,
  CORBA::ULong length,
  CORBA::Any *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      CORBA::Any *tmp = ACE_reinterpret_cast(CORBA::Any*,this->buffer_);
      _TAO_Unbounded_Sequence_DynamicAny_AnySeq::freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_ANYSEQ_CI_)
#define _DYNAMICANY_ANYSEQ_CI_

// *************************************************************
// Inline operations for class DynamicAny::AnySeq_var
// *************************************************************

ACE_INLINE
DynamicAny::AnySeq_var::AnySeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
DynamicAny::AnySeq_var::AnySeq_var (AnySeq *p)
  : ptr_ (p)
{}

ACE_INLINE
DynamicAny::AnySeq_var::AnySeq_var (const ::DynamicAny::AnySeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::DynamicAny::AnySeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::AnySeq_var::~AnySeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE DynamicAny::AnySeq_var &
DynamicAny::AnySeq_var::operator= (AnySeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::AnySeq_var &
DynamicAny::AnySeq_var::operator= (const ::DynamicAny::AnySeq_var &p) // deep copy
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          DynamicAny::AnySeq *deep_copy = 
            new DynamicAny::AnySeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              DynamicAny::AnySeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::DynamicAny::AnySeq *
DynamicAny::AnySeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::AnySeq *
DynamicAny::AnySeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::AnySeq_var::operator const ::DynamicAny::AnySeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::AnySeq_var::operator ::DynamicAny::AnySeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::AnySeq_var::operator ::DynamicAny::AnySeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
DynamicAny::AnySeq_var::operator ::DynamicAny::AnySeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE CORBA::Any &
DynamicAny::AnySeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const CORBA::Any &
DynamicAny::AnySeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::Any &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::DynamicAny::AnySeq &
DynamicAny::AnySeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::DynamicAny::AnySeq &
DynamicAny::AnySeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::DynamicAny::AnySeq *&
DynamicAny::AnySeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::AnySeq *
DynamicAny::AnySeq_var::_retn (void)
{
  ::DynamicAny::AnySeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::DynamicAny::AnySeq *
DynamicAny::AnySeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class DynamicAny::AnySeq_out
// *************************************************************

ACE_INLINE
DynamicAny::AnySeq_out::AnySeq_out (AnySeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::AnySeq_out::AnySeq_out (AnySeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::AnySeq_out::AnySeq_out (const ::DynamicAny::AnySeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (AnySeq_out&, p).ptr_)
{}

ACE_INLINE ::DynamicAny::AnySeq_out &
DynamicAny::AnySeq_out::operator= (const ::DynamicAny::AnySeq_out &p)
{
  this->ptr_ = ACE_const_cast (AnySeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::DynamicAny::AnySeq_out &
DynamicAny::AnySeq_out::operator= (AnySeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::AnySeq_out::operator ::DynamicAny::AnySeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::AnySeq *&
DynamicAny::AnySeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::AnySeq *
DynamicAny::AnySeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE CORBA::Any &
DynamicAny::AnySeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_DYNAMICANY_DYNANYSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_DYNAMICANY_DYNANYSEQ_CI_

  ACE_INLINE DynamicAny::DynAny **
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (CORBA::ULong nelems)
  {
    DynamicAny::DynAny **buf = 0;
    
    ACE_NEW_RETURN (buf, DynamicAny::DynAny*[nelems], 0);
    
    for (CORBA::ULong i = 0; i < nelems; i++)
      buf[i] = DynamicAny::DynAny::_nil ();
    
    return buf;
  }
  
  ACE_INLINE void 
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::freebuf (DynamicAny::DynAny **buffer)
  {
    if (buffer == 0)
      return;
    delete[] buffer;
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq (void)
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq (CORBA::ULong maximum)
    : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (maximum))
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq (CORBA::ULong maximum,
    CORBA::ULong length,
    DynamicAny::DynAny* *value,
    CORBA::Boolean release)
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
  {
  }
  
  ACE_INLINE
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq(const _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq &rhs)
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    if (rhs.buffer_ != 0)
    {
      DynamicAny::DynAny **tmp1 = _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (this->maximum_);
      DynamicAny::DynAny ** const tmp2 = ACE_reinterpret_cast (DynamicAny::DynAny ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        tmp1[i] = DynamicAny::DynAny::_duplicate (tmp2[i]);
      
      this->buffer_ = tmp1;
    }
    else
    {
      this->buffer_ = 0;
    }
  }
  
  ACE_INLINE DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq &
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::operator= (const _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq &rhs)
  {
    if (this == &rhs)
      return *this;
    
    if (this->release_)
    {
      DynamicAny::DynAny **tmp = ACE_reinterpret_cast (DynamicAny::DynAny **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        CORBA::release (tmp[i]);
        tmp[i] = DynamicAny::DynAny::_nil ();
      }
      if (this->maximum_ < rhs.maximum_)
      {
        _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::freebuf (tmp);
        this->buffer_ = _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (rhs.maximum_);
    
    TAO_Unbounded_Base_Sequence::operator= (rhs);
    
    DynamicAny::DynAny **tmp1 = ACE_reinterpret_cast (DynamicAny::DynAny **, this->buffer_);
    DynamicAny::DynAny ** const tmp2 = ACE_reinterpret_cast (DynamicAny::DynAny ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      tmp1[i] = DynamicAny::DynAny::_duplicate (tmp2[i]);
    
    return *this;
  }
  
  ACE_INLINE TAO_Object_Manager<DynamicAny::DynAny,DynamicAny::DynAny_var>
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::operator[] (CORBA::ULong index) const
  // read-write accessor
  {
    ACE_ASSERT (index < this->maximum_);
    DynamicAny::DynAny ** const tmp = ACE_reinterpret_cast (DynamicAny::DynAny ** ACE_CAST_CONST, this->buffer_);
    return TAO_Object_Manager<DynamicAny::DynAny,DynamicAny::DynAny_var> (tmp + index, this->release_);
  }
  
  ACE_INLINE DynamicAny::DynAny* *
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::get_buffer (CORBA::Boolean orphan)
  {
    DynamicAny::DynAny **result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (this->maximum_);
        this->buffer_ = result;
        this->release_ = 1;
      }
      else
      {
        result = ACE_reinterpret_cast (DynamicAny::DynAny**, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(DynamicAny::DynAny**,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }
  
  ACE_INLINE const DynamicAny::DynAny* *
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::get_buffer (void) const
  {
    return ACE_reinterpret_cast(const DynamicAny::DynAny ** ACE_CAST_CONST, this->buffer_);
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_DYNANYSEQ_CI_)
#define _DYNAMICANY_DYNANYSEQ_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynAnySeq_var
// *************************************************************

ACE_INLINE
DynamicAny::DynAnySeq_var::DynAnySeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
DynamicAny::DynAnySeq_var::DynAnySeq_var (DynAnySeq *p)
  : ptr_ (p)
{}

ACE_INLINE
DynamicAny::DynAnySeq_var::DynAnySeq_var (const ::DynamicAny::DynAnySeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::DynamicAny::DynAnySeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::DynAnySeq_var::~DynAnySeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE DynamicAny::DynAnySeq_var &
DynamicAny::DynAnySeq_var::operator= (DynAnySeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynAnySeq_var &
DynamicAny::DynAnySeq_var::operator= (const ::DynamicAny::DynAnySeq_var &p) // deep copy
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          DynamicAny::DynAnySeq *deep_copy = 
            new DynamicAny::DynAnySeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              DynamicAny::DynAnySeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::DynamicAny::DynAnySeq *
DynamicAny::DynAnySeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnySeq *
DynamicAny::DynAnySeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynAnySeq_var::operator const ::DynamicAny::DynAnySeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::DynAnySeq_var::operator ::DynamicAny::DynAnySeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
DynamicAny::DynAnySeq_var::operator ::DynamicAny::DynAnySeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
DynamicAny::DynAnySeq_var::operator ::DynamicAny::DynAnySeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<DynamicAny::DynAny, DynamicAny::DynAny_var>
DynamicAny::DynAnySeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::DynamicAny::DynAnySeq &
DynamicAny::DynAnySeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnySeq &
DynamicAny::DynAnySeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::DynamicAny::DynAnySeq *&
DynamicAny::DynAnySeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnySeq *
DynamicAny::DynAnySeq_var::_retn (void)
{
  ::DynamicAny::DynAnySeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::DynamicAny::DynAnySeq *
DynamicAny::DynAnySeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class DynamicAny::DynAnySeq_out
// *************************************************************

ACE_INLINE
DynamicAny::DynAnySeq_out::DynAnySeq_out (DynAnySeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::DynAnySeq_out::DynAnySeq_out (DynAnySeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
DynamicAny::DynAnySeq_out::DynAnySeq_out (const ::DynamicAny::DynAnySeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynAnySeq_out&, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynAnySeq_out &
DynamicAny::DynAnySeq_out::operator= (const ::DynamicAny::DynAnySeq_out &p)
{
  this->ptr_ = ACE_const_cast (DynAnySeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::DynamicAny::DynAnySeq_out &
DynamicAny::DynAnySeq_out::operator= (DynAnySeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynAnySeq_out::operator ::DynamicAny::DynAnySeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnySeq *&
DynamicAny::DynAnySeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnySeq *
DynamicAny::DynAnySeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<DynamicAny::DynAny, DynamicAny::DynAny_var>
DynamicAny::DynAnySeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNSEQUENCE___VAR_CI_)
#define _DYNAMICANY_DYNSEQUENCE___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynSequence_var
// *************************************************************

ACE_INLINE
DynamicAny::DynSequence_var::DynSequence_var (void) // default constructor
  : ptr_ (DynSequence::_nil ())
{}

ACE_INLINE ::DynamicAny::DynSequence_ptr
DynamicAny::DynSequence_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynSequence_var::DynSequence_var (const ::DynamicAny::DynSequence_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynSequence::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynSequence_var::~DynSequence_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynSequence_var &
DynamicAny::DynSequence_var::operator= (DynSequence_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynSequence_var &
DynamicAny::DynSequence_var::operator= (const ::DynamicAny::DynSequence_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynSequence::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynSequence_var::operator const ::DynamicAny::DynSequence_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynSequence_var::operator ::DynamicAny::DynSequence_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr
DynamicAny::DynSequence_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr
DynamicAny::DynSequence_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr &
DynamicAny::DynSequence_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr &
DynamicAny::DynSequence_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynSequence::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr
DynamicAny::DynSequence_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynSequence_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynSequence::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNSEQUENCE___OUT_CI_)
#define _DYNAMICANY_DYNSEQUENCE___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynSequence_out
// *************************************************************

ACE_INLINE
DynamicAny::DynSequence_out::DynSequence_out (DynSequence_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynSequence::_nil ();
}

ACE_INLINE
DynamicAny::DynSequence_out::DynSequence_out (DynSequence_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynSequence::_nil ();
}

ACE_INLINE
DynamicAny::DynSequence_out::DynSequence_out (const ::DynamicAny::DynSequence_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynSequence_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynSequence_out &
DynamicAny::DynSequence_out::operator= (const ::DynamicAny::DynSequence_out &p)
{
  this->ptr_ = ACE_const_cast (DynSequence_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynSequence_out &
DynamicAny::DynSequence_out::operator= (const ::DynamicAny::DynSequence_var &p)
{
  this->ptr_ = ::DynamicAny::DynSequence::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynSequence_out &
DynamicAny::DynSequence_out::operator= (DynSequence_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynSequence_out::operator ::DynamicAny::DynSequence_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr &
DynamicAny::DynSequence_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynSequence_ptr
DynamicAny::DynSequence_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNARRAY___VAR_CI_)
#define _DYNAMICANY_DYNARRAY___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynArray_var
// *************************************************************

ACE_INLINE
DynamicAny::DynArray_var::DynArray_var (void) // default constructor
  : ptr_ (DynArray::_nil ())
{}

ACE_INLINE ::DynamicAny::DynArray_ptr
DynamicAny::DynArray_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynArray_var::DynArray_var (const ::DynamicAny::DynArray_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynArray::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynArray_var::~DynArray_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynArray_var &
DynamicAny::DynArray_var::operator= (DynArray_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynArray_var &
DynamicAny::DynArray_var::operator= (const ::DynamicAny::DynArray_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynArray::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynArray_var::operator const ::DynamicAny::DynArray_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynArray_var::operator ::DynamicAny::DynArray_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr
DynamicAny::DynArray_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr
DynamicAny::DynArray_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr &
DynamicAny::DynArray_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr &
DynamicAny::DynArray_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynArray::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr
DynamicAny::DynArray_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynArray_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynArray::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNARRAY___OUT_CI_)
#define _DYNAMICANY_DYNARRAY___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynArray_out
// *************************************************************

ACE_INLINE
DynamicAny::DynArray_out::DynArray_out (DynArray_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynArray::_nil ();
}

ACE_INLINE
DynamicAny::DynArray_out::DynArray_out (DynArray_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynArray::_nil ();
}

ACE_INLINE
DynamicAny::DynArray_out::DynArray_out (const ::DynamicAny::DynArray_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynArray_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynArray_out &
DynamicAny::DynArray_out::operator= (const ::DynamicAny::DynArray_out &p)
{
  this->ptr_ = ACE_const_cast (DynArray_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynArray_out &
DynamicAny::DynArray_out::operator= (const ::DynamicAny::DynArray_var &p)
{
  this->ptr_ = ::DynamicAny::DynArray::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynArray_out &
DynamicAny::DynArray_out::operator= (DynArray_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynArray_out::operator ::DynamicAny::DynArray_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr &
DynamicAny::DynArray_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynArray_ptr
DynamicAny::DynArray_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNVALUE___VAR_CI_)
#define _DYNAMICANY_DYNVALUE___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynValue_var
// *************************************************************

ACE_INLINE
DynamicAny::DynValue_var::DynValue_var (void) // default constructor
  : ptr_ (DynValue::_nil ())
{}

ACE_INLINE ::DynamicAny::DynValue_ptr
DynamicAny::DynValue_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynValue_var::DynValue_var (const ::DynamicAny::DynValue_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynValue::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynValue_var::~DynValue_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynValue_var &
DynamicAny::DynValue_var::operator= (DynValue_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynValue_var &
DynamicAny::DynValue_var::operator= (const ::DynamicAny::DynValue_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynValue::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynValue_var::operator const ::DynamicAny::DynValue_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynValue_var::operator ::DynamicAny::DynValue_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr
DynamicAny::DynValue_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr
DynamicAny::DynValue_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr &
DynamicAny::DynValue_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr &
DynamicAny::DynValue_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynValue::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr
DynamicAny::DynValue_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynValue_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynValue::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNVALUE___OUT_CI_)
#define _DYNAMICANY_DYNVALUE___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynValue_out
// *************************************************************

ACE_INLINE
DynamicAny::DynValue_out::DynValue_out (DynValue_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynValue::_nil ();
}

ACE_INLINE
DynamicAny::DynValue_out::DynValue_out (DynValue_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynValue::_nil ();
}

ACE_INLINE
DynamicAny::DynValue_out::DynValue_out (const ::DynamicAny::DynValue_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynValue_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynValue_out &
DynamicAny::DynValue_out::operator= (const ::DynamicAny::DynValue_out &p)
{
  this->ptr_ = ACE_const_cast (DynValue_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynValue_out &
DynamicAny::DynValue_out::operator= (const ::DynamicAny::DynValue_var &p)
{
  this->ptr_ = ::DynamicAny::DynValue::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynValue_out &
DynamicAny::DynValue_out::operator= (DynValue_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynValue_out::operator ::DynamicAny::DynValue_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr &
DynamicAny::DynValue_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynValue_ptr
DynamicAny::DynValue_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception DynamicAny::DynAnyFactory::InconsistentTypeCode
// *************************************************************


#if !defined (_DYNAMICANY_DYNANYFACTORY___VAR_CI_)
#define _DYNAMICANY_DYNANYFACTORY___VAR_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynAnyFactory_var
// *************************************************************

ACE_INLINE
DynamicAny::DynAnyFactory_var::DynAnyFactory_var (void) // default constructor
  : ptr_ (DynAnyFactory::_nil ())
{}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
DynamicAny::DynAnyFactory_var::DynAnyFactory_var (const ::DynamicAny::DynAnyFactory_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (DynAnyFactory::_duplicate (p.ptr ()))
{}

ACE_INLINE
DynamicAny::DynAnyFactory_var::~DynAnyFactory_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE DynamicAny::DynAnyFactory_var &
DynamicAny::DynAnyFactory_var::operator= (DynAnyFactory_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE DynamicAny::DynAnyFactory_var &
DynamicAny::DynAnyFactory_var::operator= (const ::DynamicAny::DynAnyFactory_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::DynamicAny::DynAnyFactory::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE 
DynamicAny::DynAnyFactory_var::operator const ::DynamicAny::DynAnyFactory_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE 
DynamicAny::DynAnyFactory_var::operator ::DynamicAny::DynAnyFactory_ptr &() // cast 
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr &
DynamicAny::DynAnyFactory_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr &
DynamicAny::DynAnyFactory_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynAnyFactory::_nil ();
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::DynamicAny::DynAnyFactory_ptr val = this->ptr_;
  this->ptr_ = ::DynamicAny::DynAnyFactory::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_DYNAMICANY_DYNANYFACTORY___OUT_CI_)
#define _DYNAMICANY_DYNANYFACTORY___OUT_CI_

// *************************************************************
// Inline operations for class DynamicAny::DynAnyFactory_out
// *************************************************************

ACE_INLINE
DynamicAny::DynAnyFactory_out::DynAnyFactory_out (DynAnyFactory_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::DynamicAny::DynAnyFactory::_nil ();
}

ACE_INLINE
DynamicAny::DynAnyFactory_out::DynAnyFactory_out (DynAnyFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::DynamicAny::DynAnyFactory::_nil ();
}

ACE_INLINE
DynamicAny::DynAnyFactory_out::DynAnyFactory_out (const ::DynamicAny::DynAnyFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DynAnyFactory_out &, p).ptr_)
{}

ACE_INLINE ::DynamicAny::DynAnyFactory_out &
DynamicAny::DynAnyFactory_out::operator= (const ::DynamicAny::DynAnyFactory_out &p)
{
  this->ptr_ = ACE_const_cast (DynAnyFactory_out&, p).ptr_;
  return *this;
}

ACE_INLINE DynamicAny::DynAnyFactory_out &
DynamicAny::DynAnyFactory_out::operator= (const ::DynamicAny::DynAnyFactory_var &p)
{
  this->ptr_ = ::DynamicAny::DynAnyFactory::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE DynamicAny::DynAnyFactory_out &
DynamicAny::DynAnyFactory_out::operator= (DynAnyFactory_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
DynamicAny::DynAnyFactory_out::operator ::DynamicAny::DynAnyFactory_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr &
DynamicAny::DynAnyFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const DynamicAny::NameValuePair &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, DynamicAny::NameValuePair &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.value)
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_DynamicAny_NameValuePairSeq_I_
#define _TAO_CDR_OP_DynamicAny_NameValuePairSeq_I_

CORBA::Boolean TAO_DynamicAny_Export operator<< (
    TAO_OutputCDR &,
    const DynamicAny::NameValuePairSeq &
  );
CORBA::Boolean TAO_DynamicAny_Export operator>> (
    TAO_InputCDR &,
    DynamicAny::NameValuePairSeq &
  );

#endif /* _TAO_CDR_OP_DynamicAny_NameValuePairSeq_I_ */


#if !defined _TAO_CDR_OP_DynamicAny_AnySeq_I_
#define _TAO_CDR_OP_DynamicAny_AnySeq_I_

CORBA::Boolean TAO_DynamicAny_Export operator<< (
    TAO_OutputCDR &,
    const DynamicAny::AnySeq &
  );
CORBA::Boolean TAO_DynamicAny_Export operator>> (
    TAO_InputCDR &,
    DynamicAny::AnySeq &
  );

#endif /* _TAO_CDR_OP_DynamicAny_AnySeq_I_ */

