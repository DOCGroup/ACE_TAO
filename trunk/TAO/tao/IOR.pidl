//
// $Id$
//
// ================================================================
//
// = LIBRARY
//   TAO
//
// = FILENAME
//   XXX
//
// = DESCRIPTION
//   This file was used to generate the code in IOR{C,S,S_T}.{h,i,cpp}
//   The code is then hand-crafted to compile it inside the ORB, avoid
//   cyclic dependencies and enforce the locality constraints on
//   certain objects.
//
// ================================================================

#pragma prefix "omg.org"

module TAO_IOP {

  interface TAO_IOR_Manipulation {

    exception EmptyProfileList {};
    exception NotFound {};
    exception Duplicate {};
    exception Invalid_IOR {};

    // Manipulating Object References.  While this interface does not
    // assume the use of CORBA complient IOPs, the IOP termonology is
    // used throughout.
    // Object references (Object) are used since they encapsulate the
    // notion of object references and IORs.
    // Note, an IOR contains one or more profiles and a profile can be
    // considered to represent the location or route to a specific instance
    // of an object.
    // A profile may also contain supplimentary information useful for
    // differrent services such as security.
    // All Object references may have multiple profiles

    typedef sequence <Object> IORList;

    Object merge_iors (in IORList iors)
      raises (EmptyProfileList,Duplicate,Invalid_IOR);
    // Create a new object reference by merging the profiles lists in the
    // supplied list of one or more object references.

    Object add_profiles (in Object ior1,
                         in Object ior2)
      raises (EmptyProfileList, Duplicate, Invalid_IOR);
    // copy the profile list from "ior2" to "ior1".
    // Note on ordering, while the current implementation will place
    // the profiles from ior2 (which are not already in ior1) on the
    // end of the profile list in ior1, there is no guarantee this ordering
    // will be maintained.  For example, string_to_object or object_to_string
    // may reorder the profile lists.  So, if it is important to use one
    // profile before another then policies should be used along with tagged
    // components/tagged profiles.

    Object remove_profiles (in Object ior1,
                            in Object ior2)
      raises (Invalid_IOR, EmptyProfileList, NotFound);
    // Any profile in ior1 which matches at least one profile in ior2
    // will be removed.  Returns a new object reference

    unsigned long is_in_ior(in Object ior1, in Object ior2)
      raises (NotFound);
    // returns number of profiles which are in both ior1 and ior2.

    unsigned long get_profile_count (in Object ior)
      raises (EmptyProfileList);
    // This will return the number of profiles contained in the
    // corresponding object reference for this object.

  };
};
