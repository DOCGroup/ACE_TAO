// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:314


#include "RTScheduler.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */


#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "RTSchedulerC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int RTScheduling::ThreadAction::_tao_class_id = 0;

RTScheduling::ThreadAction_ptr
RTScheduling::tao_ThreadAction_life::tao_duplicate (
    ThreadAction_ptr p
  )
{
  return ThreadAction::_duplicate (p);
}

void
RTScheduling::tao_ThreadAction_life::tao_release (
    ThreadAction_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::ThreadAction_ptr
RTScheduling::tao_ThreadAction_life::tao_nil (
    void
  )
{
  return ThreadAction::_nil ();
}

CORBA::Boolean
RTScheduling::tao_ThreadAction_life::tao_marshal (
    ThreadAction_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

RTScheduling::ThreadAction_ptr
RTScheduling::tao_ThreadAction_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ThreadAction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::tao_ThreadAction_cast::tao_upcast (
    void *src
  )
{
  ThreadAction **tmp =
    ACE_static_cast (ThreadAction **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        RTScheduling::ThreadAction,
        RTScheduling::tao_ThreadAction_life
      >;
  template class
    TAO_Objref_Out_T<
        RTScheduling::ThreadAction,
        RTScheduling::tao_ThreadAction_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        RTScheduling::ThreadAction, \
        RTScheduling::tao_ThreadAction_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        RTScheduling::ThreadAction, \
        RTScheduling::tao_ThreadAction_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

RTScheduling::ThreadAction::ThreadAction (void)
{}

RTScheduling::ThreadAction::~ThreadAction (void)
{}

void 
RTScheduling::ThreadAction::_tao_any_destructor (void *_tao_void_pointer)
{
  ThreadAction *tmp = ACE_static_cast (ThreadAction *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ThreadAction::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::ThreadAction_ptr 
RTScheduling::ThreadAction::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ThreadAction::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          ThreadAction_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptrdiff_t,
                  &ThreadAction::_tao_class_id
                )
            )
        );
}

RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction::_duplicate (ThreadAction_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::ThreadAction::_tao_QueryInterface (ptrdiff_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &ACE_NESTED_CLASS (::RTScheduling, ThreadAction)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptrdiff_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::ThreadAction::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/ThreadAction:1.0";
}

CORBA::Boolean
RTScheduling::ThreadAction::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_ThreadAction[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f546872), 
  ACE_NTOHL (0x65616441), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:RTScheduling/ThreadAction:1.0
    13,
  ACE_NTOHL (0x54687265), 
  ACE_NTOHL (0x61644163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ThreadAction
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_ThreadAction (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_ThreadAction),
    (char *) &_oc_RTScheduling_ThreadAction,
    0,
    sizeof (RTScheduling::ThreadAction)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ThreadAction,
    &_tc_TAO_tc_RTScheduling_ThreadAction
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int RTScheduling::DistributableThread::_tao_class_id = 0;

RTScheduling::DistributableThread_ptr
RTScheduling::tao_DistributableThread_life::tao_duplicate (
    DistributableThread_ptr p
  )
{
  return DistributableThread::_duplicate (p);
}

void
RTScheduling::tao_DistributableThread_life::tao_release (
    DistributableThread_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::DistributableThread_ptr
RTScheduling::tao_DistributableThread_life::tao_nil (
    void
  )
{
  return DistributableThread::_nil ();
}

CORBA::Boolean
RTScheduling::tao_DistributableThread_life::tao_marshal (
    DistributableThread_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

RTScheduling::DistributableThread_ptr
RTScheduling::tao_DistributableThread_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return DistributableThread::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::tao_DistributableThread_cast::tao_upcast (
    void *src
  )
{
  DistributableThread **tmp =
    ACE_static_cast (DistributableThread **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        RTScheduling::DistributableThread,
        RTScheduling::tao_DistributableThread_life
      >;
  template class
    TAO_Objref_Out_T<
        RTScheduling::DistributableThread,
        RTScheduling::tao_DistributableThread_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        RTScheduling::DistributableThread, \
        RTScheduling::tao_DistributableThread_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        RTScheduling::DistributableThread, \
        RTScheduling::tao_DistributableThread_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

RTScheduling::DistributableThread::DistributableThread (void)
{}

RTScheduling::DistributableThread::~DistributableThread (void)
{}

void 
RTScheduling::DistributableThread::_tao_any_destructor (void *_tao_void_pointer)
{
  DistributableThread *tmp = ACE_static_cast (DistributableThread *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return DistributableThread::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::DistributableThread_ptr 
RTScheduling::DistributableThread::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return DistributableThread::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          DistributableThread_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptrdiff_t,
                  &DistributableThread::_tao_class_id
                )
            )
        );
}

RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread::_duplicate (DistributableThread_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::DistributableThread::_tao_QueryInterface (ptrdiff_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &ACE_NESTED_CLASS (::RTScheduling, DistributableThread)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptrdiff_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::DistributableThread::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/DistributableThread:1.0";
}

CORBA::Boolean
RTScheduling::DistributableThread::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_DistributableThread[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f446973), 
  ACE_NTOHL (0x74726962), 
  ACE_NTOHL (0x75746162), 
  ACE_NTOHL (0x6c655468), 
  ACE_NTOHL (0x72656164), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:RTScheduling/DistributableThread:1.0
    20,
  ACE_NTOHL (0x44697374), 
  ACE_NTOHL (0x72696275), 
  ACE_NTOHL (0x7461626c), 
  ACE_NTOHL (0x65546872), 
  ACE_NTOHL (0x65616400),  // name = DistributableThread
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_DistributableThread (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_DistributableThread),
    (char *) &_oc_RTScheduling_DistributableThread,
    0,
    sizeof (RTScheduling::DistributableThread)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_DistributableThread,
    &_tc_TAO_tc_RTScheduling_DistributableThread
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int RTScheduling::Current::_tao_class_id = 0;

RTScheduling::Current_ptr
RTScheduling::tao_Current_life::tao_duplicate (
    Current_ptr p
  )
{
  return Current::_duplicate (p);
}

void
RTScheduling::tao_Current_life::tao_release (
    Current_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::Current_ptr
RTScheduling::tao_Current_life::tao_nil (
    void
  )
{
  return Current::_nil ();
}

CORBA::Boolean
RTScheduling::tao_Current_life::tao_marshal (
    Current_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

RTScheduling::Current_ptr
RTScheduling::tao_Current_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Current::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::tao_Current_cast::tao_upcast (
    void *src
  )
{
  Current **tmp =
    ACE_static_cast (Current **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        RTScheduling::Current,
        RTScheduling::tao_Current_life
      >;
  template class
    TAO_Objref_Out_T<
        RTScheduling::Current,
        RTScheduling::tao_Current_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        RTScheduling::Current, \
        RTScheduling::tao_Current_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        RTScheduling::Current, \
        RTScheduling::tao_Current_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

RTScheduling::Current::Current (void)
{}

RTScheduling::Current::~Current (void)
{}

void 
RTScheduling::Current::_tao_any_destructor (void *_tao_void_pointer)
{
  Current *tmp = ACE_static_cast (Current *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::Current_ptr
RTScheduling::Current::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Current::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::Current_ptr 
RTScheduling::Current::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Current::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          Current_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptrdiff_t,
                  &Current::_tao_class_id
                )
            )
        );
}

RTScheduling::Current_ptr
RTScheduling::Current::_duplicate (Current_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::Current::_tao_QueryInterface (ptrdiff_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &ACE_NESTED_CLASS (::RTScheduling, Current)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &::RTCORBA::Current::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                RTCORBA::Current_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &::CORBA::Current::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Current_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptrdiff_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::Current::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/Current:1.0";
}

CORBA::Boolean
RTScheduling::Current::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_exception/exception_cs.cpp:63

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::UNSUPPORTED_SCHEDULING_DISCIPLINE (void)
  : CORBA::UserException (
        "IDL:RTScheduling/Current/UNSUPPORTED_SCHEDULING_DISCIPLINE:1.0",
        "UNSUPPORTED_SCHEDULING_DISCIPLINE"
      )
{
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::~UNSUPPORTED_SCHEDULING_DISCIPLINE (void)
{
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::UNSUPPORTED_SCHEDULING_DISCIPLINE (const ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE&
RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::operator= (const ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_any_destructor (void *_tao_void_pointer)
{
  UNSUPPORTED_SCHEDULING_DISCIPLINE *tmp = ACE_static_cast (UNSUPPORTED_SCHEDULING_DISCIPLINE*, _tao_void_pointer);
  delete tmp;
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE *
RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:RTScheduling/Current/UNSUPPORTED_SCHEDULING_DISCIPLINE:1.0", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (UNSUPPORTED_SCHEDULING_DISCIPLINE *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE, 0);
  return retval;
}

CORBA::Exception *
RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE (*this),
      0
    );
  return result;
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_raise (void)
{
  TAO_RAISE (*this);
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_type (void) const
{
  return ::RTScheduling::Current::_tc_UNSUPPORTED_SCHEDULING_DISCIPLINE;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  63,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x2f554e53), 
  ACE_NTOHL (0x5550504f), 
  ACE_NTOHL (0x52544544), 
  ACE_NTOHL (0x5f534348), 
  ACE_NTOHL (0x4544554c), 
  ACE_NTOHL (0x494e475f), 
  ACE_NTOHL (0x44495343), 
  ACE_NTOHL (0x49504c49), 
  ACE_NTOHL (0x4e453a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:RTScheduling/Current/UNSUPPORTED_SCHEDULING_DISCIPLINE:1.0
    34,
  ACE_NTOHL (0x554e5355), 
  ACE_NTOHL (0x50504f52), 
  ACE_NTOHL (0x5445445f), 
  ACE_NTOHL (0x53434845), 
  ACE_NTOHL (0x44554c49), 
  ACE_NTOHL (0x4e475f44), 
  ACE_NTOHL (0x49534349), 
  ACE_NTOHL (0x504c494e), 
  ACE_NTOHL (0x45000000),  // name = UNSUPPORTED_SCHEDULING_DISCIPLINE
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE (
    CORBA::tk_except,
    sizeof (_oc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE),
    (char *) &_oc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE,
    0,
    sizeof (RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE)
  );

::CORBA::TypeCode_ptr RTScheduling::Current::_tc_UNSUPPORTED_SCHEDULING_DISCIPLINE =
  &_tc_TAO_tc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE;

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:72

#if !defined (_RTSCHEDULING_CURRENT_IDTYPE_CS_)
#define _RTSCHEDULING_CURRENT_IDTYPE_CS_

RTScheduling::Current::IdType::IdType (void)
{}

RTScheduling::Current::IdType::IdType (
    CORBA::ULong max
  )
  : TAO_Unbounded_Sequence<
        CORBA::Octet
      >
    (max)
{}

RTScheduling::Current::IdType::IdType (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Octet * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        CORBA::Octet
      >
    (max, length, buffer, release)
{}

RTScheduling::Current::IdType::IdType (
    const IdType &seq
  )
  : TAO_Unbounded_Sequence<
        CORBA::Octet
      >
    (seq)
{}

RTScheduling::Current::IdType::~IdType (void)
{}

void RTScheduling::Current::IdType::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  IdType * tmp =
    ACE_static_cast (
        IdType *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_FixedSeq_Var_T<
      RTScheduling::Current::IdType,
      CORBA::Octet
    >;

template class
  TAO_Seq_Var_Base_T<
      RTScheduling::Current::IdType,
      CORBA::Octet
    >;

template class
  TAO_Seq_Out_T<
      RTScheduling::Current::IdType,
      RTScheduling::Current::IdType_var,
      CORBA::Octet
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_FixedSeq_Var_T< \
      IdType, \
      CORBA::Octet \
    >

# pragma instantiate \
  TAO_Seq_Var_Base_T< \
      IdType, \
      CORBA::Octet \
    >

# pragma instantiate \
  TAO_Seq_Out_T< \
      IdType, \
      IdType_var, \
      CORBA::Octet \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current_IdType[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x2f496454), 
  ACE_NTOHL (0x7970653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:RTScheduling/Current/IdType:1.0
    7,
  ACE_NTOHL (0x49645479), 
  ACE_NTOHL (0x70650000),  // name = IdType
    CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current_IdType (
    CORBA::tk_alias,
    sizeof (_oc_RTScheduling_Current_IdType),
    (char *) &_oc_RTScheduling_Current_IdType,
    0,
    sizeof (RTScheduling::Current::IdType)
  );

::CORBA::TypeCode_ptr RTScheduling::Current::_tc_IdType =
  &_tc_TAO_tc_RTScheduling_Current_IdType;

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:72

#if !defined (_RTSCHEDULING_CURRENT_NAMELIST_CS_)
#define _RTSCHEDULING_CURRENT_NAMELIST_CS_

RTScheduling::Current::NameList::NameList (void)
{}

RTScheduling::Current::NameList::NameList (
    CORBA::ULong max
  )
  : TAO_Unbounded_String_Sequence
    (max)
{}

RTScheduling::Current::NameList::NameList (
    CORBA::ULong max,
    CORBA::ULong length,
    char * * buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_String_Sequence
    (max, length, buffer, release)
{}

RTScheduling::Current::NameList::NameList (
    const NameList &seq
  )
  : TAO_Unbounded_String_Sequence
    (seq)
{}

RTScheduling::Current::NameList::~NameList (void)
{}

void RTScheduling::Current::NameList::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  NameList * tmp =
    ACE_static_cast (
        NameList *,
        _tao_void_pointer
      );
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_MngSeq_Var_T<
      RTScheduling::Current::NameList,
      TAO_SeqElem_String_Manager
    >;

template class
  TAO_Seq_Var_Base_T<
      RTScheduling::Current::NameList,
      TAO_SeqElem_String_Manager
    >;

template class
  TAO_MngSeq_Out_T<
      RTScheduling::Current::NameList,
      RTScheduling::Current::NameList_var,
      TAO_SeqElem_String_Manager
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_MngSeq_Var_T< \
      RTScheduling::Current::NameList, \
      TAO_SeqElem_String_Manager \
    >

# pragma instantiate \
  TAO_Seq_Var_Base_T< \
      RTScheduling::Current::NameList, \
      TAO_SeqElem_String_Manager \
    >

# pragma instantiate \
  TAO_MngSeq_Out_T< \
      RTScheduling::Current::NameList, \
      RTScheduling::Current::NameList_var, \
      TAO_SeqElem_String_Manager \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current_NameList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x2f4e616d), 
  ACE_NTOHL (0x654c6973), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:RTScheduling/Current/NameList:1.0
    9,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = NameList
    CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_string, 
    0U, // string length
    0U,

};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current_NameList (
    CORBA::tk_alias,
    sizeof (_oc_RTScheduling_Current_NameList),
    (char *) &_oc_RTScheduling_Current_NameList,
    0,
    sizeof (RTScheduling::Current::NameList)
  );

::CORBA::TypeCode_ptr RTScheduling::Current::_tc_NameList =
  &_tc_TAO_tc_RTScheduling_Current_NameList;

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:RTScheduling/Current:1.0
    8,
  ACE_NTOHL (0x43757272), 
  ACE_NTOHL (0x656e7400),  // name = Current
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_Current),
    (char *) &_oc_RTScheduling_Current,
    0,
    sizeof (RTScheduling::Current)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Current,
    &_tc_TAO_tc_RTScheduling_Current
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int RTScheduling::ResourceManager::_tao_class_id = 0;

RTScheduling::ResourceManager_ptr
RTScheduling::tao_ResourceManager_life::tao_duplicate (
    ResourceManager_ptr p
  )
{
  return ResourceManager::_duplicate (p);
}

void
RTScheduling::tao_ResourceManager_life::tao_release (
    ResourceManager_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::ResourceManager_ptr
RTScheduling::tao_ResourceManager_life::tao_nil (
    void
  )
{
  return ResourceManager::_nil ();
}

CORBA::Boolean
RTScheduling::tao_ResourceManager_life::tao_marshal (
    ResourceManager_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

RTScheduling::ResourceManager_ptr
RTScheduling::tao_ResourceManager_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ResourceManager::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::tao_ResourceManager_cast::tao_upcast (
    void *src
  )
{
  ResourceManager **tmp =
    ACE_static_cast (ResourceManager **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        RTScheduling::ResourceManager,
        RTScheduling::tao_ResourceManager_life
      >;
  template class
    TAO_Objref_Out_T<
        RTScheduling::ResourceManager,
        RTScheduling::tao_ResourceManager_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        RTScheduling::ResourceManager, \
        RTScheduling::tao_ResourceManager_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        RTScheduling::ResourceManager, \
        RTScheduling::tao_ResourceManager_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

RTScheduling::ResourceManager::ResourceManager (void)
{}

RTScheduling::ResourceManager::~ResourceManager (void)
{}

void 
RTScheduling::ResourceManager::_tao_any_destructor (void *_tao_void_pointer)
{
  ResourceManager *tmp = ACE_static_cast (ResourceManager *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ResourceManager::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::ResourceManager_ptr 
RTScheduling::ResourceManager::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ResourceManager::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          ResourceManager_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptrdiff_t,
                  &ResourceManager::_tao_class_id
                )
            )
        );
}

RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager::_duplicate (ResourceManager_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::ResourceManager::_tao_QueryInterface (ptrdiff_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &ACE_NESTED_CLASS (::RTScheduling, ResourceManager)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &::RTCORBA::Mutex::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                RTCORBA::Mutex_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptrdiff_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::ResourceManager::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/ResourceManager:1.0";
}

CORBA::Boolean
RTScheduling::ResourceManager::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_ResourceManager[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f526573), 
  ACE_NTOHL (0x6f757263), 
  ACE_NTOHL (0x654d616e), 
  ACE_NTOHL (0x61676572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:RTScheduling/ResourceManager:1.0
    16,
  ACE_NTOHL (0x5265736f), 
  ACE_NTOHL (0x75726365), 
  ACE_NTOHL (0x4d616e61), 
  ACE_NTOHL (0x67657200),  // name = ResourceManager
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_ResourceManager (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_ResourceManager),
    (char *) &_oc_RTScheduling_ResourceManager,
    0,
    sizeof (RTScheduling::ResourceManager)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ResourceManager,
    &_tc_TAO_tc_RTScheduling_ResourceManager
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:57

int RTScheduling::Scheduler::_tao_class_id = 0;

RTScheduling::Scheduler_ptr
RTScheduling::tao_Scheduler_life::tao_duplicate (
    Scheduler_ptr p
  )
{
  return Scheduler::_duplicate (p);
}

void
RTScheduling::tao_Scheduler_life::tao_release (
    Scheduler_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::Scheduler_ptr
RTScheduling::tao_Scheduler_life::tao_nil (
    void
  )
{
  return Scheduler::_nil ();
}

CORBA::Boolean
RTScheduling::tao_Scheduler_life::tao_marshal (
    Scheduler_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

RTScheduling::Scheduler_ptr
RTScheduling::tao_Scheduler_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Scheduler::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::tao_Scheduler_cast::tao_upcast (
    void *src
  )
{
  Scheduler **tmp =
    ACE_static_cast (Scheduler **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        RTScheduling::Scheduler,
        RTScheduling::tao_Scheduler_life
      >;
  template class
    TAO_Objref_Out_T<
        RTScheduling::Scheduler,
        RTScheduling::tao_Scheduler_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        RTScheduling::Scheduler, \
        RTScheduling::tao_Scheduler_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        RTScheduling::Scheduler, \
        RTScheduling::tao_Scheduler_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_cs.cpp:239

RTScheduling::Scheduler::Scheduler (void)
{}

RTScheduling::Scheduler::~Scheduler (void)
{}

void 
RTScheduling::Scheduler::_tao_any_destructor (void *_tao_void_pointer)
{
  Scheduler *tmp = ACE_static_cast (Scheduler *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::Scheduler_ptr
RTScheduling::Scheduler::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Scheduler::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::Scheduler_ptr 
RTScheduling::Scheduler::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Scheduler::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          Scheduler_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptrdiff_t,
                  &Scheduler::_tao_class_id
                )
            )
        );
}

RTScheduling::Scheduler_ptr
RTScheduling::Scheduler::_duplicate (Scheduler_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::Scheduler::_tao_QueryInterface (ptrdiff_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptrdiff_t,
              &ACE_NESTED_CLASS (::RTScheduling, Scheduler)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptrdiff_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::Scheduler::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/Scheduler:1.0";
}

CORBA::Boolean
RTScheduling::Scheduler::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from 
// be/be_visitor_exception/exception_cs.cpp:63

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::INCOMPATIBLE_SCHEDULING_DISCIPLINES (void)
  : CORBA::UserException (
        "IDL:RTScheduling/Scheduler/INCOMPATIBLE_SCHEDULING_DISCIPLINES:1.0",
        "INCOMPATIBLE_SCHEDULING_DISCIPLINES"
      )
{
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::~INCOMPATIBLE_SCHEDULING_DISCIPLINES (void)
{
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::INCOMPATIBLE_SCHEDULING_DISCIPLINES (const ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES&
RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::operator= (const ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_any_destructor (void *_tao_void_pointer)
{
  INCOMPATIBLE_SCHEDULING_DISCIPLINES *tmp = ACE_static_cast (INCOMPATIBLE_SCHEDULING_DISCIPLINES*, _tao_void_pointer);
  delete tmp;
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES *
RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:RTScheduling/Scheduler/INCOMPATIBLE_SCHEDULING_DISCIPLINES:1.0", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (INCOMPATIBLE_SCHEDULING_DISCIPLINES *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES, 0);
  return retval;
}

CORBA::Exception *
RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES (*this),
      0
    );
  return result;
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_raise (void)
{
  TAO_RAISE (*this);
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_type (void) const
{
  return ::RTScheduling::Scheduler::_tc_INCOMPATIBLE_SCHEDULING_DISCIPLINES;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  67,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f536368), 
  ACE_NTOHL (0x6564756c), 
  ACE_NTOHL (0x65722f49), 
  ACE_NTOHL (0x4e434f4d), 
  ACE_NTOHL (0x50415449), 
  ACE_NTOHL (0x424c455f), 
  ACE_NTOHL (0x53434845), 
  ACE_NTOHL (0x44554c49), 
  ACE_NTOHL (0x4e475f44), 
  ACE_NTOHL (0x49534349), 
  ACE_NTOHL (0x504c494e), 
  ACE_NTOHL (0x45533a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:RTScheduling/Scheduler/INCOMPATIBLE_SCHEDULING_DISCIPLINES:1.0
    36,
  ACE_NTOHL (0x494e434f), 
  ACE_NTOHL (0x4d504154), 
  ACE_NTOHL (0x49424c45), 
  ACE_NTOHL (0x5f534348), 
  ACE_NTOHL (0x4544554c), 
  ACE_NTOHL (0x494e475f), 
  ACE_NTOHL (0x44495343), 
  ACE_NTOHL (0x49504c49), 
  ACE_NTOHL (0x4e455300),  // name = INCOMPATIBLE_SCHEDULING_DISCIPLINES
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES (
    CORBA::tk_except,
    sizeof (_oc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES),
    (char *) &_oc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES,
    0,
    sizeof (RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES)
  );

::CORBA::TypeCode_ptr RTScheduling::Scheduler::_tc_INCOMPATIBLE_SCHEDULING_DISCIPLINES =
  &_tc_TAO_tc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES;

// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Scheduler[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f536368), 
  ACE_NTOHL (0x6564756c), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:RTScheduling/Scheduler:1.0
    10,
  ACE_NTOHL (0x53636865), 
  ACE_NTOHL (0x64756c65), 
  ACE_NTOHL (0x72000000),  // name = Scheduler
  };

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Scheduler (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_Scheduler),
    (char *) &_oc_RTScheduling_Scheduler,
    0,
    sizeof (RTScheduling::Scheduler)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Scheduler,
    &_tc_TAO_tc_RTScheduling_Scheduler
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ThreadAction_ptr _tao_elem
  )
{
  RTScheduling::ThreadAction_ptr _tao_objptr =
    RTScheduling::ThreadAction::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ThreadAction_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<RTScheduling::ThreadAction>::insert (
      _tao_any,
      RTScheduling::ThreadAction::_tao_any_destructor,
      RTScheduling::_tc_ThreadAction,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::ThreadAction_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<RTScheduling::ThreadAction>::extract (
        _tao_any,
        RTScheduling::ThreadAction::_tao_any_destructor,
        RTScheduling::_tc_ThreadAction,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<RTScheduling::ThreadAction>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<RTScheduling::ThreadAction>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::DistributableThread_ptr _tao_elem
  )
{
  RTScheduling::DistributableThread_ptr _tao_objptr =
    RTScheduling::DistributableThread::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::DistributableThread_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<RTScheduling::DistributableThread>::insert (
      _tao_any,
      RTScheduling::DistributableThread::_tao_any_destructor,
      RTScheduling::_tc_DistributableThread,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::DistributableThread_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<RTScheduling::DistributableThread>::extract (
        _tao_any,
        RTScheduling::DistributableThread::_tao_any_destructor,
        RTScheduling::_tc_DistributableThread,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<RTScheduling::DistributableThread>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<RTScheduling::DistributableThread>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Current_ptr _tao_elem
  )
{
  RTScheduling::Current_ptr _tao_objptr =
    RTScheduling::Current::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Current_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<RTScheduling::Current>::insert (
      _tao_any,
      RTScheduling::Current::_tao_any_destructor,
      RTScheduling::_tc_Current,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::Current_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<RTScheduling::Current>::extract (
        _tao_any,
        RTScheduling::Current::_tao_any_destructor,
        RTScheduling::_tc_Current,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<RTScheduling::Current>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<RTScheduling::Current>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ResourceManager_ptr _tao_elem
  )
{
  RTScheduling::ResourceManager_ptr _tao_objptr =
    RTScheduling::ResourceManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ResourceManager_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<RTScheduling::ResourceManager>::insert (
      _tao_any,
      RTScheduling::ResourceManager::_tao_any_destructor,
      RTScheduling::_tc_ResourceManager,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::ResourceManager_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<RTScheduling::ResourceManager>::extract (
        _tao_any,
        RTScheduling::ResourceManager::_tao_any_destructor,
        RTScheduling::_tc_ResourceManager,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<RTScheduling::ResourceManager>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<RTScheduling::ResourceManager>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:50

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Scheduler_ptr _tao_elem
  )
{
  RTScheduling::Scheduler_ptr _tao_objptr =
    RTScheduling::Scheduler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Scheduler_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<RTScheduling::Scheduler>::insert (
      _tao_any,
      RTScheduling::Scheduler::_tao_any_destructor,
      RTScheduling::_tc_Scheduler,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::Scheduler_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<RTScheduling::Scheduler>::extract (
        _tao_any,
        RTScheduling::Scheduler::_tao_any_destructor,
        RTScheduling::_tc_Scheduler,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<RTScheduling::Scheduler>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<RTScheduling::Scheduler>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

