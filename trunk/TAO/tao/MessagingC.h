/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_ORIG_MESSAGINGC_H_
#define _TAO_IDL_ORIG_MESSAGINGC_H_

#include "ace/pre.h"
#include "tao/orbconf.h"
#include "Remote_Object_Proxy_Impl.h"

#if (TAO_HAS_CORBA_MESSAGING == 1)

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)
#include "tao/ValueBase.h"
#include "tao/ValueFactory.h"
#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#include "tao/corbafwd.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "tao/Any.h"
#include "tao/CDR.h"
#include "tao/TimeBaseC.h"
#include "tao/PolicyC.h"
#include "tao/IOPC.h"
#include "tao/PollableC.h"

#if (TAO_HAS_SMART_PROXIES == 1)
#include "tao/Smart_Proxies.h"
#include "tao/TAO_Singleton.h"
#endif /*TAO_HAS_SMART_PROXIES == 1*/

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined(TRANSPARENT)
// Some platforms define this macro for ioctl()
#undef TRANSPARENT
#endif

TAO_NAMESPACE  Messaging
{
  typedef CORBA::Short RebindMode;
  typedef CORBA::Short_out RebindMode_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RebindMode;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short TRANSPARENT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_REBIND;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_RECONNECT;

  typedef CORBA::Short SyncScope;
  typedef CORBA::Short_out SyncScope_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_SyncScope;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TRANSPORT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_SERVER;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TARGET;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_EAGER_BUFFERING;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_DELAYED_BUFFERING;

  typedef CORBA::Short RoutingType;
  typedef CORBA::Short_out RoutingType_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingType;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_FORWARD;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_STORE_AND_FORWARD;

  typedef TimeBase::TimeT Timeout;
  typedef TimeBase::TimeT_out Timeout_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Timeout;

  typedef CORBA::Short Priority;
  typedef CORBA::Short_out Priority_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Priority;

  typedef CORBA::UShort Ordering;
  typedef CORBA::UShort_out Ordering_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Ordering;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_ANY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_TEMPORAL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_PRIORITY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_DEADLINE;

#if (TAO_HAS_REBIND_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REBIND_POLICY_TYPE;


#if !defined (_MESSAGING_REBINDPOLICY___PTR_CH_)
#define _MESSAGING_REBINDPOLICY___PTR_CH_

  class RebindPolicy;
  typedef RebindPolicy *RebindPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REBINDPOLICY___VAR_CH_)
#define _MESSAGING_REBINDPOLICY___VAR_CH_

  class TAO_Export RebindPolicy_var : public TAO_Base_var
  {
  public:
    RebindPolicy_var (void); // default constructor
    RebindPolicy_var (RebindPolicy_ptr);
    RebindPolicy_var (const RebindPolicy_var &); // copy constructor
    ~RebindPolicy_var (void); // destructor

    RebindPolicy_var &operator= (RebindPolicy_ptr);
    RebindPolicy_var &operator= (const RebindPolicy_var &);
    RebindPolicy_ptr operator-> (void) const;

    operator const RebindPolicy_ptr &() const;
    operator RebindPolicy_ptr &();
    // in, inout, out, _retn
    RebindPolicy_ptr in (void) const;
    RebindPolicy_ptr &inout (void);
    RebindPolicy_ptr &out (void);
    RebindPolicy_ptr _retn (void);
    RebindPolicy_ptr ptr (void) const;

  private:
    RebindPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RebindPolicy_var (const TAO_Base_var &rhs);
    RebindPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REBINDPOLICY___OUT_CH_)
#define _MESSAGING_REBINDPOLICY___OUT_CH_

  class TAO_Export RebindPolicy_out
  {
  public:
    RebindPolicy_out (RebindPolicy_ptr &);
    RebindPolicy_out (RebindPolicy_var &);
    RebindPolicy_out (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_var &);
    RebindPolicy_out &operator= (RebindPolicy_ptr);
    operator RebindPolicy_ptr &();
    RebindPolicy_ptr &ptr (void);
    RebindPolicy_ptr operator-> (void);

  private:
    RebindPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REBINDPOLICY_CH_)
#define _MESSAGING_REBINDPOLICY_CH_

class TAO_Export RebindPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RebindPolicy_ptr _ptr_type;
    typedef RebindPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RebindPolicy_ptr _duplicate (RebindPolicy_ptr obj);
    static RebindPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RebindPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RebindPolicy_ptr _nil (void)
      {
        return (RebindPolicy_ptr)0;
      }

    virtual Messaging::RebindMode rebind_mode (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RebindPolicy (void);
    virtual ~RebindPolicy (void);
  private:
    RebindPolicy (const RebindPolicy &);
    void operator= (const RebindPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REBIND_POLICY == 1 */

#if (TAO_HAS_SYNC_SCOPE_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SYNC_SCOPE_POLICY_TYPE;


#if !defined (_MESSAGING_SYNCSCOPEPOLICY___PTR_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY___PTR_CH_

  class SyncScopePolicy;
  typedef SyncScopePolicy *SyncScopePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_SYNCSCOPEPOLICY___VAR_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY___VAR_CH_

  class TAO_Export SyncScopePolicy_var : public TAO_Base_var
  {
  public:
    SyncScopePolicy_var (void); // default constructor
    SyncScopePolicy_var (SyncScopePolicy_ptr);
    SyncScopePolicy_var (const SyncScopePolicy_var &); // copy constructor
    ~SyncScopePolicy_var (void); // destructor

    SyncScopePolicy_var &operator= (SyncScopePolicy_ptr);
    SyncScopePolicy_var &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_ptr operator-> (void) const;

    operator const SyncScopePolicy_ptr &() const;
    operator SyncScopePolicy_ptr &();
    // in, inout, out, _retn
    SyncScopePolicy_ptr in (void) const;
    SyncScopePolicy_ptr &inout (void);
    SyncScopePolicy_ptr &out (void);
    SyncScopePolicy_ptr _retn (void);
    SyncScopePolicy_ptr ptr (void) const;

  private:
    SyncScopePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    SyncScopePolicy_var (const TAO_Base_var &rhs);
    SyncScopePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_SYNCSCOPEPOLICY___OUT_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY___OUT_CH_

  class TAO_Export SyncScopePolicy_out
  {
  public:
    SyncScopePolicy_out (SyncScopePolicy_ptr &);
    SyncScopePolicy_out (SyncScopePolicy_var &);
    SyncScopePolicy_out (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_out &operator= (SyncScopePolicy_ptr);
    operator SyncScopePolicy_ptr &();
    SyncScopePolicy_ptr &ptr (void);
    SyncScopePolicy_ptr operator-> (void);

  private:
    SyncScopePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_SYNCSCOPEPOLICY_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY_CH_

class TAO_Export SyncScopePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef SyncScopePolicy_ptr _ptr_type;
    typedef SyncScopePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static SyncScopePolicy_ptr _duplicate (SyncScopePolicy_ptr obj);
    static SyncScopePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static SyncScopePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static SyncScopePolicy_ptr _nil (void)
      {
        return (SyncScopePolicy_ptr)0;
      }

    virtual Messaging::SyncScope synchronization (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    SyncScopePolicy (void);
    virtual ~SyncScopePolicy (void);
  private:
    SyncScopePolicy (const SyncScopePolicy &);
    void operator= (const SyncScopePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_SYNC_SCOPE_POLICY == 1 */

#if (TAO_HAS_PRIORITY_POLICIES == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_PRIORITY_POLICY_TYPE;

  struct PriorityRange;
  class PriorityRange_var;

  struct TAO_Export PriorityRange
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PriorityRange_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (Messaging, Priority) min;
    ACE_NESTED_CLASS (Messaging, Priority) max;
  };

  class TAO_Export PriorityRange_var
  {
  public:
    PriorityRange_var (void); // default constructor
    PriorityRange_var (PriorityRange *);
    PriorityRange_var (const PriorityRange_var &); // copy constructor
    PriorityRange_var (const PriorityRange &); // fixed-size types only
    ~PriorityRange_var (void); // destructor

    PriorityRange_var &operator= (PriorityRange *);
    PriorityRange_var &operator= (const PriorityRange_var &);
    PriorityRange_var &operator= (const PriorityRange &); // fixed-size types only
    PriorityRange *operator-> (void);
    const PriorityRange *operator-> (void) const;

    operator const PriorityRange &() const;
    operator PriorityRange &();
    operator PriorityRange &() const;

    // in, inout, out, _retn
    const PriorityRange &in (void) const;
    PriorityRange &inout (void);
    PriorityRange &out (void);
    PriorityRange _retn (void);
    PriorityRange *ptr (void) const;

  private:
    PriorityRange *ptr_;
  };

  typedef PriorityRange &PriorityRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityRange;


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY___PTR_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY___PTR_CH_

  class RequestPriorityPolicy;
  typedef RequestPriorityPolicy *RequestPriorityPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY___VAR_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY___VAR_CH_

  class TAO_Export RequestPriorityPolicy_var : public TAO_Base_var
  {
  public:
    RequestPriorityPolicy_var (void); // default constructor
    RequestPriorityPolicy_var (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var (const RequestPriorityPolicy_var &); // copy constructor
    ~RequestPriorityPolicy_var (void); // destructor

    RequestPriorityPolicy_var &operator= (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_ptr operator-> (void) const;

    operator const RequestPriorityPolicy_ptr &() const;
    operator RequestPriorityPolicy_ptr &();
    // in, inout, out, _retn
    RequestPriorityPolicy_ptr in (void) const;
    RequestPriorityPolicy_ptr &inout (void);
    RequestPriorityPolicy_ptr &out (void);
    RequestPriorityPolicy_ptr _retn (void);
    RequestPriorityPolicy_ptr ptr (void) const;

  private:
    RequestPriorityPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestPriorityPolicy_var (const TAO_Base_var &rhs);
    RequestPriorityPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY___OUT_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY___OUT_CH_

  class TAO_Export RequestPriorityPolicy_out
  {
  public:
    RequestPriorityPolicy_out (RequestPriorityPolicy_ptr &);
    RequestPriorityPolicy_out (RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out &operator= (RequestPriorityPolicy_ptr);
    operator RequestPriorityPolicy_ptr &();
    RequestPriorityPolicy_ptr &ptr (void);
    RequestPriorityPolicy_ptr operator-> (void);

  private:
    RequestPriorityPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY_CH_

class TAO_Export RequestPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestPriorityPolicy_ptr _ptr_type;
    typedef RequestPriorityPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RequestPriorityPolicy_ptr _duplicate (RequestPriorityPolicy_ptr obj);
    static RequestPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestPriorityPolicy_ptr _nil (void)
      {
        return (RequestPriorityPolicy_ptr)0;
      }

    virtual Messaging::PriorityRange priority_range (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestPriorityPolicy (void);
    virtual ~RequestPriorityPolicy (void);
  private:
    RequestPriorityPolicy (const RequestPriorityPolicy &);
    void operator= (const RequestPriorityPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_PRIORITY_POLICY_TYPE;


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY___PTR_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY___PTR_CH_

  class ReplyPriorityPolicy;
  typedef ReplyPriorityPolicy *ReplyPriorityPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY___VAR_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY___VAR_CH_

  class TAO_Export ReplyPriorityPolicy_var : public TAO_Base_var
  {
  public:
    ReplyPriorityPolicy_var (void); // default constructor
    ReplyPriorityPolicy_var (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var (const ReplyPriorityPolicy_var &); // copy constructor
    ~ReplyPriorityPolicy_var (void); // destructor

    ReplyPriorityPolicy_var &operator= (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_ptr operator-> (void) const;

    operator const ReplyPriorityPolicy_ptr &() const;
    operator ReplyPriorityPolicy_ptr &();
    // in, inout, out, _retn
    ReplyPriorityPolicy_ptr in (void) const;
    ReplyPriorityPolicy_ptr &inout (void);
    ReplyPriorityPolicy_ptr &out (void);
    ReplyPriorityPolicy_ptr _retn (void);
    ReplyPriorityPolicy_ptr ptr (void) const;

  private:
    ReplyPriorityPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyPriorityPolicy_var (const TAO_Base_var &rhs);
    ReplyPriorityPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY___OUT_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY___OUT_CH_

  class TAO_Export ReplyPriorityPolicy_out
  {
  public:
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_ptr &);
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out &operator= (ReplyPriorityPolicy_ptr);
    operator ReplyPriorityPolicy_ptr &();
    ReplyPriorityPolicy_ptr &ptr (void);
    ReplyPriorityPolicy_ptr operator-> (void);

  private:
    ReplyPriorityPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY_CH_

class TAO_Export ReplyPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyPriorityPolicy_ptr _ptr_type;
    typedef ReplyPriorityPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static ReplyPriorityPolicy_ptr _duplicate (ReplyPriorityPolicy_ptr obj);
    static ReplyPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyPriorityPolicy_ptr _nil (void)
      {
        return (ReplyPriorityPolicy_ptr)0;
      }

    virtual Messaging::PriorityRange priority_range (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ReplyPriorityPolicy (void);
    virtual ~ReplyPriorityPolicy (void);
  private:
    ReplyPriorityPolicy (const ReplyPriorityPolicy &);
    void operator= (const ReplyPriorityPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_PRIORITY_POLICIES == 1 */

#if (TAO_HAS_REQUEST_START_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_START_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY___PTR_CH_

  class RequestStartTimePolicy;
  typedef RequestStartTimePolicy *RequestStartTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY___VAR_CH_

  class TAO_Export RequestStartTimePolicy_var : public TAO_Base_var
  {
  public:
    RequestStartTimePolicy_var (void); // default constructor
    RequestStartTimePolicy_var (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var (const RequestStartTimePolicy_var &); // copy constructor
    ~RequestStartTimePolicy_var (void); // destructor

    RequestStartTimePolicy_var &operator= (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_ptr operator-> (void) const;

    operator const RequestStartTimePolicy_ptr &() const;
    operator RequestStartTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestStartTimePolicy_ptr in (void) const;
    RequestStartTimePolicy_ptr &inout (void);
    RequestStartTimePolicy_ptr &out (void);
    RequestStartTimePolicy_ptr _retn (void);
    RequestStartTimePolicy_ptr ptr (void) const;

  private:
    RequestStartTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestStartTimePolicy_var (const TAO_Base_var &rhs);
    RequestStartTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY___OUT_CH_

  class TAO_Export RequestStartTimePolicy_out
  {
  public:
    RequestStartTimePolicy_out (RequestStartTimePolicy_ptr &);
    RequestStartTimePolicy_out (RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out &operator= (RequestStartTimePolicy_ptr);
    operator RequestStartTimePolicy_ptr &();
    RequestStartTimePolicy_ptr &ptr (void);
    RequestStartTimePolicy_ptr operator-> (void);

  private:
    RequestStartTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY_CH_

class TAO_Export RequestStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestStartTimePolicy_ptr _ptr_type;
    typedef RequestStartTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RequestStartTimePolicy_ptr _duplicate (RequestStartTimePolicy_ptr obj);
    static RequestStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestStartTimePolicy_ptr _nil (void)
      {
        return (RequestStartTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT start_time (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestStartTimePolicy (void);
    virtual ~RequestStartTimePolicy (void);
  private:
    RequestStartTimePolicy (const RequestStartTimePolicy &);
    void operator= (const RequestStartTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REQUEST_START_TIME_POLICY == 1 */

#if (TAO_HAS_REQUEST_END_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_END_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY___PTR_CH_

  class RequestEndTimePolicy;
  typedef RequestEndTimePolicy *RequestEndTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY___VAR_CH_

  class TAO_Export RequestEndTimePolicy_var : public TAO_Base_var
  {
  public:
    RequestEndTimePolicy_var (void); // default constructor
    RequestEndTimePolicy_var (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var (const RequestEndTimePolicy_var &); // copy constructor
    ~RequestEndTimePolicy_var (void); // destructor

    RequestEndTimePolicy_var &operator= (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_ptr operator-> (void) const;

    operator const RequestEndTimePolicy_ptr &() const;
    operator RequestEndTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestEndTimePolicy_ptr in (void) const;
    RequestEndTimePolicy_ptr &inout (void);
    RequestEndTimePolicy_ptr &out (void);
    RequestEndTimePolicy_ptr _retn (void);
    RequestEndTimePolicy_ptr ptr (void) const;

  private:
    RequestEndTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestEndTimePolicy_var (const TAO_Base_var &rhs);
    RequestEndTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY___OUT_CH_

  class TAO_Export RequestEndTimePolicy_out
  {
  public:
    RequestEndTimePolicy_out (RequestEndTimePolicy_ptr &);
    RequestEndTimePolicy_out (RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out &operator= (RequestEndTimePolicy_ptr);
    operator RequestEndTimePolicy_ptr &();
    RequestEndTimePolicy_ptr &ptr (void);
    RequestEndTimePolicy_ptr operator-> (void);

  private:
    RequestEndTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY_CH_

class TAO_Export RequestEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestEndTimePolicy_ptr _ptr_type;
    typedef RequestEndTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RequestEndTimePolicy_ptr _duplicate (RequestEndTimePolicy_ptr obj);
    static RequestEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RequestEndTimePolicy_ptr _nil (void)
      {
        return (RequestEndTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT end_time (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestEndTimePolicy (void);
    virtual ~RequestEndTimePolicy (void);
  private:
    RequestEndTimePolicy (const RequestEndTimePolicy &);
    void operator= (const RequestEndTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REQUEST_END_TIME_POLICY == 1 */

#if (TAO_HAS_REPLY_START_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_START_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY___PTR_CH_

  class ReplyStartTimePolicy;
  typedef ReplyStartTimePolicy *ReplyStartTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY___VAR_CH_

  class TAO_Export ReplyStartTimePolicy_var : public TAO_Base_var
  {
  public:
    ReplyStartTimePolicy_var (void); // default constructor
    ReplyStartTimePolicy_var (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var (const ReplyStartTimePolicy_var &); // copy constructor
    ~ReplyStartTimePolicy_var (void); // destructor

    ReplyStartTimePolicy_var &operator= (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_ptr operator-> (void) const;

    operator const ReplyStartTimePolicy_ptr &() const;
    operator ReplyStartTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyStartTimePolicy_ptr in (void) const;
    ReplyStartTimePolicy_ptr &inout (void);
    ReplyStartTimePolicy_ptr &out (void);
    ReplyStartTimePolicy_ptr _retn (void);
    ReplyStartTimePolicy_ptr ptr (void) const;

  private:
    ReplyStartTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyStartTimePolicy_var (const TAO_Base_var &rhs);
    ReplyStartTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY___OUT_CH_

  class TAO_Export ReplyStartTimePolicy_out
  {
  public:
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_ptr &);
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out &operator= (ReplyStartTimePolicy_ptr);
    operator ReplyStartTimePolicy_ptr &();
    ReplyStartTimePolicy_ptr &ptr (void);
    ReplyStartTimePolicy_ptr operator-> (void);

  private:
    ReplyStartTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY_CH_

class TAO_Export ReplyStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyStartTimePolicy_ptr _ptr_type;
    typedef ReplyStartTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static ReplyStartTimePolicy_ptr _duplicate (ReplyStartTimePolicy_ptr obj);
    static ReplyStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyStartTimePolicy_ptr _nil (void)
      {
        return (ReplyStartTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT start_time (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ReplyStartTimePolicy (void);
    virtual ~ReplyStartTimePolicy (void);
  private:
    ReplyStartTimePolicy (const ReplyStartTimePolicy &);
    void operator= (const ReplyStartTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REPLY_START_TIME_POLICY == 1 */

#if (TAO_HAS_REPLY_END_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_END_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY___PTR_CH_

  class ReplyEndTimePolicy;
  typedef ReplyEndTimePolicy *ReplyEndTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY___VAR_CH_

  class TAO_Export ReplyEndTimePolicy_var : public TAO_Base_var
  {
  public:
    ReplyEndTimePolicy_var (void); // default constructor
    ReplyEndTimePolicy_var (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var (const ReplyEndTimePolicy_var &); // copy constructor
    ~ReplyEndTimePolicy_var (void); // destructor

    ReplyEndTimePolicy_var &operator= (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_ptr operator-> (void) const;

    operator const ReplyEndTimePolicy_ptr &() const;
    operator ReplyEndTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyEndTimePolicy_ptr in (void) const;
    ReplyEndTimePolicy_ptr &inout (void);
    ReplyEndTimePolicy_ptr &out (void);
    ReplyEndTimePolicy_ptr _retn (void);
    ReplyEndTimePolicy_ptr ptr (void) const;

  private:
    ReplyEndTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyEndTimePolicy_var (const TAO_Base_var &rhs);
    ReplyEndTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY___OUT_CH_

  class TAO_Export ReplyEndTimePolicy_out
  {
  public:
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_ptr &);
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out &operator= (ReplyEndTimePolicy_ptr);
    operator ReplyEndTimePolicy_ptr &();
    ReplyEndTimePolicy_ptr &ptr (void);
    ReplyEndTimePolicy_ptr operator-> (void);

  private:
    ReplyEndTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY_CH_

class TAO_Export ReplyEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyEndTimePolicy_ptr _ptr_type;
    typedef ReplyEndTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static ReplyEndTimePolicy_ptr _duplicate (ReplyEndTimePolicy_ptr obj);
    static ReplyEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyEndTimePolicy_ptr _nil (void)
      {
        return (ReplyEndTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT end_time (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ReplyEndTimePolicy (void);
    virtual ~ReplyEndTimePolicy (void);
  private:
    ReplyEndTimePolicy (const ReplyEndTimePolicy &);
    void operator= (const ReplyEndTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REPLY_END_TIME_POLICY == 1 */

#if (TAO_HAS_RELATIVE_REQUEST_TIMEOUT_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_REQ_TIMEOUT_POLICY_TYPE;


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___PTR_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___PTR_CH_

  class RelativeRequestTimeoutPolicy;
  typedef RelativeRequestTimeoutPolicy *RelativeRequestTimeoutPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___VAR_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___VAR_CH_

  class TAO_Export RelativeRequestTimeoutPolicy_var : public TAO_Base_var
  {
  public:
    RelativeRequestTimeoutPolicy_var (void); // default constructor
    RelativeRequestTimeoutPolicy_var (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var (const RelativeRequestTimeoutPolicy_var &); // copy constructor
    ~RelativeRequestTimeoutPolicy_var (void); // destructor

    RelativeRequestTimeoutPolicy_var &operator= (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRequestTimeoutPolicy_ptr &() const;
    operator RelativeRequestTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRequestTimeoutPolicy_ptr in (void) const;
    RelativeRequestTimeoutPolicy_ptr &inout (void);
    RelativeRequestTimeoutPolicy_ptr &out (void);
    RelativeRequestTimeoutPolicy_ptr _retn (void);
    RelativeRequestTimeoutPolicy_ptr ptr (void) const;

  private:
    RelativeRequestTimeoutPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RelativeRequestTimeoutPolicy_var (const TAO_Base_var &rhs);
    RelativeRequestTimeoutPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___OUT_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___OUT_CH_

  class TAO_Export RelativeRequestTimeoutPolicy_out
  {
  public:
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_ptr &);
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out &operator= (RelativeRequestTimeoutPolicy_ptr);
    operator RelativeRequestTimeoutPolicy_ptr &();
    RelativeRequestTimeoutPolicy_ptr &ptr (void);
    RelativeRequestTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRequestTimeoutPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY_CH_

class TAO_Export RelativeRequestTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RelativeRequestTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRequestTimeoutPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RelativeRequestTimeoutPolicy_ptr _duplicate (RelativeRequestTimeoutPolicy_ptr obj);
    static RelativeRequestTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RelativeRequestTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RelativeRequestTimeoutPolicy_ptr _nil (void)
      {
        return (RelativeRequestTimeoutPolicy_ptr)0;
      }

    virtual TimeBase::TimeT relative_expiry (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RelativeRequestTimeoutPolicy (void);
    virtual ~RelativeRequestTimeoutPolicy (void);
  private:
    RelativeRequestTimeoutPolicy (const RelativeRequestTimeoutPolicy &);
    void operator= (const RelativeRequestTimeoutPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_RELATIVE_REQUEST_TIMEOUT_POLICY == 1 */

#if (TAO_HAS_RELATIVE_ROUNDTRIP_TIMEOUT_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_RT_TIMEOUT_POLICY_TYPE;


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___PTR_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___PTR_CH_

  class RelativeRoundtripTimeoutPolicy;
  typedef RelativeRoundtripTimeoutPolicy *RelativeRoundtripTimeoutPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___VAR_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___VAR_CH_

  class TAO_Export RelativeRoundtripTimeoutPolicy_var : public TAO_Base_var
  {
  public:
    RelativeRoundtripTimeoutPolicy_var (void); // default constructor
    RelativeRoundtripTimeoutPolicy_var (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var (const RelativeRoundtripTimeoutPolicy_var &); // copy constructor
    ~RelativeRoundtripTimeoutPolicy_var (void); // destructor

    RelativeRoundtripTimeoutPolicy_var &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRoundtripTimeoutPolicy_ptr &() const;
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRoundtripTimeoutPolicy_ptr in (void) const;
    RelativeRoundtripTimeoutPolicy_ptr &inout (void);
    RelativeRoundtripTimeoutPolicy_ptr &out (void);
    RelativeRoundtripTimeoutPolicy_ptr _retn (void);
    RelativeRoundtripTimeoutPolicy_ptr ptr (void) const;

  private:
    RelativeRoundtripTimeoutPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RelativeRoundtripTimeoutPolicy_var (const TAO_Base_var &rhs);
    RelativeRoundtripTimeoutPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___OUT_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___OUT_CH_

  class TAO_Export RelativeRoundtripTimeoutPolicy_out
  {
  public:
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_ptr &);
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    RelativeRoundtripTimeoutPolicy_ptr &ptr (void);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRoundtripTimeoutPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY_CH_

class TAO_Export RelativeRoundtripTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RelativeRoundtripTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRoundtripTimeoutPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RelativeRoundtripTimeoutPolicy_ptr _duplicate (RelativeRoundtripTimeoutPolicy_ptr obj);
    static RelativeRoundtripTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RelativeRoundtripTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RelativeRoundtripTimeoutPolicy_ptr _nil (void)
      {
        return (RelativeRoundtripTimeoutPolicy_ptr)0;
      }

    virtual TimeBase::TimeT relative_expiry (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RelativeRoundtripTimeoutPolicy (void);
    virtual ~RelativeRoundtripTimeoutPolicy (void);
  private:
    RelativeRoundtripTimeoutPolicy (const RelativeRoundtripTimeoutPolicy &);
    void operator= (const RelativeRoundtripTimeoutPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_RELATIVE_ROUNDTRIP_TIMEOUT_POLICY == 1 */

#if (TAO_HAS_ROUTING_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ROUTING_POLICY_TYPE;

  struct RoutingTypeRange;
  class RoutingTypeRange_var;

  struct TAO_Export RoutingTypeRange
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RoutingTypeRange_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (Messaging, RoutingType) min;
    ACE_NESTED_CLASS (Messaging, RoutingType) max;
  };

  class TAO_Export RoutingTypeRange_var
  {
  public:
    RoutingTypeRange_var (void); // default constructor
    RoutingTypeRange_var (RoutingTypeRange *);
    RoutingTypeRange_var (const RoutingTypeRange_var &); // copy constructor
    RoutingTypeRange_var (const RoutingTypeRange &); // fixed-size types only
    ~RoutingTypeRange_var (void); // destructor

    RoutingTypeRange_var &operator= (RoutingTypeRange *);
    RoutingTypeRange_var &operator= (const RoutingTypeRange_var &);
    RoutingTypeRange_var &operator= (const RoutingTypeRange &); // fixed-size types only
    RoutingTypeRange *operator-> (void);
    const RoutingTypeRange *operator-> (void) const;

    operator const RoutingTypeRange &() const;
    operator RoutingTypeRange &();
    operator RoutingTypeRange &() const;

    // in, inout, out, _retn
    const RoutingTypeRange &in (void) const;
    RoutingTypeRange &inout (void);
    RoutingTypeRange &out (void);
    RoutingTypeRange _retn (void);
    RoutingTypeRange *ptr (void) const;

  private:
    RoutingTypeRange *ptr_;
  };

  typedef RoutingTypeRange &RoutingTypeRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingTypeRange;


#if !defined (_MESSAGING_ROUTINGPOLICY___PTR_CH_)
#define _MESSAGING_ROUTINGPOLICY___PTR_CH_

  class RoutingPolicy;
  typedef RoutingPolicy *RoutingPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_ROUTINGPOLICY___VAR_CH_)
#define _MESSAGING_ROUTINGPOLICY___VAR_CH_

  class TAO_Export RoutingPolicy_var : public TAO_Base_var
  {
  public:
    RoutingPolicy_var (void); // default constructor
    RoutingPolicy_var (RoutingPolicy_ptr);
    RoutingPolicy_var (const RoutingPolicy_var &); // copy constructor
    ~RoutingPolicy_var (void); // destructor

    RoutingPolicy_var &operator= (RoutingPolicy_ptr);
    RoutingPolicy_var &operator= (const RoutingPolicy_var &);
    RoutingPolicy_ptr operator-> (void) const;

    operator const RoutingPolicy_ptr &() const;
    operator RoutingPolicy_ptr &();
    // in, inout, out, _retn
    RoutingPolicy_ptr in (void) const;
    RoutingPolicy_ptr &inout (void);
    RoutingPolicy_ptr &out (void);
    RoutingPolicy_ptr _retn (void);
    RoutingPolicy_ptr ptr (void) const;

  private:
    RoutingPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RoutingPolicy_var (const TAO_Base_var &rhs);
    RoutingPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_ROUTINGPOLICY___OUT_CH_)
#define _MESSAGING_ROUTINGPOLICY___OUT_CH_

  class TAO_Export RoutingPolicy_out
  {
  public:
    RoutingPolicy_out (RoutingPolicy_ptr &);
    RoutingPolicy_out (RoutingPolicy_var &);
    RoutingPolicy_out (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_var &);
    RoutingPolicy_out &operator= (RoutingPolicy_ptr);
    operator RoutingPolicy_ptr &();
    RoutingPolicy_ptr &ptr (void);
    RoutingPolicy_ptr operator-> (void);

  private:
    RoutingPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_ROUTINGPOLICY_CH_)
#define _MESSAGING_ROUTINGPOLICY_CH_

class TAO_Export RoutingPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RoutingPolicy_ptr _ptr_type;
    typedef RoutingPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static RoutingPolicy_ptr _duplicate (RoutingPolicy_ptr obj);
    static RoutingPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RoutingPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static RoutingPolicy_ptr _nil (void)
      {
        return (RoutingPolicy_ptr)0;
      }

    virtual Messaging::RoutingTypeRange routing_range (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RoutingPolicy (void);
    virtual ~RoutingPolicy (void);
  private:
    RoutingPolicy (const RoutingPolicy &);
    void operator= (const RoutingPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_ROUTING_POLICY == 1 */

#if (TAO_HAS_MAX_HOPS_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong MAX_HOPS_POLICY_TYPE;


#if !defined (_MESSAGING_MAXHOPSPOLICY___PTR_CH_)
#define _MESSAGING_MAXHOPSPOLICY___PTR_CH_

  class MaxHopsPolicy;
  typedef MaxHopsPolicy *MaxHopsPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_MAXHOPSPOLICY___VAR_CH_)
#define _MESSAGING_MAXHOPSPOLICY___VAR_CH_

  class TAO_Export MaxHopsPolicy_var : public TAO_Base_var
  {
  public:
    MaxHopsPolicy_var (void); // default constructor
    MaxHopsPolicy_var (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var (const MaxHopsPolicy_var &); // copy constructor
    ~MaxHopsPolicy_var (void); // destructor

    MaxHopsPolicy_var &operator= (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_ptr operator-> (void) const;

    operator const MaxHopsPolicy_ptr &() const;
    operator MaxHopsPolicy_ptr &();
    // in, inout, out, _retn
    MaxHopsPolicy_ptr in (void) const;
    MaxHopsPolicy_ptr &inout (void);
    MaxHopsPolicy_ptr &out (void);
    MaxHopsPolicy_ptr _retn (void);
    MaxHopsPolicy_ptr ptr (void) const;

  private:
    MaxHopsPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    MaxHopsPolicy_var (const TAO_Base_var &rhs);
    MaxHopsPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_MAXHOPSPOLICY___OUT_CH_)
#define _MESSAGING_MAXHOPSPOLICY___OUT_CH_

  class TAO_Export MaxHopsPolicy_out
  {
  public:
    MaxHopsPolicy_out (MaxHopsPolicy_ptr &);
    MaxHopsPolicy_out (MaxHopsPolicy_var &);
    MaxHopsPolicy_out (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_out &operator= (MaxHopsPolicy_ptr);
    operator MaxHopsPolicy_ptr &();
    MaxHopsPolicy_ptr &ptr (void);
    MaxHopsPolicy_ptr operator-> (void);

  private:
    MaxHopsPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_MAXHOPSPOLICY_CH_)
#define _MESSAGING_MAXHOPSPOLICY_CH_

class TAO_Export MaxHopsPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef MaxHopsPolicy_ptr _ptr_type;
    typedef MaxHopsPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static MaxHopsPolicy_ptr _duplicate (MaxHopsPolicy_ptr obj);
    static MaxHopsPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static MaxHopsPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static MaxHopsPolicy_ptr _nil (void)
      {
        return (MaxHopsPolicy_ptr)0;
      }

    virtual CORBA::UShort max_hops (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    MaxHopsPolicy (void);
    virtual ~MaxHopsPolicy (void);
  private:
    MaxHopsPolicy (const MaxHopsPolicy &);
    void operator= (const MaxHopsPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_MAX_HOPS_POLICY == 1 */

#if (TAO_HAS_QUEUE_ORDER_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong QUEUE_ORDER_POLICY_TYPE;


#if !defined (_MESSAGING_QUEUEORDERPOLICY___PTR_CH_)
#define _MESSAGING_QUEUEORDERPOLICY___PTR_CH_

  class QueueOrderPolicy;
  typedef QueueOrderPolicy *QueueOrderPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_QUEUEORDERPOLICY___VAR_CH_)
#define _MESSAGING_QUEUEORDERPOLICY___VAR_CH_

  class TAO_Export QueueOrderPolicy_var : public TAO_Base_var
  {
  public:
    QueueOrderPolicy_var (void); // default constructor
    QueueOrderPolicy_var (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var (const QueueOrderPolicy_var &); // copy constructor
    ~QueueOrderPolicy_var (void); // destructor

    QueueOrderPolicy_var &operator= (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_ptr operator-> (void) const;

    operator const QueueOrderPolicy_ptr &() const;
    operator QueueOrderPolicy_ptr &();
    // in, inout, out, _retn
    QueueOrderPolicy_ptr in (void) const;
    QueueOrderPolicy_ptr &inout (void);
    QueueOrderPolicy_ptr &out (void);
    QueueOrderPolicy_ptr _retn (void);
    QueueOrderPolicy_ptr ptr (void) const;

  private:
    QueueOrderPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    QueueOrderPolicy_var (const TAO_Base_var &rhs);
    QueueOrderPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_QUEUEORDERPOLICY___OUT_CH_)
#define _MESSAGING_QUEUEORDERPOLICY___OUT_CH_

  class TAO_Export QueueOrderPolicy_out
  {
  public:
    QueueOrderPolicy_out (QueueOrderPolicy_ptr &);
    QueueOrderPolicy_out (QueueOrderPolicy_var &);
    QueueOrderPolicy_out (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_out &operator= (QueueOrderPolicy_ptr);
    operator QueueOrderPolicy_ptr &();
    QueueOrderPolicy_ptr &ptr (void);
    QueueOrderPolicy_ptr operator-> (void);

  private:
    QueueOrderPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_QUEUEORDERPOLICY_CH_)
#define _MESSAGING_QUEUEORDERPOLICY_CH_

class TAO_Export QueueOrderPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef QueueOrderPolicy_ptr _ptr_type;
    typedef QueueOrderPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static QueueOrderPolicy_ptr _duplicate (QueueOrderPolicy_ptr obj);
    static QueueOrderPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static QueueOrderPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static QueueOrderPolicy_ptr _nil (void)
      {
        return (QueueOrderPolicy_ptr)0;
      }

    virtual Messaging::Ordering allowed_orders (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    QueueOrderPolicy (void);
    virtual ~QueueOrderPolicy (void);
  private:
    QueueOrderPolicy (const QueueOrderPolicy &);
    void operator= (const QueueOrderPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_QUEUE_ORDER_POLICY == 1 */

  struct PolicyValue;
  class PolicyValue_var;

  struct TAO_Export PolicyValue
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PolicyValue_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    CORBA::PolicyType ptype;

#if !defined (_MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CH_)
#define _MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */


#if !defined (_MESSAGING_POLICYVALUE__TAO_SEQ_OCTET___VAR_CH_)
#define _MESSAGING_POLICYVALUE__TAO_SEQ_OCTET___VAR_CH_

    // *************************************************************
    // class Messaging::PolicyValue::_tao_seq_Octet_var
    // *************************************************************

    class TAO_Export _tao_seq_Octet_var
    {
    public:
      _tao_seq_Octet_var (void); // default constructor
      _tao_seq_Octet_var (_tao_seq_Octet *);
      _tao_seq_Octet_var (const _tao_seq_Octet_var &); // copy constructor
      _tao_seq_Octet_var (const _tao_seq_Octet &); // fixed-size base types only
      ~_tao_seq_Octet_var (void); // destructor

      _tao_seq_Octet_var &operator= (_tao_seq_Octet *);
      _tao_seq_Octet_var &operator= (const _tao_seq_Octet_var &);
      _tao_seq_Octet_var &operator= (const _tao_seq_Octet &); // fixed-size base types only
      _tao_seq_Octet *operator-> (void);
      const _tao_seq_Octet *operator-> (void) const;

      operator const _tao_seq_Octet &() const;
      operator _tao_seq_Octet &();
      operator _tao_seq_Octet &() const;

      CORBA::Octet &operator[] (CORBA::ULong index);
      // in, inout, out, _retn
      const _tao_seq_Octet &in (void) const;
      _tao_seq_Octet &inout (void);
      _tao_seq_Octet *&out (void);
      _tao_seq_Octet *_retn (void);
      _tao_seq_Octet *ptr (void) const;

    private:
      _tao_seq_Octet *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_MESSAGING_POLICYVALUE__TAO_SEQ_OCTET___OUT_CH_)
#define _MESSAGING_POLICYVALUE__TAO_SEQ_OCTET___OUT_CH_

    class TAO_Export _tao_seq_Octet_out
    {
    public:
      _tao_seq_Octet_out (_tao_seq_Octet *&);
      _tao_seq_Octet_out (_tao_seq_Octet_var &);
      _tao_seq_Octet_out (const _tao_seq_Octet_out &);
      _tao_seq_Octet_out &operator= (const _tao_seq_Octet_out &);
      _tao_seq_Octet_out &operator= (_tao_seq_Octet *);
      operator _tao_seq_Octet *&();
      _tao_seq_Octet *&ptr (void);
      _tao_seq_Octet *operator-> (void);
      CORBA::Octet &operator[] (CORBA::ULong index);

    private:
      _tao_seq_Octet *&ptr_;
      // assignment from T_var not allowed
      void operator= (const _tao_seq_Octet_var &);
    };


#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _pvalue_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_Octet pvalue;
  };

  class TAO_Export PolicyValue_var
  {
  public:
    PolicyValue_var (void); // default constructor
    PolicyValue_var (PolicyValue *);
    PolicyValue_var (const PolicyValue_var &); // copy constructor
    ~PolicyValue_var (void); // destructor

    PolicyValue_var &operator= (PolicyValue *);
    PolicyValue_var &operator= (const PolicyValue_var &);
    PolicyValue *operator-> (void);
    const PolicyValue *operator-> (void) const;

    operator const PolicyValue &() const;
    operator PolicyValue &();
    operator PolicyValue &() const;
    operator PolicyValue *&(); // variable-size types only

    // in, inout, out, _retn
    const PolicyValue &in (void) const;
    PolicyValue &inout (void);
    PolicyValue *&out (void);
    PolicyValue *_retn (void);
    PolicyValue *ptr (void) const;

  private:
    PolicyValue *ptr_;
  };

  class TAO_Export PolicyValue_out
  {
  public:
    PolicyValue_out (PolicyValue *&);
    PolicyValue_out (PolicyValue_var &);
    PolicyValue_out (const PolicyValue_out &);
    PolicyValue_out &operator= (const PolicyValue_out &);
    PolicyValue_out &operator= (PolicyValue *);
    operator PolicyValue *&();
    PolicyValue *&ptr (void);
    PolicyValue *operator-> (void);

  private:
    PolicyValue *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValue_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValue;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_MESSAGING_POLICYVALUESEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_MESSAGING_POLICYVALUESEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        PolicyValue *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (const _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq &rhs);
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq &operator= (const _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (void); // Dtor.
      // = Accessors.
      PolicyValue &operator[] (CORBA::ULong i);
      const PolicyValue &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static PolicyValue *allocbuf (CORBA::ULong size);
      static void freebuf (PolicyValue *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      PolicyValue *get_buffer (CORBA::Boolean orphan = 0);
      const PolicyValue *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        PolicyValue *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_MESSAGING_POLICYVALUESEQ_CH_)
#define _MESSAGING_POLICYVALUESEQ_CH_

  class PolicyValueSeq;
  class PolicyValueSeq_var;

  // *************************************************************
  // PolicyValueSeq
  // *************************************************************

  class TAO_Export PolicyValueSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<PolicyValue>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    PolicyValueSeq (void); // default ctor
    PolicyValueSeq (CORBA::ULong max); // uses max size
    PolicyValueSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      PolicyValue *buffer,
      CORBA::Boolean release=0
    );
    PolicyValueSeq (const PolicyValueSeq &); // copy ctor
    ~PolicyValueSeq (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PolicyValueSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_POLICYVALUESEQ___VAR_CH_)
#define _MESSAGING_POLICYVALUESEQ___VAR_CH_

  // *************************************************************
  // class Messaging::PolicyValueSeq_var
  // *************************************************************

  class TAO_Export PolicyValueSeq_var
  {
  public:
    PolicyValueSeq_var (void); // default constructor
    PolicyValueSeq_var (PolicyValueSeq *);
    PolicyValueSeq_var (const PolicyValueSeq_var &); // copy constructor
    ~PolicyValueSeq_var (void); // destructor

    PolicyValueSeq_var &operator= (PolicyValueSeq *);
    PolicyValueSeq_var &operator= (const PolicyValueSeq_var &);
    PolicyValueSeq *operator-> (void);
    const PolicyValueSeq *operator-> (void) const;

    operator const PolicyValueSeq &() const;
    operator PolicyValueSeq &();
    operator PolicyValueSeq &() const;
    operator PolicyValueSeq *&(); // variable-size base types only

    PolicyValue &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const PolicyValueSeq &in (void) const;
    PolicyValueSeq &inout (void);
    PolicyValueSeq *&out (void);
    PolicyValueSeq *_retn (void);
    PolicyValueSeq *ptr (void) const;

  private:
    PolicyValueSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_POLICYVALUESEQ___OUT_CH_)
#define _MESSAGING_POLICYVALUESEQ___OUT_CH_

  class TAO_Export PolicyValueSeq_out
  {
  public:
    PolicyValueSeq_out (PolicyValueSeq *&);
    PolicyValueSeq_out (PolicyValueSeq_var &);
    PolicyValueSeq_out (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (PolicyValueSeq *);
    operator PolicyValueSeq *&();
    PolicyValueSeq *&ptr (void);
    PolicyValueSeq *operator-> (void);
    PolicyValue &operator[] (CORBA::ULong index);

  private:
    PolicyValueSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValueSeq_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValueSeq;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_POLICIES;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong INVOCATION_POLICIES;

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

// valuetype class
  class ExceptionHolder;
  typedef ExceptionHolder *ExceptionHolder_ptr;

#if !defined (_MESSAGING_EXCEPTIONHOLDER___VAR_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___VAR_CH_

  class TAO_Export ExceptionHolder_var
  {
  public:
    ExceptionHolder_var (void); // default constructor
    ExceptionHolder_var (ExceptionHolder*);
    ExceptionHolder_var (const ExceptionHolder*); // (TAO extension)
    ExceptionHolder_var (const ExceptionHolder_var &); // copy constructor
    ~ExceptionHolder_var (void); // destructor

    ExceptionHolder_var &operator= (ExceptionHolder*);
    ExceptionHolder_var &operator= (const ExceptionHolder_var &);
    ExceptionHolder* operator-> (void) const;

    operator const ExceptionHolder* () const;
    operator ExceptionHolder* ();
    // in, inout, out, _retn
    ExceptionHolder* in (void) const;
    ExceptionHolder* &inout (void);
    ExceptionHolder* &out (void);
    ExceptionHolder* _retn (void);
    ExceptionHolder* ptr (void) const;

  private:
    ExceptionHolder* ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER___OUT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___OUT_CH_

  class TAO_Export ExceptionHolder_out
  {
  public:
    ExceptionHolder_out (ExceptionHolder* &);
    ExceptionHolder_out (ExceptionHolder_var &);
    ExceptionHolder_out (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_var &);
    ExceptionHolder_out &operator= (ExceptionHolder*);
    operator ExceptionHolder* &();
    ExceptionHolder* &ptr (void);
    ExceptionHolder* operator-> (void);

  private:
    ExceptionHolder* &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER___INIT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___INIT_CH_

  class TAO_Export ExceptionHolder_init : public CORBA_ValueFactoryBase
  {
  public:
    virtual ~ExceptionHolder_init ();
    virtual const char* tao_repository_id ();

    // create () goes here

  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER_CH_)
#define _MESSAGING_EXCEPTIONHOLDER_CH_

  class TAO_Export ExceptionHolder : public virtual CORBA_ValueBase
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ExceptionHolder* _ptr_type;
    typedef ExceptionHolder_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    static ExceptionHolder* _downcast (CORBA::ValueBase* );
    // The address of static _downcast is implicit used as type id

    // (TAO extensions or internals)
    static CORBA::Boolean _tao_unmarshal (TAO_InputCDR &, ExceptionHolder *&);
    virtual const char* _tao_obv_repository_id () const;
    static const char* _tao_obv_static_repository_id ();
  public:
    virtual void is_system_exception (CORBA::Boolean) = 0;    // set
    virtual CORBA::Boolean is_system_exception (void) const = 0;     // get method

    virtual void byte_order (CORBA::Boolean) = 0;    // set
    virtual CORBA::Boolean byte_order (void) const = 0;     // get method


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___VAR_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___VAR_CH_

    // *************************************************************
    // class Messaging::ExceptionHolder::_tao_seq_Octet_var
    // *************************************************************

    class TAO_Export _tao_seq_Octet_var
    {
    public:
      _tao_seq_Octet_var (void); // default constructor
      _tao_seq_Octet_var (_tao_seq_Octet *);
      _tao_seq_Octet_var (const _tao_seq_Octet_var &); // copy constructor
      _tao_seq_Octet_var (const _tao_seq_Octet &); // fixed-size base types only
      ~_tao_seq_Octet_var (void); // destructor

      _tao_seq_Octet_var &operator= (_tao_seq_Octet *);
      _tao_seq_Octet_var &operator= (const _tao_seq_Octet_var &);
      _tao_seq_Octet_var &operator= (const _tao_seq_Octet &); // fixed-size base types only
      _tao_seq_Octet *operator-> (void);
      const _tao_seq_Octet *operator-> (void) const;

      operator const _tao_seq_Octet &() const;
      operator _tao_seq_Octet &();
      operator _tao_seq_Octet &() const;

      CORBA::Octet &operator[] (CORBA::ULong index);
      // in, inout, out, _retn
      const _tao_seq_Octet &in (void) const;
      _tao_seq_Octet &inout (void);
      _tao_seq_Octet *&out (void);
      _tao_seq_Octet *_retn (void);
      _tao_seq_Octet *ptr (void) const;

    private:
      _tao_seq_Octet *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___OUT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___OUT_CH_

    class TAO_Export _tao_seq_Octet_out
    {
    public:
      _tao_seq_Octet_out (_tao_seq_Octet *&);
      _tao_seq_Octet_out (_tao_seq_Octet_var &);
      _tao_seq_Octet_out (const _tao_seq_Octet_out &);
      _tao_seq_Octet_out &operator= (const _tao_seq_Octet_out &);
      _tao_seq_Octet_out &operator= (_tao_seq_Octet *);
      operator _tao_seq_Octet *&();
      _tao_seq_Octet *&ptr (void);
      _tao_seq_Octet *operator-> (void);
      CORBA::Octet &operator[] (CORBA::ULong index);

    private:
      _tao_seq_Octet *&ptr_;
      // assignment from T_var not allowed
      void operator= (const _tao_seq_Octet_var &);
    };


#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _marshaled_exception_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          virtual void marshaled_exception (const Messaging::ExceptionHolder::_tao_seq_Octet &) = 0;    // set
    virtual const Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void) const = 0;     // get method (read only)
    virtual Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void) = 0;     // get method (read/write only)


  protected:
    ExceptionHolder ();           // default constructor
    virtual ~ExceptionHolder ();

    // TAO internals
    virtual void *_tao_obv_narrow (ptr_arith_t);
    virtual CORBA::Boolean _tao_marshal_v (TAO_OutputCDR &);
    virtual CORBA::Boolean _tao_unmarshal_v (TAO_InputCDR &);

  private:
    ExceptionHolder (const ExceptionHolder &);
    void operator= (const ExceptionHolder &);

  protected:
    virtual CORBA::Boolean _tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &) = 0;
    virtual CORBA::Boolean _tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &) = 0;

  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER___PTR_CH_)
#define _MESSAGING_REPLYHANDLER___PTR_CH_

  class ReplyHandler;
  typedef ReplyHandler *ReplyHandler_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER___VAR_CH_)
#define _MESSAGING_REPLYHANDLER___VAR_CH_

  class TAO_Export ReplyHandler_var : public TAO_Base_var
  {
  public:
    ReplyHandler_var (void); // default constructor
    ReplyHandler_var (ReplyHandler_ptr);
    ReplyHandler_var (const ReplyHandler_var &); // copy constructor
    ~ReplyHandler_var (void); // destructor

    ReplyHandler_var &operator= (ReplyHandler_ptr);
    ReplyHandler_var &operator= (const ReplyHandler_var &);
    ReplyHandler_ptr operator-> (void) const;

    operator const ReplyHandler_ptr &() const;
    operator ReplyHandler_ptr &();
    // in, inout, out, _retn
    ReplyHandler_ptr in (void) const;
    ReplyHandler_ptr &inout (void);
    ReplyHandler_ptr &out (void);
    ReplyHandler_ptr _retn (void);
    ReplyHandler_ptr ptr (void) const;

  private:
    ReplyHandler_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyHandler_var (const TAO_Base_var &rhs);
    ReplyHandler_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER___OUT_CH_)
#define _MESSAGING_REPLYHANDLER___OUT_CH_

  class TAO_Export ReplyHandler_out
  {
  public:
    ReplyHandler_out (ReplyHandler_ptr &);
    ReplyHandler_out (ReplyHandler_var &);
    ReplyHandler_out (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_var &);
    ReplyHandler_out &operator= (ReplyHandler_ptr);
    operator ReplyHandler_ptr &();
    ReplyHandler_ptr &ptr (void);
    ReplyHandler_ptr operator-> (void);

  private:
    ReplyHandler_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER_CH_)
#define _MESSAGING_REPLYHANDLER_CH_

// Forward Classes Declaration
class _TAO_ReplyHandler_Proxy_Impl;
class _TAO_ReplyHandler_Remote_Proxy_Impl;
class _TAO_ReplyHandler_Proxy_Broker;
class _TAO_ReplyHandler_Remote_Proxy_Broker;

class TAO_Export ReplyHandler : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyHandler_ptr _ptr_type;
    typedef ReplyHandler_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static ReplyHandler_ptr _duplicate (ReplyHandler_ptr obj);
    static ReplyHandler_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyHandler_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static ReplyHandler_ptr _nil (void)
      {
        return (ReplyHandler_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_ReplyHandler_Proxy_Broker *the_TAO_ReplyHandler_Proxy_Broker_;

  protected:
    ReplyHandler (int collocated = 0);

  protected:
    virtual void _tao_setup_collocation (int collocated);

     ReplyHandler (
                  TAO_Stub *objref,
                  CORBA::Boolean _tao_collocated = 0,
                  TAO_Abstract_ServantBase *servant = 0
                  );

    friend class _TAO_ReplyHandler_Remote_Proxy_Impl;
    friend class _TAO_ReplyHandler_ThruPOA_Proxy_Impl;
    friend class _TAO_ReplyHandler_Direct_Proxy_Impl;

    virtual ~ReplyHandler (void);
  private:
    ReplyHandler (const ReplyHandler &);
    void operator= (const ReplyHandler &);
  };


  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulate
  // an invocation logics.


  ///////////////////////////////////////////////////////////////////////
  //                    Base  Impl. Declaration
  //

  class TAO_Export _TAO_ReplyHandler_Proxy_Impl : public virtual TAO_Object_Proxy_Impl
  {
  public:
    virtual ~_TAO_ReplyHandler_Proxy_Impl (void);

  };

  //
  //                Base  Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                    Remote  Impl. Declaration
  //

  class TAO_Export _TAO_ReplyHandler_Remote_Proxy_Impl :
  public virtual _TAO_ReplyHandler_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl
  {
  public:
    virtual ~_TAO_ReplyHandler_Remote_Proxy_Impl (void);

  };

  //
  //                Base  Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

 ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

  class TAO_Export _TAO_ReplyHandler_Proxy_Broker
  {
  public:
    virtual ~_TAO_ReplyHandler_Proxy_Broker (void);

    virtual _TAO_ReplyHandler_Proxy_Impl &select_proxy (
                                                        ReplyHandler *object,
                                                        CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                                                        ) = 0;

  };


  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  class TAO_Export _TAO_ReplyHandler_Remote_Proxy_Broker : public virtual _TAO_ReplyHandler_Proxy_Broker
  {
  public:
    virtual ~_TAO_ReplyHandler_Remote_Proxy_Broker (void);

    virtual _TAO_ReplyHandler_Proxy_Impl &select_proxy (
                                                        ReplyHandler *object,
                                                        CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                                                        );

  private:
    _TAO_ReplyHandler_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.

  static _TAO_ReplyHandler_Remote_Proxy_Broker *the_TAO_ReplyHandler_Remote_Proxy_Broker (void);

};


  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////

#if (TAO_HAS_SMART_PROXIES == 1)
class TAO_Export TAO_Messaging_ReplyHandler_Default_Proxy_Factory
  {
  public:

    TAO_Messaging_ReplyHandler_Default_Proxy_Factory (int register_proxy_factory = 1);

    virtual ~TAO_Messaging_ReplyHandler_Default_Proxy_Factory (void);

    virtual ReplyHandler_ptr create_proxy (
        ReplyHandler_ptr proxy,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
};


class TAO_Export TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter
  {
  public:

    friend class TAO_Singleton<TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>;

    int register_proxy_factory (
        TAO_Messaging_ReplyHandler_Default_Proxy_Factory *df,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    int unregister_proxy_factory (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    ReplyHandler_ptr create_proxy (
        ReplyHandler_ptr proxy,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

  protected:
    TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter (void);
    ~TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter (void);
    TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter &operator= (
        const TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter &
      );
    TAO_Messaging_ReplyHandler_Default_Proxy_Factory *proxy_factory_;
    int delete_proxy_factory_;
    ACE_SYNCH_RECURSIVE_MUTEX lock_;

  };

  typedef TAO_Singleton<TAO_Messaging_ReplyHandler_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX> TAO_Messaging_ReplyHandler_PROXY_FACTORY_ADAPTER;

  class TAO_Export TAO_Messaging_ReplyHandler_Smart_Proxy_Base
    : public virtual ReplyHandler,
      public virtual TAO_Smart_Proxy_Base
  {
  public:
    TAO_Messaging_ReplyHandler_Smart_Proxy_Base (void);
    ~TAO_Messaging_ReplyHandler_Smart_Proxy_Base (void);
    virtual TAO_Stub *_stubobj (void) const;
    protected:
    ::Messaging::ReplyHandler_ptr get_proxy (void);
    ::Messaging::ReplyHandler_var proxy_;
  };

#endif /* TAO_HAS_SMART_PROXIES */


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyHandler;

#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

}
TAO_NAMESPACE_CLOSE // module Messaging

// Typedef for the Reply Handler Skeleton.
// This is handcrafted not generated by the IDL compiler.

class TAO_InputCDR;

enum TAO_AMI_Reply_Status
{
  TAO_AMI_REPLY_OK,
  // Reply is normal.

  TAO_AMI_REPLY_NOT_OK,
  // Reply is not normal and no exceptions

  TAO_AMI_REPLY_USER_EXCEPTION,
  // An user exception was raised.

  TAO_AMI_REPLY_SYSTEM_EXCEPTION
  // An system exception was raised.
};


#if (TAO_HAS_AMI_CALLBACK == 1)

typedef void (*TAO_Reply_Handler_Skeleton)(
    TAO_InputCDR &,
    Messaging::ReplyHandler *,
    CORBA::ULong reply_status,
    CORBA::Environment &
    );

TAO_NAMESPACE  OBV_Messaging
{

#if !defined (_MESSAGING_EXCEPTIONHOLDER___OBV_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___OBV_CH_

  // OBV_ class
  class TAO_Export ExceptionHolder : public virtual Messaging::ExceptionHolder
  {
  public:
    virtual void is_system_exception (CORBA::Boolean);    // set
    virtual CORBA::Boolean is_system_exception (void) const;     // get method

    virtual void byte_order (CORBA::Boolean);    // set
    virtual CORBA::Boolean byte_order (void) const;     // get method

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _marshaled_exception_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          virtual void marshaled_exception (const Messaging::ExceptionHolder::_tao_seq_Octet &);    // set
    virtual const Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void) const;     // get method (read only)
    virtual Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void);     // get method (read/write only)


  protected:
    virtual CORBA::Boolean _tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &);
    virtual CORBA::Boolean _tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &);
    CORBA::Boolean _tao_marshal_state (TAO_OutputCDR &);
    CORBA::Boolean _tao_unmarshal_state (TAO_InputCDR &);


  private:
        CORBA::Boolean _pd_is_system_exception;
    CORBA::Boolean _pd_byte_order;
    _tao_seq_Octet _pd_marshaled_exception;
  };

#endif /* end #if !defined */

}
TAO_NAMESPACE_CLOSE

#endif /* TAO_HAS_AMI_CALLBACK == 1 */

#if (TAO_HAS_PRIORITY_POLICIES == 1)

TAO_Export void operator<<= (CORBA::Any &, const Messaging::PriorityRange &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::PriorityRange*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::PriorityRange *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::PriorityRange *&);

#endif /* TAO_HAS_PRIORITY_POLICIES == 1 */

#if (TAO_HAS_ROUTING_POLICY == 1)

TAO_Export void operator<<= (CORBA::Any &, const Messaging::RoutingTypeRange &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::RoutingTypeRange*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::RoutingTypeRange *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::RoutingTypeRange *&);

#endif /* TAO_HAS_ROUTING_POLICY == 1 */

TAO_Export void operator<<= (CORBA::Any &, const Messaging::PolicyValue &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::PolicyValue*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::PolicyValue *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::PolicyValue *&);
TAO_Export void operator<<= (CORBA::Any &, const Messaging::PolicyValueSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::PolicyValueSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::PolicyValueSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::PolicyValueSeq *&);

#if (TAO_HAS_AMI_CALLBACK == 1)

extern TAO_Export Messaging::_TAO_ReplyHandler_Proxy_Broker * (*Messaging__TAO_ReplyHandler_Proxy_Broker_Factory_function_pointer) (
                                                                                                                                    CORBA::Object_ptr obj
             );

extern TAO_Export Messaging::ReplyHandler_ptr (*_TAO_collocation_Messaging_ReplyHandler_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface Messaging::ReplyHandler
TAO_Export void operator<<= (CORBA::Any &, Messaging::ReplyHandler_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::ReplyHandler *&);

#endif /* TAO_HAS_AMI_CALLBACK */

#ifndef __ACE_INLINE__

#if (TAO_HAS_PRIORITY_POLICIES == 1)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::PriorityRange &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::PriorityRange &);

#endif /* TAO_HAS_PRIORITY_POLICIES == 1 */

#if (TAO_HAS_ROUTING_POLICY == 1)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::RoutingTypeRange &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::RoutingTypeRange &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::PolicyValue &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::PolicyValue &);

#endif /* TAO_HAS_ROUTING_POLICY == 1 */

#if !defined _TAO_CDR_OP_Messaging_PolicyValue__tao_seq_Octet_H_
#define _TAO_CDR_OP_Messaging_PolicyValue__tao_seq_Octet_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Messaging::PolicyValue::_tao_seq_Octet &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Messaging::PolicyValue::_tao_seq_Octet &
  );

#endif /* _TAO_CDR_OP_Messaging_PolicyValue__tao_seq_Octet_H_ */


#if !defined _TAO_CDR_OP_Messaging_PolicyValueSeq_H_
#define _TAO_CDR_OP_Messaging_PolicyValueSeq_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Messaging::PolicyValueSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Messaging::PolicyValueSeq &
  );

#endif /* _TAO_CDR_OP_Messaging_PolicyValueSeq_H_ */

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder *); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::ExceptionHolder *&);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::ReplyHandler_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::ReplyHandler_ptr &);

#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "MessagingC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* TAO_HAS_CORBA_MESSAGING */

#include "ace/post.h"
#endif /* ifndef */
