/* -*- C++ -*- */
//
// $Id$
//
// ================================================================
//
// = LIBRARY
//   TAO
//
// = FILENAME
//   TimeBaseC.h
//
// = DESCRIPTION
//   Generated from TimeBase.pidl, the common time representation for
//   Time in CORBA.
//   The code was generated by the IDL compiler and then hand-crafted
//   to reduce the includes interdependencies.
//
// ================================================================

#ifndef TAO_IDL_MESSAGINGC_H
#define TAO_IDL_MESSAGINGC_H

#include "tao/orbconf.h"

#if defined (TAO_HAS_CORBA_MESSAGING)

#include "tao/corbafwd.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "tao/Any.h"
#include "tao/CDR.h"
#include "tao/TimeBaseC.h"
#include "tao/PolicyC.h"
#include "tao/iopfwd.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export
#if defined(_MSC_VER)
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined(TRANSPARENT)
// Some platforms define this macro for ioctl()
#undef TRANSPARENT
#endif

TAO_NAMESPACE  Messaging
{
  typedef CORBA::Short RebindMode;
  typedef CORBA::Short_out RebindMode_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RebindMode;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short TRANSPARENT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_REBIND;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_RECONNECT;

  typedef CORBA::Short SyncScope;
  typedef CORBA::Short_out SyncScope_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_SyncScope;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TRANSPORT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_SERVER;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TARGET;

  typedef CORBA::Short RoutingType;
  typedef CORBA::Short_out RoutingType_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingType;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_FORWARD;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_STORE_AND_FORWARD;

  typedef TimeBase::TimeT Timeout;
  typedef TimeBase::TimeT_out Timeout_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Timeout;

  typedef CORBA::Short Priority;
  typedef CORBA::Short_out Priority_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Priority;

  typedef CORBA::UShort Ordering;
  typedef CORBA::UShort_out Ordering_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Ordering;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_ANY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_TEMPORAL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_PRIORITY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_DEADLINE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REBIND_POLICY_TYPE;


  class RebindPolicy;
  typedef RebindPolicy *RebindPolicy_ptr;

  class TAO_Export RebindPolicy_var
  {
  public:
    RebindPolicy_var (void); // default constructor
    RebindPolicy_var (RebindPolicy_ptr);
    RebindPolicy_var (const RebindPolicy_var &); // copy constructor
    ~RebindPolicy_var (void); // destructor

    RebindPolicy_var &operator= (RebindPolicy_ptr);
    RebindPolicy_var &operator= (const RebindPolicy_var &);
    RebindPolicy_ptr operator-> (void) const;

    operator const RebindPolicy_ptr &() const;
    operator RebindPolicy_ptr &();
    // in, inout, out, _retn
    RebindPolicy_ptr in (void) const;
    RebindPolicy_ptr &inout (void);
    RebindPolicy_ptr &out (void);
    RebindPolicy_ptr _retn (void);
    RebindPolicy_ptr ptr (void) const;

  private:
    RebindPolicy_ptr ptr_;
  };

  class TAO_Export RebindPolicy_out
  {
  public:
    RebindPolicy_out (RebindPolicy_ptr &);
    RebindPolicy_out (RebindPolicy_var &);
    RebindPolicy_out (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_var &);
    RebindPolicy_out &operator= (RebindPolicy_ptr);
    operator RebindPolicy_ptr &();
    RebindPolicy_ptr &ptr (void);
    RebindPolicy_ptr operator-> (void);

  private:
    RebindPolicy_ptr &ptr_;
  };

  class TAO_Export RebindPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RebindPolicy_ptr _ptr_type;
    typedef RebindPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RebindPolicy_ptr _duplicate (RebindPolicy_ptr obj);
    static RebindPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RebindPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RebindPolicy_ptr _nil (void);

    virtual RebindMode rebind_mode (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RebindPolicy (void); // default constructor
    RebindPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RebindPolicy (void);
  private:
    RebindPolicy (const RebindPolicy &);
    void operator= (const RebindPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RebindPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SYNC_SCOPE_POLICY_TYPE;

  class SyncScopePolicy;
  typedef SyncScopePolicy *SyncScopePolicy_ptr;

  class TAO_Export SyncScopePolicy_var
  {
  public:
    SyncScopePolicy_var (void); // default constructor
    SyncScopePolicy_var (SyncScopePolicy_ptr);
    SyncScopePolicy_var (const SyncScopePolicy_var &); // copy constructor
    ~SyncScopePolicy_var (void); // destructor

    SyncScopePolicy_var &operator= (SyncScopePolicy_ptr);
    SyncScopePolicy_var &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_ptr operator-> (void) const;

    operator const SyncScopePolicy_ptr &() const;
    operator SyncScopePolicy_ptr &();
    // in, inout, out, _retn
    SyncScopePolicy_ptr in (void) const;
    SyncScopePolicy_ptr &inout (void);
    SyncScopePolicy_ptr &out (void);
    SyncScopePolicy_ptr _retn (void);
    SyncScopePolicy_ptr ptr (void) const;

  private:
    SyncScopePolicy_ptr ptr_;
  };

  class TAO_Export SyncScopePolicy_out
  {
  public:
    SyncScopePolicy_out (SyncScopePolicy_ptr &);
    SyncScopePolicy_out (SyncScopePolicy_var &);
    SyncScopePolicy_out (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_out &operator= (SyncScopePolicy_ptr);
    operator SyncScopePolicy_ptr &();
    SyncScopePolicy_ptr &ptr (void);
    SyncScopePolicy_ptr operator-> (void);

  private:
    SyncScopePolicy_ptr &ptr_;
  };

  class TAO_Export SyncScopePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef SyncScopePolicy_ptr _ptr_type;
    typedef SyncScopePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static SyncScopePolicy_ptr _duplicate (SyncScopePolicy_ptr obj);
    static SyncScopePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static SyncScopePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static SyncScopePolicy_ptr _nil (void);

    virtual SyncScope synchronization (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    SyncScopePolicy (void); // default constructor
    SyncScopePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~SyncScopePolicy (void);
  private:
    SyncScopePolicy (const SyncScopePolicy &);
    void operator= (const SyncScopePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_SyncScopePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_PRIORITY_POLICY_TYPE;

  struct TAO_Export PriorityRange
  {
    Priority min;
    Priority max;
  };

  class TAO_Export PriorityRange_var
  {
  public:
    PriorityRange_var (void); // default constructor
    PriorityRange_var (PriorityRange *);
    PriorityRange_var (const PriorityRange_var &); // copy constructor
    ~PriorityRange_var (void); // destructor

    PriorityRange_var &operator= (PriorityRange *);
    PriorityRange_var &operator= (const PriorityRange_var &);
    PriorityRange *operator-> (void);
    const PriorityRange *operator-> (void) const;

    operator const PriorityRange &() const;
    operator PriorityRange &();
    operator PriorityRange &() const;
    // in, inout, out, _retn
    const PriorityRange &in (void) const;
    PriorityRange &inout (void);
    PriorityRange &out (void);
    PriorityRange _retn (void);
    PriorityRange *ptr (void) const;

  private:
    PriorityRange *ptr_;
  };

  typedef PriorityRange &PriorityRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityRange;

  class RequestPriorityPolicy;
  typedef RequestPriorityPolicy *RequestPriorityPolicy_ptr;

  class TAO_Export RequestPriorityPolicy_var
  {
  public:
    RequestPriorityPolicy_var (void); // default constructor
    RequestPriorityPolicy_var (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var (const RequestPriorityPolicy_var &); // copy constructor
    ~RequestPriorityPolicy_var (void); // destructor

    RequestPriorityPolicy_var &operator= (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_ptr operator-> (void) const;

    operator const RequestPriorityPolicy_ptr &() const;
    operator RequestPriorityPolicy_ptr &();
    // in, inout, out, _retn
    RequestPriorityPolicy_ptr in (void) const;
    RequestPriorityPolicy_ptr &inout (void);
    RequestPriorityPolicy_ptr &out (void);
    RequestPriorityPolicy_ptr _retn (void);
    RequestPriorityPolicy_ptr ptr (void) const;

  private:
    RequestPriorityPolicy_ptr ptr_;
  };

  class TAO_Export RequestPriorityPolicy_out
  {
  public:
    RequestPriorityPolicy_out (RequestPriorityPolicy_ptr &);
    RequestPriorityPolicy_out (RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out &operator= (RequestPriorityPolicy_ptr);
    operator RequestPriorityPolicy_ptr &();
    RequestPriorityPolicy_ptr &ptr (void);
    RequestPriorityPolicy_ptr operator-> (void);

  private:
    RequestPriorityPolicy_ptr &ptr_;
  };

  class TAO_Export RequestPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestPriorityPolicy_ptr _ptr_type;
    typedef RequestPriorityPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestPriorityPolicy_ptr _duplicate (RequestPriorityPolicy_ptr obj);
    static RequestPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RequestPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RequestPriorityPolicy_ptr _nil (void);

    virtual PriorityRange priority_range (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestPriorityPolicy (void); // default constructor
    RequestPriorityPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestPriorityPolicy (void);
  private:
    RequestPriorityPolicy (const RequestPriorityPolicy &);
    void operator= (const RequestPriorityPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestPriorityPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_PRIORITY_POLICY_TYPE;

  class ReplyPriorityPolicy;
  typedef ReplyPriorityPolicy *ReplyPriorityPolicy_ptr;

  class TAO_Export ReplyPriorityPolicy_var
  {
  public:
    ReplyPriorityPolicy_var (void); // default constructor
    ReplyPriorityPolicy_var (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var (const ReplyPriorityPolicy_var &); // copy constructor
    ~ReplyPriorityPolicy_var (void); // destructor

    ReplyPriorityPolicy_var &operator= (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_ptr operator-> (void) const;

    operator const ReplyPriorityPolicy_ptr &() const;
    operator ReplyPriorityPolicy_ptr &();
    // in, inout, out, _retn
    ReplyPriorityPolicy_ptr in (void) const;
    ReplyPriorityPolicy_ptr &inout (void);
    ReplyPriorityPolicy_ptr &out (void);
    ReplyPriorityPolicy_ptr _retn (void);
    ReplyPriorityPolicy_ptr ptr (void) const;

  private:
    ReplyPriorityPolicy_ptr ptr_;
  };

  class TAO_Export ReplyPriorityPolicy_out
  {
  public:
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_ptr &);
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out &operator= (ReplyPriorityPolicy_ptr);
    operator ReplyPriorityPolicy_ptr &();
    ReplyPriorityPolicy_ptr &ptr (void);
    ReplyPriorityPolicy_ptr operator-> (void);

  private:
    ReplyPriorityPolicy_ptr &ptr_;
  };

  class TAO_Export ReplyPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyPriorityPolicy_ptr _ptr_type;
    typedef ReplyPriorityPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyPriorityPolicy_ptr _duplicate (ReplyPriorityPolicy_ptr obj);
    static ReplyPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyPriorityPolicy_ptr _nil (void);

    virtual PriorityRange priority_range (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyPriorityPolicy (void); // default constructor
    ReplyPriorityPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyPriorityPolicy (void);
  private:
    ReplyPriorityPolicy (const ReplyPriorityPolicy &);
    void operator= (const ReplyPriorityPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyPriorityPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_START_TIME_POLICY_TYPE;

  class RequestStartTimePolicy;
  typedef RequestStartTimePolicy *RequestStartTimePolicy_ptr;

  class TAO_Export RequestStartTimePolicy_var
  {
  public:
    RequestStartTimePolicy_var (void); // default constructor
    RequestStartTimePolicy_var (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var (const RequestStartTimePolicy_var &); // copy constructor
    ~RequestStartTimePolicy_var (void); // destructor

    RequestStartTimePolicy_var &operator= (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_ptr operator-> (void) const;

    operator const RequestStartTimePolicy_ptr &() const;
    operator RequestStartTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestStartTimePolicy_ptr in (void) const;
    RequestStartTimePolicy_ptr &inout (void);
    RequestStartTimePolicy_ptr &out (void);
    RequestStartTimePolicy_ptr _retn (void);
    RequestStartTimePolicy_ptr ptr (void) const;

  private:
    RequestStartTimePolicy_ptr ptr_;
  };

  class TAO_Export RequestStartTimePolicy_out
  {
  public:
    RequestStartTimePolicy_out (RequestStartTimePolicy_ptr &);
    RequestStartTimePolicy_out (RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out &operator= (RequestStartTimePolicy_ptr);
    operator RequestStartTimePolicy_ptr &();
    RequestStartTimePolicy_ptr &ptr (void);
    RequestStartTimePolicy_ptr operator-> (void);

  private:
    RequestStartTimePolicy_ptr &ptr_;
  };

  class TAO_Export RequestStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestStartTimePolicy_ptr _ptr_type;
    typedef RequestStartTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestStartTimePolicy_ptr _duplicate (RequestStartTimePolicy_ptr obj);
    static RequestStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RequestStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RequestStartTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT start_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestStartTimePolicy (void); // default constructor
    RequestStartTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestStartTimePolicy (void);
  private:
    RequestStartTimePolicy (const RequestStartTimePolicy &);
    void operator= (const RequestStartTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestStartTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_END_TIME_POLICY_TYPE;

  class RequestEndTimePolicy;
  typedef RequestEndTimePolicy *RequestEndTimePolicy_ptr;

  class TAO_Export RequestEndTimePolicy_var
  {
  public:
    RequestEndTimePolicy_var (void); // default constructor
    RequestEndTimePolicy_var (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var (const RequestEndTimePolicy_var &); // copy constructor
    ~RequestEndTimePolicy_var (void); // destructor

    RequestEndTimePolicy_var &operator= (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_ptr operator-> (void) const;

    operator const RequestEndTimePolicy_ptr &() const;
    operator RequestEndTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestEndTimePolicy_ptr in (void) const;
    RequestEndTimePolicy_ptr &inout (void);
    RequestEndTimePolicy_ptr &out (void);
    RequestEndTimePolicy_ptr _retn (void);
    RequestEndTimePolicy_ptr ptr (void) const;

  private:
    RequestEndTimePolicy_ptr ptr_;
  };

  class TAO_Export RequestEndTimePolicy_out
  {
  public:
    RequestEndTimePolicy_out (RequestEndTimePolicy_ptr &);
    RequestEndTimePolicy_out (RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out &operator= (RequestEndTimePolicy_ptr);
    operator RequestEndTimePolicy_ptr &();
    RequestEndTimePolicy_ptr &ptr (void);
    RequestEndTimePolicy_ptr operator-> (void);

  private:
    RequestEndTimePolicy_ptr &ptr_;
  };

  class TAO_Export RequestEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestEndTimePolicy_ptr _ptr_type;
    typedef RequestEndTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestEndTimePolicy_ptr _duplicate (RequestEndTimePolicy_ptr obj);
    static RequestEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RequestEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RequestEndTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT end_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestEndTimePolicy (void); // default constructor
    RequestEndTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestEndTimePolicy (void);
  private:
    RequestEndTimePolicy (const RequestEndTimePolicy &);
    void operator= (const RequestEndTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestEndTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_START_TIME_POLICY_TYPE;

  class ReplyStartTimePolicy;
  typedef ReplyStartTimePolicy *ReplyStartTimePolicy_ptr;

  class TAO_Export ReplyStartTimePolicy_var
  {
  public:
    ReplyStartTimePolicy_var (void); // default constructor
    ReplyStartTimePolicy_var (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var (const ReplyStartTimePolicy_var &); // copy constructor
    ~ReplyStartTimePolicy_var (void); // destructor

    ReplyStartTimePolicy_var &operator= (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_ptr operator-> (void) const;

    operator const ReplyStartTimePolicy_ptr &() const;
    operator ReplyStartTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyStartTimePolicy_ptr in (void) const;
    ReplyStartTimePolicy_ptr &inout (void);
    ReplyStartTimePolicy_ptr &out (void);
    ReplyStartTimePolicy_ptr _retn (void);
    ReplyStartTimePolicy_ptr ptr (void) const;

  private:
    ReplyStartTimePolicy_ptr ptr_;
  };

  class TAO_Export ReplyStartTimePolicy_out
  {
  public:
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_ptr &);
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out &operator= (ReplyStartTimePolicy_ptr);
    operator ReplyStartTimePolicy_ptr &();
    ReplyStartTimePolicy_ptr &ptr (void);
    ReplyStartTimePolicy_ptr operator-> (void);

  private:
    ReplyStartTimePolicy_ptr &ptr_;
  };

  class TAO_Export ReplyStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyStartTimePolicy_ptr _ptr_type;
    typedef ReplyStartTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyStartTimePolicy_ptr _duplicate (ReplyStartTimePolicy_ptr obj);
    static ReplyStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyStartTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT start_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyStartTimePolicy (void); // default constructor
    ReplyStartTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyStartTimePolicy (void);
  private:
    ReplyStartTimePolicy (const ReplyStartTimePolicy &);
    void operator= (const ReplyStartTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyStartTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_END_TIME_POLICY_TYPE;

  class ReplyEndTimePolicy;
  typedef ReplyEndTimePolicy *ReplyEndTimePolicy_ptr;

  class TAO_Export ReplyEndTimePolicy_var
  {
  public:
    ReplyEndTimePolicy_var (void); // default constructor
    ReplyEndTimePolicy_var (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var (const ReplyEndTimePolicy_var &); // copy constructor
    ~ReplyEndTimePolicy_var (void); // destructor

    ReplyEndTimePolicy_var &operator= (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_ptr operator-> (void) const;

    operator const ReplyEndTimePolicy_ptr &() const;
    operator ReplyEndTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyEndTimePolicy_ptr in (void) const;
    ReplyEndTimePolicy_ptr &inout (void);
    ReplyEndTimePolicy_ptr &out (void);
    ReplyEndTimePolicy_ptr _retn (void);
    ReplyEndTimePolicy_ptr ptr (void) const;

  private:
    ReplyEndTimePolicy_ptr ptr_;
  };

  class TAO_Export ReplyEndTimePolicy_out
  {
  public:
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_ptr &);
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out &operator= (ReplyEndTimePolicy_ptr);
    operator ReplyEndTimePolicy_ptr &();
    ReplyEndTimePolicy_ptr &ptr (void);
    ReplyEndTimePolicy_ptr operator-> (void);

  private:
    ReplyEndTimePolicy_ptr &ptr_;
  };

  class TAO_Export ReplyEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyEndTimePolicy_ptr _ptr_type;
    typedef ReplyEndTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyEndTimePolicy_ptr _duplicate (ReplyEndTimePolicy_ptr obj);
    static ReplyEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyEndTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT end_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyEndTimePolicy (void); // default constructor
    ReplyEndTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyEndTimePolicy (void);
  private:
    ReplyEndTimePolicy (const ReplyEndTimePolicy &);
    void operator= (const ReplyEndTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyEndTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_REQ_TIMEOUT_POLICY_TYPE;

  class RelativeRequestTimeoutPolicy;
  typedef RelativeRequestTimeoutPolicy *RelativeRequestTimeoutPolicy_ptr;

  class TAO_Export RelativeRequestTimeoutPolicy_var
  {
  public:
    RelativeRequestTimeoutPolicy_var (void); // default constructor
    RelativeRequestTimeoutPolicy_var (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var (const RelativeRequestTimeoutPolicy_var &); // copy constructor
    ~RelativeRequestTimeoutPolicy_var (void); // destructor

    RelativeRequestTimeoutPolicy_var &operator= (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRequestTimeoutPolicy_ptr &() const;
    operator RelativeRequestTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRequestTimeoutPolicy_ptr in (void) const;
    RelativeRequestTimeoutPolicy_ptr &inout (void);
    RelativeRequestTimeoutPolicy_ptr &out (void);
    RelativeRequestTimeoutPolicy_ptr _retn (void);
    RelativeRequestTimeoutPolicy_ptr ptr (void) const;

  private:
    RelativeRequestTimeoutPolicy_ptr ptr_;
  };

  class TAO_Export RelativeRequestTimeoutPolicy_out
  {
  public:
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_ptr &);
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out &operator= (RelativeRequestTimeoutPolicy_ptr);
    operator RelativeRequestTimeoutPolicy_ptr &();
    RelativeRequestTimeoutPolicy_ptr &ptr (void);
    RelativeRequestTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRequestTimeoutPolicy_ptr &ptr_;
  };

  class TAO_Export RelativeRequestTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RelativeRequestTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRequestTimeoutPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RelativeRequestTimeoutPolicy_ptr _duplicate (RelativeRequestTimeoutPolicy_ptr obj);
    static RelativeRequestTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RelativeRequestTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RelativeRequestTimeoutPolicy_ptr _nil (void);

    virtual TimeBase::TimeT relative_expiry (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RelativeRequestTimeoutPolicy (void); // default constructor
    RelativeRequestTimeoutPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RelativeRequestTimeoutPolicy (void);
  private:
    RelativeRequestTimeoutPolicy (const RelativeRequestTimeoutPolicy &);
    void operator= (const RelativeRequestTimeoutPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RelativeRequestTimeoutPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_RT_TIMEOUT_POLICY_TYPE;

  class RelativeRoundtripTimeoutPolicy;
  typedef RelativeRoundtripTimeoutPolicy *RelativeRoundtripTimeoutPolicy_ptr;

  class TAO_Export RelativeRoundtripTimeoutPolicy_var
  {
  public:
    RelativeRoundtripTimeoutPolicy_var (void); // default constructor
    RelativeRoundtripTimeoutPolicy_var (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var (const RelativeRoundtripTimeoutPolicy_var &); // copy constructor
    ~RelativeRoundtripTimeoutPolicy_var (void); // destructor

    RelativeRoundtripTimeoutPolicy_var &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRoundtripTimeoutPolicy_ptr &() const;
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRoundtripTimeoutPolicy_ptr in (void) const;
    RelativeRoundtripTimeoutPolicy_ptr &inout (void);
    RelativeRoundtripTimeoutPolicy_ptr &out (void);
    RelativeRoundtripTimeoutPolicy_ptr _retn (void);
    RelativeRoundtripTimeoutPolicy_ptr ptr (void) const;

  private:
    RelativeRoundtripTimeoutPolicy_ptr ptr_;
  };

  class TAO_Export RelativeRoundtripTimeoutPolicy_out
  {
  public:
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_ptr &);
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    RelativeRoundtripTimeoutPolicy_ptr &ptr (void);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRoundtripTimeoutPolicy_ptr &ptr_;
  };

  class TAO_Export RelativeRoundtripTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RelativeRoundtripTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRoundtripTimeoutPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RelativeRoundtripTimeoutPolicy_ptr _duplicate (RelativeRoundtripTimeoutPolicy_ptr obj);
    static RelativeRoundtripTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RelativeRoundtripTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RelativeRoundtripTimeoutPolicy_ptr _nil (void);

    virtual TimeBase::TimeT relative_expiry (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RelativeRoundtripTimeoutPolicy (void); // default constructor
    RelativeRoundtripTimeoutPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RelativeRoundtripTimeoutPolicy (void);
  private:
    RelativeRoundtripTimeoutPolicy (const RelativeRoundtripTimeoutPolicy &);
    void operator= (const RelativeRoundtripTimeoutPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RelativeRoundtripTimeoutPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ROUTING_POLICY_TYPE;

  struct TAO_Export RoutingTypeRange
  {
    RoutingType min;
    RoutingType max;
  };

  class TAO_Export RoutingTypeRange_var
  {
  public:
    RoutingTypeRange_var (void); // default constructor
    RoutingTypeRange_var (RoutingTypeRange *);
    RoutingTypeRange_var (const RoutingTypeRange_var &); // copy constructor
    ~RoutingTypeRange_var (void); // destructor

    RoutingTypeRange_var &operator= (RoutingTypeRange *);
    RoutingTypeRange_var &operator= (const RoutingTypeRange_var &);
    RoutingTypeRange *operator-> (void);
    const RoutingTypeRange *operator-> (void) const;

    operator const RoutingTypeRange &() const;
    operator RoutingTypeRange &();
    operator RoutingTypeRange &() const;
    // in, inout, out, _retn
    const RoutingTypeRange &in (void) const;
    RoutingTypeRange &inout (void);
    RoutingTypeRange &out (void);
    RoutingTypeRange _retn (void);
    RoutingTypeRange *ptr (void) const;

  private:
    RoutingTypeRange *ptr_;
  };

  typedef RoutingTypeRange &RoutingTypeRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingTypeRange;

  class RoutingPolicy;
  typedef RoutingPolicy *RoutingPolicy_ptr;

  class TAO_Export RoutingPolicy_var
  {
  public:
    RoutingPolicy_var (void); // default constructor
    RoutingPolicy_var (RoutingPolicy_ptr);
    RoutingPolicy_var (const RoutingPolicy_var &); // copy constructor
    ~RoutingPolicy_var (void); // destructor

    RoutingPolicy_var &operator= (RoutingPolicy_ptr);
    RoutingPolicy_var &operator= (const RoutingPolicy_var &);
    RoutingPolicy_ptr operator-> (void) const;

    operator const RoutingPolicy_ptr &() const;
    operator RoutingPolicy_ptr &();
    // in, inout, out, _retn
    RoutingPolicy_ptr in (void) const;
    RoutingPolicy_ptr &inout (void);
    RoutingPolicy_ptr &out (void);
    RoutingPolicy_ptr _retn (void);
    RoutingPolicy_ptr ptr (void) const;

  private:
    RoutingPolicy_ptr ptr_;
  };

  class TAO_Export RoutingPolicy_out
  {
  public:
    RoutingPolicy_out (RoutingPolicy_ptr &);
    RoutingPolicy_out (RoutingPolicy_var &);
    RoutingPolicy_out (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_var &);
    RoutingPolicy_out &operator= (RoutingPolicy_ptr);
    operator RoutingPolicy_ptr &();
    RoutingPolicy_ptr &ptr (void);
    RoutingPolicy_ptr operator-> (void);

  private:
    RoutingPolicy_ptr &ptr_;
  };

  class TAO_Export RoutingPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RoutingPolicy_ptr _ptr_type;
    typedef RoutingPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RoutingPolicy_ptr _duplicate (RoutingPolicy_ptr obj);
    static RoutingPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RoutingPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static RoutingPolicy_ptr _nil (void);

    virtual RoutingTypeRange routing_range (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RoutingPolicy (void); // default constructor
    RoutingPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RoutingPolicy (void);
  private:
    RoutingPolicy (const RoutingPolicy &);
    void operator= (const RoutingPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong MAX_HOPS_POLICY_TYPE;

  class MaxHopsPolicy;
  typedef MaxHopsPolicy *MaxHopsPolicy_ptr;

  class TAO_Export MaxHopsPolicy_var
  {
  public:
    MaxHopsPolicy_var (void); // default constructor
    MaxHopsPolicy_var (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var (const MaxHopsPolicy_var &); // copy constructor
    ~MaxHopsPolicy_var (void); // destructor

    MaxHopsPolicy_var &operator= (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_ptr operator-> (void) const;

    operator const MaxHopsPolicy_ptr &() const;
    operator MaxHopsPolicy_ptr &();
    // in, inout, out, _retn
    MaxHopsPolicy_ptr in (void) const;
    MaxHopsPolicy_ptr &inout (void);
    MaxHopsPolicy_ptr &out (void);
    MaxHopsPolicy_ptr _retn (void);
    MaxHopsPolicy_ptr ptr (void) const;

  private:
    MaxHopsPolicy_ptr ptr_;
  };

  class TAO_Export MaxHopsPolicy_out
  {
  public:
    MaxHopsPolicy_out (MaxHopsPolicy_ptr &);
    MaxHopsPolicy_out (MaxHopsPolicy_var &);
    MaxHopsPolicy_out (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_out &operator= (MaxHopsPolicy_ptr);
    operator MaxHopsPolicy_ptr &();
    MaxHopsPolicy_ptr &ptr (void);
    MaxHopsPolicy_ptr operator-> (void);

  private:
    MaxHopsPolicy_ptr &ptr_;
  };

  class TAO_Export MaxHopsPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef MaxHopsPolicy_ptr _ptr_type;
    typedef MaxHopsPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static MaxHopsPolicy_ptr _duplicate (MaxHopsPolicy_ptr obj);
    static MaxHopsPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static MaxHopsPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static MaxHopsPolicy_ptr _nil (void);

    virtual CORBA::UShort max_hops (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    MaxHopsPolicy (void); // default constructor
    MaxHopsPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~MaxHopsPolicy (void);
  private:
    MaxHopsPolicy (const MaxHopsPolicy &);
    void operator= (const MaxHopsPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MaxHopsPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong QUEUE_ORDER_POLICY_TYPE;

  class QueueOrderPolicy;
  typedef QueueOrderPolicy *QueueOrderPolicy_ptr;

  class TAO_Export QueueOrderPolicy_var
  {
  public:
    QueueOrderPolicy_var (void); // default constructor
    QueueOrderPolicy_var (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var (const QueueOrderPolicy_var &); // copy constructor
    ~QueueOrderPolicy_var (void); // destructor

    QueueOrderPolicy_var &operator= (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_ptr operator-> (void) const;

    operator const QueueOrderPolicy_ptr &() const;
    operator QueueOrderPolicy_ptr &();
    // in, inout, out, _retn
    QueueOrderPolicy_ptr in (void) const;
    QueueOrderPolicy_ptr &inout (void);
    QueueOrderPolicy_ptr &out (void);
    QueueOrderPolicy_ptr _retn (void);
    QueueOrderPolicy_ptr ptr (void) const;

  private:
    QueueOrderPolicy_ptr ptr_;
  };

  class TAO_Export QueueOrderPolicy_out
  {
  public:
    QueueOrderPolicy_out (QueueOrderPolicy_ptr &);
    QueueOrderPolicy_out (QueueOrderPolicy_var &);
    QueueOrderPolicy_out (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_out &operator= (QueueOrderPolicy_ptr);
    operator QueueOrderPolicy_ptr &();
    QueueOrderPolicy_ptr &ptr (void);
    QueueOrderPolicy_ptr operator-> (void);

  private:
    QueueOrderPolicy_ptr &ptr_;
  };

  class TAO_Export QueueOrderPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef QueueOrderPolicy_ptr _ptr_type;
    typedef QueueOrderPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static QueueOrderPolicy_ptr _duplicate (QueueOrderPolicy_ptr obj);
    static QueueOrderPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static QueueOrderPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static QueueOrderPolicy_ptr _nil (void);

    virtual Ordering allowed_orders (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    QueueOrderPolicy (void); // default constructor
    QueueOrderPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~QueueOrderPolicy (void);
  private:
    QueueOrderPolicy (const QueueOrderPolicy &);
    void operator= (const QueueOrderPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_QueueOrderPolicy;

  struct TAO_Export PolicyValue
  {
    CORBA::PolicyType ptype;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public TAO_Unbounded_Sequence<CORBA::Octet>
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void); // dtor

#if defined(TAO_NO_COPY_OCTET_SEQUENCES)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE */

    };
    typedef _tao_seq_Octet *_tao_seq_Octet_ptr;
    static CORBA::TypeCode_ptr _tc__tao_seq_Octet;

    _tao_seq_Octet pvalue;
  };

  class TAO_Export PolicyValue_var
  {
  public:
    PolicyValue_var (void); // default constructor
    PolicyValue_var (PolicyValue *);
    PolicyValue_var (const PolicyValue_var &); // copy constructor
    ~PolicyValue_var (void); // destructor

    PolicyValue_var &operator= (PolicyValue *);
    PolicyValue_var &operator= (const PolicyValue_var &);
    PolicyValue *operator-> (void);
    const PolicyValue *operator-> (void) const;

    operator const PolicyValue &() const;
    operator PolicyValue &();
    operator PolicyValue &() const;
    // in, inout, out, _retn
    const PolicyValue &in (void) const;
    PolicyValue &inout (void);
    PolicyValue *&out (void);
    PolicyValue *_retn (void);
    PolicyValue *ptr (void) const;

  private:
    PolicyValue *ptr_;
  };

  class TAO_Export PolicyValue_out
  {
  public:
    PolicyValue_out (PolicyValue *&);
    PolicyValue_out (PolicyValue_var &);
    PolicyValue_out (const PolicyValue_out &);
    PolicyValue_out &operator= (const PolicyValue_out &);
    PolicyValue_out &operator= (PolicyValue *);
    operator PolicyValue *&();
    PolicyValue *&ptr (void);
    PolicyValue *operator-> (void);

  private:
    PolicyValue *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValue_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValue;

  // *************************************************************
  // PolicyValueSeq
  // *************************************************************

  class TAO_Export PolicyValueSeq : public TAO_Unbounded_Sequence<PolicyValue>
  {
  public:
    PolicyValueSeq (void); // default ctor
    PolicyValueSeq (CORBA::ULong max); // uses max size
    PolicyValueSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      PolicyValue *buffer,
      CORBA::Boolean release=0
    );
    PolicyValueSeq (const PolicyValueSeq &); // copy ctor
    ~PolicyValueSeq (void); // dtor
  };
  typedef PolicyValueSeq *PolicyValueSeq_ptr;

  // *************************************************************
  // class Messaging::PolicyValueSeq_var
  // *************************************************************

  class TAO_Export PolicyValueSeq_var
  {
  public:
    PolicyValueSeq_var (void); // default constructor
    PolicyValueSeq_var (PolicyValueSeq *);
    PolicyValueSeq_var (const PolicyValueSeq_var &); // copy constructor
    ~PolicyValueSeq_var (void); // destructor

    PolicyValueSeq_var &operator= (PolicyValueSeq *);
    PolicyValueSeq_var &operator= (const PolicyValueSeq_var &);
    PolicyValueSeq *operator-> (void);
    const PolicyValueSeq *operator-> (void) const;

    operator const PolicyValueSeq &() const;
    operator PolicyValueSeq &();
    operator PolicyValueSeq &() const;
    PolicyValue &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const PolicyValueSeq &in (void) const;
    PolicyValueSeq &inout (void);
    PolicyValueSeq *&out (void);
    PolicyValueSeq *_retn (void);
    PolicyValueSeq *ptr (void) const;

  private:
    PolicyValueSeq *ptr_;
  };

  class TAO_Export PolicyValueSeq_out
  {
  public:
    PolicyValueSeq_out (PolicyValueSeq *&);
    PolicyValueSeq_out (PolicyValueSeq_var &);
    PolicyValueSeq_out (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (PolicyValueSeq *);
    operator PolicyValueSeq *&();
    PolicyValueSeq *&ptr (void);
    PolicyValueSeq *operator-> (void);
    PolicyValue &operator[] (CORBA::ULong index);

  private:
    PolicyValueSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValueSeq_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValueSeq;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_POLICIES;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong INVOCATION_POLICIES;

#if defined (TAO_POLLER)
  struct TAO_Export ExceptionHolder
  {
    CORBA::Boolean is_system_exception;
    CORBA::Boolean byte_order;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public TAO_Unbounded_Sequence<CORBA::Octet>
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void); // dtor

#if defined(TAO_NO_COPY_OCTET_SEQUENCES)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE */

    };
    typedef _tao_seq_Octet *_tao_seq_Octet_ptr;
    static CORBA::TypeCode_ptr _tc__tao_seq_Octet;

    _tao_seq_Octet marshaled_exception;
  };

  class TAO_Export ExceptionHolder_var
  {
  public:
    ExceptionHolder_var (void); // default constructor
    ExceptionHolder_var (ExceptionHolder *);
    ExceptionHolder_var (const ExceptionHolder_var &); // copy constructor
    ~ExceptionHolder_var (void); // destructor

    ExceptionHolder_var &operator= (ExceptionHolder *);
    ExceptionHolder_var &operator= (const ExceptionHolder_var &);
    ExceptionHolder *operator-> (void);
    const ExceptionHolder *operator-> (void) const;

    operator const ExceptionHolder &() const;
    operator ExceptionHolder &();
    operator ExceptionHolder &() const;
    // in, inout, out, _retn
    const ExceptionHolder &in (void) const;
    ExceptionHolder &inout (void);
    ExceptionHolder *&out (void);
    ExceptionHolder *_retn (void);
    ExceptionHolder *ptr (void) const;

  private:
    ExceptionHolder *ptr_;
  };

  class TAO_Export ExceptionHolder_out
  {
  public:
    ExceptionHolder_out (ExceptionHolder *&);
    ExceptionHolder_out (ExceptionHolder_var &);
    ExceptionHolder_out (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (ExceptionHolder *);
    operator ExceptionHolder *&();
    ExceptionHolder *&ptr (void);
    ExceptionHolder *operator-> (void);

  private:
    ExceptionHolder *&ptr_;
    // assignment from T_var not allowed
    void operator= (const ExceptionHolder_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ExceptionHolder;

  class ReplyHandler;
  typedef ReplyHandler *ReplyHandler_ptr;

  class TAO_Export ReplyHandler_var
  {
  public:
    ReplyHandler_var (void); // default constructor
    ReplyHandler_var (ReplyHandler_ptr);
    ReplyHandler_var (const ReplyHandler_var &); // copy constructor
    ~ReplyHandler_var (void); // destructor

    ReplyHandler_var &operator= (ReplyHandler_ptr);
    ReplyHandler_var &operator= (const ReplyHandler_var &);
    ReplyHandler_ptr operator-> (void) const;

    operator const ReplyHandler_ptr &() const;
    operator ReplyHandler_ptr &();
    // in, inout, out, _retn
    ReplyHandler_ptr in (void) const;
    ReplyHandler_ptr &inout (void);
    ReplyHandler_ptr &out (void);
    ReplyHandler_ptr _retn (void);
    ReplyHandler_ptr ptr (void) const;

  private:
    ReplyHandler_ptr ptr_;
  };

  class TAO_Export ReplyHandler_out
  {
  public:
    ReplyHandler_out (ReplyHandler_ptr &);
    ReplyHandler_out (ReplyHandler_var &);
    ReplyHandler_out (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_var &);
    ReplyHandler_out &operator= (ReplyHandler_ptr);
    operator ReplyHandler_ptr &();
    ReplyHandler_ptr &ptr (void);
    ReplyHandler_ptr operator-> (void);

  private:
    ReplyHandler_ptr &ptr_;
  };

  class TAO_Export ReplyHandler : public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyHandler_ptr _ptr_type;
    typedef ReplyHandler_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyHandler_ptr _duplicate (ReplyHandler_ptr obj);
    static ReplyHandler_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyHandler_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static ReplyHandler_ptr _nil (void);

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyHandler (void); // default constructor
    ReplyHandler (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyHandler (void);
  private:
    ReplyHandler (const ReplyHandler &);
    void operator= (const ReplyHandler &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyHandler;

  class Poller;
  typedef Poller *Poller_ptr;

  class TAO_Export Poller_var
  {
  public:
    Poller_var (void); // default constructor
    Poller_var (Poller_ptr);
    Poller_var (const Poller_var &); // copy constructor
    ~Poller_var (void); // destructor

    Poller_var &operator= (Poller_ptr);
    Poller_var &operator= (const Poller_var &);
    Poller_ptr operator-> (void) const;

    operator const Poller_ptr &() const;
    operator Poller_ptr &();
    // in, inout, out, _retn
    Poller_ptr in (void) const;
    Poller_ptr &inout (void);
    Poller_ptr &out (void);
    Poller_ptr _retn (void);
    Poller_ptr ptr (void) const;

  private:
    Poller_ptr ptr_;
  };

  class TAO_Export Poller_out
  {
  public:
    Poller_out (Poller_ptr &);
    Poller_out (Poller_var &);
    Poller_out (const Poller_out &);
    Poller_out &operator= (const Poller_out &);
    Poller_out &operator= (const Poller_var &);
    Poller_out &operator= (Poller_ptr);
    operator Poller_ptr &();
    Poller_ptr &ptr (void);
    Poller_ptr operator-> (void);

  private:
    Poller_ptr &ptr_;
  };

  class TAO_Export Poller: public virtual CORBA::Pollable
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef Poller_ptr _ptr_type;
    typedef Poller_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static Poller_ptr _duplicate (Poller_ptr obj);
    static Poller_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static Poller_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    static Poller_ptr _nil (void);

    virtual CORBA::Object_ptr operation_target (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual char * operation_name (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual ReplyHandler_ptr associated_handler (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual void associated_handler (
        ReplyHandler_ptr associated_handler,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean is_from_poller (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Object_ptr target (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual char * op_name (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    Poller (void); // default constructor
    Poller (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~Poller (void);
  private:
    Poller (const Poller &);
    void operator= (const Poller &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Poller;
#endif /* 0 */

}; // module Messaging

void TAO_Export operator<<= (CORBA::Any &, Messaging::PriorityRange*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::PriorityRange *&);

void TAO_Export operator<<= (CORBA::Any &, const Messaging::RoutingTypeRange &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::RoutingTypeRange*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::RoutingTypeRange *&);

void TAO_Export operator<<= (CORBA::Any &, const Messaging::PolicyValue &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::PolicyValue*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::PolicyValue *&);
void TAO_Export operator<<= (CORBA::Any &, const Messaging::PolicyValueSeq &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::PolicyValueSeq*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::PolicyValueSeq *&);

#if defined (TAO_POLLER)
void TAO_Export operator<<= (CORBA::Any &, const Messaging::ExceptionHolder &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::ExceptionHolder*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::ExceptionHolder *&);
// Any operators for interface Messaging::ReplyHandler
void TAO_Export operator<<= (CORBA::Any &, Messaging::ReplyHandler_ptr);
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::ReplyHandler *&);
// Any operators for interface Messaging::Poller
void TAO_Export operator<<= (CORBA::Any &, Messaging::Poller_ptr);
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::Poller *&);
#endif

#ifndef __ACE_INLINE__

CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PriorityRange &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PriorityRange &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::RoutingTypeRange &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::RoutingTypeRange &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PolicyValue &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PolicyValue &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PolicyValue::_tao_seq_Octet &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PolicyValue::_tao_seq_Octet &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PolicyValueSeq &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PolicyValueSeq &);

#if defined (TAO_POLLER)
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::ExceptionHolder &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder::_tao_seq_Octet &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::ExceptionHolder::_tao_seq_Octet &);
CORBA::Boolean TAO_Export
operator<< (TAO_OutputCDR &, const Messaging::ReplyHandler_ptr );
CORBA::Boolean TAO_Export
operator>> (TAO_InputCDR &, Messaging::ReplyHandler_ptr &);
CORBA::Boolean TAO_Export
operator<< (TAO_OutputCDR &, const Messaging::Poller_ptr );
CORBA::Boolean TAO_Export
operator>> (TAO_InputCDR &, Messaging::Poller_ptr &);
#endif

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "MessagingC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER)
#pragma warning(default:4250)
#endif /* _MSC_VER */

#endif /* TAO_HAS_CORBA_MESSAGING */

#endif /* TAO_IDL_MESSAGINGC_H */
