/* -*- C++ -*- */
//
// $Id$
//
// ================================================================
//
// = LIBRARY
//   TAO
//
// = FILENAME
//   MessagingC.h
//
// = DESCRIPTION
//   Generated from MessagingC.pidl, the CORBA module for the Message
//   specification.
//   The code was generated by the IDL compiler and then hand-crafted
//   to reduce the includes interdependencies.
//
// ================================================================

#ifndef TAO_IDL_MESSAGINGC_H
#define TAO_IDL_MESSAGINGC_H

#include "tao/orbconf.h"

#if defined (TAO_HAS_CORBA_MESSAGING)

#include "tao/ValueBase.h"
#include "tao/ValueFactory.h"
#include "tao/corbafwd.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "tao/Any.h"
#include "tao/CDR.h"
#include "tao/TimeBaseC.h"
#include "tao/PolicyC.h"
#include "tao/IOPC.h"
#include "tao/PollableC.h"
#include "tao/varout.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export
#if defined(_MSC_VER)
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined(TRANSPARENT)
// Some platforms define this macro for ioctl()
#undef TRANSPARENT
#endif

TAO_NAMESPACE  Messaging
{
  typedef CORBA::Short RebindMode;
  typedef CORBA::Short_out RebindMode_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RebindMode;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short TRANSPARENT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_REBIND;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_RECONNECT;

  typedef CORBA::Short SyncScope;
  typedef CORBA::Short_out SyncScope_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_SyncScope;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TRANSPORT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_SERVER;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TARGET;

  typedef CORBA::Short RoutingType;
  typedef CORBA::Short_out RoutingType_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingType;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_FORWARD;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_STORE_AND_FORWARD;

  typedef TimeBase::TimeT Timeout;
  typedef TimeBase::TimeT_out Timeout_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Timeout;

  typedef CORBA::Short Priority;
  typedef CORBA::Short_out Priority_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Priority;

  typedef CORBA::UShort Ordering;
  typedef CORBA::UShort_out Ordering_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Ordering;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_ANY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_TEMPORAL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_PRIORITY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_DEADLINE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REBIND_POLICY_TYPE;


  class RebindPolicy;
  typedef RebindPolicy *RebindPolicy_ptr;

  class TAO_Export RebindPolicy_var
  {
  public:
    RebindPolicy_var (void); // default constructor
    RebindPolicy_var (RebindPolicy_ptr);
    RebindPolicy_var (const RebindPolicy_var &); // copy constructor
    ~RebindPolicy_var (void); // destructor

    RebindPolicy_var &operator= (RebindPolicy_ptr);
    RebindPolicy_var &operator= (const RebindPolicy_var &);
    RebindPolicy_ptr operator-> (void) const;

    operator const RebindPolicy_ptr &() const;
    operator RebindPolicy_ptr &();
    // in, inout, out, _retn
    RebindPolicy_ptr in (void) const;
    RebindPolicy_ptr &inout (void);
    RebindPolicy_ptr &out (void);
    RebindPolicy_ptr _retn (void);
    RebindPolicy_ptr ptr (void) const;

  private:
    RebindPolicy_ptr ptr_;
  };

  class TAO_Export RebindPolicy_out
  {
  public:
    RebindPolicy_out (RebindPolicy_ptr &);
    RebindPolicy_out (RebindPolicy_var &);
    RebindPolicy_out (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_var &);
    RebindPolicy_out &operator= (RebindPolicy_ptr);
    operator RebindPolicy_ptr &();
    RebindPolicy_ptr &ptr (void);
    RebindPolicy_ptr operator-> (void);

  private:
    RebindPolicy_ptr &ptr_;
  };

  class TAO_Export RebindPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RebindPolicy_ptr _ptr_type;
    typedef RebindPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RebindPolicy_ptr _duplicate (RebindPolicy_ptr obj);
    static RebindPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RebindPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RebindPolicy_ptr _nil (void);

    virtual RebindMode rebind_mode (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RebindPolicy (void); // default constructor
    RebindPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RebindPolicy (void);
  private:
    RebindPolicy (const RebindPolicy &);
    void operator= (const RebindPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RebindPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SYNC_SCOPE_POLICY_TYPE;

  class SyncScopePolicy;
  typedef SyncScopePolicy *SyncScopePolicy_ptr;

  class TAO_Export SyncScopePolicy_var
  {
  public:
    SyncScopePolicy_var (void); // default constructor
    SyncScopePolicy_var (SyncScopePolicy_ptr);
    SyncScopePolicy_var (const SyncScopePolicy_var &); // copy constructor
    ~SyncScopePolicy_var (void); // destructor

    SyncScopePolicy_var &operator= (SyncScopePolicy_ptr);
    SyncScopePolicy_var &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_ptr operator-> (void) const;

    operator const SyncScopePolicy_ptr &() const;
    operator SyncScopePolicy_ptr &();
    // in, inout, out, _retn
    SyncScopePolicy_ptr in (void) const;
    SyncScopePolicy_ptr &inout (void);
    SyncScopePolicy_ptr &out (void);
    SyncScopePolicy_ptr _retn (void);
    SyncScopePolicy_ptr ptr (void) const;

  private:
    SyncScopePolicy_ptr ptr_;
  };

  class TAO_Export SyncScopePolicy_out
  {
  public:
    SyncScopePolicy_out (SyncScopePolicy_ptr &);
    SyncScopePolicy_out (SyncScopePolicy_var &);
    SyncScopePolicy_out (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_out &operator= (SyncScopePolicy_ptr);
    operator SyncScopePolicy_ptr &();
    SyncScopePolicy_ptr &ptr (void);
    SyncScopePolicy_ptr operator-> (void);

  private:
    SyncScopePolicy_ptr &ptr_;
  };

  class TAO_Export SyncScopePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef SyncScopePolicy_ptr _ptr_type;
    typedef SyncScopePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static SyncScopePolicy_ptr _duplicate (SyncScopePolicy_ptr obj);
    static SyncScopePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static SyncScopePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static SyncScopePolicy_ptr _nil (void);

    virtual SyncScope synchronization (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    SyncScopePolicy (void); // default constructor
    SyncScopePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~SyncScopePolicy (void);
  private:
    SyncScopePolicy (const SyncScopePolicy &);
    void operator= (const SyncScopePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_SyncScopePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_PRIORITY_POLICY_TYPE;

  struct TAO_Export PriorityRange
  {
    Priority min;
    Priority max;
  };

  class TAO_Export PriorityRange_var
  {
  public:
    PriorityRange_var (void); // default constructor
    PriorityRange_var (PriorityRange *);
    PriorityRange_var (const PriorityRange_var &); // copy constructor
    ~PriorityRange_var (void); // destructor

    PriorityRange_var &operator= (PriorityRange *);
    PriorityRange_var &operator= (const PriorityRange_var &);
    PriorityRange *operator-> (void);
    const PriorityRange *operator-> (void) const;

    operator const PriorityRange &() const;
    operator PriorityRange &();
    operator PriorityRange &() const;
    // in, inout, out, _retn
    const PriorityRange &in (void) const;
    PriorityRange &inout (void);
    PriorityRange &out (void);
    PriorityRange _retn (void);
    PriorityRange *ptr (void) const;

  private:
    PriorityRange *ptr_;
  };

  typedef PriorityRange &PriorityRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityRange;

  class RequestPriorityPolicy;
  typedef RequestPriorityPolicy *RequestPriorityPolicy_ptr;

  class TAO_Export RequestPriorityPolicy_var
  {
  public:
    RequestPriorityPolicy_var (void); // default constructor
    RequestPriorityPolicy_var (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var (const RequestPriorityPolicy_var &); // copy constructor
    ~RequestPriorityPolicy_var (void); // destructor

    RequestPriorityPolicy_var &operator= (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_ptr operator-> (void) const;

    operator const RequestPriorityPolicy_ptr &() const;
    operator RequestPriorityPolicy_ptr &();
    // in, inout, out, _retn
    RequestPriorityPolicy_ptr in (void) const;
    RequestPriorityPolicy_ptr &inout (void);
    RequestPriorityPolicy_ptr &out (void);
    RequestPriorityPolicy_ptr _retn (void);
    RequestPriorityPolicy_ptr ptr (void) const;

  private:
    RequestPriorityPolicy_ptr ptr_;
  };

  class TAO_Export RequestPriorityPolicy_out
  {
  public:
    RequestPriorityPolicy_out (RequestPriorityPolicy_ptr &);
    RequestPriorityPolicy_out (RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out &operator= (RequestPriorityPolicy_ptr);
    operator RequestPriorityPolicy_ptr &();
    RequestPriorityPolicy_ptr &ptr (void);
    RequestPriorityPolicy_ptr operator-> (void);

  private:
    RequestPriorityPolicy_ptr &ptr_;
  };

  class TAO_Export RequestPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestPriorityPolicy_ptr _ptr_type;
    typedef RequestPriorityPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestPriorityPolicy_ptr _duplicate (RequestPriorityPolicy_ptr obj);
    static RequestPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RequestPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RequestPriorityPolicy_ptr _nil (void);

    virtual PriorityRange priority_range (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestPriorityPolicy (void); // default constructor
    RequestPriorityPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestPriorityPolicy (void);
  private:
    RequestPriorityPolicy (const RequestPriorityPolicy &);
    void operator= (const RequestPriorityPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestPriorityPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_PRIORITY_POLICY_TYPE;

  class ReplyPriorityPolicy;
  typedef ReplyPriorityPolicy *ReplyPriorityPolicy_ptr;

  class TAO_Export ReplyPriorityPolicy_var
  {
  public:
    ReplyPriorityPolicy_var (void); // default constructor
    ReplyPriorityPolicy_var (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var (const ReplyPriorityPolicy_var &); // copy constructor
    ~ReplyPriorityPolicy_var (void); // destructor

    ReplyPriorityPolicy_var &operator= (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_ptr operator-> (void) const;

    operator const ReplyPriorityPolicy_ptr &() const;
    operator ReplyPriorityPolicy_ptr &();
    // in, inout, out, _retn
    ReplyPriorityPolicy_ptr in (void) const;
    ReplyPriorityPolicy_ptr &inout (void);
    ReplyPriorityPolicy_ptr &out (void);
    ReplyPriorityPolicy_ptr _retn (void);
    ReplyPriorityPolicy_ptr ptr (void) const;

  private:
    ReplyPriorityPolicy_ptr ptr_;
  };

  class TAO_Export ReplyPriorityPolicy_out
  {
  public:
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_ptr &);
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out &operator= (ReplyPriorityPolicy_ptr);
    operator ReplyPriorityPolicy_ptr &();
    ReplyPriorityPolicy_ptr &ptr (void);
    ReplyPriorityPolicy_ptr operator-> (void);

  private:
    ReplyPriorityPolicy_ptr &ptr_;
  };

  class TAO_Export ReplyPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyPriorityPolicy_ptr _ptr_type;
    typedef ReplyPriorityPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyPriorityPolicy_ptr _duplicate (ReplyPriorityPolicy_ptr obj);
    static ReplyPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyPriorityPolicy_ptr _nil (void);

    virtual PriorityRange priority_range (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyPriorityPolicy (void); // default constructor
    ReplyPriorityPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyPriorityPolicy (void);
  private:
    ReplyPriorityPolicy (const ReplyPriorityPolicy &);
    void operator= (const ReplyPriorityPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyPriorityPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_START_TIME_POLICY_TYPE;

  class RequestStartTimePolicy;
  typedef RequestStartTimePolicy *RequestStartTimePolicy_ptr;

  class TAO_Export RequestStartTimePolicy_var
  {
  public:
    RequestStartTimePolicy_var (void); // default constructor
    RequestStartTimePolicy_var (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var (const RequestStartTimePolicy_var &); // copy constructor
    ~RequestStartTimePolicy_var (void); // destructor

    RequestStartTimePolicy_var &operator= (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_ptr operator-> (void) const;

    operator const RequestStartTimePolicy_ptr &() const;
    operator RequestStartTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestStartTimePolicy_ptr in (void) const;
    RequestStartTimePolicy_ptr &inout (void);
    RequestStartTimePolicy_ptr &out (void);
    RequestStartTimePolicy_ptr _retn (void);
    RequestStartTimePolicy_ptr ptr (void) const;

  private:
    RequestStartTimePolicy_ptr ptr_;
  };

  class TAO_Export RequestStartTimePolicy_out
  {
  public:
    RequestStartTimePolicy_out (RequestStartTimePolicy_ptr &);
    RequestStartTimePolicy_out (RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out &operator= (RequestStartTimePolicy_ptr);
    operator RequestStartTimePolicy_ptr &();
    RequestStartTimePolicy_ptr &ptr (void);
    RequestStartTimePolicy_ptr operator-> (void);

  private:
    RequestStartTimePolicy_ptr &ptr_;
  };

  class TAO_Export RequestStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestStartTimePolicy_ptr _ptr_type;
    typedef RequestStartTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestStartTimePolicy_ptr _duplicate (RequestStartTimePolicy_ptr obj);
    static RequestStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RequestStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RequestStartTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT start_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestStartTimePolicy (void); // default constructor
    RequestStartTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestStartTimePolicy (void);
  private:
    RequestStartTimePolicy (const RequestStartTimePolicy &);
    void operator= (const RequestStartTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestStartTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_END_TIME_POLICY_TYPE;

  class RequestEndTimePolicy;
  typedef RequestEndTimePolicy *RequestEndTimePolicy_ptr;

  class TAO_Export RequestEndTimePolicy_var
  {
  public:
    RequestEndTimePolicy_var (void); // default constructor
    RequestEndTimePolicy_var (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var (const RequestEndTimePolicy_var &); // copy constructor
    ~RequestEndTimePolicy_var (void); // destructor

    RequestEndTimePolicy_var &operator= (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_ptr operator-> (void) const;

    operator const RequestEndTimePolicy_ptr &() const;
    operator RequestEndTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestEndTimePolicy_ptr in (void) const;
    RequestEndTimePolicy_ptr &inout (void);
    RequestEndTimePolicy_ptr &out (void);
    RequestEndTimePolicy_ptr _retn (void);
    RequestEndTimePolicy_ptr ptr (void) const;

  private:
    RequestEndTimePolicy_ptr ptr_;
  };

  class TAO_Export RequestEndTimePolicy_out
  {
  public:
    RequestEndTimePolicy_out (RequestEndTimePolicy_ptr &);
    RequestEndTimePolicy_out (RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out &operator= (RequestEndTimePolicy_ptr);
    operator RequestEndTimePolicy_ptr &();
    RequestEndTimePolicy_ptr &ptr (void);
    RequestEndTimePolicy_ptr operator-> (void);

  private:
    RequestEndTimePolicy_ptr &ptr_;
  };

  class TAO_Export RequestEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestEndTimePolicy_ptr _ptr_type;
    typedef RequestEndTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestEndTimePolicy_ptr _duplicate (RequestEndTimePolicy_ptr obj);
    static RequestEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RequestEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RequestEndTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT end_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestEndTimePolicy (void); // default constructor
    RequestEndTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RequestEndTimePolicy (void);
  private:
    RequestEndTimePolicy (const RequestEndTimePolicy &);
    void operator= (const RequestEndTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestEndTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_START_TIME_POLICY_TYPE;

  class ReplyStartTimePolicy;
  typedef ReplyStartTimePolicy *ReplyStartTimePolicy_ptr;

  class TAO_Export ReplyStartTimePolicy_var
  {
  public:
    ReplyStartTimePolicy_var (void); // default constructor
    ReplyStartTimePolicy_var (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var (const ReplyStartTimePolicy_var &); // copy constructor
    ~ReplyStartTimePolicy_var (void); // destructor

    ReplyStartTimePolicy_var &operator= (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_ptr operator-> (void) const;

    operator const ReplyStartTimePolicy_ptr &() const;
    operator ReplyStartTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyStartTimePolicy_ptr in (void) const;
    ReplyStartTimePolicy_ptr &inout (void);
    ReplyStartTimePolicy_ptr &out (void);
    ReplyStartTimePolicy_ptr _retn (void);
    ReplyStartTimePolicy_ptr ptr (void) const;

  private:
    ReplyStartTimePolicy_ptr ptr_;
  };

  class TAO_Export ReplyStartTimePolicy_out
  {
  public:
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_ptr &);
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out &operator= (ReplyStartTimePolicy_ptr);
    operator ReplyStartTimePolicy_ptr &();
    ReplyStartTimePolicy_ptr &ptr (void);
    ReplyStartTimePolicy_ptr operator-> (void);

  private:
    ReplyStartTimePolicy_ptr &ptr_;
  };

  class TAO_Export ReplyStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyStartTimePolicy_ptr _ptr_type;
    typedef ReplyStartTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyStartTimePolicy_ptr _duplicate (ReplyStartTimePolicy_ptr obj);
    static ReplyStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyStartTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT start_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyStartTimePolicy (void); // default constructor
    ReplyStartTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyStartTimePolicy (void);
  private:
    ReplyStartTimePolicy (const ReplyStartTimePolicy &);
    void operator= (const ReplyStartTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyStartTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_END_TIME_POLICY_TYPE;

  class ReplyEndTimePolicy;
  typedef ReplyEndTimePolicy *ReplyEndTimePolicy_ptr;

  class TAO_Export ReplyEndTimePolicy_var
  {
  public:
    ReplyEndTimePolicy_var (void); // default constructor
    ReplyEndTimePolicy_var (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var (const ReplyEndTimePolicy_var &); // copy constructor
    ~ReplyEndTimePolicy_var (void); // destructor

    ReplyEndTimePolicy_var &operator= (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_ptr operator-> (void) const;

    operator const ReplyEndTimePolicy_ptr &() const;
    operator ReplyEndTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyEndTimePolicy_ptr in (void) const;
    ReplyEndTimePolicy_ptr &inout (void);
    ReplyEndTimePolicy_ptr &out (void);
    ReplyEndTimePolicy_ptr _retn (void);
    ReplyEndTimePolicy_ptr ptr (void) const;

  private:
    ReplyEndTimePolicy_ptr ptr_;
  };

  class TAO_Export ReplyEndTimePolicy_out
  {
  public:
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_ptr &);
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out &operator= (ReplyEndTimePolicy_ptr);
    operator ReplyEndTimePolicy_ptr &();
    ReplyEndTimePolicy_ptr &ptr (void);
    ReplyEndTimePolicy_ptr operator-> (void);

  private:
    ReplyEndTimePolicy_ptr &ptr_;
  };

  class TAO_Export ReplyEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyEndTimePolicy_ptr _ptr_type;
    typedef ReplyEndTimePolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyEndTimePolicy_ptr _duplicate (ReplyEndTimePolicy_ptr obj);
    static ReplyEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyEndTimePolicy_ptr _nil (void);

    virtual TimeBase::UtcT end_time (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyEndTimePolicy (void); // default constructor
    ReplyEndTimePolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyEndTimePolicy (void);
  private:
    ReplyEndTimePolicy (const ReplyEndTimePolicy &);
    void operator= (const ReplyEndTimePolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyEndTimePolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_REQ_TIMEOUT_POLICY_TYPE;

  class RelativeRequestTimeoutPolicy;
  typedef RelativeRequestTimeoutPolicy *RelativeRequestTimeoutPolicy_ptr;

  class TAO_Export RelativeRequestTimeoutPolicy_var
  {
  public:
    RelativeRequestTimeoutPolicy_var (void); // default constructor
    RelativeRequestTimeoutPolicy_var (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var (const RelativeRequestTimeoutPolicy_var &); // copy constructor
    ~RelativeRequestTimeoutPolicy_var (void); // destructor

    RelativeRequestTimeoutPolicy_var &operator= (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRequestTimeoutPolicy_ptr &() const;
    operator RelativeRequestTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRequestTimeoutPolicy_ptr in (void) const;
    RelativeRequestTimeoutPolicy_ptr &inout (void);
    RelativeRequestTimeoutPolicy_ptr &out (void);
    RelativeRequestTimeoutPolicy_ptr _retn (void);
    RelativeRequestTimeoutPolicy_ptr ptr (void) const;

  private:
    RelativeRequestTimeoutPolicy_ptr ptr_;
  };

  class TAO_Export RelativeRequestTimeoutPolicy_out
  {
  public:
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_ptr &);
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out &operator= (RelativeRequestTimeoutPolicy_ptr);
    operator RelativeRequestTimeoutPolicy_ptr &();
    RelativeRequestTimeoutPolicy_ptr &ptr (void);
    RelativeRequestTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRequestTimeoutPolicy_ptr &ptr_;
  };

  class TAO_Export RelativeRequestTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RelativeRequestTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRequestTimeoutPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RelativeRequestTimeoutPolicy_ptr _duplicate (RelativeRequestTimeoutPolicy_ptr obj);
    static RelativeRequestTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RelativeRequestTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RelativeRequestTimeoutPolicy_ptr _nil (void);

    virtual TimeBase::TimeT relative_expiry (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RelativeRequestTimeoutPolicy (void); // default constructor
    RelativeRequestTimeoutPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RelativeRequestTimeoutPolicy (void);
  private:
    RelativeRequestTimeoutPolicy (const RelativeRequestTimeoutPolicy &);
    void operator= (const RelativeRequestTimeoutPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RelativeRequestTimeoutPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_RT_TIMEOUT_POLICY_TYPE;

  class RelativeRoundtripTimeoutPolicy;
  typedef RelativeRoundtripTimeoutPolicy *RelativeRoundtripTimeoutPolicy_ptr;

  class TAO_Export RelativeRoundtripTimeoutPolicy_var
  {
  public:
    RelativeRoundtripTimeoutPolicy_var (void); // default constructor
    RelativeRoundtripTimeoutPolicy_var (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var (const RelativeRoundtripTimeoutPolicy_var &); // copy constructor
    ~RelativeRoundtripTimeoutPolicy_var (void); // destructor

    RelativeRoundtripTimeoutPolicy_var &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRoundtripTimeoutPolicy_ptr &() const;
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRoundtripTimeoutPolicy_ptr in (void) const;
    RelativeRoundtripTimeoutPolicy_ptr &inout (void);
    RelativeRoundtripTimeoutPolicy_ptr &out (void);
    RelativeRoundtripTimeoutPolicy_ptr _retn (void);
    RelativeRoundtripTimeoutPolicy_ptr ptr (void) const;

  private:
    RelativeRoundtripTimeoutPolicy_ptr ptr_;
  };

  class TAO_Export RelativeRoundtripTimeoutPolicy_out
  {
  public:
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_ptr &);
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    RelativeRoundtripTimeoutPolicy_ptr &ptr (void);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRoundtripTimeoutPolicy_ptr &ptr_;
  };

  class TAO_Export RelativeRoundtripTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RelativeRoundtripTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRoundtripTimeoutPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RelativeRoundtripTimeoutPolicy_ptr _duplicate (RelativeRoundtripTimeoutPolicy_ptr obj);
    static RelativeRoundtripTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RelativeRoundtripTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RelativeRoundtripTimeoutPolicy_ptr _nil (void);

    virtual TimeBase::TimeT relative_expiry (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RelativeRoundtripTimeoutPolicy (void); // default constructor
    RelativeRoundtripTimeoutPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RelativeRoundtripTimeoutPolicy (void);
  private:
    RelativeRoundtripTimeoutPolicy (const RelativeRoundtripTimeoutPolicy &);
    void operator= (const RelativeRoundtripTimeoutPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RelativeRoundtripTimeoutPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ROUTING_POLICY_TYPE;

  struct TAO_Export RoutingTypeRange
  {
    RoutingType min;
    RoutingType max;
  };

  class TAO_Export RoutingTypeRange_var
  {
  public:
    RoutingTypeRange_var (void); // default constructor
    RoutingTypeRange_var (RoutingTypeRange *);
    RoutingTypeRange_var (const RoutingTypeRange_var &); // copy constructor
    ~RoutingTypeRange_var (void); // destructor

    RoutingTypeRange_var &operator= (RoutingTypeRange *);
    RoutingTypeRange_var &operator= (const RoutingTypeRange_var &);
    RoutingTypeRange *operator-> (void);
    const RoutingTypeRange *operator-> (void) const;

    operator const RoutingTypeRange &() const;
    operator RoutingTypeRange &();
    operator RoutingTypeRange &() const;
    // in, inout, out, _retn
    const RoutingTypeRange &in (void) const;
    RoutingTypeRange &inout (void);
    RoutingTypeRange &out (void);
    RoutingTypeRange _retn (void);
    RoutingTypeRange *ptr (void) const;

  private:
    RoutingTypeRange *ptr_;
  };

  typedef RoutingTypeRange &RoutingTypeRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingTypeRange;

  class RoutingPolicy;
  typedef RoutingPolicy *RoutingPolicy_ptr;

  class TAO_Export RoutingPolicy_var
  {
  public:
    RoutingPolicy_var (void); // default constructor
    RoutingPolicy_var (RoutingPolicy_ptr);
    RoutingPolicy_var (const RoutingPolicy_var &); // copy constructor
    ~RoutingPolicy_var (void); // destructor

    RoutingPolicy_var &operator= (RoutingPolicy_ptr);
    RoutingPolicy_var &operator= (const RoutingPolicy_var &);
    RoutingPolicy_ptr operator-> (void) const;

    operator const RoutingPolicy_ptr &() const;
    operator RoutingPolicy_ptr &();
    // in, inout, out, _retn
    RoutingPolicy_ptr in (void) const;
    RoutingPolicy_ptr &inout (void);
    RoutingPolicy_ptr &out (void);
    RoutingPolicy_ptr _retn (void);
    RoutingPolicy_ptr ptr (void) const;

  private:
    RoutingPolicy_ptr ptr_;
  };

  class TAO_Export RoutingPolicy_out
  {
  public:
    RoutingPolicy_out (RoutingPolicy_ptr &);
    RoutingPolicy_out (RoutingPolicy_var &);
    RoutingPolicy_out (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_var &);
    RoutingPolicy_out &operator= (RoutingPolicy_ptr);
    operator RoutingPolicy_ptr &();
    RoutingPolicy_ptr &ptr (void);
    RoutingPolicy_ptr operator-> (void);

  private:
    RoutingPolicy_ptr &ptr_;
  };

  class TAO_Export RoutingPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RoutingPolicy_ptr _ptr_type;
    typedef RoutingPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RoutingPolicy_ptr _duplicate (RoutingPolicy_ptr obj);
    static RoutingPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RoutingPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static RoutingPolicy_ptr _nil (void);

    virtual RoutingTypeRange routing_range (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    RoutingPolicy (void); // default constructor
    RoutingPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~RoutingPolicy (void);
  private:
    RoutingPolicy (const RoutingPolicy &);
    void operator= (const RoutingPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong MAX_HOPS_POLICY_TYPE;

  class MaxHopsPolicy;
  typedef MaxHopsPolicy *MaxHopsPolicy_ptr;

  class TAO_Export MaxHopsPolicy_var
  {
  public:
    MaxHopsPolicy_var (void); // default constructor
    MaxHopsPolicy_var (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var (const MaxHopsPolicy_var &); // copy constructor
    ~MaxHopsPolicy_var (void); // destructor

    MaxHopsPolicy_var &operator= (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_ptr operator-> (void) const;

    operator const MaxHopsPolicy_ptr &() const;
    operator MaxHopsPolicy_ptr &();
    // in, inout, out, _retn
    MaxHopsPolicy_ptr in (void) const;
    MaxHopsPolicy_ptr &inout (void);
    MaxHopsPolicy_ptr &out (void);
    MaxHopsPolicy_ptr _retn (void);
    MaxHopsPolicy_ptr ptr (void) const;

  private:
    MaxHopsPolicy_ptr ptr_;
  };

  class TAO_Export MaxHopsPolicy_out
  {
  public:
    MaxHopsPolicy_out (MaxHopsPolicy_ptr &);
    MaxHopsPolicy_out (MaxHopsPolicy_var &);
    MaxHopsPolicy_out (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_out &operator= (MaxHopsPolicy_ptr);
    operator MaxHopsPolicy_ptr &();
    MaxHopsPolicy_ptr &ptr (void);
    MaxHopsPolicy_ptr operator-> (void);

  private:
    MaxHopsPolicy_ptr &ptr_;
  };

  class TAO_Export MaxHopsPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef MaxHopsPolicy_ptr _ptr_type;
    typedef MaxHopsPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static MaxHopsPolicy_ptr _duplicate (MaxHopsPolicy_ptr obj);
    static MaxHopsPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static MaxHopsPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static MaxHopsPolicy_ptr _nil (void);

    virtual CORBA::UShort max_hops (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    MaxHopsPolicy (void); // default constructor
    MaxHopsPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~MaxHopsPolicy (void);
  private:
    MaxHopsPolicy (const MaxHopsPolicy &);
    void operator= (const MaxHopsPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MaxHopsPolicy;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong QUEUE_ORDER_POLICY_TYPE;

  class QueueOrderPolicy;
  typedef QueueOrderPolicy *QueueOrderPolicy_ptr;

  class TAO_Export QueueOrderPolicy_var
  {
  public:
    QueueOrderPolicy_var (void); // default constructor
    QueueOrderPolicy_var (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var (const QueueOrderPolicy_var &); // copy constructor
    ~QueueOrderPolicy_var (void); // destructor

    QueueOrderPolicy_var &operator= (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_ptr operator-> (void) const;

    operator const QueueOrderPolicy_ptr &() const;
    operator QueueOrderPolicy_ptr &();
    // in, inout, out, _retn
    QueueOrderPolicy_ptr in (void) const;
    QueueOrderPolicy_ptr &inout (void);
    QueueOrderPolicy_ptr &out (void);
    QueueOrderPolicy_ptr _retn (void);
    QueueOrderPolicy_ptr ptr (void) const;

  private:
    QueueOrderPolicy_ptr ptr_;
  };

  class TAO_Export QueueOrderPolicy_out
  {
  public:
    QueueOrderPolicy_out (QueueOrderPolicy_ptr &);
    QueueOrderPolicy_out (QueueOrderPolicy_var &);
    QueueOrderPolicy_out (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_out &operator= (QueueOrderPolicy_ptr);
    operator QueueOrderPolicy_ptr &();
    QueueOrderPolicy_ptr &ptr (void);
    QueueOrderPolicy_ptr operator-> (void);

  private:
    QueueOrderPolicy_ptr &ptr_;
  };

  class TAO_Export QueueOrderPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef QueueOrderPolicy_ptr _ptr_type;
    typedef QueueOrderPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static QueueOrderPolicy_ptr _duplicate (QueueOrderPolicy_ptr obj);
    static QueueOrderPolicy_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static QueueOrderPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static QueueOrderPolicy_ptr _nil (void);

    virtual Ordering allowed_orders (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      ) = 0;
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    QueueOrderPolicy (void); // default constructor
    QueueOrderPolicy (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~QueueOrderPolicy (void);
  private:
    QueueOrderPolicy (const QueueOrderPolicy &);
    void operator= (const QueueOrderPolicy &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_QueueOrderPolicy;

  struct TAO_Export PolicyValue
  {
    CORBA::PolicyType ptype;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public TAO_Unbounded_Sequence<CORBA::Octet>
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void); // dtor

#if defined(TAO_NO_COPY_OCTET_SEQUENCES)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE */

    };
    typedef _tao_seq_Octet *_tao_seq_Octet_ptr;
    static CORBA::TypeCode_ptr _tc__tao_seq_Octet;

    _tao_seq_Octet pvalue;
  };

  class TAO_Export PolicyValue_var
  {
  public:
    PolicyValue_var (void); // default constructor
    PolicyValue_var (PolicyValue *);
    PolicyValue_var (const PolicyValue_var &); // copy constructor
    ~PolicyValue_var (void); // destructor

    PolicyValue_var &operator= (PolicyValue *);
    PolicyValue_var &operator= (const PolicyValue_var &);
    PolicyValue *operator-> (void);
    const PolicyValue *operator-> (void) const;

    operator const PolicyValue &() const;
    operator PolicyValue &();
    operator PolicyValue &() const;
    // in, inout, out, _retn
    const PolicyValue &in (void) const;
    PolicyValue &inout (void);
    PolicyValue *&out (void);
    PolicyValue *_retn (void);
    PolicyValue *ptr (void) const;

  private:
    PolicyValue *ptr_;
  };

  class TAO_Export PolicyValue_out
  {
  public:
    PolicyValue_out (PolicyValue *&);
    PolicyValue_out (PolicyValue_var &);
    PolicyValue_out (const PolicyValue_out &);
    PolicyValue_out &operator= (const PolicyValue_out &);
    PolicyValue_out &operator= (PolicyValue *);
    operator PolicyValue *&();
    PolicyValue *&ptr (void);
    PolicyValue *operator-> (void);

  private:
    PolicyValue *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValue_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValue;

  // *************************************************************
  // PolicyValueSeq
  // *************************************************************

  class TAO_Export PolicyValueSeq : public TAO_Unbounded_Sequence<PolicyValue>
  {
  public:
    PolicyValueSeq (void); // default ctor
    PolicyValueSeq (CORBA::ULong max); // uses max size
    PolicyValueSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      PolicyValue *buffer,
      CORBA::Boolean release=0
    );
    PolicyValueSeq (const PolicyValueSeq &); // copy ctor
    ~PolicyValueSeq (void); // dtor
  };
  typedef PolicyValueSeq *PolicyValueSeq_ptr;

  // *************************************************************
  // class Messaging::PolicyValueSeq_var
  // *************************************************************

  class TAO_Export PolicyValueSeq_var
  {
  public:
    PolicyValueSeq_var (void); // default constructor
    PolicyValueSeq_var (PolicyValueSeq *);
    PolicyValueSeq_var (const PolicyValueSeq_var &); // copy constructor
    ~PolicyValueSeq_var (void); // destructor

    PolicyValueSeq_var &operator= (PolicyValueSeq *);
    PolicyValueSeq_var &operator= (const PolicyValueSeq_var &);
    PolicyValueSeq *operator-> (void);
    const PolicyValueSeq *operator-> (void) const;

    operator const PolicyValueSeq &() const;
    operator PolicyValueSeq &();
    operator PolicyValueSeq &() const;
    PolicyValue &operator[] (CORBA::ULong slot);
    // in, inout, out, _retn
    const PolicyValueSeq &in (void) const;
    PolicyValueSeq &inout (void);
    PolicyValueSeq *&out (void);
    PolicyValueSeq *_retn (void);
    PolicyValueSeq *ptr (void) const;

  private:
    PolicyValueSeq *ptr_;
  };

  class TAO_Export PolicyValueSeq_out
  {
  public:
    PolicyValueSeq_out (PolicyValueSeq *&);
    PolicyValueSeq_out (PolicyValueSeq_var &);
    PolicyValueSeq_out (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (PolicyValueSeq *);
    operator PolicyValueSeq *&();
    PolicyValueSeq *&ptr (void);
    PolicyValueSeq *operator-> (void);
    PolicyValue &operator[] (CORBA::ULong slot);

  private:
    PolicyValueSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValueSeq_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValueSeq;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_POLICIES;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong INVOCATION_POLICIES;

#if defined (TAO_HAS_AMI_CALLBACK) || defined (TAO_HAS_AMI_POLLER)

  // valuetype class
  class ExceptionHolder;
  typedef ExceptionHolder *ExceptionHolder_ptr;
  
#if !defined (_MESSAGING_EXCEPTIONHOLDER___VAR_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___VAR_CH_

  class  ExceptionHolder_var
  {
  public:
    ExceptionHolder_var (void); // default constructor
    ExceptionHolder_var (ExceptionHolder*);
    ExceptionHolder_var (const ExceptionHolder*); // (TAO extension)
    ExceptionHolder_var (const ExceptionHolder_var &); // copy constructor
    ~ExceptionHolder_var (void); // destructor
    
    ExceptionHolder_var &operator= (ExceptionHolder*);
    ExceptionHolder_var &operator= (const ExceptionHolder_var &);
    ExceptionHolder* operator-> (void) const;
    
    operator const ExceptionHolder* () const;
    operator ExceptionHolder* ();
    // in, inout, out, _retn 
    ExceptionHolder* in (void) const;
    ExceptionHolder* &inout (void);
    ExceptionHolder* &out (void);
    ExceptionHolder* _retn (void);
    ExceptionHolder* ptr (void) const;

  private:
    ExceptionHolder* ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER___OUT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___OUT_CH_

  class  ExceptionHolder_out
  {
  public:
    ExceptionHolder_out (ExceptionHolder* &);
    ExceptionHolder_out (ExceptionHolder_var &);
    ExceptionHolder_out (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_var &);
    ExceptionHolder_out &operator= (ExceptionHolder*);
    operator ExceptionHolder* &();
    ExceptionHolder* &ptr (void);
    ExceptionHolder* operator-> (void);
    
  private:
    ExceptionHolder* &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER___INIT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___INIT_CH_

  class  ExceptionHolder_init : public ACE_CORBA_1 (ValueFactoryBase)
  {
  public:
    virtual ~ExceptionHolder_init ();
    virtual const char* tao_repository_id ();

    // create () goes here
    
  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER_CH_)
#define _MESSAGING_EXCEPTIONHOLDER_CH_

  class  ExceptionHolder : public virtual ACE_CORBA_1 (ValueBase)
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ExceptionHolder* _ptr_type;
    typedef ExceptionHolder_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    static ExceptionHolder* _downcast (CORBA::ValueBase* );
    // The address of static _downcast is implicit used as type id

    // (TAO extensions or internals)
    static CORBA::Boolean _tao_unmarshal (TAO_InputCDR &, ExceptionHolder *&);
    virtual const char* _tao_obv_repository_id () const;
    static const char* _tao_obv_static_repository_id ();
  public:
    virtual void is_system_exception (CORBA::Boolean) = 0;    // set
    virtual CORBA::Boolean is_system_exception (void) const = 0;     // get method

    virtual void byte_order (CORBA::Boolean) = 0;    // set
    virtual CORBA::Boolean byte_order (void) const = 0;     // get method


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET_CH_

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************
    
    class  _tao_seq_Octet : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max, 
        CORBA::ULong length, 
        CORBA::Octet *buffer, 
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void); // dtor

#if defined(TAO_NO_COPY_OCTET_SEQUENCES)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE */

    };
    typedef _tao_seq_Octet *_tao_seq_Octet_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___VAR_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___VAR_CH_

// *************************************************************
    // class Messaging::ExceptionHolder::_tao_seq_Octet_var
    // *************************************************************

    class  _tao_seq_Octet_var
    {
    public:
      _tao_seq_Octet_var (void); // default constructor
      _tao_seq_Octet_var (_tao_seq_Octet *);
      _tao_seq_Octet_var (const _tao_seq_Octet_var &); // copy constructor
      ~_tao_seq_Octet_var (void); // destructor
      
      _tao_seq_Octet_var &operator= (_tao_seq_Octet *);
      _tao_seq_Octet_var &operator= (const _tao_seq_Octet_var &);
      _tao_seq_Octet *operator-> (void);
      const _tao_seq_Octet *operator-> (void) const;
      
      operator const _tao_seq_Octet &() const;
      operator _tao_seq_Octet &();
      operator _tao_seq_Octet &() const;
      CORBA::Octet &operator[] (CORBA::ULong index);
      // in, inout, out, _retn 
      const _tao_seq_Octet &in (void) const;
      _tao_seq_Octet &inout (void);
      _tao_seq_Octet *&out (void);
      _tao_seq_Octet *_retn (void);
      _tao_seq_Octet *ptr (void) const;

    private:
      _tao_seq_Octet *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___OUT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET___OUT_CH_

    class  _tao_seq_Octet_out
    {
    public:
      _tao_seq_Octet_out (_tao_seq_Octet *&);
      _tao_seq_Octet_out (_tao_seq_Octet_var &);
      _tao_seq_Octet_out (const _tao_seq_Octet_out &);
      _tao_seq_Octet_out &operator= (const _tao_seq_Octet_out &);
      _tao_seq_Octet_out &operator= (_tao_seq_Octet *);
      operator _tao_seq_Octet *&();
      _tao_seq_Octet *&ptr (void);
      _tao_seq_Octet *operator-> (void);
      CORBA::Octet &operator[] (CORBA::ULong index);
      
    private:
      _tao_seq_Octet *&ptr_;
      // assignment from T_var not allowed
      void operator= (const _tao_seq_Octet_var &);
    };


#endif /* end #if !defined */

    virtual void marshaled_exception (const _tao_seq_Octet &) = 0;    // set
    virtual const _tao_seq_Octet &marshaled_exception (void) const = 0;     // get method (read only)
    virtual _tao_seq_Octet &marshaled_exception (void) = 0;     // get method (read/write only)


  protected:
    ExceptionHolder (void) { };           // default constructor
    virtual ~ExceptionHolder (void) { };

    // TAO internals
    virtual void *_tao_obv_narrow (ptr_arith_t);
    virtual CORBA::Boolean _tao_marshal_v (TAO_OutputCDR &);
    virtual CORBA::Boolean _tao_unmarshal_v (TAO_InputCDR &);
    
  private:
    ExceptionHolder (const ExceptionHolder &);
    void operator= (const ExceptionHolder &);
    
  protected:
    virtual CORBA::Boolean _tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &) = 0;
    virtual CORBA::Boolean _tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &) = 0;
    
  };

#endif /* end #if !defined */

  class ReplyHandler;
  typedef ReplyHandler *ReplyHandler_ptr;

  class TAO_Export ReplyHandler_var
  {
  public:
    ReplyHandler_var (void); // default constructor
    ReplyHandler_var (ReplyHandler_ptr);
    ReplyHandler_var (const ReplyHandler_var &); // copy constructor
    ~ReplyHandler_var (void); // destructor

    ReplyHandler_var &operator= (ReplyHandler_ptr);
    ReplyHandler_var &operator= (const ReplyHandler_var &);
    ReplyHandler_ptr operator-> (void) const;

    operator const ReplyHandler_ptr &() const;
    operator ReplyHandler_ptr &();
    // in, inout, out, _retn
    ReplyHandler_ptr in (void) const;
    ReplyHandler_ptr &inout (void);
    ReplyHandler_ptr &out (void);
    ReplyHandler_ptr _retn (void);
    ReplyHandler_ptr ptr (void) const;

  private:
    ReplyHandler_ptr ptr_;
  };

  class TAO_Export ReplyHandler_out
  {
  public:
    ReplyHandler_out (ReplyHandler_ptr &);
    ReplyHandler_out (ReplyHandler_var &);
    ReplyHandler_out (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_var &);
    ReplyHandler_out &operator= (ReplyHandler_ptr);
    operator ReplyHandler_ptr &();
    ReplyHandler_ptr &ptr (void);
    ReplyHandler_ptr operator-> (void);

  private:
    ReplyHandler_ptr &ptr_;
  };

  class TAO_Export ReplyHandler : public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ReplyHandler_ptr _ptr_type;
    typedef ReplyHandler_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ReplyHandler_ptr _duplicate (ReplyHandler_ptr obj);
    static ReplyHandler_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyHandler_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static ReplyHandler_ptr _nil (void);

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    ReplyHandler (void); // default constructor
    ReplyHandler (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~ReplyHandler (void);
  private:
    ReplyHandler (const ReplyHandler &);
    void operator= (const ReplyHandler &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyHandler;

#endif /* TAO_HAS_AMI_CALLBACK || TAO_HAS_AMI_POLLER */

#if defined (TAO_HAS_AMI_POLLER)

  class Poller;
  typedef Poller *Poller_ptr;

  class TAO_Export Poller_var
  {
  public:
    Poller_var (void); // default constructor
    Poller_var (Poller_ptr);
    Poller_var (const Poller_var &); // copy constructor
    ~Poller_var (void); // destructor

    Poller_var &operator= (Poller_ptr);
    Poller_var &operator= (const Poller_var &);
    Poller_ptr operator-> (void) const;

    operator const Poller_ptr &() const;
    operator Poller_ptr &();
    // in, inout, out, _retn
    Poller_ptr in (void) const;
    Poller_ptr &inout (void);
    Poller_ptr &out (void);
    Poller_ptr _retn (void);
    Poller_ptr ptr (void) const;

  private:
    Poller_ptr ptr_;
  };

  class TAO_Export Poller_out
  {
  public:
    Poller_out (Poller_ptr &);
    Poller_out (Poller_var &);
    Poller_out (const Poller_out &);
    Poller_out &operator= (const Poller_out &);
    Poller_out &operator= (const Poller_var &);
    Poller_out &operator= (Poller_ptr);
    operator Poller_ptr &();
    Poller_ptr &ptr (void);
    Poller_ptr operator-> (void);

  private:
    Poller_ptr &ptr_;
  };

  class TAO_Export Poller: public virtual CORBA::Pollable
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef Poller_ptr _ptr_type;
    typedef Poller_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static Poller_ptr _duplicate (Poller_ptr obj);
    static Poller_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static Poller_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    static Poller_ptr _nil (void);

    virtual CORBA::Object_ptr operation_target (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual char * operation_name (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual ReplyHandler_ptr associated_handler (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual void associated_handler (
        ReplyHandler_ptr associated_handler,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean is_from_poller (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Object_ptr target (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual char * op_name (
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          CORBA::Environment::default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;
  protected:
    Poller (void); // default constructor
    Poller (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~Poller (void);
  private:
    Poller (const Poller &);
    void operator= (const Poller &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Poller;
#endif /* TAO_HAS_AMI_POLLER */

}
TAO_NAMESPACE_CLOSE // module Messaging


TAO_NAMESPACE  OBV_Messaging
{

#if !defined (_MESSAGING_EXCEPTIONHOLDER___OBV_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___OBV_CH_

  // OBV_ class
  class ExceptionHolder : public virtual Messaging::ExceptionHolder
  {
  public:
    virtual void is_system_exception (CORBA::Boolean);    // set
    virtual CORBA::Boolean is_system_exception (void) const;     // get method

    virtual void byte_order (CORBA::Boolean);    // set
    virtual CORBA::Boolean byte_order (void) const;     // get method

    virtual void marshaled_exception (const _tao_seq_Octet &);    // set
    virtual const _tao_seq_Octet &marshaled_exception (void) const;     // get method (read only)
    virtual _tao_seq_Octet &marshaled_exception (void);     // get method (read/write only)


  protected:
    virtual CORBA::Boolean _tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &);
    virtual CORBA::Boolean _tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &);
    CORBA::Boolean _tao_marshal_state (TAO_OutputCDR &);
    CORBA::Boolean _tao_unmarshal_state (TAO_InputCDR &);


  private:
        CORBA::Boolean _pd_is_system_exception;
    CORBA::Boolean _pd_byte_order;
#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _marshaled_exception_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

  // @@ Michael: Needed to add the "*"
   _tao_seq_Octet *_pd_marshaled_exception;
  };

#endif /* end #if !defined */

}
TAO_NAMESPACE_CLOSE



// Typedef for the Reply Handler Skeleton.
// This is handcrafted not generated by the IDL compiler.

class TAO_InputCDR;

// @@ Michael: Addition

enum TAO_AMI_Reply_Status
{
  TAO_AMI_REPLY_OK,
  // Reply is normal.

  TAO_AMI_REPLY_NOT_OK,
  // Reply is not normal and no exceptions

  TAO_AMI_REPLY_USER_EXCEPTION,
  // An user exception was raised.

  TAO_AMI_REPLY_SYSTEM_EXCEPTION
  // An system exception was raised.
};

#if defined (TAO_HAS_AMI_CALLBACK)
typedef void (*TAO_Reply_Handler_Skeleton)(
    TAO_InputCDR &,
    Messaging::ReplyHandler *,
    CORBA::ULong reply_status,
    CORBA::Environment &
    );
#endif /* TAO_HAS_AMI_CALLBACK */

void TAO_Export operator<<= (CORBA::Any &, Messaging::PriorityRange*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::PriorityRange *&);

void TAO_Export operator<<= (CORBA::Any &, const Messaging::RoutingTypeRange &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::RoutingTypeRange*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::RoutingTypeRange *&);

void TAO_Export operator<<= (CORBA::Any &, const Messaging::PolicyValue &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::PolicyValue*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::PolicyValue *&);
void TAO_Export operator<<= (CORBA::Any &, const Messaging::PolicyValueSeq &); // copying version
void TAO_Export operator<<= (CORBA::Any &, Messaging::PolicyValueSeq*); // noncopying version
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::PolicyValueSeq *&);

#if defined (TAO_HAS_AMI_CALLBACK)
// Any operators for interface Messaging::ReplyHandler
void TAO_Export operator<<= (CORBA::Any &, Messaging::ReplyHandler_ptr);
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::ReplyHandler *&);
CORBA::Boolean  operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder *); // 
CORBA::Boolean  operator>> (TAO_InputCDR &, Messaging::ExceptionHolder *&);
#endif /* TAO_HAS_AMI_CALLBACK */

#if defined (TAO_HAS_AMI_POLLER)
// Any operators for interface Messaging::Poller
void TAO_Export operator<<= (CORBA::Any &, Messaging::Poller_ptr);
CORBA::Boolean TAO_Export operator>>= (const CORBA::Any &, Messaging::Poller *&);
#endif /* TAO_HAS_AMI_POLLER */

#ifndef __ACE_INLINE__

CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PriorityRange &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PriorityRange &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::RoutingTypeRange &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::RoutingTypeRange &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PolicyValue &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PolicyValue &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PolicyValue::_tao_seq_Octet &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PolicyValue::_tao_seq_Octet &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::PolicyValueSeq &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::PolicyValueSeq &);

#if defined (TAO_HAS_AMI_CALLBACK)
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::ReplyHandler_ptr );
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::ReplyHandler_ptr &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::ExceptionHolder &);
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder::_tao_seq_Octet &); //
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::ExceptionHolder::_tao_seq_Octet &);
#endif /* TAO_HAS_AMI_CALLBACK */

#if defined (TAO_HAS_AMI_POLLER)
CORBA::Boolean TAO_Export operator<< (TAO_OutputCDR &, const Messaging::Poller_ptr );
CORBA::Boolean TAO_Export operator>> (TAO_InputCDR &, Messaging::Poller_ptr &);
#endif

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "MessagingC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER)
#pragma warning(default:4250)
#endif /* _MSC_VER */

#endif /* TAO_HAS_CORBA_MESSAGING */

#endif /* TAO_IDL_MESSAGINGC_H */
