// -*- C++ -*-
//
// $Id$


// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_MESSAGINGC_H_
#define _TAO_IDL_MESSAGINGC_H_

#include "ace/pre.h"
#include "orbconf.h"

#if (TAO_HAS_CORBA_MESSAGING == 1)

#include "corbafwd.h"

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)
#include "ValueBase.h"
#include "ValueFactory.h"
#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "TAO_Export.h"
#include "Any.h"
#include "CDR.h"
#include "Remote_Object_Proxy_Impl.h"
#include "TimeBaseC.h"
#include "IOPC.h"
#include "PolicyC.h"
#include "PollableC.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

#if defined(TRANSPARENT)
// Some platforms define this macro for ioctl()
#undef TRANSPARENT
#endif

TAO_NAMESPACE  Messaging
{
  typedef CORBA::Short RebindMode;
  typedef CORBA::Short_out RebindMode_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RebindMode;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short TRANSPARENT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_REBIND;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short NO_RECONNECT;

  typedef CORBA::Short SyncScope;
  typedef CORBA::Short_out SyncScope_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_SyncScope;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TRANSPORT;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_SERVER;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_WITH_TARGET;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_EAGER_BUFFERING;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short SYNC_DELAYED_BUFFERING;

  typedef CORBA::Short RoutingType;
  typedef CORBA::Short_out RoutingType_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingType;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_NONE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_FORWARD;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ROUTE_STORE_AND_FORWARD;

  typedef TimeBase::TimeT Timeout;
  typedef TimeBase::TimeT_out Timeout_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Timeout;

  typedef CORBA::Short Priority;
  typedef CORBA::Short_out Priority_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Priority;

  typedef CORBA::UShort Ordering;
  typedef CORBA::UShort_out Ordering_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Ordering;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_ANY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_TEMPORAL;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_PRIORITY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::UShort ORDER_DEADLINE;

#if (TAO_HAS_REBIND_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REBIND_POLICY_TYPE;


#if !defined (_MESSAGING_REBINDPOLICY___PTR_CH_)
#define _MESSAGING_REBINDPOLICY___PTR_CH_

  class RebindPolicy;
  typedef RebindPolicy *RebindPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REBINDPOLICY___VAR_CH_)
#define _MESSAGING_REBINDPOLICY___VAR_CH_

  class TAO_Export RebindPolicy_var : public TAO_Base_var
  {
  public:
    RebindPolicy_var (void); // default constructor
    RebindPolicy_var (RebindPolicy_ptr p) : ptr_ (p) {}
    RebindPolicy_var (const RebindPolicy_var &); // copy constructor
    ~RebindPolicy_var (void); // destructor

    RebindPolicy_var &operator= (RebindPolicy_ptr);
    RebindPolicy_var &operator= (const RebindPolicy_var &);
    RebindPolicy_ptr operator-> (void) const;

    operator const RebindPolicy_ptr &() const;
    operator RebindPolicy_ptr &();
    // in, inout, out, _retn
    RebindPolicy_ptr in (void) const;
    RebindPolicy_ptr &inout (void);
    RebindPolicy_ptr &out (void);
    RebindPolicy_ptr _retn (void);
    RebindPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RebindPolicy_ptr tao_duplicate (RebindPolicy_ptr);
    static void tao_release (RebindPolicy_ptr);
    static RebindPolicy_ptr tao_nil (void);
    static RebindPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RebindPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RebindPolicy_var (const TAO_Base_var &rhs);
    RebindPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REBINDPOLICY___OUT_CH_)
#define _MESSAGING_REBINDPOLICY___OUT_CH_

  class TAO_Export RebindPolicy_out
  {
  public:
    RebindPolicy_out (RebindPolicy_ptr &);
    RebindPolicy_out (RebindPolicy_var &);
    RebindPolicy_out (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_out &);
    RebindPolicy_out &operator= (const RebindPolicy_var &);
    RebindPolicy_out &operator= (RebindPolicy_ptr);
    operator RebindPolicy_ptr &();
    RebindPolicy_ptr &ptr (void);
    RebindPolicy_ptr operator-> (void);

  private:
    RebindPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REBINDPOLICY_CH_)
#define _MESSAGING_REBINDPOLICY_CH_

  class TAO_Export RebindPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RebindPolicy_ptr _ptr_type;
    typedef RebindPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RebindPolicy_ptr _duplicate (RebindPolicy_ptr obj);
    static RebindPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RebindPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RebindPolicy_ptr _nil (void)
      {
        return (RebindPolicy_ptr)0;
      }

    virtual Messaging::RebindMode rebind_mode (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RebindPolicy ();

    virtual ~RebindPolicy (void);
  private:
    RebindPolicy (const RebindPolicy &);
    void operator= (const RebindPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REBIND_POLICY == 1 */

#if (TAO_HAS_SYNC_SCOPE_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SYNC_SCOPE_POLICY_TYPE;


#if !defined (_MESSAGING_SYNCSCOPEPOLICY___PTR_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY___PTR_CH_

  class SyncScopePolicy;
  typedef SyncScopePolicy *SyncScopePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_SYNCSCOPEPOLICY___VAR_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY___VAR_CH_

  class TAO_Export SyncScopePolicy_var : public TAO_Base_var
  {
  public:
    SyncScopePolicy_var (void); // default constructor
    SyncScopePolicy_var (SyncScopePolicy_ptr p) : ptr_ (p) {}
    SyncScopePolicy_var (const SyncScopePolicy_var &); // copy constructor
    ~SyncScopePolicy_var (void); // destructor

    SyncScopePolicy_var &operator= (SyncScopePolicy_ptr);
    SyncScopePolicy_var &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_ptr operator-> (void) const;

    operator const SyncScopePolicy_ptr &() const;
    operator SyncScopePolicy_ptr &();
    // in, inout, out, _retn
    SyncScopePolicy_ptr in (void) const;
    SyncScopePolicy_ptr &inout (void);
    SyncScopePolicy_ptr &out (void);
    SyncScopePolicy_ptr _retn (void);
    SyncScopePolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static SyncScopePolicy_ptr tao_duplicate (SyncScopePolicy_ptr);
    static void tao_release (SyncScopePolicy_ptr);
    static SyncScopePolicy_ptr tao_nil (void);
    static SyncScopePolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    SyncScopePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    SyncScopePolicy_var (const TAO_Base_var &rhs);
    SyncScopePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_SYNCSCOPEPOLICY___OUT_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY___OUT_CH_

  class TAO_Export SyncScopePolicy_out
  {
  public:
    SyncScopePolicy_out (SyncScopePolicy_ptr &);
    SyncScopePolicy_out (SyncScopePolicy_var &);
    SyncScopePolicy_out (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_out &);
    SyncScopePolicy_out &operator= (const SyncScopePolicy_var &);
    SyncScopePolicy_out &operator= (SyncScopePolicy_ptr);
    operator SyncScopePolicy_ptr &();
    SyncScopePolicy_ptr &ptr (void);
    SyncScopePolicy_ptr operator-> (void);

  private:
    SyncScopePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_SYNCSCOPEPOLICY_CH_)
#define _MESSAGING_SYNCSCOPEPOLICY_CH_

  class TAO_Export SyncScopePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef SyncScopePolicy_ptr _ptr_type;
    typedef SyncScopePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static SyncScopePolicy_ptr _duplicate (SyncScopePolicy_ptr obj);
    static SyncScopePolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static SyncScopePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static SyncScopePolicy_ptr _nil (void)
      {
        return (SyncScopePolicy_ptr)0;
      }

    virtual Messaging::SyncScope synchronization (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    SyncScopePolicy ();

    virtual ~SyncScopePolicy (void);
  private:
    SyncScopePolicy (const SyncScopePolicy &);
    void operator= (const SyncScopePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_SYNC_SCOPE_POLICY == 1 */

#if (TAO_HAS_PRIORITY_POLICIES == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_PRIORITY_POLICY_TYPE;

  struct PriorityRange;
  class PriorityRange_var;

  struct TAO_Export PriorityRange
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PriorityRange_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (Messaging, Priority) min;
    ACE_NESTED_CLASS (Messaging, Priority) max;
  };

  class TAO_Export PriorityRange_var
  {
  public:
    PriorityRange_var (void); // default constructor
    PriorityRange_var (PriorityRange *);
    PriorityRange_var (const PriorityRange_var &); // copy constructor
    PriorityRange_var (const PriorityRange &); // fixed-size types only
    ~PriorityRange_var (void); // destructor

    PriorityRange_var &operator= (PriorityRange *);
    PriorityRange_var &operator= (const PriorityRange_var &);
    PriorityRange_var &operator= (const PriorityRange &); // fixed-size types only
    PriorityRange *operator-> (void);
    const PriorityRange *operator-> (void) const;

    operator const PriorityRange &() const;
    operator PriorityRange &();
    operator PriorityRange &() const;

    // in, inout, out, _retn
    const PriorityRange &in (void) const;
    PriorityRange &inout (void);
    PriorityRange &out (void);
    PriorityRange _retn (void);
    PriorityRange *ptr (void) const;

  private:
    PriorityRange *ptr_;
  };

  typedef PriorityRange &PriorityRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PriorityRange;


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY___PTR_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY___PTR_CH_

  class RequestPriorityPolicy;
  typedef RequestPriorityPolicy *RequestPriorityPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY___VAR_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY___VAR_CH_

  class TAO_Export RequestPriorityPolicy_var : public TAO_Base_var
  {
  public:
    RequestPriorityPolicy_var (void); // default constructor
    RequestPriorityPolicy_var (RequestPriorityPolicy_ptr p) : ptr_ (p) {}
    RequestPriorityPolicy_var (const RequestPriorityPolicy_var &); // copy constructor
    ~RequestPriorityPolicy_var (void); // destructor

    RequestPriorityPolicy_var &operator= (RequestPriorityPolicy_ptr);
    RequestPriorityPolicy_var &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_ptr operator-> (void) const;

    operator const RequestPriorityPolicy_ptr &() const;
    operator RequestPriorityPolicy_ptr &();
    // in, inout, out, _retn
    RequestPriorityPolicy_ptr in (void) const;
    RequestPriorityPolicy_ptr &inout (void);
    RequestPriorityPolicy_ptr &out (void);
    RequestPriorityPolicy_ptr _retn (void);
    RequestPriorityPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RequestPriorityPolicy_ptr tao_duplicate (RequestPriorityPolicy_ptr);
    static void tao_release (RequestPriorityPolicy_ptr);
    static RequestPriorityPolicy_ptr tao_nil (void);
    static RequestPriorityPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RequestPriorityPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestPriorityPolicy_var (const TAO_Base_var &rhs);
    RequestPriorityPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY___OUT_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY___OUT_CH_

  class TAO_Export RequestPriorityPolicy_out
  {
  public:
    RequestPriorityPolicy_out (RequestPriorityPolicy_ptr &);
    RequestPriorityPolicy_out (RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_out &);
    RequestPriorityPolicy_out &operator= (const RequestPriorityPolicy_var &);
    RequestPriorityPolicy_out &operator= (RequestPriorityPolicy_ptr);
    operator RequestPriorityPolicy_ptr &();
    RequestPriorityPolicy_ptr &ptr (void);
    RequestPriorityPolicy_ptr operator-> (void);

  private:
    RequestPriorityPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTPRIORITYPOLICY_CH_)
#define _MESSAGING_REQUESTPRIORITYPOLICY_CH_

  class TAO_Export RequestPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestPriorityPolicy_ptr _ptr_type;
    typedef RequestPriorityPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RequestPriorityPolicy_ptr _duplicate (RequestPriorityPolicy_ptr obj);
    static RequestPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RequestPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RequestPriorityPolicy_ptr _nil (void)
      {
        return (RequestPriorityPolicy_ptr)0;
      }

    virtual Messaging::PriorityRange priority_range (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestPriorityPolicy ();

    virtual ~RequestPriorityPolicy (void);
  private:
    RequestPriorityPolicy (const RequestPriorityPolicy &);
    void operator= (const RequestPriorityPolicy &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_PRIORITY_POLICY_TYPE;


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY___PTR_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY___PTR_CH_

  class ReplyPriorityPolicy;
  typedef ReplyPriorityPolicy *ReplyPriorityPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY___VAR_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY___VAR_CH_

  class TAO_Export ReplyPriorityPolicy_var : public TAO_Base_var
  {
  public:
    ReplyPriorityPolicy_var (void); // default constructor
    ReplyPriorityPolicy_var (ReplyPriorityPolicy_ptr p) : ptr_ (p) {}
    ReplyPriorityPolicy_var (const ReplyPriorityPolicy_var &); // copy constructor
    ~ReplyPriorityPolicy_var (void); // destructor

    ReplyPriorityPolicy_var &operator= (ReplyPriorityPolicy_ptr);
    ReplyPriorityPolicy_var &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_ptr operator-> (void) const;

    operator const ReplyPriorityPolicy_ptr &() const;
    operator ReplyPriorityPolicy_ptr &();
    // in, inout, out, _retn
    ReplyPriorityPolicy_ptr in (void) const;
    ReplyPriorityPolicy_ptr &inout (void);
    ReplyPriorityPolicy_ptr &out (void);
    ReplyPriorityPolicy_ptr _retn (void);
    ReplyPriorityPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ReplyPriorityPolicy_ptr tao_duplicate (ReplyPriorityPolicy_ptr);
    static void tao_release (ReplyPriorityPolicy_ptr);
    static ReplyPriorityPolicy_ptr tao_nil (void);
    static ReplyPriorityPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    ReplyPriorityPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyPriorityPolicy_var (const TAO_Base_var &rhs);
    ReplyPriorityPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY___OUT_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY___OUT_CH_

  class TAO_Export ReplyPriorityPolicy_out
  {
  public:
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_ptr &);
    ReplyPriorityPolicy_out (ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_out &);
    ReplyPriorityPolicy_out &operator= (const ReplyPriorityPolicy_var &);
    ReplyPriorityPolicy_out &operator= (ReplyPriorityPolicy_ptr);
    operator ReplyPriorityPolicy_ptr &();
    ReplyPriorityPolicy_ptr &ptr (void);
    ReplyPriorityPolicy_ptr operator-> (void);

  private:
    ReplyPriorityPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYPRIORITYPOLICY_CH_)
#define _MESSAGING_REPLYPRIORITYPOLICY_CH_

  class TAO_Export ReplyPriorityPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyPriorityPolicy_ptr _ptr_type;
    typedef ReplyPriorityPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ReplyPriorityPolicy_ptr _duplicate (ReplyPriorityPolicy_ptr obj);
    static ReplyPriorityPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyPriorityPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyPriorityPolicy_ptr _nil (void)
      {
        return (ReplyPriorityPolicy_ptr)0;
      }

    virtual Messaging::PriorityRange priority_range (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ReplyPriorityPolicy ();

    virtual ~ReplyPriorityPolicy (void);
  private:
    ReplyPriorityPolicy (const ReplyPriorityPolicy &);
    void operator= (const ReplyPriorityPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_PRIORITY_POLICIES == 1 */

#if (TAO_HAS_REQUEST_START_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_START_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY___PTR_CH_

  class RequestStartTimePolicy;
  typedef RequestStartTimePolicy *RequestStartTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY___VAR_CH_

  class TAO_Export RequestStartTimePolicy_var : public TAO_Base_var
  {
  public:
    RequestStartTimePolicy_var (void); // default constructor
    RequestStartTimePolicy_var (RequestStartTimePolicy_ptr p) : ptr_ (p) {}
    RequestStartTimePolicy_var (const RequestStartTimePolicy_var &); // copy constructor
    ~RequestStartTimePolicy_var (void); // destructor

    RequestStartTimePolicy_var &operator= (RequestStartTimePolicy_ptr);
    RequestStartTimePolicy_var &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_ptr operator-> (void) const;

    operator const RequestStartTimePolicy_ptr &() const;
    operator RequestStartTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestStartTimePolicy_ptr in (void) const;
    RequestStartTimePolicy_ptr &inout (void);
    RequestStartTimePolicy_ptr &out (void);
    RequestStartTimePolicy_ptr _retn (void);
    RequestStartTimePolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RequestStartTimePolicy_ptr tao_duplicate (RequestStartTimePolicy_ptr);
    static void tao_release (RequestStartTimePolicy_ptr);
    static RequestStartTimePolicy_ptr tao_nil (void);
    static RequestStartTimePolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RequestStartTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestStartTimePolicy_var (const TAO_Base_var &rhs);
    RequestStartTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY___OUT_CH_

  class TAO_Export RequestStartTimePolicy_out
  {
  public:
    RequestStartTimePolicy_out (RequestStartTimePolicy_ptr &);
    RequestStartTimePolicy_out (RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_out &);
    RequestStartTimePolicy_out &operator= (const RequestStartTimePolicy_var &);
    RequestStartTimePolicy_out &operator= (RequestStartTimePolicy_ptr);
    operator RequestStartTimePolicy_ptr &();
    RequestStartTimePolicy_ptr &ptr (void);
    RequestStartTimePolicy_ptr operator-> (void);

  private:
    RequestStartTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTSTARTTIMEPOLICY_CH_)
#define _MESSAGING_REQUESTSTARTTIMEPOLICY_CH_

  class TAO_Export RequestStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestStartTimePolicy_ptr _ptr_type;
    typedef RequestStartTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RequestStartTimePolicy_ptr _duplicate (RequestStartTimePolicy_ptr obj);
    static RequestStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RequestStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RequestStartTimePolicy_ptr _nil (void)
      {
        return (RequestStartTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT start_time (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestStartTimePolicy ();

    virtual ~RequestStartTimePolicy (void);
  private:
    RequestStartTimePolicy (const RequestStartTimePolicy &);
    void operator= (const RequestStartTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REQUEST_START_TIME_POLICY == 1 */

#if (TAO_HAS_REQUEST_END_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_END_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY___PTR_CH_

  class RequestEndTimePolicy;
  typedef RequestEndTimePolicy *RequestEndTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY___VAR_CH_

  class TAO_Export RequestEndTimePolicy_var : public TAO_Base_var
  {
  public:
    RequestEndTimePolicy_var (void); // default constructor
    RequestEndTimePolicy_var (RequestEndTimePolicy_ptr p) : ptr_ (p) {}
    RequestEndTimePolicy_var (const RequestEndTimePolicy_var &); // copy constructor
    ~RequestEndTimePolicy_var (void); // destructor

    RequestEndTimePolicy_var &operator= (RequestEndTimePolicy_ptr);
    RequestEndTimePolicy_var &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_ptr operator-> (void) const;

    operator const RequestEndTimePolicy_ptr &() const;
    operator RequestEndTimePolicy_ptr &();
    // in, inout, out, _retn
    RequestEndTimePolicy_ptr in (void) const;
    RequestEndTimePolicy_ptr &inout (void);
    RequestEndTimePolicy_ptr &out (void);
    RequestEndTimePolicy_ptr _retn (void);
    RequestEndTimePolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RequestEndTimePolicy_ptr tao_duplicate (RequestEndTimePolicy_ptr);
    static void tao_release (RequestEndTimePolicy_ptr);
    static RequestEndTimePolicy_ptr tao_nil (void);
    static RequestEndTimePolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RequestEndTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestEndTimePolicy_var (const TAO_Base_var &rhs);
    RequestEndTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY___OUT_CH_

  class TAO_Export RequestEndTimePolicy_out
  {
  public:
    RequestEndTimePolicy_out (RequestEndTimePolicy_ptr &);
    RequestEndTimePolicy_out (RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_out &);
    RequestEndTimePolicy_out &operator= (const RequestEndTimePolicy_var &);
    RequestEndTimePolicy_out &operator= (RequestEndTimePolicy_ptr);
    operator RequestEndTimePolicy_ptr &();
    RequestEndTimePolicy_ptr &ptr (void);
    RequestEndTimePolicy_ptr operator-> (void);

  private:
    RequestEndTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REQUESTENDTIMEPOLICY_CH_)
#define _MESSAGING_REQUESTENDTIMEPOLICY_CH_

  class TAO_Export RequestEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RequestEndTimePolicy_ptr _ptr_type;
    typedef RequestEndTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RequestEndTimePolicy_ptr _duplicate (RequestEndTimePolicy_ptr obj);
    static RequestEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RequestEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RequestEndTimePolicy_ptr _nil (void)
      {
        return (RequestEndTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT end_time (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RequestEndTimePolicy ();

    virtual ~RequestEndTimePolicy (void);
  private:
    RequestEndTimePolicy (const RequestEndTimePolicy &);
    void operator= (const RequestEndTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REQUEST_END_TIME_POLICY == 1 */

#if (TAO_HAS_REPLY_START_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_START_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY___PTR_CH_

  class ReplyStartTimePolicy;
  typedef ReplyStartTimePolicy *ReplyStartTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY___VAR_CH_

  class TAO_Export ReplyStartTimePolicy_var : public TAO_Base_var
  {
  public:
    ReplyStartTimePolicy_var (void); // default constructor
    ReplyStartTimePolicy_var (ReplyStartTimePolicy_ptr p) : ptr_ (p) {}
    ReplyStartTimePolicy_var (const ReplyStartTimePolicy_var &); // copy constructor
    ~ReplyStartTimePolicy_var (void); // destructor

    ReplyStartTimePolicy_var &operator= (ReplyStartTimePolicy_ptr);
    ReplyStartTimePolicy_var &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_ptr operator-> (void) const;

    operator const ReplyStartTimePolicy_ptr &() const;
    operator ReplyStartTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyStartTimePolicy_ptr in (void) const;
    ReplyStartTimePolicy_ptr &inout (void);
    ReplyStartTimePolicy_ptr &out (void);
    ReplyStartTimePolicy_ptr _retn (void);
    ReplyStartTimePolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ReplyStartTimePolicy_ptr tao_duplicate (ReplyStartTimePolicy_ptr);
    static void tao_release (ReplyStartTimePolicy_ptr);
    static ReplyStartTimePolicy_ptr tao_nil (void);
    static ReplyStartTimePolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    ReplyStartTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyStartTimePolicy_var (const TAO_Base_var &rhs);
    ReplyStartTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY___OUT_CH_

  class TAO_Export ReplyStartTimePolicy_out
  {
  public:
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_ptr &);
    ReplyStartTimePolicy_out (ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_out &);
    ReplyStartTimePolicy_out &operator= (const ReplyStartTimePolicy_var &);
    ReplyStartTimePolicy_out &operator= (ReplyStartTimePolicy_ptr);
    operator ReplyStartTimePolicy_ptr &();
    ReplyStartTimePolicy_ptr &ptr (void);
    ReplyStartTimePolicy_ptr operator-> (void);

  private:
    ReplyStartTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYSTARTTIMEPOLICY_CH_)
#define _MESSAGING_REPLYSTARTTIMEPOLICY_CH_

  class TAO_Export ReplyStartTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyStartTimePolicy_ptr _ptr_type;
    typedef ReplyStartTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ReplyStartTimePolicy_ptr _duplicate (ReplyStartTimePolicy_ptr obj);
    static ReplyStartTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyStartTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyStartTimePolicy_ptr _nil (void)
      {
        return (ReplyStartTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT start_time (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ReplyStartTimePolicy ();

    virtual ~ReplyStartTimePolicy (void);
  private:
    ReplyStartTimePolicy (const ReplyStartTimePolicy &);
    void operator= (const ReplyStartTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REPLY_START_TIME_POLICY == 1 */

#if (TAO_HAS_REPLY_END_TIME_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REPLY_END_TIME_POLICY_TYPE;


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY___PTR_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY___PTR_CH_

  class ReplyEndTimePolicy;
  typedef ReplyEndTimePolicy *ReplyEndTimePolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY___VAR_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY___VAR_CH_

  class TAO_Export ReplyEndTimePolicy_var : public TAO_Base_var
  {
  public:
    ReplyEndTimePolicy_var (void); // default constructor
    ReplyEndTimePolicy_var (ReplyEndTimePolicy_ptr p) : ptr_ (p) {}
    ReplyEndTimePolicy_var (const ReplyEndTimePolicy_var &); // copy constructor
    ~ReplyEndTimePolicy_var (void); // destructor

    ReplyEndTimePolicy_var &operator= (ReplyEndTimePolicy_ptr);
    ReplyEndTimePolicy_var &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_ptr operator-> (void) const;

    operator const ReplyEndTimePolicy_ptr &() const;
    operator ReplyEndTimePolicy_ptr &();
    // in, inout, out, _retn
    ReplyEndTimePolicy_ptr in (void) const;
    ReplyEndTimePolicy_ptr &inout (void);
    ReplyEndTimePolicy_ptr &out (void);
    ReplyEndTimePolicy_ptr _retn (void);
    ReplyEndTimePolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ReplyEndTimePolicy_ptr tao_duplicate (ReplyEndTimePolicy_ptr);
    static void tao_release (ReplyEndTimePolicy_ptr);
    static ReplyEndTimePolicy_ptr tao_nil (void);
    static ReplyEndTimePolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    ReplyEndTimePolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyEndTimePolicy_var (const TAO_Base_var &rhs);
    ReplyEndTimePolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY___OUT_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY___OUT_CH_

  class TAO_Export ReplyEndTimePolicy_out
  {
  public:
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_ptr &);
    ReplyEndTimePolicy_out (ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_out &);
    ReplyEndTimePolicy_out &operator= (const ReplyEndTimePolicy_var &);
    ReplyEndTimePolicy_out &operator= (ReplyEndTimePolicy_ptr);
    operator ReplyEndTimePolicy_ptr &();
    ReplyEndTimePolicy_ptr &ptr (void);
    ReplyEndTimePolicy_ptr operator-> (void);

  private:
    ReplyEndTimePolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYENDTIMEPOLICY_CH_)
#define _MESSAGING_REPLYENDTIMEPOLICY_CH_

  class TAO_Export ReplyEndTimePolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyEndTimePolicy_ptr _ptr_type;
    typedef ReplyEndTimePolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ReplyEndTimePolicy_ptr _duplicate (ReplyEndTimePolicy_ptr obj);
    static ReplyEndTimePolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyEndTimePolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyEndTimePolicy_ptr _nil (void)
      {
        return (ReplyEndTimePolicy_ptr)0;
      }

    virtual TimeBase::UtcT end_time (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    ReplyEndTimePolicy ();

    virtual ~ReplyEndTimePolicy (void);
  private:
    ReplyEndTimePolicy (const ReplyEndTimePolicy &);
    void operator= (const ReplyEndTimePolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_REPLY_END_TIME_POLICY == 1 */

#if (TAO_HAS_RELATIVE_REQUEST_TIMEOUT_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_REQ_TIMEOUT_POLICY_TYPE;


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___PTR_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___PTR_CH_

  class RelativeRequestTimeoutPolicy;
  typedef RelativeRequestTimeoutPolicy *RelativeRequestTimeoutPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___VAR_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___VAR_CH_

  class TAO_Export RelativeRequestTimeoutPolicy_var : public TAO_Base_var
  {
  public:
    RelativeRequestTimeoutPolicy_var (void); // default constructor
    RelativeRequestTimeoutPolicy_var (RelativeRequestTimeoutPolicy_ptr p) : ptr_ (p) {}
    RelativeRequestTimeoutPolicy_var (const RelativeRequestTimeoutPolicy_var &); // copy constructor
    ~RelativeRequestTimeoutPolicy_var (void); // destructor

    RelativeRequestTimeoutPolicy_var &operator= (RelativeRequestTimeoutPolicy_ptr);
    RelativeRequestTimeoutPolicy_var &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRequestTimeoutPolicy_ptr &() const;
    operator RelativeRequestTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRequestTimeoutPolicy_ptr in (void) const;
    RelativeRequestTimeoutPolicy_ptr &inout (void);
    RelativeRequestTimeoutPolicy_ptr &out (void);
    RelativeRequestTimeoutPolicy_ptr _retn (void);
    RelativeRequestTimeoutPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RelativeRequestTimeoutPolicy_ptr tao_duplicate (RelativeRequestTimeoutPolicy_ptr);
    static void tao_release (RelativeRequestTimeoutPolicy_ptr);
    static RelativeRequestTimeoutPolicy_ptr tao_nil (void);
    static RelativeRequestTimeoutPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RelativeRequestTimeoutPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RelativeRequestTimeoutPolicy_var (const TAO_Base_var &rhs);
    RelativeRequestTimeoutPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___OUT_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY___OUT_CH_

  class TAO_Export RelativeRequestTimeoutPolicy_out
  {
  public:
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_ptr &);
    RelativeRequestTimeoutPolicy_out (RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_out &);
    RelativeRequestTimeoutPolicy_out &operator= (const RelativeRequestTimeoutPolicy_var &);
    RelativeRequestTimeoutPolicy_out &operator= (RelativeRequestTimeoutPolicy_ptr);
    operator RelativeRequestTimeoutPolicy_ptr &();
    RelativeRequestTimeoutPolicy_ptr &ptr (void);
    RelativeRequestTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRequestTimeoutPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY_CH_)
#define _MESSAGING_RELATIVEREQUESTTIMEOUTPOLICY_CH_

  class TAO_Export RelativeRequestTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RelativeRequestTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRequestTimeoutPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RelativeRequestTimeoutPolicy_ptr _duplicate (RelativeRequestTimeoutPolicy_ptr obj);
    static RelativeRequestTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RelativeRequestTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RelativeRequestTimeoutPolicy_ptr _nil (void)
      {
        return (RelativeRequestTimeoutPolicy_ptr)0;
      }

    virtual TimeBase::TimeT relative_expiry (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RelativeRequestTimeoutPolicy ();

    virtual ~RelativeRequestTimeoutPolicy (void);
  private:
    RelativeRequestTimeoutPolicy (const RelativeRequestTimeoutPolicy &);
    void operator= (const RelativeRequestTimeoutPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_RELATIVE_REQUEST_TIMEOUT_POLICY == 1 */

#if (TAO_HAS_RELATIVE_ROUNDTRIP_TIMEOUT_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RELATIVE_RT_TIMEOUT_POLICY_TYPE;


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___PTR_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___PTR_CH_

  class RelativeRoundtripTimeoutPolicy;
  typedef RelativeRoundtripTimeoutPolicy *RelativeRoundtripTimeoutPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___VAR_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___VAR_CH_

  class TAO_Export RelativeRoundtripTimeoutPolicy_var : public TAO_Base_var
  {
  public:
    RelativeRoundtripTimeoutPolicy_var (void); // default constructor
    RelativeRoundtripTimeoutPolicy_var (RelativeRoundtripTimeoutPolicy_ptr p) : ptr_ (p) {}
    RelativeRoundtripTimeoutPolicy_var (const RelativeRoundtripTimeoutPolicy_var &); // copy constructor
    ~RelativeRoundtripTimeoutPolicy_var (void); // destructor

    RelativeRoundtripTimeoutPolicy_var &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    RelativeRoundtripTimeoutPolicy_var &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void) const;

    operator const RelativeRoundtripTimeoutPolicy_ptr &() const;
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    // in, inout, out, _retn
    RelativeRoundtripTimeoutPolicy_ptr in (void) const;
    RelativeRoundtripTimeoutPolicy_ptr &inout (void);
    RelativeRoundtripTimeoutPolicy_ptr &out (void);
    RelativeRoundtripTimeoutPolicy_ptr _retn (void);
    RelativeRoundtripTimeoutPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RelativeRoundtripTimeoutPolicy_ptr tao_duplicate (RelativeRoundtripTimeoutPolicy_ptr);
    static void tao_release (RelativeRoundtripTimeoutPolicy_ptr);
    static RelativeRoundtripTimeoutPolicy_ptr tao_nil (void);
    static RelativeRoundtripTimeoutPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RelativeRoundtripTimeoutPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RelativeRoundtripTimeoutPolicy_var (const TAO_Base_var &rhs);
    RelativeRoundtripTimeoutPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___OUT_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY___OUT_CH_

  class TAO_Export RelativeRoundtripTimeoutPolicy_out
  {
  public:
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_ptr &);
    RelativeRoundtripTimeoutPolicy_out (RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_out &);
    RelativeRoundtripTimeoutPolicy_out &operator= (const RelativeRoundtripTimeoutPolicy_var &);
    RelativeRoundtripTimeoutPolicy_out &operator= (RelativeRoundtripTimeoutPolicy_ptr);
    operator RelativeRoundtripTimeoutPolicy_ptr &();
    RelativeRoundtripTimeoutPolicy_ptr &ptr (void);
    RelativeRoundtripTimeoutPolicy_ptr operator-> (void);

  private:
    RelativeRoundtripTimeoutPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY_CH_)
#define _MESSAGING_RELATIVEROUNDTRIPTIMEOUTPOLICY_CH_

  class TAO_Export RelativeRoundtripTimeoutPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RelativeRoundtripTimeoutPolicy_ptr _ptr_type;
    typedef RelativeRoundtripTimeoutPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RelativeRoundtripTimeoutPolicy_ptr _duplicate (RelativeRoundtripTimeoutPolicy_ptr obj);
    static RelativeRoundtripTimeoutPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RelativeRoundtripTimeoutPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RelativeRoundtripTimeoutPolicy_ptr _nil (void)
      {
        return (RelativeRoundtripTimeoutPolicy_ptr)0;
      }

    virtual TimeBase::TimeT relative_expiry (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RelativeRoundtripTimeoutPolicy ();

    virtual ~RelativeRoundtripTimeoutPolicy (void);
  private:
    RelativeRoundtripTimeoutPolicy (const RelativeRoundtripTimeoutPolicy &);
    void operator= (const RelativeRoundtripTimeoutPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_RELATIVE_ROUNDTRIP_TIMEOUT_POLICY == 1 */

#if (TAO_HAS_ROUTING_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ROUTING_POLICY_TYPE;

  struct RoutingTypeRange;
  class RoutingTypeRange_var;

  struct TAO_Export RoutingTypeRange
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RoutingTypeRange_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (Messaging, RoutingType) min;
    ACE_NESTED_CLASS (Messaging, RoutingType) max;
  };

  class TAO_Export RoutingTypeRange_var
  {
  public:
    RoutingTypeRange_var (void); // default constructor
    RoutingTypeRange_var (RoutingTypeRange *);
    RoutingTypeRange_var (const RoutingTypeRange_var &); // copy constructor
    RoutingTypeRange_var (const RoutingTypeRange &); // fixed-size types only
    ~RoutingTypeRange_var (void); // destructor

    RoutingTypeRange_var &operator= (RoutingTypeRange *);
    RoutingTypeRange_var &operator= (const RoutingTypeRange_var &);
    RoutingTypeRange_var &operator= (const RoutingTypeRange &); // fixed-size types only
    RoutingTypeRange *operator-> (void);
    const RoutingTypeRange *operator-> (void) const;

    operator const RoutingTypeRange &() const;
    operator RoutingTypeRange &();
    operator RoutingTypeRange &() const;

    // in, inout, out, _retn
    const RoutingTypeRange &in (void) const;
    RoutingTypeRange &inout (void);
    RoutingTypeRange &out (void);
    RoutingTypeRange _retn (void);
    RoutingTypeRange *ptr (void) const;

  private:
    RoutingTypeRange *ptr_;
  };

  typedef RoutingTypeRange &RoutingTypeRange_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RoutingTypeRange;


#if !defined (_MESSAGING_ROUTINGPOLICY___PTR_CH_)
#define _MESSAGING_ROUTINGPOLICY___PTR_CH_

  class RoutingPolicy;
  typedef RoutingPolicy *RoutingPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_ROUTINGPOLICY___VAR_CH_)
#define _MESSAGING_ROUTINGPOLICY___VAR_CH_

  class TAO_Export RoutingPolicy_var : public TAO_Base_var
  {
  public:
    RoutingPolicy_var (void); // default constructor
    RoutingPolicy_var (RoutingPolicy_ptr p) : ptr_ (p) {}
    RoutingPolicy_var (const RoutingPolicy_var &); // copy constructor
    ~RoutingPolicy_var (void); // destructor

    RoutingPolicy_var &operator= (RoutingPolicy_ptr);
    RoutingPolicy_var &operator= (const RoutingPolicy_var &);
    RoutingPolicy_ptr operator-> (void) const;

    operator const RoutingPolicy_ptr &() const;
    operator RoutingPolicy_ptr &();
    // in, inout, out, _retn
    RoutingPolicy_ptr in (void) const;
    RoutingPolicy_ptr &inout (void);
    RoutingPolicy_ptr &out (void);
    RoutingPolicy_ptr _retn (void);
    RoutingPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static RoutingPolicy_ptr tao_duplicate (RoutingPolicy_ptr);
    static void tao_release (RoutingPolicy_ptr);
    static RoutingPolicy_ptr tao_nil (void);
    static RoutingPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    RoutingPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RoutingPolicy_var (const TAO_Base_var &rhs);
    RoutingPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_ROUTINGPOLICY___OUT_CH_)
#define _MESSAGING_ROUTINGPOLICY___OUT_CH_

  class TAO_Export RoutingPolicy_out
  {
  public:
    RoutingPolicy_out (RoutingPolicy_ptr &);
    RoutingPolicy_out (RoutingPolicy_var &);
    RoutingPolicy_out (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_out &);
    RoutingPolicy_out &operator= (const RoutingPolicy_var &);
    RoutingPolicy_out &operator= (RoutingPolicy_ptr);
    operator RoutingPolicy_ptr &();
    RoutingPolicy_ptr &ptr (void);
    RoutingPolicy_ptr operator-> (void);

  private:
    RoutingPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_ROUTINGPOLICY_CH_)
#define _MESSAGING_ROUTINGPOLICY_CH_

  class TAO_Export RoutingPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef RoutingPolicy_ptr _ptr_type;
    typedef RoutingPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static RoutingPolicy_ptr _duplicate (RoutingPolicy_ptr obj);
    static RoutingPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RoutingPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static RoutingPolicy_ptr _nil (void)
      {
        return (RoutingPolicy_ptr)0;
      }

    virtual Messaging::RoutingTypeRange routing_range (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    RoutingPolicy ();

    virtual ~RoutingPolicy (void);
  private:
    RoutingPolicy (const RoutingPolicy &);
    void operator= (const RoutingPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_ROUTING_POLICY == 1 */

#if (TAO_HAS_MAX_HOPS_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong MAX_HOPS_POLICY_TYPE;


#if !defined (_MESSAGING_MAXHOPSPOLICY___PTR_CH_)
#define _MESSAGING_MAXHOPSPOLICY___PTR_CH_

  class MaxHopsPolicy;
  typedef MaxHopsPolicy *MaxHopsPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_MAXHOPSPOLICY___VAR_CH_)
#define _MESSAGING_MAXHOPSPOLICY___VAR_CH_

  class TAO_Export MaxHopsPolicy_var : public TAO_Base_var
  {
  public:
    MaxHopsPolicy_var (void); // default constructor
    MaxHopsPolicy_var (MaxHopsPolicy_ptr p) : ptr_ (p) {}
    MaxHopsPolicy_var (const MaxHopsPolicy_var &); // copy constructor
    ~MaxHopsPolicy_var (void); // destructor

    MaxHopsPolicy_var &operator= (MaxHopsPolicy_ptr);
    MaxHopsPolicy_var &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_ptr operator-> (void) const;

    operator const MaxHopsPolicy_ptr &() const;
    operator MaxHopsPolicy_ptr &();
    // in, inout, out, _retn
    MaxHopsPolicy_ptr in (void) const;
    MaxHopsPolicy_ptr &inout (void);
    MaxHopsPolicy_ptr &out (void);
    MaxHopsPolicy_ptr _retn (void);
    MaxHopsPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static MaxHopsPolicy_ptr tao_duplicate (MaxHopsPolicy_ptr);
    static void tao_release (MaxHopsPolicy_ptr);
    static MaxHopsPolicy_ptr tao_nil (void);
    static MaxHopsPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    MaxHopsPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    MaxHopsPolicy_var (const TAO_Base_var &rhs);
    MaxHopsPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_MAXHOPSPOLICY___OUT_CH_)
#define _MESSAGING_MAXHOPSPOLICY___OUT_CH_

  class TAO_Export MaxHopsPolicy_out
  {
  public:
    MaxHopsPolicy_out (MaxHopsPolicy_ptr &);
    MaxHopsPolicy_out (MaxHopsPolicy_var &);
    MaxHopsPolicy_out (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_out &);
    MaxHopsPolicy_out &operator= (const MaxHopsPolicy_var &);
    MaxHopsPolicy_out &operator= (MaxHopsPolicy_ptr);
    operator MaxHopsPolicy_ptr &();
    MaxHopsPolicy_ptr &ptr (void);
    MaxHopsPolicy_ptr operator-> (void);

  private:
    MaxHopsPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_MAXHOPSPOLICY_CH_)
#define _MESSAGING_MAXHOPSPOLICY_CH_

  class TAO_Export MaxHopsPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef MaxHopsPolicy_ptr _ptr_type;
    typedef MaxHopsPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static MaxHopsPolicy_ptr _duplicate (MaxHopsPolicy_ptr obj);
    static MaxHopsPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static MaxHopsPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static MaxHopsPolicy_ptr _nil (void)
      {
        return (MaxHopsPolicy_ptr)0;
      }

    virtual CORBA::UShort max_hops (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    MaxHopsPolicy ();

    virtual ~MaxHopsPolicy (void);
  private:
    MaxHopsPolicy (const MaxHopsPolicy &);
    void operator= (const MaxHopsPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_MAX_HOPS_POLICY == 1 */

#if (TAO_HAS_QUEUE_ORDER_POLICY == 1)

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong QUEUE_ORDER_POLICY_TYPE;


#if !defined (_MESSAGING_QUEUEORDERPOLICY___PTR_CH_)
#define _MESSAGING_QUEUEORDERPOLICY___PTR_CH_

  class QueueOrderPolicy;
  typedef QueueOrderPolicy *QueueOrderPolicy_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_QUEUEORDERPOLICY___VAR_CH_)
#define _MESSAGING_QUEUEORDERPOLICY___VAR_CH_

  class TAO_Export QueueOrderPolicy_var : public TAO_Base_var
  {
  public:
    QueueOrderPolicy_var (void); // default constructor
    QueueOrderPolicy_var (QueueOrderPolicy_ptr p) : ptr_ (p) {}
    QueueOrderPolicy_var (const QueueOrderPolicy_var &); // copy constructor
    ~QueueOrderPolicy_var (void); // destructor

    QueueOrderPolicy_var &operator= (QueueOrderPolicy_ptr);
    QueueOrderPolicy_var &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_ptr operator-> (void) const;

    operator const QueueOrderPolicy_ptr &() const;
    operator QueueOrderPolicy_ptr &();
    // in, inout, out, _retn
    QueueOrderPolicy_ptr in (void) const;
    QueueOrderPolicy_ptr &inout (void);
    QueueOrderPolicy_ptr &out (void);
    QueueOrderPolicy_ptr _retn (void);
    QueueOrderPolicy_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static QueueOrderPolicy_ptr tao_duplicate (QueueOrderPolicy_ptr);
    static void tao_release (QueueOrderPolicy_ptr);
    static QueueOrderPolicy_ptr tao_nil (void);
    static QueueOrderPolicy_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    QueueOrderPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    QueueOrderPolicy_var (const TAO_Base_var &rhs);
    QueueOrderPolicy_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_QUEUEORDERPOLICY___OUT_CH_)
#define _MESSAGING_QUEUEORDERPOLICY___OUT_CH_

  class TAO_Export QueueOrderPolicy_out
  {
  public:
    QueueOrderPolicy_out (QueueOrderPolicy_ptr &);
    QueueOrderPolicy_out (QueueOrderPolicy_var &);
    QueueOrderPolicy_out (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_out &);
    QueueOrderPolicy_out &operator= (const QueueOrderPolicy_var &);
    QueueOrderPolicy_out &operator= (QueueOrderPolicy_ptr);
    operator QueueOrderPolicy_ptr &();
    QueueOrderPolicy_ptr &ptr (void);
    QueueOrderPolicy_ptr operator-> (void);

  private:
    QueueOrderPolicy_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_QUEUEORDERPOLICY_CH_)
#define _MESSAGING_QUEUEORDERPOLICY_CH_

  class TAO_Export QueueOrderPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef QueueOrderPolicy_ptr _ptr_type;
    typedef QueueOrderPolicy_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static QueueOrderPolicy_ptr _duplicate (QueueOrderPolicy_ptr obj);
    static QueueOrderPolicy_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static QueueOrderPolicy_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static QueueOrderPolicy_ptr _nil (void)
      {
        return (QueueOrderPolicy_ptr)0;
      }

    virtual Messaging::Ordering allowed_orders (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    QueueOrderPolicy ();

    virtual ~QueueOrderPolicy (void);
  private:
    QueueOrderPolicy (const QueueOrderPolicy &);
    void operator= (const QueueOrderPolicy &);
  };


#endif /* end #if !defined */

#endif /* TAO_HAS_QUEUE_ORDER_POLICY == 1 */

  struct PolicyValue;
  class PolicyValue_var;

  struct TAO_Export PolicyValue
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PolicyValue_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    CORBA::PolicyType ptype;

#if !defined (_MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CH_)
#define _MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release = 0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _pvalue_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_Octet pvalue;
  };

  class TAO_Export PolicyValue_var
  {
  public:
    PolicyValue_var (void); // default constructor
    PolicyValue_var (PolicyValue *);
    PolicyValue_var (const PolicyValue_var &); // copy constructor
    ~PolicyValue_var (void); // destructor

    PolicyValue_var &operator= (PolicyValue *);
    PolicyValue_var &operator= (const PolicyValue_var &);
    PolicyValue *operator-> (void);
    const PolicyValue *operator-> (void) const;

    operator const PolicyValue &() const;
    operator PolicyValue &();
    operator PolicyValue &() const;
    operator PolicyValue *&(); // variable-size types only

    // in, inout, out, _retn
    const PolicyValue &in (void) const;
    PolicyValue &inout (void);
    PolicyValue *&out (void);
    PolicyValue *_retn (void);
    PolicyValue *ptr (void) const;

  private:
    PolicyValue *ptr_;
  };

  class TAO_Export PolicyValue_out
  {
  public:
    PolicyValue_out (PolicyValue *&);
    PolicyValue_out (PolicyValue_var &);
    PolicyValue_out (const PolicyValue_out &);
    PolicyValue_out &operator= (const PolicyValue_out &);
    PolicyValue_out &operator= (PolicyValue *);
    operator PolicyValue *&();
    PolicyValue *&ptr (void);
    PolicyValue *operator-> (void);

  private:
    PolicyValue *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValue_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValue;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_MESSAGING_POLICYVALUESEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_MESSAGING_POLICYVALUESEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        PolicyValue *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (const _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq &rhs);
      _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq &operator= (const _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_Messaging_PolicyValueSeq (void); // Dtor.
      // = Accessors.
      PolicyValue &operator[] (CORBA::ULong i);
      const PolicyValue &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static PolicyValue *allocbuf (CORBA::ULong size);
      static void freebuf (PolicyValue *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      PolicyValue *get_buffer (CORBA::Boolean orphan = 0);
      const PolicyValue *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        PolicyValue *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_MESSAGING_POLICYVALUESEQ_CH_)
#define _MESSAGING_POLICYVALUESEQ_CH_

  class PolicyValueSeq;
  class PolicyValueSeq_var;

  // *************************************************************
  // PolicyValueSeq
  // *************************************************************

  class TAO_Export PolicyValueSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_Messaging_PolicyValueSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<PolicyValue>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    PolicyValueSeq (void); // default ctor
    PolicyValueSeq (CORBA::ULong max); // uses max size
    PolicyValueSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      PolicyValue *buffer,
      CORBA::Boolean release = 0
    );
    PolicyValueSeq (const PolicyValueSeq &); // copy ctor
    ~PolicyValueSeq (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef PolicyValueSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_POLICYVALUESEQ___VAR_CH_)
#define _MESSAGING_POLICYVALUESEQ___VAR_CH_

  // *************************************************************
  // class Messaging::PolicyValueSeq_var
  // *************************************************************

  class TAO_Export PolicyValueSeq_var
  {
  public:
    PolicyValueSeq_var (void); // default constructor
    PolicyValueSeq_var (PolicyValueSeq *);
    PolicyValueSeq_var (const PolicyValueSeq_var &); // copy constructor
    ~PolicyValueSeq_var (void); // destructor

    PolicyValueSeq_var &operator= (PolicyValueSeq *);
    PolicyValueSeq_var &operator= (const PolicyValueSeq_var &);
    PolicyValueSeq *operator-> (void);
    const PolicyValueSeq *operator-> (void) const;

    operator const PolicyValueSeq &() const;
    operator PolicyValueSeq &();
    operator PolicyValueSeq &() const;
    operator PolicyValueSeq *&(); // variable-size base types only

    PolicyValue & operator[] (CORBA::ULong index);
    const PolicyValue & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const PolicyValueSeq &in (void) const;
    PolicyValueSeq &inout (void);
    PolicyValueSeq *&out (void);
    PolicyValueSeq *_retn (void);
    PolicyValueSeq *ptr (void) const;

  private:
    PolicyValueSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_POLICYVALUESEQ___OUT_CH_)
#define _MESSAGING_POLICYVALUESEQ___OUT_CH_

  class TAO_Export PolicyValueSeq_out
  {
  public:
    PolicyValueSeq_out (PolicyValueSeq *&);
    PolicyValueSeq_out (PolicyValueSeq_var &);
    PolicyValueSeq_out (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (const PolicyValueSeq_out &);
    PolicyValueSeq_out &operator= (PolicyValueSeq *);
    operator PolicyValueSeq *&();
    PolicyValueSeq *&ptr (void);
    PolicyValueSeq *operator-> (void);
    PolicyValue & operator[] (CORBA::ULong index);

  private:
    PolicyValueSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const PolicyValueSeq_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_PolicyValueSeq;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_POLICIES;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong INVOCATION_POLICIES;

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

// valuetype class
  class ExceptionHolder;
  typedef ExceptionHolder *ExceptionHolder_ptr;

#if !defined (_MESSAGING_EXCEPTIONHOLDER___VAR_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___VAR_CH_

  class TAO_Export ExceptionHolder_var
  {
  public:
    ExceptionHolder_var (void); // default constructor
    ExceptionHolder_var (ExceptionHolder*);
    ExceptionHolder_var (const ExceptionHolder*); // (TAO extension)
    ExceptionHolder_var (const ExceptionHolder_var &); // copy constructor
    ~ExceptionHolder_var (void); // destructor

    ExceptionHolder_var &operator= (ExceptionHolder*);
    ExceptionHolder_var &operator= (const ExceptionHolder_var &);
    ExceptionHolder* operator-> (void) const;

    operator const ExceptionHolder* () const;
    operator ExceptionHolder* ();
    // in, inout, out, _retn
    ExceptionHolder* in (void) const;
    ExceptionHolder* &inout (void);
    ExceptionHolder* &out (void);
    ExceptionHolder* _retn (void);
    ExceptionHolder* ptr (void) const;

  private:
    ExceptionHolder* ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER___OUT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___OUT_CH_

  class TAO_Export ExceptionHolder_out
  {
  public:
    ExceptionHolder_out (ExceptionHolder* &);
    ExceptionHolder_out (ExceptionHolder_var &);
    ExceptionHolder_out (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_out &);
    ExceptionHolder_out &operator= (const ExceptionHolder_var &);
    ExceptionHolder_out &operator= (ExceptionHolder*);
    operator ExceptionHolder* &();
    ExceptionHolder* &ptr (void);
    ExceptionHolder* operator-> (void);

  private:
    ExceptionHolder* &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER___INIT_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___INIT_CH_

  class TAO_Export ExceptionHolder_init : public CORBA_ValueFactoryBase
  {
  public:
    virtual ~ExceptionHolder_init ();
    virtual const char* tao_repository_id (void);

    // create () goes here

  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_EXCEPTIONHOLDER_CH_)
#define _MESSAGING_EXCEPTIONHOLDER_CH_

  class TAO_Export ExceptionHolder : public virtual CORBA_ValueBase
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ExceptionHolder* _ptr_type;
    typedef ExceptionHolder_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    static ExceptionHolder* _downcast (CORBA::ValueBase* );
    // The address of static _downcast is implicit used as type id

    // (TAO extensions or internals)
    static CORBA::Boolean _tao_unmarshal (TAO_InputCDR &, ExceptionHolder *&);
    virtual const char* _tao_obv_repository_id () const;
    static const char* _tao_obv_static_repository_id ();
  public:
    virtual void is_system_exception (CORBA::Boolean) = 0;    // set
    virtual CORBA::Boolean is_system_exception (void) const = 0;     // get method

    virtual void byte_order (CORBA::Boolean) = 0;    // set
    virtual CORBA::Boolean byte_order (void) const = 0;     // get method


#if !defined (_MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET_CH_)
#define _MESSAGING_EXCEPTIONHOLDER__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release = 0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _marshaled_exception_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          virtual void marshaled_exception (const Messaging::ExceptionHolder::_tao_seq_Octet &) = 0;    // set
    virtual const Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void) const = 0;     // get method (read only)
    virtual Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void) = 0;     // get method (read/write only)


  protected:
    ExceptionHolder ();           // default constructor
    virtual ~ExceptionHolder ();

    // TAO internals
    virtual void *_tao_obv_narrow (ptr_arith_t);
    virtual CORBA::Boolean _tao_marshal_v (TAO_OutputCDR &);
    virtual CORBA::Boolean _tao_unmarshal_v (TAO_InputCDR &);

  private:
    ExceptionHolder (const ExceptionHolder &);
    void operator= (const ExceptionHolder &);

  protected:
    virtual CORBA::Boolean _tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &) = 0;
    virtual CORBA::Boolean _tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &) = 0;

  };

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER___PTR_CH_)
#define _MESSAGING_REPLYHANDLER___PTR_CH_

  class ReplyHandler;
  typedef ReplyHandler *ReplyHandler_ptr;

#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER___VAR_CH_)
#define _MESSAGING_REPLYHANDLER___VAR_CH_

  class TAO_Export ReplyHandler_var : public TAO_Base_var
  {
  public:
    ReplyHandler_var (void); // default constructor
    ReplyHandler_var (ReplyHandler_ptr p) : ptr_ (p) {}
    ReplyHandler_var (const ReplyHandler_var &); // copy constructor
    ~ReplyHandler_var (void); // destructor

    ReplyHandler_var &operator= (ReplyHandler_ptr);
    ReplyHandler_var &operator= (const ReplyHandler_var &);
    ReplyHandler_ptr operator-> (void) const;

    operator const ReplyHandler_ptr &() const;
    operator ReplyHandler_ptr &();
    // in, inout, out, _retn
    ReplyHandler_ptr in (void) const;
    ReplyHandler_ptr &inout (void);
    ReplyHandler_ptr &out (void);
    ReplyHandler_ptr _retn (void);
    ReplyHandler_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static ReplyHandler_ptr tao_duplicate (ReplyHandler_ptr);
    static void tao_release (ReplyHandler_ptr);
    static ReplyHandler_ptr tao_nil (void);
    static ReplyHandler_ptr tao_narrow (CORBA::Object * ACE_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    ReplyHandler_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ReplyHandler_var (const TAO_Base_var &rhs);
    ReplyHandler_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER___OUT_CH_)
#define _MESSAGING_REPLYHANDLER___OUT_CH_

  class TAO_Export ReplyHandler_out
  {
  public:
    ReplyHandler_out (ReplyHandler_ptr &);
    ReplyHandler_out (ReplyHandler_var &);
    ReplyHandler_out (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_out &);
    ReplyHandler_out &operator= (const ReplyHandler_var &);
    ReplyHandler_out &operator= (ReplyHandler_ptr);
    operator ReplyHandler_ptr &();
    ReplyHandler_ptr &ptr (void);
    ReplyHandler_ptr operator-> (void);

  private:
    ReplyHandler_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_MESSAGING_REPLYHANDLER_CH_)
#define _MESSAGING_REPLYHANDLER_CH_

  // Forward Classes Declaration
  class _TAO_ReplyHandler_Proxy_Impl;
  class _TAO_ReplyHandler_Remote_Proxy_Impl;
  class _TAO_ReplyHandler_Proxy_Broker;
  class _TAO_ReplyHandler_Remote_Proxy_Broker;

  class TAO_Export ReplyHandler : public virtual CORBA::Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ReplyHandler_ptr _ptr_type;
    typedef ReplyHandler_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static ReplyHandler_ptr _duplicate (ReplyHandler_ptr obj);
    static ReplyHandler_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyHandler_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    static ReplyHandler_ptr _nil (void)
      {
        return (ReplyHandler_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_ReplyHandler_Proxy_Broker *the_TAO_ReplyHandler_Proxy_Broker_;

  protected:
    ReplyHandler (int collocated = 0);

    protected:
      // This methods travese the inheritance tree and set the
      // parents piece of the given class in the right mode
      virtual void Messaging_ReplyHandler_setup_collocation (int collocated);

      ReplyHandler (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
        );

      friend class _TAO_ReplyHandler_Remote_Proxy_Impl;
      friend class _TAO_ReplyHandler_ThruPOA_Proxy_Impl;
      friend class _TAO_ReplyHandler_Direct_Proxy_Impl;

    virtual ~ReplyHandler (void);
  private:
    ReplyHandler (const ReplyHandler &);
    void operator= (const ReplyHandler &);
  };


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


  ///////////////////////////////////////////////////////////////////////
  //                    Base  Impl. Declaration
  //

  class TAO_Export _TAO_ReplyHandler_Proxy_Impl : public virtual TAO_Object_Proxy_Impl
  {
  public:
    virtual ~_TAO_ReplyHandler_Proxy_Impl (void) { }

    protected:
    _TAO_ReplyHandler_Proxy_Impl (void);

  };
  //
  //                Base  Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ReplyHandler_Remote_Proxy_Impl :
  public virtual _TAO_ReplyHandler_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl
{
public:
  _TAO_ReplyHandler_Remote_Proxy_Impl (void);

  virtual ~_TAO_ReplyHandler_Remote_Proxy_Impl (void) { }

  };

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ReplyHandler_Proxy_Broker
{
public:
  virtual ~_TAO_ReplyHandler_Proxy_Broker (void);
  virtual _TAO_ReplyHandler_Proxy_Impl &select_proxy (
    ReplyHandler *object
    ACE_ENV_ARG_DECL_WITH_DEFAULTS
  ) = 0;

protected:
  _TAO_ReplyHandler_Proxy_Broker (void);

};

//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ReplyHandler_Remote_Proxy_Broker : public virtual _TAO_ReplyHandler_Proxy_Broker
{
public:
  _TAO_ReplyHandler_Remote_Proxy_Broker (void);

  virtual ~_TAO_ReplyHandler_Remote_Proxy_Broker (void);

  virtual _TAO_ReplyHandler_Proxy_Impl &select_proxy (
    ReplyHandler *object
    ACE_ENV_ARG_DECL
  );

private:
  _TAO_ReplyHandler_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ReplyHandler_Remote_Proxy_Broker *the_TAO_ReplyHandler_Remote_Proxy_Broker (void);
};


//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ReplyHandler;

#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

}
TAO_NAMESPACE_CLOSE // module Messaging

// Proxy Broker Factory function pointer declarations.

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

extern TAO_Export
Messaging::_TAO_ReplyHandler_Proxy_Broker *
(*Messaging__TAO_ReplyHandler_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );

#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#if (TAO_HAS_AMI_CALLBACK == 1)

TAO_NAMESPACE  OBV_Messaging
{

#if !defined (_MESSAGING_EXCEPTIONHOLDER___OBV_CH_)
#define _MESSAGING_EXCEPTIONHOLDER___OBV_CH_

  // OBV_ class
  class TAO_Export ExceptionHolder : public virtual Messaging::ExceptionHolder
  {
  public:
    virtual void is_system_exception (CORBA::Boolean);    // set
    virtual CORBA::Boolean is_system_exception (void) const;     // get method

    virtual void byte_order (CORBA::Boolean);    // set
    virtual CORBA::Boolean byte_order (void) const;     // get method

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _marshaled_exception_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          virtual void marshaled_exception (const Messaging::ExceptionHolder::_tao_seq_Octet &);    // set
    virtual const Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void) const;     // get method (read only)
    virtual Messaging::ExceptionHolder::_tao_seq_Octet &marshaled_exception (void);     // get method (read/write only)


  protected:
    virtual CORBA::Boolean _tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &);
    virtual CORBA::Boolean _tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &);
    CORBA::Boolean _tao_marshal_state (TAO_OutputCDR &);
    CORBA::Boolean _tao_unmarshal_state (TAO_InputCDR &);


  private:
        CORBA::Boolean _pd_is_system_exception;
    CORBA::Boolean _pd_byte_order;
    _tao_seq_Octet _pd_marshaled_exception;
  };

#endif /* end #if !defined */

}
TAO_NAMESPACE_CLOSE

#endif /* TAO_HAS_AMI_CALLBACK == 1 */

#if (TAO_HAS_PRIORITY_POLICIES == 1)

TAO_Export void operator<<= (CORBA::Any &, const Messaging::PriorityRange &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::PriorityRange*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::PriorityRange *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::PriorityRange *&);

#endif /* TAO_HAS_PRIORITY_POLICIES == 1 */

#if (TAO_HAS_ROUTING_POLICY == 1)

TAO_Export void operator<<= (CORBA::Any &, const Messaging::RoutingTypeRange &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::RoutingTypeRange*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::RoutingTypeRange *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::RoutingTypeRange *&);

#endif /* TAO_HAS_ROUTING_POLICY == 1 */

TAO_Export void operator<<= (CORBA::Any &, const Messaging::PolicyValue &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::PolicyValue*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::PolicyValue *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::PolicyValue *&);
TAO_Export void operator<<= (CORBA::Any &, const Messaging::PolicyValueSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, Messaging::PolicyValueSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::PolicyValueSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const Messaging::PolicyValueSeq *&);

#if (TAO_HAS_AMI_CALLBACK == 1)

// Any operators for interface Messaging::ReplyHandler
TAO_Export void operator<<= (CORBA::Any &, Messaging::ReplyHandler_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, Messaging::ReplyHandler *&);

#endif /* TAO_HAS_AMI_CALLBACK */

#ifndef __ACE_INLINE__

#if (TAO_HAS_PRIORITY_POLICIES == 1)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::PriorityRange &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::PriorityRange &);

#endif /* TAO_HAS_PRIORITY_POLICIES == 1 */

#if (TAO_HAS_ROUTING_POLICY == 1)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::RoutingTypeRange &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::RoutingTypeRange &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::PolicyValue &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::PolicyValue &);

#endif /* TAO_HAS_ROUTING_POLICY == 1 */

#if !defined _TAO_CDR_OP_Messaging_PolicyValue__tao_seq_Octet_H_
#define _TAO_CDR_OP_Messaging_PolicyValue__tao_seq_Octet_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Messaging::PolicyValue::_tao_seq_Octet &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Messaging::PolicyValue::_tao_seq_Octet &
  );

#endif /* _TAO_CDR_OP_Messaging_PolicyValue__tao_seq_Octet_H_ */


#if !defined _TAO_CDR_OP_Messaging_PolicyValueSeq_H_
#define _TAO_CDR_OP_Messaging_PolicyValueSeq_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Messaging::PolicyValueSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Messaging::PolicyValueSeq &
  );

#endif /* _TAO_CDR_OP_Messaging_PolicyValueSeq_H_ */

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::ExceptionHolder *); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::ExceptionHolder *&);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Messaging::ReplyHandler_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Messaging::ReplyHandler_ptr &);

#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "MessagingC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#endif /* TAO_HAS_CORBA_MESSAGING == 1 */

#include "ace/post.h"
#endif /* ifndef */
