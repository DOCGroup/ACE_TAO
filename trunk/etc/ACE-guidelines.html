<!-- $Id$ -->

<html>
  <head>
    <title>ACE Implementation Guidelines</title>
    <link rev=made href="mailto:levine@cs.wustl.edu">
  </head>

<body>
<center>
  <h1>ACE Implementation Guidelines</h1>
  <font size=-1>
    Last modified <!--#echo var="LAST_MODIFIED" -->.<p>
  </font>
</center>
<h2>&nbsp</h2>

Thanks to Graham Dumpleton &lt;grahamd@nms.otc.com.au&gt; for providing
corrections to the OSE Classtools link and description.  Thanks also
to Graham for providing the OSE tools!<p>


<h3>Coding Guidelines</h3>
<ul>
  <li><strong>General</strong><p>
  <ul>
    <li>Every text file must end with a newline.<p>

    <li>Use spaces instead of tabs, except in Makefiles.  Emacs users
        can add this to their <strong>.emacs</strong>:

        <pre>(setq-default indent-tabs-mode nil)</pre></p>

        Microsoft Visual C++ users should do the following:

        <pre>
        Choose:  Tools -- Options -- Tabs
        Then Set:  "Tab size" to 8 and "Indent size" to 2, and
        indent using spaces.
        </pre><p>

    <li>Every program should have a ``usage'' message.  It should be
        printed out if erroneous command line arguments, or a
        <strong><code>-?</code></strong> command line argument, are
        provided to the program.<p>

    <li>The program <strong><code>main</code></strong> function should
        always be declared with arguments, e.g.,
        <pre>
        int
        main (int argc, char *argv[])
        {
          [...]

          return 0;
        }
        </pre><p>

        It should also return 0 on successful termination, and non-zero
        otherwise.<p>
  </ul>

  <li><strong>Code Documentation</strong><p>
  <ul>
    <li>Use comments and whitespace (:-) liberally.<p>

    <li>Insert a CVS/RCS keyword string at the top of every source file,
        Makefile, config file, <em>etc</em>.  For C++ files, it is:
        <pre>
        // $<!-- -->Id$
        </pre>
        It is not necessary to fill in the fields of the keyword string,
        or modify them when you edit a file that already has one.  CVS
        does that automatically when you checkout or update the file.<p>

        To insert that string at the top of a file:
        <pre>
        perl -pi -e 'if (! $o) {printf "// \$<!-- -->Id\$\n\n";}; $o = 1;' <em>file</em>
        </pre><p>

    <li>Comments, especially in header files, must follow the
        <a href=http://www.dscpl.com.au>OSE</a> Tools format requirements.
        Please see the ``Classinfo Tools'' section of the
        <a href=http://www.dscpl.com.au>OSE</a> ``Tools Manual''
        for these requirements.<p>

        Please note that the Classinfo tools in OSE have been developed
        independently since the copies in ACE were made and thus they
        support new features not supported in the ACE version of the tools.
        Certain subtle changes were also made in the ACE copies for
        indicating sections, <em>etc.</em>, which makes them different
        from the OSE documentation.  Please see the
        <a href=http://www.cs.wustl.edu/~schmidt/ACE-doctools.html>ACE-doctools
        page</a> for descriptions of these changes.<p>
  </ul>

  <li><strong>Preprocessor</strong><p>
  <ul>
    <li>Never #include standard headers directly, except in a few
        specific ACE files, <em>e.g.</em>, OS.h and stdcpp.h.  Let
        those files #include the correct headers.  If you do not do
        this, your code will not compile with the Standard C++ Library.<p>

    <li>Always follow a preprocessor <strong><code>#endif</code></strong>
        with a <strong><code>/*  */</code></strong> C-style comment.  It
        should correspond to the condition in the matching
        <strong><code>#if</code></strong> directive.  For example,
        <pre>
        #if defined (ACE_HAS_THREADS)
        # if defined (ACE_HAS_STHREADS)
        #   include /**/ &lt;synch.h&gt;
        #   include /**/ &lt;thread.h&gt;
        #   define ACE_SCOPE_PROCESS P_PID
        #   define ACE_SCOPE_LWP P_LWPID
        #   define ACE_SCOPE_THREAD (ACE_SCOPE_LWP + 1)
        # else
        #   define ACE_SCOPE_PROCESS 0
        #   define ACE_SCOPE_LWP 1
        #   define ACE_SCOPE_THREAD 2
        # endif /* ACE_HAS_STHREADS */
        #endif /* ACE_HAS_THREADS */
        </pre><p>

    <li>Always insert a <strong><code>/**/</code></strong> between an
        <strong><code>#include</code></strong> and
        <strong><code>filename</code></strong>, as shown in the above
        example.  This avoids dependency problems with Visual C++.<p>
  </ul>

  <li><strong>C++ Syntax and Constructs</strong><p>
  <ul>
    <li><strong><code>for</code></strong> loops should look like:
        <pre>
        for (size_t i = 0; i &lt; Options::instance ()-&gt;spawn_count (); i++)
          spawn ();
        </pre>
        (though I prefer to always wrap the body of the loop in braces,
         to avoid surprises when other code or debugging statements are
         added, and to maintain sanity when the body consists of a macro,
         such as ACE_ASSERT:)
        <pre>
        for (size_t i = 0; i &lt; Options::instance ()-&gt;spawn_count (); i++)
          {
            ACE_ASSERT (spawn () == 0);
          }
        </pre><p>

        Similarly, <strong><code>if</code></strong> statements should have
        a space after the ``<strong>if</strong>'', and no spaces just after
        the opening parenthesis and just before the closing parenthesis.<p>

    <li>Avoid unnecessary parenthesis.  We're not writing Lisp :-)<p>

    <li>Put inline member functions in a <strong><code>.i</code></strong>
        file.  That file is conditionally included by both the
        <strong><code>.h</code></strong> file, for example:<p>

            <pre>
            class ACE_Export ACE_High_Res_Timer
            {
              [...]
            };

            #if defined (__ACE_INLINE__)
            #include "ace/High_Res_Timer.i"
            #endif /* __ACE_INLINE__ */
            </pre><p>

        and <strong><code>.cpp</code></strong> file:<p>

            <pre>
            #define ACE_BUILD_DLL
            #include "ace/High_Res_Timer.h"

            #if !defined (__ACE_INLINE__)
            #include "ace/High_Res_Timer.i"
            #endif /* __ACE_INLINE__ */

            ACE_ALLOC_HOOK_DEFINE(ACE_High_Res_Timer)
            </pre><p>

        <strong>NOTE:</strong> It is very important to ensure than an
        inline function will not be used before its definition is seen.
        Therefore, the inline functions in the .i file should be arranged
        properly.  Some compilers, such as <code>g++</code> with the
        <code>-Wall</code> option, will issue warnings for violations.<p>

    <li>Mutators and accessors should be of this form:<p>

        <pre>
        void object_addr (const ACE_INET_Addr &);
        // Sets &lt;object_addr_&gt; cache from &lt;host&gt; and &lt;port&gt;.

        ACE_INET_Addr &object_addr (void);
        // Returns the &lt;ACE_INET_Addr&gt; for this profile.
        </pre><p>

        instead of the ``set_'' and ``get_'' form.<p>

    <li>Never use <strong><code>delete</code></strong> to deallocate
        memory that was allocated with <strong><code>malloc</code></strong>.
        Similarly, never associate <strong><code>free</code></strong> with
        <strong><code>new</code></strong>.
        <strong><code>ACE_NEW</code></strong> or
        <strong><code>ACE_NEW_RETURN</code></strong> should be used to
        allocate memory, and <strong><code>delete</code></strong> should
        be used to deallocate it.  And be careful to use the correct form,
        <strong><code>delete</code></strong> or
        <strong><code>delete []</code></strong> to correspond to the
        allocation.<p>

    <li>Always use <strong><code>ACE_NEW</code></strong> or
        <strong><code>ACE_NEW_RETURN</code></strong> to allocate memory,
        because they check for successful allocation and set errno
        appropriately if it fails.<p>

    <li>Never compare or assign a pointer value with <strong>NULL</strong>;
        use <strong>0</strong> instead.  The language allows any pointer to
        be compared or assigned with <strong>0</strong>.  The definition
        of <strong>NULL</strong> is implementation dependent, so it is
        difficult to use portably without casting.<p>

    <li>If a class has any virtual functions, and its destructor is
        declared explicitly in the class, then the destructor should
        <strong>always</strong> be virtual as well.  And to support
        compiler activities such as generation of virtual tables and,
        in some cases, template instantiation, the virtual destructor
        should <strong>not be inline</strong>.  (Actually, any non-pure
        virtual function could be made non-inline for this purpose.  But,
        for convenience, if its performance is not critical, it is usually
        easiest just to make the virtual destructor non-inline.)<p>

    <li>Be very careful when selecting an integer type that must be a
        certain size, <em>e.g.</em>, 4 bytes.  <strong>long</strong> is
        not 4 bytes on all platforms; it is 8 bytes on many 64-bit
        machines.  ACE_UINT32 is always 4 bytes, and ACE_hrtime_t is
        always 8 bytes.  (We should/may/will add an ACE_UINT64, soon.)<p>

    <li>Constructor initializers must appear in the same order as
        the data members are declared in the class header.  This avoids
        subtle errors, because initialization takes place in the order
        of member declaration.<p>

    <li>Initialization is usually cleaner than assignment, especially
        in a conditional.  So, instead of writing code like this:

        <pre>
        ssize_t n_bytes;

        // Send multicast of one byte, enough to wake up server.
        if ((n_bytes = multicast.send ((char *) &reply_port, sizeof reply_port)) == -1)
        </pre>

        Write it like this:

        <pre>
        ssize_t n_bytes = multicast.send ((char *) &reply_port, sizeof reply_port)

        // Send multicast of one byte, enough to wake up server.
        if (n_bytes == -1)
        </pre><p>

        But, beware if the initialization is of a static variable.
        A static variable is only initialized the first time its
        declaration is seen.  Of course, we should avoid using
        static variables at all.<p>

    <li>It is usually clearer to write conditionals that have
        both branches without a negated condition.  For example,<p>

        <pre>
        if (test)
          {
            // true branch
          }
        else
          {
            // false branch
          }
        </pre><p>

        is preferred over:<p>

        <pre>
        if (! test)
          {
            // false test branch
          }
        else
          {
            // true test branch
          }
        </pre><p>

    <li>If a cast is necessary, avoid use of ANSI-style casts,
        <em>e.g.</em>, <code>int (foo)</code>.  Instead, use
        the ACE_static_cast macro:

        <pre>
        return ACE_static_cast(size_t, this-&gt;count_) &gt; that-&gt;size_;
        </pre><p>

    <li>In general, if instances of a class should not be copied,
        then a private copy constructor and assignment operator should
        be declared for the class, but not implemented.  For example:

        <pre>
        // Disallow copying by not implementing the following . . .
        ACE_Object_Manager (const ACE_Object_Manager &);
        ACE_Object_Manager &operator= (const ACE_Object_Manager &);
        </pre><p>

        If the class is a template class, then the
        <code>ACE_UNIMPLEMENTED_FUNC</code> macro should be used:

        <pre>
        // = Disallow copying...
        ACE_UNIMPLEMENTED_FUNC (ACE_TSS (const ACE_TSS<TYPE> &))
        ACE_UNIMPLEMENTED_FUNC (void operator= (const ACE_TSS<TYPE> &))
        </pre><p>

        <code>ACE_UNIMPLEMENTED_FUNC</code> can be used with non-template
        classes as well.  Though for consistency and maximum safety, it
        should be avoided for non-template classes.<p>
  </ul>

  <li><strong>I/O</strong><p>
  <ul>
     <li>Use <strong><code>ACE_DEBUG</code></strong> for printouts,
         and <strong><code>ACE_OS::scanf/fprintf ()</code></strong> for
         file I/O.  Avoid using iostreams because of implementation
         differences across platforms.<p>
  </ul>
</ul><p>


<h3><a href="http://www.cs.wustl.edu/~schmidt/ACE-overview.html">ACE</a>
  Usage Guidelines</h3>
<ul>
  <li>Always use <strong><code>ACE_OS</code></strong> (static)
      member functions instead of bare OS system calls.<p>

  <li>Use the <strong><code>ACE_SYNCH_MUTEX</code></strong> macro,
      instead of using one of the specific mutexes, such as
      <strong><code>ACE_Thread_Mutex</code></strong>.  This provides
      portability between threaded and non-threaded platforms.<p>

  <li>Avoid creating a static instance of user-defined (class) type.
      Instead, either create it as an
      <strong><code>ACE_Singleton</code></strong>,
      <strong><code>ACE_TSS_Singleton</code></strong>, or as an
      <strong><code>ACE_Cleanup</code></strong> object.  See the
      <strong>ACE</strong>
      <a href="../ace/Singleton.h"><code>Singleton.h</code></a>,
      <a href="../ace/Object_Manager.h"><code>Object_Manager.h</code></a>, and
      <a href="../ace/Managed_Object.h"><code>Managed_Object.h</code></a>
      header files for more information.<p>

      Static instances of built-in types, such as
      <strong><code>int</code></strong> or any pointer type, are fine.<p>

      Construction of static instance of a user-defined type should
      <em>never</em> spawn threads.  Because order of construction of
      statics across files is not defined by the language, it is usually
      assumed that only one thread exists during static construction.
      This allows statics suchs as locks to be safely created.  We do not
      want to violate this assumption.<p>

  <li>Do not use run-time type identification (RTTI).  Some platforms
      do not support it.<p>

  <li>Do not use exception handling.  Some platforms do not support it.
      And, it imposes an execution speed penalty.<p>

  <li>Because ACE does not use exception handling, dealing with
      failures requires a bit of care.  This is especially true
      in constructors.  Consider the following approach:

      <pre>
      ACE_NEW_RETURN (this-&gt;name_space_, LOCAL_NAME_SPACE, -1);

      if (ACE_LOG_MSG-&gt;op_status () != 0)
      ....
      </pre>

      This snip of code is from
      <a href="../ace/Naming_Context.cpp"><code>ACE_Naming_Context</code></a>.
      All failed constructors in ACE (should) call ACE_ERROR.  This sets
      the thread specific <strong>op_status</strong>, which can be checked
      by the caller.  This mechanism allows the caller to check for a failed
      constructor without the requiring the constructor to throw
      exceptions.<p>

  <li>Avoid using the C++ Standard Template Library (STL) in our
      applications.  Some platforms do not support it yet.<p>
</ul><p>


<h3><a href="http://www.cs.wustl.edu/~schmidt/ACE-overview.html">ACE</a>
  Design Rules</h3>
<dl>
  <dt><strong>Initialization on first use is preferred over using static
      initializations, especially when creating OO class
      libraries.</strong>  <i>I.e.</i>, use Double Check Locking.
  <dd>This is a well known problem among OO C++ class designers.  See
      <em>Designing and Coding Reusable C++</em> by Caroll and Ellis,
      for example.<p>

  <dt>If you are parameterizing a searchable container template class
      with readers/writer locks, do not use sentinels or any state
      that requires updating during a a search.
  <dd>....<p>

  <dt>In multi-threaded objects, all methods should be re-entrant..<p>

  <dt>Framework users should always use wrappers instead of directly
      making system calls.
  <dd>....<p>

  <dt>Always guard against multiple inclusion of header files..<p>

  <dt>Templates may require source.  Hence, source files may need to
      be guarded against multiple inclusion too.
  <dt>Template classes should not be mixed with non-template classes..<p>

  <dt>Guard against quirky compiler implementations through #define
      abstractions (whereever possible)..<p>

  <dt>Use consistent error-handling..<p>

  <dt>Abstract away different representations of handles / file
      descriptors..<p>

  <dt>Avoid the use of global functions..<p>

  <dt>If functions are required, place them within a namespace or
      nested in a class..<p>

  <dt>Avoid polluting the namespace..<p>

  <dt>Don't use the inline keyword directly..<p>

  <dt>Separate inline code into their own implementation files.
      <i>I.e.</i> do not write code in header files..<p>

  <dt>(Internationalization) Do not use the char type directly.
      Abstract it for wide characters.  Thus, do not assume your
      character abstraction is a single byte..<p>

  <dt>Don't use conditional compilation based on compiler/OS/hardware
      platform, but upon available features..<p>

  <dt>Centralize portability #ifdefs in a single place to ease
      portability maintainence..<p>

  <dt>Either check or return all return values (from framework
      calls)..<p>

  <dt>Apply strategy pattern to factor out common sources of variation
      in a component..<p>

  <dt>Use traits to merge multiple template arguments..<p>

  <dt>Allow customization of memory allocation.<p>

  <dt>Instrument framework methods to allow for run-time tracing.<p>

  <dt>Avoid long chains of dereference operators.<p>

  <dt>Use open() methods rather than constructors.
  <p>

  <dt>Instrument a dump() method in every object.
  <p>


  <dt>Qualify references to base class methods and data.  <i>I.e.</i>,
      anything outside the scope of the class.

  <p>

  <dt>Guard against multiple open() and close() calls, for
      idempotency.

  <p>

  <dt>The state of an object does not need to be guarded in
      destructors.

  <p>

  <dt>Base classes should not store information about derived
      classes.

  <p>

  <dt>Don't make static objects whose correctness depends on
      constructors being called.  (That is, if 0 initialization is not
      sufficient.)

  <p>

  <dt>Guarantee singleton destruction.  <i>E.g.</i>, provide
      hooks that allow singletons to be deleted before the process
      exits.

  <p>

  <dt>All uses of the placement new operator must be accompanied by a
      corresponding explicit destructor call.

  <p>

  <dt>In classes that require locking, have public methods acquire the
      locks and call protected/private methods that do not acquire the
      locks.

  <p>

  <dt>Try to minimize the number of template parameters passed to a
      base class.  Try to have a base class that is not a template,
      from which specialized classes can be derived that may have
      template parameters.

  <p>

  <dt>Define wrappers around clusters of functionality that are
      semantically the same but may have accidental
      incompatibilities.  <i>E.g.</i>, semaphores, readers/writer
      locks, mutex + condition variables, which can be used by
      threads, processes, that may or may not reside on the same
      machine.

  <p>

  <dt>Define generic components that can be parameterized by the
      wrappers defined above (in the previous point).

  <p>

  <dt>Separate creation from use.  <i>E.g.</i>, acceptor/connector and
      service handler.

  <p>

  <dt>In searchable containers, separate traversal logic from item
      operations.

  <p>

  <dt>...
</dl><p>

<h3><a href="http://www.cs.wustl.edu/~levine/CVS.html">CVS</a>
  Usage Guidelines</h3>
<ul>
  <li>Always make sure that a change builds and executes correctly
      on at least one platform before checking it into the CVS repository.<p>
</ul><p>


<h3>Software Engineering Guidelines</h3>
<ul>
  <li>Advise:  keep other developers informed of problems and progress.<p>

  <li>Authorize:  we have contractual obligations to not unilaterally
      change interfaces.  If you need to change or remove an interface,
      get an OK.<p>

  <li>Minimize risk:  Test all changes.  Solicit review of changes.<p>

  <li>Revise only when necessary:  every change has risk, so avoid making
      changes unless there is a good reason for the change.<p>
</ul><p>


<hr>
<!-- hhmts start -->
Last modified: Fri Dec  5 17:29:17 CST 1997
<!-- hhmts end -->

</body>
</html>
