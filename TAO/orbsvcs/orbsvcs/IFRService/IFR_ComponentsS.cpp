// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_COMPONENTSS_CPP_
#define _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_COMPONENTSS_CPP_

#include "IFR_ComponentsS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#include "tao/PortableServer/ServerInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"
#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ComponentsS.i"
#endif /* !defined INLINE */

class TAO_IR_ComponentRepository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:23 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentRepository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 11,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 25,
     66,  0, 31, 15, 66, 10, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 25,  0, 30,
     66, 25, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66,  0,  5, 66, 66, 66,  0, 20, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66,
#else
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 11, 66, 25, 66,  0,
     31, 15, 66, 10, 66, 66, 66, 66, 25,  0,
     30, 66, 25, 66, 66,  0,  5, 66, 66, 66,
      0, 20, 66, 66, 66, 66, 66, 66,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 32,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 8,
      MAX_HASH_VALUE = 65,
      HASH_VALUE_RANGE = 58,
      DUPLICATES = 2,
      WORDLIST_SIZE = 40
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"contents",      &POA_IR::ComponentRepository::contents_skel},
      {"create_enum",   &POA_IR::ComponentRepository::create_enum_skel},
      {"create_alias",  &POA_IR::ComponentRepository::create_alias_skel},
      {"create_value_box",      &POA_IR::ComponentRepository::create_value_box_skel},
      {"create_struct",         &POA_IR::ComponentRepository::create_struct_skel},
      {"create_constant",       &POA_IR::ComponentRepository::create_constant_skel},
      {"create_component",      &POA_IR::ComponentRepository::create_component_skel},
      {"create_string",         &POA_IR::ComponentRepository::create_string_skel},
      {"create_wstring",        &POA_IR::ComponentRepository::create_wstring_skel},
      {"create_home",   &POA_IR::ComponentRepository::create_home_skel},
      {"create_value",  &POA_IR::ComponentRepository::create_value_skel},
      {"create_module",         &POA_IR::ComponentRepository::create_module_skel},
      {"create_native",         &POA_IR::ComponentRepository::create_native_skel},
      {"_non_existent",  &POA_IR::ComponentRepository::_non_existent_skel},
      {"create_sequence",       &POA_IR::ComponentRepository::create_sequence_skel},
      {"create_interface",      &POA_IR::ComponentRepository::create_interface_skel},
      {"create_array",  &POA_IR::ComponentRepository::create_array_skel},
      {"_interface",  &POA_IR::ComponentRepository::_interface_skel},
      {"create_local_interface",        &POA_IR::ComponentRepository::create_local_interface_skel},
      {"get_primitive",         &POA_IR::ComponentRepository::get_primitive_skel},
      {"create_abstract_interface",     &POA_IR::ComponentRepository::create_abstract_interface_skel},
      {"_is_a",  &POA_IR::ComponentRepository::_is_a_skel},
      {"create_union",  &POA_IR::ComponentRepository::create_union_skel},
      {"create_fixed",  &POA_IR::ComponentRepository::create_fixed_skel},
      {"create_exception",      &POA_IR::ComponentRepository::create_exception_skel},
      {"get_canonical_typecode",        &POA_IR::ComponentRepository::get_canonical_typecode_skel},
      {"describe_contents",     &POA_IR::ComponentRepository::describe_contents_skel},
      {"lookup_name",   &POA_IR::ComponentRepository::lookup_name_skel},
      {"_get_def_kind",         &POA_IR::ComponentRepository::_get_def_kind_skel},
      {"lookup",        &POA_IR::ComponentRepository::lookup_skel},
      {"destroy",       &POA_IR::ComponentRepository::destroy_skel},
      {"lookup_id",     &POA_IR::ComponentRepository::lookup_id_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   8,  -1,  -1,   9,  10,  -1,
      -19,  -2,  11,  -1,  12,  -1,  13,  14,  -1,  15,  16,  -1,  17,  18,
      -79,  21,  22,  23,  24,  -1,  -1,  -1,  25,  26,  27,  -1,  28,  29,
       30,  31,  -1,  -1,  32,  33,  34,  -1,  -1,  35,  -1,  -1,  -1,  36,
       37,  -1,  38,  -1,  -1,  -1,  -1,  -1,  -1,  39,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:24 */
static TAO_IR_ComponentRepository_Perfect_Hash_OpTable tao_IR_ComponentRepository_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_ComponentRepository_create_component : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_component (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentRepository *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_component (const TAO_ServerRequestInfo_IR_ComponentRepository_create_component &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentRepository_create_component &);

private:
  POA_IR::ComponentRepository *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  IR::ComponentDef_ptr base_component_;
  const CORBA_InterfaceDefSeq & supports_interfaces_;
  IR::ComponentDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentRepository_create_component::TAO_ServerRequestInfo_IR_ComponentRepository_create_component (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_component_ (base_component),
    supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->supports_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentRepository_create_home : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_home (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentRepository *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_home (const TAO_ServerRequestInfo_IR_ComponentRepository_create_home &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentRepository_create_home &);

private:
  POA_IR::ComponentRepository *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  IR::HomeDef_ptr base_home_;
  IR::ComponentDef_ptr managed_component_;
  CORBA_ValueDef_ptr primary_key_;
  IR::HomeDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentRepository_create_home::TAO_ServerRequestInfo_IR_ComponentRepository_create_home (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_home_ (base_home),
    managed_component_ (managed_component),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (6);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_home_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->managed_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->primary_key_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::result (IR::HomeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::~_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_ComponentRepository_Proxy_Impl&
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::select_proxy (
    ::IR::ComponentRepository *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ComponentRepository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ComponentRepository_Proxy_Broker *
IR__TAO_ComponentRepository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker();
}

int
IR__TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer =
    IR__TAO_ComponentRepository_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_ComponentRepository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ComponentRepository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::_TAO_ComponentRepository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::ComponentDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_component",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_component (
        id,
        name,
        version,
        base_component,
        supports_interfaces
        ACE_ENV_ARG_PARAMETER
      );
}

IR::HomeDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_home",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_home (
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key
        ACE_ENV_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentRepository::ComponentRepository (void)
{
  this->optable_ = &tao_IR_ComponentRepository_optable;
}

// copy ctor
POA_IR::ComponentRepository::ComponentRepository (const ComponentRepository& rhs)
  :   POA_CORBA_Repository (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentRepository::~ComponentRepository (void)
{
}

void POA_IR::ComponentRepository::create_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl =
    ACE_static_cast (POA_IR::ComponentRepository *, _tao_object_reference);

    IR::ComponentDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ComponentDef_var base_component;
  CORBA_InterfaceDefSeq supports_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_component.out ()) &&
    (_tao_in >> supports_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentRepository_create_component ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_component.in (),
      supports_interfaces
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_component (
          id.in (),
          name.in (),
          version.in (),
          base_component.in (),
          supports_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentRepository::create_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl =
    ACE_static_cast (POA_IR::ComponentRepository *, _tao_object_reference);

    IR::HomeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::HomeDef_var base_home;
  IR::ComponentDef_var managed_component;
  CORBA_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_home.out ()) &&
    (_tao_in >> managed_component.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentRepository_create_home ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_home.in (),
      managed_component.in (),
      primary_key.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_home (
          id.in (),
          name.in (),
          version.in (),
          base_home.in (),
          managed_component.in (),
          primary_key.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::HomeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentRepository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ComponentRepository::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentRepository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentRepository:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentRepository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Repository:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentRepository::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentRepository*
POA_IR::ComponentRepository::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::ComponentRepository::_unchecked_narrow (obj.in ());
}


class TAO_IR_ProvidesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:24 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ProvidesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 21
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ProvidesDef::move_skel},
      {"_is_a",  &POA_IR::ProvidesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ProvidesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ProvidesDef::_set_id_skel},
      {"describe",      &POA_IR::ProvidesDef::describe_skel},
      {"_get_name",     &POA_IR::ProvidesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ProvidesDef::_set_name_skel},
      {"_interface",  &POA_IR::ProvidesDef::_interface_skel},
      {"_get_version",  &POA_IR::ProvidesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ProvidesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ProvidesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ProvidesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ProvidesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ProvidesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::ProvidesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::ProvidesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ProvidesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  49,   8, -45,  11,  -1, -46,  14,
       -1,  15,  -1,  16,  17,  18,  -6,  -2,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:24 */
static TAO_IR_ProvidesDef_Perfect_Hash_OpTable tao_IR_ProvidesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ProvidesDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (const TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get &);

private:
  POA_IR::ProvidesDef *_tao_impl;
  CORBA_InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ProvidesDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::~_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_ProvidesDef_Proxy_Impl&
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::ProvidesDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ProvidesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ProvidesDef_Proxy_Broker *
IR__TAO_ProvidesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_ProvidesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_ProvidesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::_TAO_ProvidesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->interface_type (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ProvidesDef::ProvidesDef (void)
{
  this->optable_ = &tao_IR_ProvidesDef_optable;
}

// copy ctor
POA_IR::ProvidesDef::ProvidesDef (const ProvidesDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ProvidesDef::~ProvidesDef (void)
{
}

void POA_IR::ProvidesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ProvidesDef *_tao_impl =
    ACE_static_cast (POA_IR::ProvidesDef *, _tao_object_reference);

    CORBA_InterfaceDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->interface_type (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ProvidesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ProvidesDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ProvidesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ProvidesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ProvidesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ProvidesDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR::ProvidesDef*
POA_IR::ProvidesDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::ProvidesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_UsesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:25 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UsesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UsesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UsesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UsesDef::move_skel},
      {"_is_a",  &POA_IR::UsesDef::_is_a_skel},
      {"_get_id",       &POA_IR::UsesDef::_get_id_skel},
      {"_set_id",       &POA_IR::UsesDef::_set_id_skel},
      {"describe",      &POA_IR::UsesDef::describe_skel},
      {"_get_name",     &POA_IR::UsesDef::_get_name_skel},
      {"_set_name",     &POA_IR::UsesDef::_set_name_skel},
      {"_interface",  &POA_IR::UsesDef::_interface_skel},
      {"_get_version",  &POA_IR::UsesDef::_get_version_skel},
      {"_set_version",  &POA_IR::UsesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::UsesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::UsesDef::_get_defined_in_skel},
      {"_get_is_multiple",      &POA_IR::UsesDef::_get_is_multiple_skel},
      {"destroy",       &POA_IR::UsesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::UsesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::UsesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::UsesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UsesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  49,   8, -45,  11,  -1, -46,  14,
       -1,  15,  16,  17,  18,  19,  -6,  -2,  -1,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:25 */
static TAO_IR_UsesDef_Perfect_Hash_OpTable tao_IR_UsesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_UsesDef_interface_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::UsesDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (const TAO_ServerRequestInfo_IR_UsesDef_interface_type_get &);
  void operator= (const TAO_ServerRequestInfo_IR_UsesDef_interface_type_get &);

private:
  POA_IR::UsesDef *_tao_impl;
  CORBA_InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::UsesDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::UsesDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (const TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get &);
  void operator= (const TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get &);

private:
  POA_IR::UsesDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::UsesDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker *POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::~_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_UsesDef_Proxy_Impl&
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::UsesDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_UsesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_UsesDef_Proxy_Broker *
IR__TAO_UsesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_UsesDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_UsesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_UsesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_UsesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_UsesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::_TAO_UsesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->interface_type (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA::Boolean POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_multiple",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->is_multiple (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::UsesDef::UsesDef (void)
{
  this->optable_ = &tao_IR_UsesDef_optable;
}

// copy ctor
POA_IR::UsesDef::UsesDef (const UsesDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UsesDef::~UsesDef (void)
{
}

void POA_IR::UsesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::UsesDef *_tao_impl =
    ACE_static_cast (POA_IR::UsesDef *, _tao_object_reference);

    CORBA_InterfaceDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_UsesDef_interface_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->interface_type (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::UsesDef::_get_is_multiple_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::UsesDef *_tao_impl =
    ACE_static_cast (POA_IR::UsesDef *, _tao_object_reference);

    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_multiple (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::UsesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::UsesDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::UsesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UsesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UsesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UsesDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR::UsesDef*
POA_IR::UsesDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::UsesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_EventDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:25 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EventDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EventDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EventDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EventDef::move_skel},
      {"_is_a",  &POA_IR::EventDef::_is_a_skel},
      {"_get_id",       &POA_IR::EventDef::_get_id_skel},
      {"_set_id",       &POA_IR::EventDef::_set_id_skel},
      {"describe",      &POA_IR::EventDef::describe_skel},
      {"_get_name",     &POA_IR::EventDef::_get_name_skel},
      {"_set_name",     &POA_IR::EventDef::_set_name_skel},
      {"_interface",  &POA_IR::EventDef::_interface_skel},
      {"_get_version",  &POA_IR::EventDef::_get_version_skel},
      {"_set_version",  &POA_IR::EventDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EventDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EventDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EventDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EventDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EventDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EventDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EventDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EventDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14,
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:25 */
static TAO_IR_EventDef_Perfect_Hash_OpTable tao_IR_EventDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_EventDef_is_a : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_EventDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::EventDef *tao_impl
    ,
    const char * event_id
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_EventDef_is_a (const TAO_ServerRequestInfo_IR_EventDef_is_a &);
  void operator= (const TAO_ServerRequestInfo_IR_EventDef_is_a &);

private:
  POA_IR::EventDef *_tao_impl;
  const char * event_id_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_EventDef_is_a::TAO_ServerRequestInfo_IR_EventDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::EventDef *tao_impl,
    const char * event_id
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    event_id_ (event_id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_EventDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= event_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_EventDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_EventDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_EventDef_is_a::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_EventDef_is_a::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_EventDef_event_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_EventDef_event_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::EventDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_EventDef_event_get (const TAO_ServerRequestInfo_IR_EventDef_event_get &);
  void operator= (const TAO_ServerRequestInfo_IR_EventDef_event_get &);

private:
  POA_IR::EventDef *_tao_impl;
  CORBA_ValueDef_ptr _result;
};

TAO_ServerRequestInfo_IR_EventDef_event_get::TAO_ServerRequestInfo_IR_EventDef_event_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::EventDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_EventDef_event_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_EventDef_event_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_EventDef_event_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_EventDef_event_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_EventDef_event_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_EventDef_event_get::result (CORBA_ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker *POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EventDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::~_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_EventDef_Proxy_Impl&
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::EventDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_EventDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_EventDef_Proxy_Broker *
IR__TAO_EventDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker();
}

int
IR__TAO_EventDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_EventDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_EventDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_EventDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_EventDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::_TAO_EventDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->is_a (
        event_id
        ACE_ENV_ARG_PARAMETER
      );
}

CORBA_ValueDef_ptr POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "event",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->event (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EventDef::EventDef (void)
{
  this->optable_ = &tao_IR_EventDef_optable;
}

// copy ctor
POA_IR::EventDef::EventDef (const EventDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EventDef::~EventDef (void)
{
}

void POA_IR::EventDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl =
    ACE_static_cast (POA_IR::EventDef *, _tao_object_reference);

    CORBA::Boolean _tao_retval = 0;
  CORBA::String_var event_id;
  if (!(
    (_tao_in >> event_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_EventDef_is_a ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      event_id.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          event_id.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::EventDef::_get_event_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::EventDef *_tao_impl =
    ACE_static_cast (POA_IR::EventDef *, _tao_object_reference);

    CORBA_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_EventDef_event_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->event (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::EventDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::EventDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::EventDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EventDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

IR::EventDef*
POA_IR::EventDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::EventDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_EmitsDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:26 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EmitsDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EmitsDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EmitsDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EmitsDef::move_skel},
      {"_is_a",  &POA_IR::EmitsDef::_is_a_skel},
      {"_get_id",       &POA_IR::EmitsDef::_get_id_skel},
      {"_set_id",       &POA_IR::EmitsDef::_set_id_skel},
      {"describe",      &POA_IR::EmitsDef::describe_skel},
      {"_get_name",     &POA_IR::EmitsDef::_get_name_skel},
      {"_set_name",     &POA_IR::EmitsDef::_set_name_skel},
      {"_interface",  &POA_IR::EmitsDef::_interface_skel},
      {"_get_version",  &POA_IR::EmitsDef::_get_version_skel},
      {"_set_version",  &POA_IR::EmitsDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EmitsDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EmitsDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EmitsDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EmitsDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EmitsDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EmitsDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EmitsDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EmitsDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14,
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:26 */
static TAO_IR_EmitsDef_Perfect_Hash_OpTable tao_IR_EmitsDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker *POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::~_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_EmitsDef_Proxy_Impl&
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::EmitsDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_EmitsDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_EmitsDef_Proxy_Broker *
IR__TAO_EmitsDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker();
}

int
IR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_EmitsDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_EmitsDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl::_TAO_EmitsDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EmitsDef::EmitsDef (void)
{
  this->optable_ = &tao_IR_EmitsDef_optable;
}

// copy ctor
POA_IR::EmitsDef::EmitsDef (const EmitsDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EmitsDef::~EmitsDef (void)
{
}

void POA_IR::EmitsDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::EmitsDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::EmitsDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EmitsDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EmitsDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EmitsDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

IR::EmitsDef*
POA_IR::EmitsDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::EmitsDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_PublishesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:26 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PublishesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PublishesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PublishesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PublishesDef::move_skel},
      {"_is_a",  &POA_IR::PublishesDef::_is_a_skel},
      {"_get_id",       &POA_IR::PublishesDef::_get_id_skel},
      {"_set_id",       &POA_IR::PublishesDef::_set_id_skel},
      {"describe",      &POA_IR::PublishesDef::describe_skel},
      {"_get_name",     &POA_IR::PublishesDef::_get_name_skel},
      {"_set_name",     &POA_IR::PublishesDef::_set_name_skel},
      {"_interface",  &POA_IR::PublishesDef::_interface_skel},
      {"_get_version",  &POA_IR::PublishesDef::_get_version_skel},
      {"_set_version",  &POA_IR::PublishesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::PublishesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PublishesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::PublishesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::PublishesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::PublishesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::PublishesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::PublishesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PublishesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14,
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:26 */
static TAO_IR_PublishesDef_Perfect_Hash_OpTable tao_IR_PublishesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker *POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::~_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_PublishesDef_Proxy_Impl&
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::PublishesDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_PublishesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_PublishesDef_Proxy_Broker *
IR__TAO_PublishesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_PublishesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_PublishesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl::_TAO_PublishesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PublishesDef::PublishesDef (void)
{
  this->optable_ = &tao_IR_PublishesDef_optable;
}

// copy ctor
POA_IR::PublishesDef::PublishesDef (const PublishesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PublishesDef::~PublishesDef (void)
{
}

void POA_IR::PublishesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::PublishesDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::PublishesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PublishesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PublishesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PublishesDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

IR::PublishesDef*
POA_IR::PublishesDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::PublishesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_ConsumesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:27 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConsumesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConsumesDef::move_skel},
      {"_is_a",  &POA_IR::ConsumesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConsumesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConsumesDef::_set_id_skel},
      {"describe",      &POA_IR::ConsumesDef::describe_skel},
      {"_get_name",     &POA_IR::ConsumesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ConsumesDef::_set_name_skel},
      {"_interface",  &POA_IR::ConsumesDef::_interface_skel},
      {"_get_version",  &POA_IR::ConsumesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConsumesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConsumesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::ConsumesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::ConsumesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConsumesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConsumesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::ConsumesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::ConsumesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConsumesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14,
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:27 */
static TAO_IR_ConsumesDef_Perfect_Hash_OpTable tao_IR_ConsumesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::~_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_ConsumesDef_Proxy_Impl&
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::ConsumesDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ConsumesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ConsumesDef_Proxy_Broker *
IR__TAO_ConsumesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_ConsumesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_ConsumesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl::_TAO_ConsumesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ConsumesDef::ConsumesDef (void)
{
  this->optable_ = &tao_IR_ConsumesDef_optable;
}

// copy ctor
POA_IR::ConsumesDef::ConsumesDef (const ConsumesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConsumesDef::~ConsumesDef (void)
{
}

void POA_IR::ConsumesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ConsumesDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ConsumesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConsumesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConsumesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConsumesDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

IR::ConsumesDef*
POA_IR::ConsumesDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::ConsumesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_ComponentDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:27 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108,   0,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108,   0,
     108,  51,  30,  20, 108, 108, 108,   0, 108, 108,
     108, 108, 108, 108, 108, 108, 108,   5,  15,  40,
     108,   0, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108,   0,  15, 108, 108, 108,   5,   5, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108,
#else
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108,   0, 108,   0, 108,  51,
      30,  20, 108, 108, 108,   0, 108, 108,   5,  15,
      40, 108,   0, 108, 108,   0,  15, 108, 108, 108,
       5,   5, 108, 108, 108, 108, 108, 108,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 54,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 107,
      HASH_VALUE_RANGE = 104,
      DUPLICATES = 14,
      WORDLIST_SIZE = 58
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::ComponentDef::is_a_skel},
      {"_is_a",  &POA_IR::ComponentDef::_is_a_skel},
      {"lookup",        &POA_IR::ComponentDef::lookup_skel},
      {"_get_emits_events",     &POA_IR::ComponentDef::_get_emits_events_skel},
      {"_get_uses_interfaces",  &POA_IR::ComponentDef::_get_uses_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::ComponentDef::_set_base_interfaces_skel},
      {"_get_base_interfaces",  &POA_IR::ComponentDef::_get_base_interfaces_skel},
      {"_get_consumes_events",  &POA_IR::ComponentDef::_get_consumes_events_skel},
      {"_get_publishes_events",         &POA_IR::ComponentDef::_get_publishes_events_skel},
      {"_get_provides_interfaces",      &POA_IR::ComponentDef::_get_provides_interfaces_skel},
      {"_get_supported_interfaces",     &POA_IR::ComponentDef::_get_supported_interfaces_skel},
      {"_set_supported_interfaces",     &POA_IR::ComponentDef::_set_supported_interfaces_skel},
      {"_non_existent",  &POA_IR::ComponentDef::_non_existent_skel},
      {"_get_name",     &POA_IR::ComponentDef::_get_name_skel},
      {"_get_type",     &POA_IR::ComponentDef::_get_type_skel},
      {"_set_name",     &POA_IR::ComponentDef::_set_name_skel},
      {"_interface",  &POA_IR::ComponentDef::_interface_skel},
      {"_get_containing_repository",    &POA_IR::ComponentDef::_get_containing_repository_skel},
      {"_get_base_component",   &POA_IR::ComponentDef::_get_base_component_skel},
      {"lookup_name",   &POA_IR::ComponentDef::lookup_name_skel},
      {"_get_id",       &POA_IR::ComponentDef::_get_id_skel},
      {"_set_id",       &POA_IR::ComponentDef::_set_id_skel},
      {"_get_absolute_name",    &POA_IR::ComponentDef::_get_absolute_name_skel},
      {"move",  &POA_IR::ComponentDef::move_skel},
      {"destroy",       &POA_IR::ComponentDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ComponentDef::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::ComponentDef::describe_contents_skel},
      {"_get_version",  &POA_IR::ComponentDef::_get_version_skel},
      {"_set_version",  &POA_IR::ComponentDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::ComponentDef::_get_defined_in_skel},
      {"describe",      &POA_IR::ComponentDef::describe_skel},
      {"contents",      &POA_IR::ComponentDef::contents_skel},
      {"create_uses",   &POA_IR::ComponentDef::create_uses_skel},
      {"create_emits",  &POA_IR::ComponentDef::create_emits_skel},
      {"create_alias",  &POA_IR::ComponentDef::create_alias_skel},
      {"_get_is_basic",         &POA_IR::ComponentDef::_get_is_basic_skel},
      {"create_provides",       &POA_IR::ComponentDef::create_provides_skel},
      {"create_consumes",       &POA_IR::ComponentDef::create_consumes_skel},
      {"create_publishes",      &POA_IR::ComponentDef::create_publishes_skel},
      {"describe_interface",    &POA_IR::ComponentDef::describe_interface_skel},
      {"create_value_box",      &POA_IR::ComponentDef::create_value_box_skel},
      {"create_enum",   &POA_IR::ComponentDef::create_enum_skel},
      {"create_struct",         &POA_IR::ComponentDef::create_struct_skel},
      {"create_constant",       &POA_IR::ComponentDef::create_constant_skel},
      {"create_value",  &POA_IR::ComponentDef::create_value_skel},
      {"create_module",         &POA_IR::ComponentDef::create_module_skel},
      {"create_native",         &POA_IR::ComponentDef::create_native_skel},
      {"create_attribute",      &POA_IR::ComponentDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ComponentDef::create_interface_skel},
      {"create_local_interface",        &POA_IR::ComponentDef::create_local_interface_skel},
      {"create_abstract_interface",     &POA_IR::ComponentDef::create_abstract_interface_skel},
      {"create_union",  &POA_IR::ComponentDef::create_union_skel},
      {"create_operation",      &POA_IR::ComponentDef::create_operation_skel},
      {"create_exception",      &POA_IR::ComponentDef::create_exception_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -1,   -1,    4,    5,   -1,   -1,   -1,   -1,   -1,    6,   -1,   -1,
        -1,   -1,   -1,    7,   -8,   -4, -109,   12,  -14,   -2,   13, -110,  -17,   -3,
        16, -110,   20,   21,  -24,   -2,   22,   -1,   23, -112,   26,   27,   -1,   -1,
        28,   29,   -1,   -1,   -1,   30,   -1,   -1,  -31,   -2, -109,   -1,   -1,   33,
       -37,   -2,   34,   35,  -40,   -2,   36, -114,   39,   -1, -113,   42,   43,   -1,
        -1,   -1,   44,   -1,   -1,  -49,   -2,   45,   -1,   46,   -1,   47,   -1,   48,
      -116,  -51,   -2, -109,   -1,   -1,   -1,   -1,   -1,   53,   -1,   -1,   54,   -1,
        -1,   -1,   -1,   -1,   -1,   55,   -1,  -56,   -2, -109,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:28 */
static TAO_IR_ComponentDef_Perfect_Hash_OpTable tao_IR_ComponentDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  CORBA_InterfaceDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA_InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl
    ,
    const CORBA_InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set &);

private:
  POA_IR::ComponentDef *_tao_impl;
  const CORBA_InterfaceDefSeq & supported_interfaces_;

};

TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl,
    const CORBA_InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_IR_ComponentDef_base_component_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (const TAO_ServerRequestInfo_IR_ComponentDef_base_component_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_base_component_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  IR::ComponentDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (const TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  IR::ProvidesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR::ProvidesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (const TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  IR::UsesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR::UsesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (const TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  IR::EmitsDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::result (IR::EmitsDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (const TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  IR::PublishesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::result (IR::PublishesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (const TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  IR::ConsumesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::result (IR::ConsumesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (const TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get &);

private:
  POA_IR::ComponentDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_provides : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_provides (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_provides (const TAO_ServerRequestInfo_IR_ComponentDef_create_provides &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_provides &);

private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  IR::ProvidesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_provides::TAO_ServerRequestInfo_IR_ComponentDef_create_provides (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::result (IR::ProvidesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_uses : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_uses (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_uses (const TAO_ServerRequestInfo_IR_ComponentDef_create_uses &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_uses &);

private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  const CORBA::Boolean & is_multiple_;
  IR::UsesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_uses::TAO_ServerRequestInfo_IR_ComponentDef_create_uses (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type),
    is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::result (IR::UsesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_emits : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_emits (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_emits (const TAO_ServerRequestInfo_IR_ComponentDef_create_emits &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_emits &);

private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::EmitsDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_emits::TAO_ServerRequestInfo_IR_ComponentDef_create_emits (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::result (IR::EmitsDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_publishes : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (const TAO_ServerRequestInfo_IR_ComponentDef_create_publishes &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_publishes &);

private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::PublishesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::result (IR::PublishesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_consumes : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::ComponentDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (const TAO_ServerRequestInfo_IR_ComponentDef_create_consumes &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_consumes &);

private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::ConsumesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::result (IR::ConsumesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::~_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_ComponentDef_Proxy_Impl&
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::ComponentDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ComponentDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ComponentDef_Proxy_Broker *
IR__TAO_ComponentDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker();
}

int
IR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_ComponentDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_ComponentDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::_TAO_ComponentDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

void POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces
        ACE_ENV_ARG_PARAMETER
      );
  return;
}

IR::ComponentDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_component",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->base_component (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::ProvidesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ProvidesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "provides_interfaces",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->provides_interfaces (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::UsesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::UsesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "uses_interfaces",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->uses_interfaces (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::EmitsDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::EmitsDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "emits_events",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->emits_events (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::PublishesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PublishesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "publishes_events",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->publishes_events (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::ConsumesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ConsumesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "consumes_events",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->consumes_events (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA::Boolean POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->is_basic (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::ProvidesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ProvidesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_provides",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_provides (
        id,
        name,
        version,
        interface_type
        ACE_ENV_ARG_PARAMETER
      );
}

IR::UsesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::UsesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_uses",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_uses (
        id,
        name,
        version,
        interface_type,
        is_multiple
        ACE_ENV_ARG_PARAMETER
      );
}

IR::EmitsDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::EmitsDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_emits",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_emits (
        id,
        name,
        version,
        value
        ACE_ENV_ARG_PARAMETER
      );
}

IR::PublishesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PublishesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_publishes",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_publishes (
        id,
        name,
        version,
        value
        ACE_ENV_ARG_PARAMETER
      );
}

IR::ConsumesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ConsumesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_consumes",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_consumes (
        id,
        name,
        version,
        value
        ACE_ENV_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentDef::ComponentDef (void)
{
  this->optable_ = &tao_IR_ComponentDef_optable;
}

// copy ctor
POA_IR::ComponentDef::ComponentDef (const ComponentDef& rhs)
  :   POA_CORBA_InterfaceDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentDef::~ComponentDef (void)
{
}

void POA_IR::ComponentDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    CORBA_InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->supported_interfaces (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      supported_interfaces
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->supported_interfaces (
          supported_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_base_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::ComponentDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_base_component_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_component (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_provides_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::ProvidesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->provides_interfaces (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ProvidesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_uses_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::UsesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->uses_interfaces (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::UsesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_emits_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::EmitsDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->emits_events (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::EmitsDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_publishes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::PublishesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->publishes_events (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PublishesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_consumes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::ConsumesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->consumes_events (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ConsumesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_basic (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::create_provides_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::ProvidesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDef_var interface_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_create_provides ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      interface_type.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_provides (
          id.in (),
          name.in (),
          version.in (),
          interface_type.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ProvidesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::create_uses_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::UsesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDef_var interface_type;
  CORBA::Boolean is_multiple;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_multiple))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_create_uses ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      is_multiple
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_uses (
          id.in (),
          name.in (),
          version.in (),
          interface_type.in (),
          is_multiple
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::UsesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::create_emits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::EmitsDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_create_emits ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_emits (
          id.in (),
          name.in (),
          version.in (),
          value.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::EmitsDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::create_publishes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::PublishesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_create_publishes ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_publishes (
          id.in (),
          name.in (),
          version.in (),
          value.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PublishesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::create_consumes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl =
    ACE_static_cast (POA_IR::ComponentDef *, _tao_object_reference);

    IR::ConsumesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_ComponentDef_create_consumes ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_consumes (
          id.in (),
          name.in (),
          version.in (),
          value.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ConsumesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::ComponentDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ComponentDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR::ComponentDef*
POA_IR::ComponentDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::ComponentDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:30 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 10, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  5,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32,  5, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 10, 32, 32, 32,  0,
      5, 32, 32, 32, 32, 32, 10, 32, 32, 32,
     32,  5, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 28,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PrimaryKeyDef::move_skel},
      {"_is_a",  &POA_IR::PrimaryKeyDef::_is_a_skel},
      {"_get_id",       &POA_IR::PrimaryKeyDef::_get_id_skel},
      {"_set_id",       &POA_IR::PrimaryKeyDef::_set_id_skel},
      {"describe",      &POA_IR::PrimaryKeyDef::describe_skel},
      {"_get_name",     &POA_IR::PrimaryKeyDef::_get_name_skel},
      {"_set_name",     &POA_IR::PrimaryKeyDef::_set_name_skel},
      {"_interface",  &POA_IR::PrimaryKeyDef::_interface_skel},
      {"destroy",       &POA_IR::PrimaryKeyDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::PrimaryKeyDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PrimaryKeyDef::is_a_skel},
      {"_get_version",  &POA_IR::PrimaryKeyDef::_get_version_skel},
      {"_set_version",  &POA_IR::PrimaryKeyDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::PrimaryKeyDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::PrimaryKeyDef::_get_defined_in_skel},
      {"_get_primary_key",      &POA_IR::PrimaryKeyDef::_get_primary_key_skel},
      {"_non_existent",  &POA_IR::PrimaryKeyDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PrimaryKeyDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -38,   8, -38,  11,  -1,  12,  13,
       14, -15,  -2, -33,  17,  -1,  18,  19,  -1,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:30 */
static TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable tao_IR_PrimaryKeyDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::PrimaryKeyDef *tao_impl
    ,
    const char * primary_key_id
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a &);
  void operator= (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a &);

private:
  POA_IR::PrimaryKeyDef *_tao_impl;
  const char * primary_key_id_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::PrimaryKeyDef *tao_impl,
    const char * primary_key_id
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    primary_key_id_ (primary_key_id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= primary_key_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::PrimaryKeyDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get &);
  void operator= (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get &);

private:
  POA_IR::PrimaryKeyDef *_tao_impl;
  CORBA_ValueDef_ptr _result;
};

TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::PrimaryKeyDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA_ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker *POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::~_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_PrimaryKeyDef_Proxy_Impl&
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::PrimaryKeyDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_PrimaryKeyDef_Proxy_Broker *
IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker();
}

int
IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_PrimaryKeyDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->is_a (
        primary_key_id
        ACE_ENV_ARG_PARAMETER
      );
}

CORBA_ValueDef_ptr POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->primary_key (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (void)
{
  this->optable_ = &tao_IR_PrimaryKeyDef_optable;
}

// copy ctor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (const PrimaryKeyDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{
}

void POA_IR::PrimaryKeyDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl =
    ACE_static_cast (POA_IR::PrimaryKeyDef *, _tao_object_reference);

    CORBA::Boolean _tao_retval = 0;
  CORBA::String_var primary_key_id;
  if (!(
    (_tao_in >> primary_key_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      primary_key_id.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          primary_key_id.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::PrimaryKeyDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl =
    ACE_static_cast (POA_IR::PrimaryKeyDef *, _tao_object_reference);

    CORBA_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->primary_key (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::PrimaryKeyDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::PrimaryKeyDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimaryKeyDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimaryKeyDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimaryKeyDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimaryKeyDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

IR::PrimaryKeyDef*
POA_IR::PrimaryKeyDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::PrimaryKeyDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_FactoryDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:30 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FactoryDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FactoryDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FactoryDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 31
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FactoryDef::move_skel},
      {"_is_a",  &POA_IR::FactoryDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FactoryDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FactoryDef::_set_name_skel},
      {"_get_name",     &POA_IR::FactoryDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FactoryDef::_set_mode_skel},
      {"_interface",  &POA_IR::FactoryDef::_interface_skel},
      {"_get_params",   &POA_IR::FactoryDef::_get_params_skel},
      {"_set_params",   &POA_IR::FactoryDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FactoryDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FactoryDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FactoryDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FactoryDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FactoryDef::_get_version_skel},
      {"_set_version",  &POA_IR::FactoryDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FactoryDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FactoryDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FactoryDef::_get_id_skel},
      {"_set_id",       &POA_IR::FactoryDef::_set_id_skel},
      {"describe",      &POA_IR::FactoryDef::describe_skel},
      {"_get_result_def",       &POA_IR::FactoryDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FactoryDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FactoryDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FactoryDef::_get_result_skel},
      {"destroy",       &POA_IR::FactoryDef::destroy_skel},
      {"_non_existent",  &POA_IR::FactoryDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FactoryDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  31:
                  resword = &wordlist[27]; break;
                case  32:
                  resword = &wordlist[28]; break;
                case  33:
                  resword = &wordlist[29]; break;
                case  36:
                  resword = &wordlist[30]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:30 */
static TAO_IR_FactoryDef_Perfect_Hash_OpTable tao_IR_FactoryDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker *POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::~_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_FactoryDef_Proxy_Impl&
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::FactoryDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_FactoryDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_FactoryDef_Proxy_Broker *
IR__TAO_FactoryDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker();
}

int
IR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_FactoryDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_FactoryDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl::_TAO_FactoryDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FactoryDef::FactoryDef (void)
{
  this->optable_ = &tao_IR_FactoryDef_optable;
}

// copy ctor
POA_IR::FactoryDef::FactoryDef (const FactoryDef& rhs)
  :   POA_CORBA_OperationDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FactoryDef::~FactoryDef (void)
{
}

void POA_IR::FactoryDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::FactoryDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::FactoryDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FactoryDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FactoryDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FactoryDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

IR::FactoryDef*
POA_IR::FactoryDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::FactoryDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_FinderDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:31 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FinderDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FinderDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FinderDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 31
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FinderDef::move_skel},
      {"_is_a",  &POA_IR::FinderDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FinderDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FinderDef::_set_name_skel},
      {"_get_name",     &POA_IR::FinderDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FinderDef::_set_mode_skel},
      {"_interface",  &POA_IR::FinderDef::_interface_skel},
      {"_get_params",   &POA_IR::FinderDef::_get_params_skel},
      {"_set_params",   &POA_IR::FinderDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FinderDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FinderDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FinderDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FinderDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FinderDef::_get_version_skel},
      {"_set_version",  &POA_IR::FinderDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FinderDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FinderDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FinderDef::_get_id_skel},
      {"_set_id",       &POA_IR::FinderDef::_set_id_skel},
      {"describe",      &POA_IR::FinderDef::describe_skel},
      {"_get_result_def",       &POA_IR::FinderDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FinderDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FinderDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FinderDef::_get_result_skel},
      {"destroy",       &POA_IR::FinderDef::destroy_skel},
      {"_non_existent",  &POA_IR::FinderDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FinderDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  31:
                  resword = &wordlist[27]; break;
                case  32:
                  resword = &wordlist[28]; break;
                case  33:
                  resword = &wordlist[29]; break;
                case  36:
                  resword = &wordlist[30]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:31 */
static TAO_IR_FinderDef_Perfect_Hash_OpTable tao_IR_FinderDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker *POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::~_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_FinderDef_Proxy_Impl&
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::FinderDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_FinderDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_FinderDef_Proxy_Broker *
IR__TAO_FinderDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker();
}

int
IR__TAO_FinderDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_FinderDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_FinderDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_FinderDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_FinderDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl::_TAO_FinderDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FinderDef::FinderDef (void)
{
  this->optable_ = &tao_IR_FinderDef_optable;
}

// copy ctor
POA_IR::FinderDef::FinderDef (const FinderDef& rhs)
  :   POA_CORBA_OperationDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FinderDef::~FinderDef (void)
{
}

void POA_IR::FinderDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::FinderDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::FinderDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FinderDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FinderDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FinderDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

IR::FinderDef*
POA_IR::FinderDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::FinderDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_HomeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 23:08:31 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_HomeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_HomeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91,  0,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91,  0,
     91, 20,  5, 40, 91, 91, 91,  0, 91, 91,
     91, 91, 91, 91, 91, 91, 91,  0,  0,  5,
     91,  0, 91,  5, 91, 91, 91, 91, 91, 91,
     91, 91, 20, 55, 91, 91, 91,  0, 45, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91,
#else
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91,  0, 91,  0, 91, 20,
      5, 40, 91, 91, 91,  0, 91, 91,  0,  0,
      5, 91,  0, 91,  5, 20, 55, 91, 91, 91,
      0, 45, 91, 91, 91, 91, 91, 91,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_HomeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 90,
      HASH_VALUE_RANGE = 87,
      DUPLICATES = 9,
      WORDLIST_SIZE = 53
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::HomeDef::is_a_skel},
      {"_is_a",  &POA_IR::HomeDef::_is_a_skel},
      {"lookup",        &POA_IR::HomeDef::lookup_skel},
      {"_get_id",       &POA_IR::HomeDef::_get_id_skel},
      {"_set_id",       &POA_IR::HomeDef::_set_id_skel},
      {"_get_version",  &POA_IR::HomeDef::_get_version_skel},
      {"_set_version",  &POA_IR::HomeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::HomeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::HomeDef::_get_defined_in_skel},
      {"create_enum",   &POA_IR::HomeDef::create_enum_skel},
      {"_get_finders",  &POA_IR::HomeDef::_get_finders_skel},
      {"_get_is_basic",         &POA_IR::HomeDef::_get_is_basic_skel},
      {"_get_factories",        &POA_IR::HomeDef::_get_factories_skel},
      {"create_value_box",      &POA_IR::HomeDef::create_value_box_skel},
      {"create_union",  &POA_IR::HomeDef::create_union_skel},
      {"create_finder",         &POA_IR::HomeDef::create_finder_skel},
      {"_get_base_interfaces",  &POA_IR::HomeDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::HomeDef::_set_base_interfaces_skel},
      {"create_operation",      &POA_IR::HomeDef::create_operation_skel},
      {"create_exception",      &POA_IR::HomeDef::create_exception_skel},
      {"describe_contents",     &POA_IR::HomeDef::describe_contents_skel},
      {"move",  &POA_IR::HomeDef::move_skel},
      {"contents",      &POA_IR::HomeDef::contents_skel},
      {"_get_name",     &POA_IR::HomeDef::_get_name_skel},
      {"_get_type",     &POA_IR::HomeDef::_get_type_skel},
      {"_set_name",     &POA_IR::HomeDef::_set_name_skel},
      {"_interface",  &POA_IR::HomeDef::_interface_skel},
      {"lookup_name",   &POA_IR::HomeDef::lookup_name_skel},
      {"create_alias",  &POA_IR::HomeDef::create_alias_skel},
      {"describe",      &POA_IR::HomeDef::describe_skel},
      {"_get_base_home",        &POA_IR::HomeDef::_get_base_home_skel},
      {"destroy",       &POA_IR::HomeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::HomeDef::_get_absolute_name_skel},
      {"_get_primary_key",      &POA_IR::HomeDef::_get_primary_key_skel},
      {"describe_interface",    &POA_IR::HomeDef::describe_interface_skel},
      {"_non_existent",  &POA_IR::HomeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::HomeDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::HomeDef::create_value_skel},
      {"create_module",         &POA_IR::HomeDef::create_module_skel},
      {"create_native",         &POA_IR::HomeDef::create_native_skel},
      {"create_attribute",      &POA_IR::HomeDef::create_attribute_skel},
      {"create_interface",      &POA_IR::HomeDef::create_interface_skel},
      {"_get_managed_component",        &POA_IR::HomeDef::_get_managed_component_skel},
      {"create_factory",        &POA_IR::HomeDef::create_factory_skel},
      {"create_local_interface",        &POA_IR::HomeDef::create_local_interface_skel},
      {"create_primary_key",    &POA_IR::HomeDef::create_primary_key_skel},
      {"create_abstract_interface",     &POA_IR::HomeDef::create_abstract_interface_skel},
      {"create_struct",         &POA_IR::HomeDef::create_struct_skel},
      {"create_constant",       &POA_IR::HomeDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -1,   -1,    4,    5,    6,   -1,   -1,   -1,   -7,   -2,  -92,   -1,
        -1,   -9,   -2,  -92,   11,   -1,   12,   -1,   -1,   -1,   -1,   -1,   -1,  -20,
        -2,  -22,   -2,   13,   14,   15,   16,   -1,   17,   18,   19,   -1, -103, -102,
        24,   -1,   25,   -1,  -27,   -3,   26,  -93,   30,   31,   32,   33,   34,   -1,
        -1,   35,   36,   -1,   -1,   37,   -1,   38,   -1,   -1,   -1,   -1,   39,  -42,
        -2,   40,   41,  -94,  -44,   -2,  -92,   46,   -1,   47,   -1,   -1,   48,   49,
        -1,   50,   -1,   -1,   51,   -1,   52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 23:08:31 */
static TAO_IR_HomeDef_Perfect_Hash_OpTable tao_IR_HomeDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_HomeDef_base_home_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_base_home_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_base_home_get (const TAO_ServerRequestInfo_IR_HomeDef_base_home_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_base_home_get &);

private:
  POA_IR::HomeDef *_tao_impl;
  IR::HomeDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_base_home_get::TAO_ServerRequestInfo_IR_HomeDef_base_home_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::result (IR::HomeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_managed_component_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (const TAO_ServerRequestInfo_IR_HomeDef_managed_component_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_managed_component_get &);

private:
  POA_IR::HomeDef *_tao_impl;
  IR::ComponentDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_primary_key_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (const TAO_ServerRequestInfo_IR_HomeDef_primary_key_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_primary_key_get &);

private:
  POA_IR::HomeDef *_tao_impl;
  IR::PrimaryKeyDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::result (IR::PrimaryKeyDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_factories_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_factories_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_factories_get (const TAO_ServerRequestInfo_IR_HomeDef_factories_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_factories_get &);

private:
  POA_IR::HomeDef *_tao_impl;
  IR::FactoryDefSeq * _result;
};

TAO_ServerRequestInfo_IR_HomeDef_factories_get::TAO_ServerRequestInfo_IR_HomeDef_factories_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_factories_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_factories_get::result (IR::FactoryDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_finders_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_finders_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_finders_get (const TAO_ServerRequestInfo_IR_HomeDef_finders_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_finders_get &);

private:
  POA_IR::HomeDef *_tao_impl;
  IR::FinderDefSeq * _result;
};

TAO_ServerRequestInfo_IR_HomeDef_finders_get::TAO_ServerRequestInfo_IR_HomeDef_finders_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_finders_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_finders_get::result (IR::FinderDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_is_basic_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl

    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (const TAO_ServerRequestInfo_IR_HomeDef_is_basic_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_is_basic_get &);

private:
  POA_IR::HomeDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_create_primary_key : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (const TAO_ServerRequestInfo_IR_HomeDef_create_primary_key &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_create_primary_key &);

private:
  POA_IR::HomeDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr primary_key_;
  IR::PrimaryKeyDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->primary_key_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::result (IR::PrimaryKeyDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_create_factory : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_create_factory (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_create_factory (const TAO_ServerRequestInfo_IR_HomeDef_create_factory &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_create_factory &);

private:
  POA_IR::HomeDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FactoryDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_create_factory::TAO_ServerRequestInfo_IR_HomeDef_create_factory (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_create_factory::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_create_factory::result (IR::FactoryDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_create_finder : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_create_finder (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_IR::HomeDef *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_create_finder (const TAO_ServerRequestInfo_IR_HomeDef_create_finder &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_create_finder &);

private:
  POA_IR::HomeDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FinderDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_create_finder::TAO_ServerRequestInfo_IR_HomeDef_create_finder (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_create_finder::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_IR_HomeDef_create_finder::result (IR::FinderDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker *POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::~_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

IR::_TAO_HomeDef_Proxy_Impl&
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::HomeDef *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_HomeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_HomeDef_Proxy_Broker *
IR__TAO_HomeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker();
}

int
IR__TAO_HomeDef_Proxy_Broker_Factory_Initializer (long)
{
  IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer =
    IR__TAO_HomeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int IR__TAO_HomeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  IR__TAO_HomeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_HomeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::_TAO_HomeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::HomeDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_home",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->base_home (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::ComponentDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "managed_component",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->managed_component (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->primary_key (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::FactoryDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FactoryDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "factories",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->factories (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::FinderDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FinderDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "finders",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->finders (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA::Boolean POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->is_basic (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
}

IR::PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_primary_key",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_primary_key (
        id,
        name,
        version,
        primary_key
        ACE_ENV_ARG_PARAMETER
      );
}

IR::FactoryDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FactoryDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_factory",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_factory (
        id,
        name,
        version,
        params,
        exceptions
        ACE_ENV_ARG_PARAMETER
      );
}

IR::FinderDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FinderDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_finder",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_finder (
        id,
        name,
        version,
        params,
        exceptions
        ACE_ENV_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::HomeDef::HomeDef (void)
{
  this->optable_ = &tao_IR_HomeDef_optable;
}

// copy ctor
POA_IR::HomeDef::HomeDef (const HomeDef& rhs)
  :   POA_CORBA_InterfaceDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::HomeDef::~HomeDef (void)
{
}

void POA_IR::HomeDef::_get_base_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::HomeDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_base_home_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_home (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::HomeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::_get_managed_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::ComponentDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_managed_component_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->managed_component (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::PrimaryKeyDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_primary_key_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->primary_key (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::_get_factories_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::FactoryDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_factories_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->factories (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FactoryDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::_get_finders_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::FinderDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_finders_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->finders (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FinderDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_is_basic_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_basic (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::create_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::PrimaryKeyDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_create_primary_key ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      primary_key.in ()
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_primary_key (
          id.in (),
          name.in (),
          version.in (),
          primary_key.in ()
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::create_factory_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::FactoryDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ParDescriptionSeq params;
  CORBA_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_create_factory ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_factory (
          id.in (),
          name.in (),
          version.in (),
          params,
          exceptions
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FactoryDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::create_finder_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl =
    ACE_static_cast (POA_IR::HomeDef *, _tao_object_reference);

    IR::FinderDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ParDescriptionSeq params;
  CORBA_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_IR_HomeDef_create_finder ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_finder (
          id.in (),
          name.in (),
          version.in (),
          params,
          exceptions
          ACE_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FinderDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_IR::HomeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::HomeDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::HomeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/HomeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::HomeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::HomeDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall ACE_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


const char* POA_IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef*
POA_IR::HomeDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::IR::HomeDef::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
