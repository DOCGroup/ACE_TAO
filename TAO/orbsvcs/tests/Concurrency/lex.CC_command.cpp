/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp
 */

#define FLEX_SCANNER
#define ACE_CC_YY_FLEX_MAJOR_VERSION 2
#define ACE_CC_YY_FLEX_MINOR_VERSION 5

#include "ace/OS_NS_string.h"


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include /**/ <stdlib.h>

/* Use prototypes in function declarations. */
#define ACE_CC_YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define ACE_CC_YY_USE_CONST

#else /* ! __cplusplus */

#if __STDC__

#define ACE_CC_YY_USE_PROTOS
#define ACE_CC_YY_USE_CONST

#endif  /* __STDC__ */
#endif  /* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include /**/ <io.h>
#include /**/ <stdlib.h>
#define ACE_CC_YY_USE_CONST
#define ACE_CC_YY_USE_PROTOS
#endif

#ifdef ACE_CC_YY_USE_CONST
#define ace_cc_yyconst const
#else
#define ace_cc_yyconst
#endif


#ifdef ACE_CC_YY_USE_PROTOS
#define ACE_CC_YY_PROTO(proto) proto
#else
#define ACE_CC_YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define ACE_CC_YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define ACE_CC_YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN ace_cc_yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The ACE_CC_YYSTATE alias is for lex
 * compatibility.
 */
#define ACE_CC_YY_START ((ace_cc_yy_start - 1) / 2)
#define ACE_CC_YYSTATE ACE_CC_YY_START

/* Action number for EOF rule of a given start state. */
#define ACE_CC_YY_STATE_EOF(state) (ACE_CC_YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define ACE_CC_YY_NEW_FILE ace_cc_yyrestart( ace_cc_yyin )

#define ACE_CC_YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define ACE_CC_YY_BUF_SIZE 16384

typedef struct ace_cc_yy_buffer_state *ACE_CC_YY_BUFFER_STATE;

extern int ace_cc_yyleng;
extern FILE *ace_cc_yyin, *ace_cc_yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 *  if ( condition_holds )
 *    ace_cc_yyless( 5 );
 *  else
 *    do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the ace_cc_yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define ace_cc_yyless(n) \
  do \
    { \
    /* Undo effects of setting up ace_cc_yytext. */ \
    *ace_cc_yy_cp = ace_cc_yy_hold_char; \
    ACE_CC_YY_RESTORE_ACE_CC_YY_MORE_OFFSET \
    ace_cc_yy_c_buf_p = ace_cc_yy_cp = ace_cc_yy_bp + n - ACE_CC_YY_MORE_ADJ; \
    ACE_CC_YY_DO_BEFORE_ACTION; /* set up ace_cc_yytext again */ \
    } \
  while ( 0 )

#define unput(c) ace_cc_yyunput( c, ace_cc_yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int ace_cc_yy_size_t;


struct ace_cc_yy_buffer_state
{
  FILE *ace_cc_yy_input_file;

  char *ace_cc_yy_ch_buf;   /* input buffer */
  char *ace_cc_yy_buf_pos;    /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  ace_cc_yy_size_t ace_cc_yy_buf_size;

  /* Number of characters read into ace_cc_yy_ch_buf, not including EOB
   * characters.
   */
  int ace_cc_yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int ace_cc_yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int ace_cc_yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int ace_cc_yy_at_bol;

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int ace_cc_yy_fill_buffer;

  int ace_cc_yy_buffer_status;
#define ACE_CC_YY_BUFFER_NEW 0
#define ACE_CC_YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as ACE_CC_YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via ace_cc_yyrestart()), so that the user can continue scanning by
   * just pointing ace_cc_yyin at a new input file.
   */
#define ACE_CC_YY_BUFFER_EOF_PENDING 2
};

static ACE_CC_YY_BUFFER_STATE ace_cc_yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define ACE_CC_YY_CURRENT_BUFFER ace_cc_yy_current_buffer


/* ace_cc_yy_hold_char holds the character lost when ace_cc_yytext is formed. */
static char ace_cc_yy_hold_char;

static int ace_cc_yy_n_chars;   /* number of characters read into ace_cc_yy_ch_buf */


int ace_cc_yyleng;

/* Points to current character in buffer. */
static char *ace_cc_yy_c_buf_p = (char *) 0;
static int ace_cc_yy_init = 1;    /* whether we need to initialize */
static int ace_cc_yy_start = 0; /* start state number */

#define ace_cc_yywrap() 1
/* Flag which is used to allow ace_cc_yywrap()'s to do buffer switches
 * instead of setting up a fresh ace_cc_yyin.  A bit of a hack ...
 */
#if (ace_cc_yywrap() != 1)
static int ace_cc_yy_did_buffer_switch_on_eof;
#endif

void ace_cc_yyrestart ACE_CC_YY_PROTO(( FILE *input_file ));

void ace_cc_yy_switch_to_buffer ACE_CC_YY_PROTO(( ACE_CC_YY_BUFFER_STATE new_buffer ));
void ace_cc_yy_load_buffer_state ACE_CC_YY_PROTO(( void ));
ACE_CC_YY_BUFFER_STATE ace_cc_yy_create_buffer ACE_CC_YY_PROTO(( FILE *file, int size ));
void ace_cc_yy_delete_buffer ACE_CC_YY_PROTO(( ACE_CC_YY_BUFFER_STATE b ));
void ace_cc_yy_init_buffer ACE_CC_YY_PROTO(( ACE_CC_YY_BUFFER_STATE b, FILE *file ));
void ace_cc_yy_flush_buffer ACE_CC_YY_PROTO(( ACE_CC_YY_BUFFER_STATE b ));
#define ACE_CC_YY_FLUSH_BUFFER ace_cc_yy_flush_buffer( ace_cc_yy_current_buffer )

ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_buffer ACE_CC_YY_PROTO(( char *base, ace_cc_yy_size_t size ));
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_string ACE_CC_YY_PROTO(( ace_cc_yyconst char *ace_cc_yy_str ));
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_bytes ACE_CC_YY_PROTO(( ace_cc_yyconst char *bytes, int len ));

static void *ace_cc_yy_flex_alloc ACE_CC_YY_PROTO(( ace_cc_yy_size_t ));
static void *ace_cc_yy_flex_realloc ACE_CC_YY_PROTO(( void *, ace_cc_yy_size_t ));
static void ace_cc_yy_flex_free ACE_CC_YY_PROTO(( void * ));

#define ace_cc_yy_new_buffer ace_cc_yy_create_buffer

#define ace_cc_yy_set_interactive(is_interactive) \
  { \
  if ( ! ace_cc_yy_current_buffer ) \
    ace_cc_yy_current_buffer = ace_cc_yy_create_buffer( ace_cc_yyin, ACE_CC_YY_BUF_SIZE ); \
  ace_cc_yy_current_buffer->ace_cc_yy_is_interactive = is_interactive; \
  }

#define ace_cc_yy_set_bol(at_bol) \
  { \
  if ( ! ace_cc_yy_current_buffer ) \
    ace_cc_yy_current_buffer = ace_cc_yy_create_buffer( ace_cc_yyin, ACE_CC_YY_BUF_SIZE ); \
  ace_cc_yy_current_buffer->ace_cc_yy_at_bol = at_bol; \
  }

#define ACE_CC_YY_AT_BOL() (ace_cc_yy_current_buffer->ace_cc_yy_at_bol)


#define ACE_CC_YY_SKIP_ACE_CC_YYWRAP
typedef unsigned char ACE_CC_YY_CHAR;
FILE *ace_cc_yyin = (FILE *) 0, *ace_cc_yyout = (FILE *) 0;
typedef int ace_cc_yy_state_type;
extern char *ace_cc_yytext;
#define ace_cc_yytext_ptr ace_cc_yytext

static ace_cc_yy_state_type ace_cc_yy_get_previous_state ACE_CC_YY_PROTO(( void ));
static ace_cc_yy_state_type ace_cc_yy_try_NUL_trans ACE_CC_YY_PROTO(( ace_cc_yy_state_type current_state ));
static int ace_cc_yy_get_next_buffer ACE_CC_YY_PROTO(( void ));
static void ace_cc_yy_fatal_error ACE_CC_YY_PROTO(( ace_cc_yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up ace_cc_yytext.
 */
#define ACE_CC_YY_DO_BEFORE_ACTION \
  ace_cc_yytext_ptr = ace_cc_yy_bp; \
  ace_cc_yyleng = (int) (ace_cc_yy_cp - ace_cc_yy_bp); \
  ace_cc_yy_hold_char = *ace_cc_yy_cp; \
  *ace_cc_yy_cp = '\0'; \
  ace_cc_yy_c_buf_p = ace_cc_yy_cp;

#define ACE_CC_YY_NUM_RULES 25
#define ACE_CC_YY_END_OF_BUFFER 26
static ace_cc_yyconst short int ace_cc_yy_accept[124] =
    {   0,
        0,    0,   26,   25,   24,   23,   25,   20,    1,   21,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       25,   24,   23,    0,   19,   20,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
       21,    0,   21,   21,   21,   21,   21,   21,   21,   21,
       21,   21,   21,   21,   21,   21,   21,   21,    0,   22,
       21,   21,   21,   21,    4,   21,   21,   14,   21,   21,
       21,   21,   21,   21,    9,   21,   21,   21,   21,   21,
       21,   10,   21,    8,    2,   21,   21,   21,   17,   21,
        3,   21,   21,   13,   11,   21,    5,   21,   21,   21,

       21,   21,   16,   21,   21,   21,    6,   21,   12,   21,
       21,   21,    7,   21,   21,   21,   21,   21,   21,   15,
       21,   18,    0
    } ;

static ace_cc_yyconst int ace_cc_yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    1,    4,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    5,    6,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    5,    8,    1,
        1,    1,    1,    1,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
        1,    1,    1,    1,   10,    1,   11,    9,   12,   13,

       14,    9,   15,   16,   17,    9,   18,   19,   20,   21,
       22,   23,    9,   24,   25,   26,   27,    9,   28,   29,
       30,    9,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static ace_cc_yyconst int ace_cc_yy_meta[31] =
    {   0,
        1,    2,    1,    1,    3,    3,    3,    1,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    3,    3
    } ;

static ace_cc_yyconst short int ace_cc_yy_base[128] =
    {   0,
        0,  136,  141,  143,    0,  137,  135,  131,  143,    0,
       15,  108,  115,  113,  110,  119,   14,  108,   11,   24,
      125,    0,  127,  125,  124,  120,    0,  115,  111,  112,
       97,   24,  105,   26,  107,  109,   89,   99,  102,   99,
       98,  112,   92,  101,   97,   96,   91,   90,   86,   93,
       91,   90,   79,   92,   79,   76,   73,   72,   95,  143,
       81,   69,   71,   72,    0,   65,   65,    0,   79,   66,
       62,   68,   74,   74,    0,   70,   69,   68,   55,   54,
       56,    0,   52,    0,    0,   55,   58,   62,    0,   64,
        0,   56,   55,    0,    0,   59,    0,   56,   49,   46,

       45,   48,    0,   43,   43,   42,    0,   49,    0,   51,
       46,   14,    0,   45,   30,   40,   30,   32,   18,    0,
       29,    0,  143,   49,   52,   38,   55
    } ;

static ace_cc_yyconst short int ace_cc_yy_def[128] =
    {   0,
      123,    1,  123,  123,  124,  123,  125,  123,  123,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      123,  124,  123,  125,  125,  123,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  127,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  127,  123,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,

      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  126,  126,
      126,  126,    0,  123,  123,  123,  123
    } ;

static ace_cc_yyconst short int ace_cc_yy_nxt[174] =
    {   0,
        4,    5,    6,    7,    4,    4,    8,    9,   10,    4,
       10,   11,   10,   12,   10,   10,   13,   10,   14,   10,
       10,   10,   15,   16,   17,   18,   19,   20,   10,   10,
       28,   38,   35,   39,   40,   47,   50,  114,   29,   36,
       27,  115,  122,  121,  120,   48,  119,   41,   51,   22,
      118,   22,   24,  117,   24,   59,   59,   59,  116,  113,
      112,  111,  110,  109,  108,  107,  106,  105,  104,  103,
      102,  101,  100,   99,   98,   97,   96,   95,   94,   93,
       92,   91,   90,   89,   88,   87,   86,   85,   84,   83,
       82,   81,   80,   79,   78,   77,   60,   76,   75,   74,

       73,   72,   71,   70,   69,   68,   67,   66,   65,   64,
       63,   62,   61,   60,   58,   57,   56,   55,   54,   53,
       52,   49,   46,   45,   44,   43,   26,   25,   25,   23,
       42,   37,   34,   33,   32,   31,   30,   26,   25,   23,
      123,   21,    3,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123
    } ;

static ace_cc_yyconst short int ace_cc_yy_chk[174] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
       11,   19,   17,   19,   20,   32,   34,  112,   11,   17,
      126,  112,  121,  119,  118,   32,  117,   20,   34,  124,
      116,  124,  125,  115,  125,  127,  127,  127,  114,  111,
      110,  108,  106,  105,  104,  102,  101,  100,   99,   98,
       96,   93,   92,   90,   88,   87,   86,   83,   81,   80,
       79,   78,   77,   76,   74,   73,   72,   71,   70,   69,
       67,   66,   64,   63,   62,   61,   59,   58,   57,   56,

       55,   54,   53,   52,   51,   50,   49,   48,   47,   46,
       45,   44,   43,   42,   41,   40,   39,   38,   37,   36,
       35,   33,   31,   30,   29,   28,   26,   25,   24,   23,
       21,   18,   16,   15,   14,   13,   12,    8,    7,    6,
        3,    2,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123
    } ;

static ace_cc_yy_state_type ace_cc_yy_last_accepting_state;
static char *ace_cc_yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define ace_cc_yymore() ace_cc_yymore_used_but_not_detected
#define ACE_CC_YY_MORE_ADJ 0
#define ACE_CC_YY_RESTORE_ACE_CC_YY_MORE_OFFSET
char *ace_cc_yytext;
#define INITIAL 0
//=============================================================================
/**
 *
 * = LIBRARY
 *    TAO/orbsvcs/tests
 *
 * This is the lex file for the concurrency service script language.
 *
 *
 */
//=============================================================================

 */
#define ACE_CC_YY_NO_UNPUT 1
#define ACE_CC_YY_NO_INPUT 1
#define ACE_CC_YY_ALWAYS_INTERACTIVE 1
#include "CC_command.h"
#include "CC_command.tab.h"
#include "ace/ACE.h"

extern int line_no;
extern char line_buf[500];

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef ACE_CC_YY_SKIP_ACE_CC_YYWRAP
#ifdef __cplusplus
extern "C" int ace_cc_yywrap ACE_CC_YY_PROTO(( void ));
#else
extern int ace_cc_yywrap ACE_CC_YY_PROTO(( void ));
#endif
#endif

#ifndef ACE_CC_YY_NO_UNPUT
static void ace_cc_yyunput ACE_CC_YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef ace_cc_yytext_ptr
static void ace_cc_yy_flex_strncpy ACE_CC_YY_PROTO(( char *, ace_cc_yyconst char *, int ));
#endif

#ifdef ACE_CC_YY_NEED_STRLEN
static int ace_cc_yy_flex_strlen ACE_CC_YY_PROTO(( ace_cc_yyconst char * ));
#endif

#ifndef ACE_CC_YY_NO_INPUT
#ifdef __cplusplus
static int ace_cc_yyinput ACE_CC_YY_PROTO(( void ));
#else
static int input ACE_CC_YY_PROTO(( void ));
#endif
#endif

#if ACE_CC_YY_STACK_USED
static int ace_cc_yy_start_stack_ptr = 0;
static int ace_cc_yy_start_stack_depth = 0;
static int *ace_cc_yy_start_stack = 0;
#ifndef ACE_CC_YY_NO_PUSH_STATE
static void ace_cc_yy_push_state ACE_CC_YY_PROTO(( int new_state ));
#endif
#ifndef ACE_CC_YY_NO_POP_STATE
static void ace_cc_yy_pop_state ACE_CC_YY_PROTO(( void ));
#endif
#ifndef ACE_CC_YY_NO_TOP_STATE
static int ace_cc_yy_top_state ACE_CC_YY_PROTO(( void ));
#endif

#else
#define ACE_CC_YY_NO_PUSH_STATE 1
#define ACE_CC_YY_NO_POP_STATE 1
#define ACE_CC_YY_NO_TOP_STATE 1
#endif

#ifdef ACE_CC_YY_MALLOC_DECL
ACE_CC_YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include /**/ <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef ACE_CC_YY_READ_BUF_SIZE
#define ACE_CC_YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

//FUZZ: disable check_for_lack_ACE_OS
#ifndef ACE_CC_ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ACE_CC_ECHO { size_t __dum_ret = fwrite( ace_cc_yytext, ace_cc_yyleng, 1, ace_cc_yyout ); (void) __dum_ret; }
#endif
//FUZZ: enable check_for_lack_ACE_OS

/* Gets input and stuffs it into "buf".  number of characters read, or ACE_CC_YY_NULL,
 * is returned in "result".
 */
#ifndef ACE_CC_YY_INPUT
#define ACE_CC_YY_INPUT(buf,result,max_size) \
  if ( ace_cc_yy_current_buffer->ace_cc_yy_is_interactive ) \
  { \
    int c = '*', n; \
    for ( n = 0; n < max_size && \
         (c = ACE_OS::getc( ace_cc_yyin )) != EOF && c != '\n'; ++n ) \
      buf[n] = (char) c; \
    if ( c == '\n' ) \
      buf[n++] = (char) c; \
    if ( c == EOF && ferror( ace_cc_yyin ) ) \
      ACE_CC_YY_FATAL_ERROR( "input in flex scanner failed" ); \
    result = n; \
  } \
  else if ( ((result = ACE_OS::fread( buf, 1, max_size, ace_cc_yyin )) == 0) \
            && ferror( ace_cc_yyin ) ) \
    ACE_CC_YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "ace_cc_yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef ace_cc_yyterminate
#define ace_cc_yyterminate() return ACE_CC_YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef ACE_CC_YY_START_STACK_INCR
#define ACE_CC_YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef ACE_CC_YY_FATAL_ERROR
#define ACE_CC_YY_FATAL_ERROR(msg) ace_cc_yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef ACE_CC_YY_DECL
#define ACE_CC_YY_DECL int ace_cc_yylex ACE_CC_YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after ace_cc_yytext and ace_cc_yyleng
 * have been set up.
 */
#ifndef ACE_CC_YY_USER_ACTION
#define ACE_CC_YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef ACE_CC_YY_BREAK
#define ACE_CC_YY_BREAK break;
#endif

#define ACE_CC_YY_RULE_SETUP \
  if ( ace_cc_yyleng > 0 ) \
    ace_cc_yy_current_buffer->ace_cc_yy_at_bol = \
        (ace_cc_yytext[ace_cc_yyleng - 1] == '\n'); \
  ACE_CC_YY_USER_ACTION

ACE_CC_YY_DECL
  {
  register ace_cc_yy_state_type ace_cc_yy_current_state;
  register char *ace_cc_yy_cp = 0, *ace_cc_yy_bp = 0;
  register int ace_cc_yy_act;




  if ( ace_cc_yy_init )
    {
    ace_cc_yy_init = 0;

#ifdef ACE_CC_YY_USER_INIT
    ACE_CC_YY_USER_INIT;
#endif

    if ( ! ace_cc_yy_start )
      ace_cc_yy_start = 1;  /* first start state */

    if ( ! ace_cc_yyin )
      ace_cc_yyin = stdin;

    if ( ! ace_cc_yyout )
      ace_cc_yyout = stdout;

    if ( ! ace_cc_yy_current_buffer )
      ace_cc_yy_current_buffer =
        ace_cc_yy_create_buffer( ace_cc_yyin, ACE_CC_YY_BUF_SIZE );

    ace_cc_yy_load_buffer_state();
    }

        ace_cc_yy_cp = ace_cc_yy_bp = 0; /* To avoid g++ warning about
                                            possible uninitialized use. */
  while ( 1 )   /* loops until end-of-file is reached */
    {
    ace_cc_yy_cp = ace_cc_yy_c_buf_p;

    /* Support of ace_cc_yytext. */
    *ace_cc_yy_cp = ace_cc_yy_hold_char;

    /* ace_cc_yy_bp points to the position in ace_cc_yy_ch_buf of the start of
     * the current run.
     */
    ace_cc_yy_bp = ace_cc_yy_cp;

    ace_cc_yy_current_state = ace_cc_yy_start;
    ace_cc_yy_current_state += ACE_CC_YY_AT_BOL();
ace_cc_yy_match:
    do
      {
      register ACE_CC_YY_CHAR ace_cc_yy_c = ace_cc_yy_ec[ACE_CC_YY_SC_TO_UI(*ace_cc_yy_cp)];
      if ( ace_cc_yy_accept[ace_cc_yy_current_state] )
        {
        ace_cc_yy_last_accepting_state = ace_cc_yy_current_state;
        ace_cc_yy_last_accepting_cpos = ace_cc_yy_cp;
        }
      while ( ace_cc_yy_chk[ace_cc_yy_base[ace_cc_yy_current_state] + ace_cc_yy_c] != ace_cc_yy_current_state )
        {
        ace_cc_yy_current_state = (int) ace_cc_yy_def[ace_cc_yy_current_state];
        if ( ace_cc_yy_current_state >= 124 )
          ace_cc_yy_c = ace_cc_yy_meta[(unsigned int) ace_cc_yy_c];
        }
      ace_cc_yy_current_state = ace_cc_yy_nxt[ace_cc_yy_base[ace_cc_yy_current_state] + (unsigned int) ace_cc_yy_c];
      ++ace_cc_yy_cp;
      }
    while ( ace_cc_yy_base[ace_cc_yy_current_state] != 143 );

ace_cc_yy_find_action:
    ace_cc_yy_act = ace_cc_yy_accept[ace_cc_yy_current_state];
    if ( ace_cc_yy_act == 0 )
      { /* have to back up */
      ace_cc_yy_cp = ace_cc_yy_last_accepting_cpos;
      ace_cc_yy_current_state = ace_cc_yy_last_accepting_state;
      ace_cc_yy_act = ace_cc_yy_accept[ace_cc_yy_current_state];
      }

    ACE_CC_YY_DO_BEFORE_ACTION;


do_action:  /* This label is used only to access EOF actions. */


    switch ( ace_cc_yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of ACE_CC_YY_DO_BEFORE_ACTION */
      *ace_cc_yy_cp = ace_cc_yy_hold_char;
      ace_cc_yy_cp = ace_cc_yy_last_accepting_cpos;
      ace_cc_yy_current_state = ace_cc_yy_last_accepting_state;
      goto ace_cc_yy_find_action;

case 1:
ACE_CC_YY_RULE_SETUP
return T_TERM;
  /* ACE_CC_YY_BREAK */
case 2:
ACE_CC_YY_RULE_SETUP
return T_START_CMD;
  /* ACE_CC_YY_BREAK */
case 3:
ACE_CC_YY_RULE_SETUP
return T_CREATE_CMD;
  /* ACE_CC_YY_BREAK */
case 4:
ACE_CC_YY_RULE_SETUP
return T_LOCK_CMD;
  /* ACE_CC_YY_BREAK */
case 5:
ACE_CC_YY_RULE_SETUP
return T_UNLOCK_CMD;
  /* ACE_CC_YY_BREAK */
case 6:
ACE_CC_YY_RULE_SETUP
return T_TRYLOCK_CMD;
  /* ACE_CC_YY_BREAK */
case 7:
ACE_CC_YY_RULE_SETUP
return T_CHANGEMODE_CMD;
  /* ACE_CC_YY_BREAK */
case 8:
ACE_CC_YY_RULE_SETUP
return T_SLEEP_CMD;
  /* ACE_CC_YY_BREAK */
case 9:
ACE_CC_YY_RULE_SETUP
return T_WAIT_CMD;
  /* ACE_CC_YY_BREAK */
case 10:
ACE_CC_YY_RULE_SETUP
return T_PRINT_CMD;
  /* ACE_CC_YY_BREAK */
case 11:
ACE_CC_YY_RULE_SETUP
return T_REPEAT_CMD;
  /* ACE_CC_YY_BREAK */
case 12:
ACE_CC_YY_RULE_SETUP
return T_EXCEP_CMD;
  /* ACE_CC_YY_BREAK */
case 13:
ACE_CC_YY_RULE_SETUP
return T_LOOKUP_CMD;
  /* ACE_CC_YY_BREAK */
case 14:
ACE_CC_YY_RULE_SETUP
return T_READ;
  /* ACE_CC_YY_BREAK */
case 15:
ACE_CC_YY_RULE_SETUP
return T_IREAD;
  /* ACE_CC_YY_BREAK */
case 16:
ACE_CC_YY_RULE_SETUP
return T_UPGRADE;
  /* ACE_CC_YY_BREAK */
case 17:
ACE_CC_YY_RULE_SETUP
return T_WRITE;
  /* ACE_CC_YY_BREAK */
case 18:
ACE_CC_YY_RULE_SETUP
return T_IWRITE;
  /* ACE_CC_YY_BREAK */
case 19:
ACE_CC_YY_RULE_SETUP
{ ace_cc_yylval.id = ACE_OS::strdup(&ace_cc_yytext[1]);
       ace_cc_yylval.id[ace_cc_yyleng-2]='\0';
       return Q_STRING; }
  /* ACE_CC_YY_BREAK */
case 20:
ACE_CC_YY_RULE_SETUP
{ ace_cc_yylval.num = ACE_OS::atoi(ace_cc_yytext); return T_NUM; }
  /* ACE_CC_YY_BREAK */
case 21:
ACE_CC_YY_RULE_SETUP
{ ace_cc_yylval.id = ACE_OS::strdup(ace_cc_yytext);
                           return T_IDENT; }
  /* ACE_CC_YY_BREAK */
case 22:
ACE_CC_YY_RULE_SETUP
{ }
  ACE_CC_YY_BREAK
case 23:
ACE_CC_YY_RULE_SETUP
{ }
  ACE_CC_YY_BREAK
case 24:
ACE_CC_YY_RULE_SETUP
{ line_no ++;
                           ACE_OS::strcpy(line_buf, ace_cc_yytext+1);
                           ace_cc_yyless(1); }
  ACE_CC_YY_BREAK
case 25:
ACE_CC_YY_RULE_SETUP
ACE_CC_ECHO;
  ACE_CC_YY_BREAK
case ACE_CC_YY_STATE_EOF(INITIAL):
  ace_cc_yyterminate();

  case ACE_CC_YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int ace_cc_yy_amount_of_matched_text = (int) (ace_cc_yy_cp - ace_cc_yytext_ptr) - 1;

    /* Undo the effects of ACE_CC_YY_DO_BEFORE_ACTION. */
    *ace_cc_yy_cp = ace_cc_yy_hold_char;
    ACE_CC_YY_RESTORE_ACE_CC_YY_MORE_OFFSET

    if ( ace_cc_yy_current_buffer->ace_cc_yy_buffer_status == ACE_CC_YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed ace_cc_yyin at a new source and called
       * ace_cc_yylex().  If so, then we have to assure
       * consistency between ace_cc_yy_current_buffer and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      ace_cc_yy_n_chars = ace_cc_yy_current_buffer->ace_cc_yy_n_chars;
      ace_cc_yy_current_buffer->ace_cc_yy_input_file = ace_cc_yyin;
      ace_cc_yy_current_buffer->ace_cc_yy_buffer_status = ACE_CC_YY_BUFFER_NORMAL;
      }

    /* Note that here we test for ace_cc_yy_c_buf_p "<=" to the position
     * of the first EOB in the buffer, since ace_cc_yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( ace_cc_yy_c_buf_p <= &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[ace_cc_yy_n_chars] )
      { /* This was really a NUL. */
      ace_cc_yy_state_type ace_cc_yy_next_state;

      ace_cc_yy_c_buf_p = ace_cc_yytext_ptr + ace_cc_yy_amount_of_matched_text;

      ace_cc_yy_current_state = ace_cc_yy_get_previous_state();

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * ace_cc_yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      ace_cc_yy_next_state = ace_cc_yy_try_NUL_trans( ace_cc_yy_current_state );

      ace_cc_yy_bp = ace_cc_yytext_ptr + ACE_CC_YY_MORE_ADJ;

      if ( ace_cc_yy_next_state )
        {
        /* Consume the NUL. */
        ace_cc_yy_cp = ++ace_cc_yy_c_buf_p;
        ace_cc_yy_current_state = ace_cc_yy_next_state;
        goto ace_cc_yy_match;
        }

      else
        {
        ace_cc_yy_cp = ace_cc_yy_c_buf_p;
        goto ace_cc_yy_find_action;
        }
      }

    else switch ( ace_cc_yy_get_next_buffer() )
      {
      case EOB_ACT_END_OF_FILE:
        {
#if (ace_cc_yywrap() != 1)
        ace_cc_yy_did_buffer_switch_on_eof = 0;
#endif

        if ( ace_cc_yywrap() )
          {
          /* Note: because we've taken care in
           * ace_cc_yy_get_next_buffer() to have set up
           * ace_cc_yytext, we can now set up
           * ace_cc_yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * ACE_CC_YY_NULL, it'll still work - another
           * ACE_CC_YY_NULL will get returned.
           */
          ace_cc_yy_c_buf_p = ace_cc_yytext_ptr + ACE_CC_YY_MORE_ADJ;

          ace_cc_yy_act = ACE_CC_YY_STATE_EOF(ACE_CC_YY_START);
          goto do_action;
          }

        else
          {
#if (ace_cc_yywrap() != 1)
          if ( ! ace_cc_yy_did_buffer_switch_on_eof )
            ACE_CC_YY_NEW_FILE;
#endif
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        ace_cc_yy_c_buf_p =
          ace_cc_yytext_ptr + ace_cc_yy_amount_of_matched_text;

        ace_cc_yy_current_state = ace_cc_yy_get_previous_state();

        ace_cc_yy_cp = ace_cc_yy_c_buf_p;
        ace_cc_yy_bp = ace_cc_yytext_ptr + ACE_CC_YY_MORE_ADJ;
        goto ace_cc_yy_match;

      case EOB_ACT_LAST_MATCH:
        ace_cc_yy_c_buf_p =
        &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[ace_cc_yy_n_chars];

        ace_cc_yy_current_state = ace_cc_yy_get_previous_state();

        ace_cc_yy_cp = ace_cc_yy_c_buf_p;
        ace_cc_yy_bp = ace_cc_yytext_ptr + ACE_CC_YY_MORE_ADJ;
        goto ace_cc_yy_find_action;
      }
    break;
    }

  default:
    ACE_CC_YY_FATAL_ERROR(
      "fatal flex scanner internal error--no action found" );
  } /* end of action switch */
    } /* end of scanning one token */
  } /* end of ace_cc_yylex */


/* ace_cc_yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */

static int ace_cc_yy_get_next_buffer()
  {
  register char *dest = ace_cc_yy_current_buffer->ace_cc_yy_ch_buf;
  register char *source = ace_cc_yytext_ptr;
  register int number_to_move, i;
  int ret_val;

  if ( ace_cc_yy_c_buf_p > &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[ace_cc_yy_n_chars + 1] )
    ACE_CC_YY_FATAL_ERROR(
    "fatal flex scanner internal error--end of buffer missed" );

  if ( ace_cc_yy_current_buffer->ace_cc_yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( ace_cc_yy_c_buf_p - ace_cc_yytext_ptr - ACE_CC_YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (ace_cc_yy_c_buf_p - ace_cc_yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( ace_cc_yy_current_buffer->ace_cc_yy_buffer_status == ACE_CC_YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    ace_cc_yy_current_buffer->ace_cc_yy_n_chars = ace_cc_yy_n_chars = 0;

  else
    {
    int num_to_read =
      ace_cc_yy_current_buffer->ace_cc_yy_buf_size - number_to_move - 1;

    while ( num_to_read <= 0 )
      { /* Not enough room in the buffer - grow it. */
#ifdef ACE_CC_YY_USES_REJECT
      ACE_CC_YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

      /* just a shorter name for the current buffer */
      ACE_CC_YY_BUFFER_STATE b = ace_cc_yy_current_buffer;

      int ace_cc_yy_c_buf_p_offset =
        (int) (ace_cc_yy_c_buf_p - b->ace_cc_yy_ch_buf);

      if ( b->ace_cc_yy_is_our_buffer )
        {
        int new_size = b->ace_cc_yy_buf_size * 2;

        if ( new_size <= 0 )
          b->ace_cc_yy_buf_size += b->ace_cc_yy_buf_size / 8;
        else
          b->ace_cc_yy_buf_size *= 2;

        b->ace_cc_yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          ace_cc_yy_flex_realloc( (void *) b->ace_cc_yy_ch_buf,
               b->ace_cc_yy_buf_size + 2 );
        }
      else
        /* Can't grow it, we don't own it. */
        b->ace_cc_yy_ch_buf = 0;

      if ( ! b->ace_cc_yy_ch_buf )
        ACE_CC_YY_FATAL_ERROR(
        "fatal error - scanner input buffer overflow" );

      ace_cc_yy_c_buf_p = &b->ace_cc_yy_ch_buf[ace_cc_yy_c_buf_p_offset];

      num_to_read = ace_cc_yy_current_buffer->ace_cc_yy_buf_size -
            number_to_move - 1;
#endif
      }

    if ( num_to_read > ACE_CC_YY_READ_BUF_SIZE )
      num_to_read = ACE_CC_YY_READ_BUF_SIZE;

    /* Read in more data. */
    ACE_CC_YY_INPUT( (&ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[number_to_move]),
      ace_cc_yy_n_chars, num_to_read );

    ace_cc_yy_current_buffer->ace_cc_yy_n_chars = ace_cc_yy_n_chars;
    }

  if ( ace_cc_yy_n_chars == 0 )
    {
    if ( number_to_move == ACE_CC_YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      ace_cc_yyrestart( ace_cc_yyin );
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      ace_cc_yy_current_buffer->ace_cc_yy_buffer_status =
        ACE_CC_YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  ace_cc_yy_n_chars += number_to_move;
  ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[ace_cc_yy_n_chars] = ACE_CC_YY_END_OF_BUFFER_CHAR;
  ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[ace_cc_yy_n_chars + 1] = ACE_CC_YY_END_OF_BUFFER_CHAR;

  ace_cc_yytext_ptr = &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[0];

  return ret_val;
  }


/* ace_cc_yy_get_previous_state - get the state just before the EOB char was reached */

static ace_cc_yy_state_type ace_cc_yy_get_previous_state()
  {
  register ace_cc_yy_state_type ace_cc_yy_current_state;
  register char *ace_cc_yy_cp;

  ace_cc_yy_current_state = ace_cc_yy_start;
  ace_cc_yy_current_state += ACE_CC_YY_AT_BOL();

  for ( ace_cc_yy_cp = ace_cc_yytext_ptr + ACE_CC_YY_MORE_ADJ; ace_cc_yy_cp < ace_cc_yy_c_buf_p; ++ace_cc_yy_cp )
    {
    register ACE_CC_YY_CHAR ace_cc_yy_c = (*ace_cc_yy_cp ? ace_cc_yy_ec[ACE_CC_YY_SC_TO_UI(*ace_cc_yy_cp)] : 1);
    if ( ace_cc_yy_accept[ace_cc_yy_current_state] )
      {
      ace_cc_yy_last_accepting_state = ace_cc_yy_current_state;
      ace_cc_yy_last_accepting_cpos = ace_cc_yy_cp;
      }
    while ( ace_cc_yy_chk[ace_cc_yy_base[ace_cc_yy_current_state] + ace_cc_yy_c] != ace_cc_yy_current_state )
      {
      ace_cc_yy_current_state = (int) ace_cc_yy_def[ace_cc_yy_current_state];
      if ( ace_cc_yy_current_state >= 124 )
        ace_cc_yy_c = ace_cc_yy_meta[(unsigned int) ace_cc_yy_c];
      }
    ace_cc_yy_current_state = ace_cc_yy_nxt[ace_cc_yy_base[ace_cc_yy_current_state] + (unsigned int) ace_cc_yy_c];
    }

  return ace_cc_yy_current_state;
  }


/* ace_cc_yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = ace_cc_yy_try_NUL_trans( current_state );
 */

#ifdef ACE_CC_YY_USE_PROTOS
static ace_cc_yy_state_type ace_cc_yy_try_NUL_trans( ace_cc_yy_state_type ace_cc_yy_current_state )
#else
static ace_cc_yy_state_type ace_cc_yy_try_NUL_trans( ace_cc_yy_current_state )
ace_cc_yy_state_type ace_cc_yy_current_state;
#endif
  {
  register int ace_cc_yy_is_jam;
  register char *ace_cc_yy_cp = ace_cc_yy_c_buf_p;

  register ACE_CC_YY_CHAR ace_cc_yy_c = 1;
  if ( ace_cc_yy_accept[ace_cc_yy_current_state] )
    {
    ace_cc_yy_last_accepting_state = ace_cc_yy_current_state;
    ace_cc_yy_last_accepting_cpos = ace_cc_yy_cp;
    }
  while ( ace_cc_yy_chk[ace_cc_yy_base[ace_cc_yy_current_state] + ace_cc_yy_c] != ace_cc_yy_current_state )
    {
    ace_cc_yy_current_state = (int) ace_cc_yy_def[ace_cc_yy_current_state];
    if ( ace_cc_yy_current_state >= 124 )
      ace_cc_yy_c = ace_cc_yy_meta[(unsigned int) ace_cc_yy_c];
    }
  ace_cc_yy_current_state = ace_cc_yy_nxt[ace_cc_yy_base[ace_cc_yy_current_state] + (unsigned int) ace_cc_yy_c];
  ace_cc_yy_is_jam = (ace_cc_yy_current_state == 123);

  return ace_cc_yy_is_jam ? 0 : ace_cc_yy_current_state;
  }


#ifndef ACE_CC_YY_NO_UNPUT
#ifdef ACE_CC_YY_USE_PROTOS
static void ace_cc_yyunput( int c, register char *ace_cc_yy_bp )
#else
static void ace_cc_yyunput( c, ace_cc_yy_bp )
int c;
register char *ace_cc_yy_bp;
#endif
  {
  register char *ace_cc_yy_cp = ace_cc_yy_c_buf_p;

  /* undo effects of setting up ace_cc_yytext */
  *ace_cc_yy_cp = ace_cc_yy_hold_char;

  if ( ace_cc_yy_cp < ace_cc_yy_current_buffer->ace_cc_yy_ch_buf + 2 )
    { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    register int number_to_move = ace_cc_yy_n_chars + 2;
    register char *dest = &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[
          ace_cc_yy_current_buffer->ace_cc_yy_buf_size + 2];
    register char *source =
        &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[number_to_move];

    while ( source > ace_cc_yy_current_buffer->ace_cc_yy_ch_buf )
      *--dest = *--source;

    ace_cc_yy_cp += (int) (dest - source);
    ace_cc_yy_bp += (int) (dest - source);
    ace_cc_yy_current_buffer->ace_cc_yy_n_chars =
      ace_cc_yy_n_chars = ace_cc_yy_current_buffer->ace_cc_yy_buf_size;

    if ( ace_cc_yy_cp < ace_cc_yy_current_buffer->ace_cc_yy_ch_buf + 2 )
      ACE_CC_YY_FATAL_ERROR( "flex scanner push-back overflow" );
    }

  *--ace_cc_yy_cp = (char) c;


  ace_cc_yytext_ptr = ace_cc_yy_bp;
  ace_cc_yy_hold_char = *ace_cc_yy_cp;
  ace_cc_yy_c_buf_p = ace_cc_yy_cp;
  }
#endif  /* ifndef ACE_CC_YY_NO_UNPUT */

#ifndef ACE_CC_YY_NO_INPUT
#ifdef __cplusplus
static int ace_cc_yyinput()
#else
static int input()
#endif
  {
  int c;

  *ace_cc_yy_c_buf_p = ace_cc_yy_hold_char;

  if ( *ace_cc_yy_c_buf_p == ACE_CC_YY_END_OF_BUFFER_CHAR )
    {
    /* ace_cc_yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ( ace_cc_yy_c_buf_p < &ace_cc_yy_current_buffer->ace_cc_yy_ch_buf[ace_cc_yy_n_chars] )
      /* This was really a NUL. */
      *ace_cc_yy_c_buf_p = '\0';

    else
      { /* need more input */
      int offset = ace_cc_yy_c_buf_p - ace_cc_yytext_ptr;
      ++ace_cc_yy_c_buf_p;

      switch ( ace_cc_yy_get_next_buffer() )
        {
        case EOB_ACT_LAST_MATCH:
          /* This happens because ace_cc_yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          ace_cc_yyrestart( ace_cc_yyin );

          /* fall through */

        case EOB_ACT_END_OF_FILE:
          {
          if ( ace_cc_yywrap() )
            return EOF;

                                        /*          if ( ! ace_cc_yy_did_buffer_switch_on_eof )
            ACE_CC_YY_NEW_FILE;
#ifdef __cplusplus
          return ace_cc_yyinput();
#else
          return input();
                                        #endif */
          }

        case EOB_ACT_CONTINUE_SCAN:
          ace_cc_yy_c_buf_p = ace_cc_yytext_ptr + offset;
          break;
        }
      }
    }

  c = *(unsigned char *) ace_cc_yy_c_buf_p; /* cast for 8-bit char's */
  *ace_cc_yy_c_buf_p = '\0';  /* preserve ace_cc_yytext */
  ace_cc_yy_hold_char = *++ace_cc_yy_c_buf_p;

  ace_cc_yy_current_buffer->ace_cc_yy_at_bol = (c == '\n');

  return c;
  }
#endif /* ! ACE_CC_YY_NO_INPUT */


#ifdef ACE_CC_YY_USE_PROTOS
void ace_cc_yyrestart( FILE *input_file )
#else
void ace_cc_yyrestart( input_file )
FILE *input_file;
#endif
  {
  if ( ! ace_cc_yy_current_buffer )
    ace_cc_yy_current_buffer = ace_cc_yy_create_buffer( ace_cc_yyin, ACE_CC_YY_BUF_SIZE );

  ace_cc_yy_init_buffer( ace_cc_yy_current_buffer, input_file );
  ace_cc_yy_load_buffer_state();
  }


#ifdef ACE_CC_YY_USE_PROTOS
void ace_cc_yy_switch_to_buffer( ACE_CC_YY_BUFFER_STATE new_buffer )
#else
void ace_cc_yy_switch_to_buffer( new_buffer )
ACE_CC_YY_BUFFER_STATE new_buffer;
#endif
  {
  if ( ace_cc_yy_current_buffer == new_buffer )
    return;

  if ( ace_cc_yy_current_buffer )
    {
    /* Flush out information for old buffer. */
    *ace_cc_yy_c_buf_p = ace_cc_yy_hold_char;
    ace_cc_yy_current_buffer->ace_cc_yy_buf_pos = ace_cc_yy_c_buf_p;
    ace_cc_yy_current_buffer->ace_cc_yy_n_chars = ace_cc_yy_n_chars;
    }

  ace_cc_yy_current_buffer = new_buffer;
  ace_cc_yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (ace_cc_yywrap()) processing, but the only time this flag
   * is looked at is after ace_cc_yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
#if (ace_cc_yywrap() != 1)
  ace_cc_yy_did_buffer_switch_on_eof = 1;
#endif
  }


#ifdef ACE_CC_YY_USE_PROTOS
void ace_cc_yy_load_buffer_state( void )
#else
void ace_cc_yy_load_buffer_state()
#endif
  {
  ace_cc_yy_n_chars = ace_cc_yy_current_buffer->ace_cc_yy_n_chars;
  ace_cc_yytext_ptr = ace_cc_yy_c_buf_p = ace_cc_yy_current_buffer->ace_cc_yy_buf_pos;
  ace_cc_yyin = ace_cc_yy_current_buffer->ace_cc_yy_input_file;
  ace_cc_yy_hold_char = *ace_cc_yy_c_buf_p;
  }


#ifdef ACE_CC_YY_USE_PROTOS
ACE_CC_YY_BUFFER_STATE ace_cc_yy_create_buffer( FILE *file, int size )
#else
ACE_CC_YY_BUFFER_STATE ace_cc_yy_create_buffer( file, size )
FILE *file;
int size;
#endif
  {
  ACE_CC_YY_BUFFER_STATE b;

  b = (ACE_CC_YY_BUFFER_STATE) ace_cc_yy_flex_alloc( sizeof( struct ace_cc_yy_buffer_state ) );
  if ( ! b )
    ACE_CC_YY_FATAL_ERROR( "out of dynamic memory in ace_cc_yy_create_buffer()" );

  b->ace_cc_yy_buf_size = size;

  /* ace_cc_yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->ace_cc_yy_ch_buf = (char *) ace_cc_yy_flex_alloc( b->ace_cc_yy_buf_size + 2 );
  if ( ! b->ace_cc_yy_ch_buf )
    ACE_CC_YY_FATAL_ERROR( "out of dynamic memory in ace_cc_yy_create_buffer()" );

  b->ace_cc_yy_is_our_buffer = 1;

  ace_cc_yy_init_buffer( b, file );

  return b;
  }


#ifdef ACE_CC_YY_USE_PROTOS
void ace_cc_yy_delete_buffer( ACE_CC_YY_BUFFER_STATE b )
#else
void ace_cc_yy_delete_buffer( b )
ACE_CC_YY_BUFFER_STATE b;
#endif
  {
  if ( ! b )
    return;

  if ( b == ace_cc_yy_current_buffer )
    ace_cc_yy_current_buffer = (ACE_CC_YY_BUFFER_STATE) 0;

  if ( b->ace_cc_yy_is_our_buffer )
    ace_cc_yy_flex_free( (void *) b->ace_cc_yy_ch_buf );

  ace_cc_yy_flex_free( (void *) b );
  }



#ifdef ACE_CC_YY_USE_PROTOS
void ace_cc_yy_init_buffer( ACE_CC_YY_BUFFER_STATE b, FILE *file )
#else
void ace_cc_yy_init_buffer( b, file )
ACE_CC_YY_BUFFER_STATE b;
FILE *file;
#endif


  {
  ace_cc_yy_flush_buffer( b );

  b->ace_cc_yy_input_file = file;
  b->ace_cc_yy_fill_buffer = 1;

#if ACE_CC_YY_ALWAYS_INTERACTIVE
  b->ace_cc_yy_is_interactive = 1;
#else
#if ACE_CC_YY_NEVER_INTERACTIVE
  b->ace_cc_yy_is_interactive = 0;
#else
  b->ace_cc_yy_is_interactive = file ? (ACE_OS::ace_isatty( fileno(file) ) > 0) : 0;
#endif
#endif
  }


#ifdef ACE_CC_YY_USE_PROTOS
void ace_cc_yy_flush_buffer( ACE_CC_YY_BUFFER_STATE b )
#else
void ace_cc_yy_flush_buffer( b )
ACE_CC_YY_BUFFER_STATE b;
#endif

  {
  if ( ! b )
    return;

  b->ace_cc_yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->ace_cc_yy_ch_buf[0] = ACE_CC_YY_END_OF_BUFFER_CHAR;
  b->ace_cc_yy_ch_buf[1] = ACE_CC_YY_END_OF_BUFFER_CHAR;

  b->ace_cc_yy_buf_pos = &b->ace_cc_yy_ch_buf[0];

  b->ace_cc_yy_at_bol = 1;
  b->ace_cc_yy_buffer_status = ACE_CC_YY_BUFFER_NEW;

  if ( b == ace_cc_yy_current_buffer )
    ace_cc_yy_load_buffer_state();
  }


#ifndef ACE_CC_YY_NO_SCAN_BUFFER
#ifdef ACE_CC_YY_USE_PROTOS
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_buffer( char *base, ace_cc_yy_size_t size )
#else
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_buffer( base, size )
char *base;
ace_cc_yy_size_t size;
#endif
  {
  ACE_CC_YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != ACE_CC_YY_END_OF_BUFFER_CHAR ||
       base[size-1] != ACE_CC_YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (ACE_CC_YY_BUFFER_STATE) ace_cc_yy_flex_alloc( sizeof( struct ace_cc_yy_buffer_state ) );
  if ( ! b )
    ACE_CC_YY_FATAL_ERROR( "out of dynamic memory in ace_cc_yy_scan_buffer()" );

  b->ace_cc_yy_buf_size = size - 2; /* "- 2" to take care of EOB's */
  b->ace_cc_yy_buf_pos = b->ace_cc_yy_ch_buf = base;
  b->ace_cc_yy_is_our_buffer = 0;
  b->ace_cc_yy_input_file = 0;
  b->ace_cc_yy_n_chars = b->ace_cc_yy_buf_size;
  b->ace_cc_yy_is_interactive = 0;
  b->ace_cc_yy_at_bol = 1;
  b->ace_cc_yy_fill_buffer = 0;
  b->ace_cc_yy_buffer_status = ACE_CC_YY_BUFFER_NEW;

  ace_cc_yy_switch_to_buffer( b );

  return b;
  }
#endif


#ifndef ACE_CC_YY_NO_SCAN_STRING
#ifdef ACE_CC_YY_USE_PROTOS
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_string( ace_cc_yyconst char *ace_cc_yy_str )
#else
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_string( ace_cc_yy_str )
ace_cc_yyconst char *ace_cc_yy_str;
#endif
  {
  int len;
  for ( len = 0; ace_cc_yy_str[len]; ++len )
    ;

  return ace_cc_yy_scan_bytes( ace_cc_yy_str, len );
  }
#endif


#ifndef ACE_CC_YY_NO_SCAN_BYTES
#ifdef ACE_CC_YY_USE_PROTOS
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_bytes( ace_cc_yyconst char *bytes, int len )
#else
ACE_CC_YY_BUFFER_STATE ace_cc_yy_scan_bytes( bytes, len )
ace_cc_yyconst char *bytes;
int len;
#endif
  {
  ACE_CC_YY_BUFFER_STATE b;
  char *buf;
  ace_cc_yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len + 2;
  buf = (char *) ace_cc_yy_flex_alloc( n );
  if ( ! buf )
    ACE_CC_YY_FATAL_ERROR( "out of dynamic memory in ace_cc_yy_scan_bytes()" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = ACE_CC_YY_END_OF_BUFFER_CHAR;

  b = ace_cc_yy_scan_buffer( buf, n );
  if ( ! b )
    ACE_CC_YY_FATAL_ERROR( "bad buffer in ace_cc_yy_scan_bytes()" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->ace_cc_yy_is_our_buffer = 1;

  return b;
  }
#endif


#ifndef ACE_CC_YY_NO_PUSH_STATE
#ifdef ACE_CC_YY_USE_PROTOS
static void ace_cc_yy_push_state( int new_state )
#else
static void ace_cc_yy_push_state( new_state )
int new_state;
#endif
  {
  if ( ace_cc_yy_start_stack_ptr >= ace_cc_yy_start_stack_depth )
    {
    ace_cc_yy_size_t new_size;

    ace_cc_yy_start_stack_depth += ACE_CC_YY_START_STACK_INCR;
    new_size = ace_cc_yy_start_stack_depth * sizeof( int );

    if ( ! ace_cc_yy_start_stack )
      ace_cc_yy_start_stack = (int *) ace_cc_yy_flex_alloc( new_size );

    else
      ace_cc_yy_start_stack = (int *) ace_cc_yy_flex_realloc(
          (void *) ace_cc_yy_start_stack, new_size );

    if ( ! ace_cc_yy_start_stack )
      ACE_CC_YY_FATAL_ERROR(
      "out of memory expanding start-condition stack" );
    }

  ace_cc_yy_start_stack[ace_cc_yy_start_stack_ptr++] = ACE_CC_YY_START;

  BEGIN(new_state);
  }
#endif


#ifndef ACE_CC_YY_NO_POP_STATE
static void ace_cc_yy_pop_state()
  {
  if ( --ace_cc_yy_start_stack_ptr < 0 )
    ACE_CC_YY_FATAL_ERROR( "start-condition stack underflow" );

  BEGIN(ace_cc_yy_start_stack[ace_cc_yy_start_stack_ptr]);
  }
#endif


#ifndef ACE_CC_YY_NO_TOP_STATE
static int ace_cc_yy_top_state()
  {
  return ace_cc_yy_start_stack[ace_cc_yy_start_stack_ptr - 1];
  }
#endif

#ifndef ACE_CC_YY_EXIT_FAILURE
#define ACE_CC_YY_EXIT_FAILURE 2
#endif

#ifdef ACE_CC_YY_USE_PROTOS
static void ace_cc_yy_fatal_error( ace_cc_yyconst char msg[] )
#else
static void ace_cc_yy_fatal_error( msg )
char msg[];
#endif
  {
  (void) ACE_OS::fprintf( stderr, "%s\n", msg );
  ACE_OS::exit( ACE_CC_YY_EXIT_FAILURE );
  }



/* Redefine ace_cc_yyless() so it works in section 3 code. */

#undef ace_cc_yyless
#define ace_cc_yyless(n) \
  do \
    { \
    /* Undo effects of setting up ace_cc_yytext. */ \
    ace_cc_yytext[ace_cc_yyleng] = ace_cc_yy_hold_char; \
    ace_cc_yy_c_buf_p = ace_cc_yytext + n; \
    ace_cc_yy_hold_char = *ace_cc_yy_c_buf_p; \
    *ace_cc_yy_c_buf_p = '\0'; \
    ace_cc_yyleng = n; \
    } \
  while ( 0 )


/* Internal utility routines. */

#ifndef ace_cc_yytext_ptr
#ifdef ACE_CC_YY_USE_PROTOS
static void ace_cc_yy_flex_strncpy( char *s1, ace_cc_yyconst char *s2, int n )
#else
static void ace_cc_yy_flex_strncpy( s1, s2, n )
char *s1;
ace_cc_yyconst char *s2;
int n;
#endif
  {
  register int i;
  for ( i = 0; i < n; ++i )
    s1[i] = s2[i];
  }
#endif

#ifdef ACE_CC_YY_NEED_STRLEN
#ifdef ACE_CC_YY_USE_PROTOS
static int ace_cc_yy_flex_strlen( ace_cc_yyconst char *s )
#else
static int ace_cc_yy_flex_strlen( s )
ace_cc_yyconst char *s;
#endif
  {
  register int n;
  for ( n = 0; s[n]; ++n )
    ;

  return n;
  }
#endif


#ifdef ACE_CC_YY_USE_PROTOS
static void *ace_cc_yy_flex_alloc( ace_cc_yy_size_t size )
#else
static void *ace_cc_yy_flex_alloc( size )
ace_cc_yy_size_t size;
#endif
  {
    return (void *) ACE_OS::malloc( size );
  }

#ifdef ACE_CC_YY_USE_PROTOS
static void *ace_cc_yy_flex_realloc( void *ptr, ace_cc_yy_size_t size )
#else
static void *ace_cc_yy_flex_realloc( ptr, size )
void *ptr;
ace_cc_yy_size_t size;
#endif
  {
  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
   return (void *) ACE_OS::realloc( (char *) ptr, size );
  }

#ifdef ACE_CC_YY_USE_PROTOS
static void ace_cc_yy_flex_free( void *ptr )
#else
static void ace_cc_yy_flex_free( ptr )
void *ptr;
#endif
  {
  ACE_OS::free( ACE_MALLOC_T (ptr) );
  }

#if ACE_CC_YY_MAIN
int main()
  {
  ace_cc_yylex();
  return 0;
  }
#endif
