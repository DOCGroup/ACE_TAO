//
// $Id$
//
// ================================================================
//
// = LIBRARY
//   TAO
//
// = FILENAME
//   RTCORBA.pidl
//
// = DESCRIPTION
//
//   The RTCORBA module specified in ptc/99-05-03 (Real-Time
//   CORBA Joint Revised Submission May 28, 1999).
//
//   Changes to the original OMG idl:
//     1.  All RT policies have been assigned PolicyType values
//         from the range reserved for TAO.  0x54410002 through
//         0x54410007 are used for RT Policies.  This is in effect
//         until OMG will standardize PolicyType values (currently RT
//         CORBA spec contains question marks instead of values).
//     2.  All interfaces in RTCORBA module have been made <local>.
//         Original idl defined most interfaces as local, but not
//         all.  It is unclear whether that was intentional or a
//         result of sloppiness.  Until the former is proved, the
//         latter will be assumed and all interfaces made <local>.
//     3.  Two TAO-specific interfaces, UnixDomainProtocolProperties
//         and SharedMemoryProtocolProperties, have been added to allow
//         configuration of TAO's UIOP and SHMEM pluggable protocols
//         through RTCORBA Protocol Policies.
//
//   This file was used to generate the code in
//   RTCORBA{C,S,S_T}.{h,i,cpp} The command used to generate code
//   is:
//
//     tao_idl -o orig -Gp -Gd -Ge 1 -Gv
//          -Wb,export_macro=TAO_Export
//          -Wb,export_include="tao/corbafwd.h"
//          -Wb,pre_include="ace/pre.h"
//          -Wb,post_include="ace/post.h"
//          RTCORBA.pidl
//
//   After the files are generated, patches located in tao/diffs
//   directory must be applied.  The patches provide the following
//   fixes: 1) disable the code under certain configurations, i.e.,
//   apply "if (TAO_HAS_RT_CORBA)", 2) remove several unnecessary
//   includes, e.g., corba.h, stream.h, Policy.h, 3) add anything else
//   we need into the namespace, i.e., TAO_Priority_Mapping, and 4)
//   fix "nested_class" occurrences in .cpp.
//   These changes are required because the generated code is part of
//   the TAO library, it hardly makes any sense to change the IDL
//   compiler to support changes that are very occasional.
//
// ================================================================

#ifndef _RT_CORBA_IDL_
#define _RT_CORBA_IDL_

#include <orb.idl>
#include <IOP.pidl>
#include <TimeBase.pidl>

#pragma prefix "omg.org"

module RTCORBA
{
  // Priorities.
  typedef short NativePriority;
  typedef short Priority;
  const Priority minPriority = 0;
  const Priority maxPriority = 32767;

  native PriorityMapping;
  native PriorityTransform;

  // Threadpool types.
  typedef unsigned long ThreadpoolId;
  struct ThreadpoolLane
  {
    Priority lane_priority;
    unsigned long static_threads;
    unsigned long dynamic_threads;
  };
  typedef sequence <ThreadpoolLane> ThreadpoolLanes;

  // RT Policies.

  // Priority Model Policy.
  const CORBA::PolicyType PRIORITY_MODEL_POLICY_TYPE = 0x54410002;
  enum PriorityModel
  {
    CLIENT_PROPAGATED,
    SERVER_DECLARED
  };

  local interface PriorityModelPolicy : CORBA::Policy
  {
    readonly attribute PriorityModel priority_model;
    readonly attribute Priority server_priority;
  };

  // Threadpool Policy.
  const CORBA::PolicyType THREADPOOL_POLICY_TYPE = 0x54410003;
  local interface ThreadpoolPolicy : CORBA::Policy
  {
    readonly attribute ThreadpoolId threadpool;
  };

  // Private Connection Policy
  const CORBA::PolicyType PRIVATE_CONNECTION_POLICY_TYPE = 0x54410006;
  local interface PrivateConnectionPolicy : CORBA::Policy {};

  // PriorityBandedConnectionPolicy.
  struct PriorityBand
  {
    Priority low;
    Priority high;
  };
  typedef sequence <PriorityBand> PriorityBands;

  const CORBA::PolicyType PRIORITY_BANDED_CONNECTION_POLICY_TYPE = 0x54410007;
  local interface PriorityBandedConnectionPolicy : CORBA::Policy
  {
    readonly attribute PriorityBands priority_bands;
  };

  // Protocol Properties.
  local interface ProtocolProperties {};

  local interface TCPProtocolProperties : ProtocolProperties
  {
    attribute long send_buffer_size;
    attribute long recv_buffer_size;
    attribute boolean keep_alive;
    attribute boolean dont_route;
    attribute boolean no_delay;
  };

  local interface GIOPProtocolProperties : ProtocolProperties {};

  // Properties for TAO-specific protocols (these protocols &
  // interfaces are not specified by the OMG).

  // Communication over Unix Domain Sockets (Local IPC).
  local interface UnixDomainProtocolProperties : ProtocolProperties
  {
    attribute long send_buffer_size;
    attribute long recv_buffer_size;
  };

  // Communication over Shared Memory.
  local interface SharedMemoryProtocolProperties : ProtocolProperties
  {
    attribute long preallocate_buffer_size;
    attribute string mmap_filename;
    attribute string mmap_lockname;
  };

  // End of TAO-specific interfaces.

  struct Protocol
  {
    IOP::ProfileId protocol_type;
    ProtocolProperties orb_protocol_properties;
    ProtocolProperties transport_protocol_properties;
  };
  typedef sequence <Protocol> ProtocolList;

  // Server Protocol Policy
  const CORBA::PolicyType SERVER_PROTOCOL_POLICY_TYPE = 0x54410004;
  local interface ServerProtocolPolicy : CORBA::Policy
  {
    readonly attribute ProtocolList protocols;
  };

  // Client Protocol Policy
  const CORBA::PolicyType CLIENT_PROTOCOL_POLICY_TYPE = 0x54410005;
  local interface ClientProtocolPolicy : CORBA::Policy
  {
    readonly attribute ProtocolList protocols;
  };

  // RT Current.
  local interface Current : CORBA::Current
  {
    attribute Priority the_priority;
  };

  // Mutex.
  local interface Mutex
  {
      void lock ();
      void unlock ();
      boolean try_lock (in TimeBase::TimeT max_wait);
    // if max_wait = 0 then return immediately
  };

  // RTORB.
  local interface RTORB
  {
    // Mutex creation/destruction.
    Mutex create_mutex ();
    void destroy_mutex (in Mutex the_mutex);

    // Named Mutex creation/opening
    exception MutexNotFound {};
    Mutex create_named_mutex (in string name,
                              out boolean created_flag);
    Mutex open_named_mutex (in string name)
      raises (MutexNotFound);

    // Threadpool creation/destruction.
    exception InvalidThreadpool {};

    ThreadpoolId create_threadpool (in unsigned long stacksize,
                                    in unsigned long static_threads,
                                    in unsigned long dynamic_threads,
                                    in Priority default_priority,
                                    in boolean allow_request_buffering,
                                    in unsigned long max_buffered_requests,
                                    in unsigned long max_request_buffer_size);

    ThreadpoolId create_threadpool_with_lanes (in unsigned long stacksize,
                                               in ThreadpoolLanes lanes,
                                               in boolean allow_borrowing,
                                               in boolean allow_request_buffering,
                                               in unsigned long max_buffered_requests,
                                               in unsigned long max_request_buffer_size);

    void destroy_threadpool (in ThreadpoolId threadpool)
      raises (InvalidThreadpool);

    // RT Policies creation.
    PriorityModelPolicy create_priority_model_policy (in PriorityModel priority_model,
                                                      in Priority server_priority);

    ThreadpoolPolicy create_threadpool_policy (in ThreadpoolId threadpool);

    PriorityBandedConnectionPolicy
      create_priority_banded_connection_policy (in PriorityBands priority_bands);

    PrivateConnectionPolicy create_private_connection_policy ();

    ServerProtocolPolicy create_server_protocol_policy (in ProtocolList protocols);

    ClientProtocolPolicy create_client_protocol_policy (in ProtocolList protocols);
  };
};

#pragma prefix ""

#endif /* _RT_CORBA_IDL_ */
