/* -*- C++ -*- */
// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/MessagingS.h"
#include "tao/POA_CORBA.h"
#include "tao/Operation_Table.h"
#include "tao/Server_Request.h"

#if !defined (__ACE_INLINE__)
#include "MessagingS.i"
#endif /* !defined INLINE */

ACE_RCSID(tao, MessagingS, "$Id$")

POA_Messaging::RebindPolicy::RebindPolicy (void)
{
}

POA_Messaging::RebindPolicy::RebindPolicy (const RebindPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RebindPolicy::~RebindPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RebindPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RebindPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RebindPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RebindPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RebindPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RebindPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RebindPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RebindPolicy:1.0";
}

POA_Messaging::_tao_collocated_RebindPolicy::_tao_collocated_RebindPolicy (
    POA_Messaging::RebindPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RebindPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RebindPolicy_ptr POA_Messaging::_tao_collocated_RebindPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RebindPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

Messaging::RebindMode POA_Messaging::_tao_collocated_RebindPolicy::rebind_mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->rebind_mode (
    ACE_TRY_ENV
  );
}


Messaging::RebindPolicy*
POA_Messaging::RebindPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RebindPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::SyncScopePolicy::SyncScopePolicy (void)
{
}

POA_Messaging::SyncScopePolicy::SyncScopePolicy (const SyncScopePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::SyncScopePolicy::~SyncScopePolicy (void)
{
}

CORBA::Boolean POA_Messaging::SyncScopePolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/SyncScopePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::SyncScopePolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/SyncScopePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::SyncScopePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::SyncScopePolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::SyncScopePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/SyncScopePolicy:1.0";
}

POA_Messaging::_tao_collocated_SyncScopePolicy::_tao_collocated_SyncScopePolicy (
    POA_Messaging::SyncScopePolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,SyncScopePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::SyncScopePolicy_ptr POA_Messaging::_tao_collocated_SyncScopePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_SyncScopePolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

Messaging::SyncScope POA_Messaging::_tao_collocated_SyncScopePolicy::synchronization  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->synchronization (
    ACE_TRY_ENV
  );
}


Messaging::SyncScopePolicy*
POA_Messaging::SyncScopePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_SyncScopePolicy (this, stub);
}

// ****************************************************************

POA_Messaging::RequestPriorityPolicy::RequestPriorityPolicy (void)
{
}

POA_Messaging::RequestPriorityPolicy::RequestPriorityPolicy (const RequestPriorityPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RequestPriorityPolicy::~RequestPriorityPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RequestPriorityPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestPriorityPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RequestPriorityPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RequestPriorityPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RequestPriorityPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RequestPriorityPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RequestPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestPriorityPolicy:1.0";
}

POA_Messaging::_tao_collocated_RequestPriorityPolicy::_tao_collocated_RequestPriorityPolicy (
    POA_Messaging::RequestPriorityPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RequestPriorityPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RequestPriorityPolicy_ptr POA_Messaging::_tao_collocated_RequestPriorityPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RequestPriorityPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

Messaging::PriorityRange POA_Messaging::_tao_collocated_RequestPriorityPolicy::priority_range  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->priority_range (
    ACE_TRY_ENV
  );
}


Messaging::RequestPriorityPolicy*
POA_Messaging::RequestPriorityPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RequestPriorityPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::ReplyPriorityPolicy::ReplyPriorityPolicy (void)
{
}

POA_Messaging::ReplyPriorityPolicy::ReplyPriorityPolicy (const ReplyPriorityPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyPriorityPolicy::~ReplyPriorityPolicy (void)
{
}

CORBA::Boolean POA_Messaging::ReplyPriorityPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyPriorityPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::ReplyPriorityPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyPriorityPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyPriorityPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::ReplyPriorityPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::ReplyPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyPriorityPolicy:1.0";
}

POA_Messaging::_tao_collocated_ReplyPriorityPolicy::_tao_collocated_ReplyPriorityPolicy (
    POA_Messaging::ReplyPriorityPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,ReplyPriorityPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyPriorityPolicy_ptr POA_Messaging::_tao_collocated_ReplyPriorityPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyPriorityPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

Messaging::PriorityRange POA_Messaging::_tao_collocated_ReplyPriorityPolicy::priority_range  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->priority_range (
    ACE_TRY_ENV
  );
}


Messaging::ReplyPriorityPolicy*
POA_Messaging::ReplyPriorityPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_ReplyPriorityPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::RequestStartTimePolicy::RequestStartTimePolicy (void)
{
}

POA_Messaging::RequestStartTimePolicy::RequestStartTimePolicy (const RequestStartTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RequestStartTimePolicy::~RequestStartTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::RequestStartTimePolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestStartTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RequestStartTimePolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RequestStartTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RequestStartTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RequestStartTimePolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RequestStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestStartTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_RequestStartTimePolicy::_tao_collocated_RequestStartTimePolicy (
    POA_Messaging::RequestStartTimePolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RequestStartTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RequestStartTimePolicy_ptr POA_Messaging::_tao_collocated_RequestStartTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RequestStartTimePolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_RequestStartTimePolicy::start_time  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->start_time (
    ACE_TRY_ENV
  );
}


Messaging::RequestStartTimePolicy*
POA_Messaging::RequestStartTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RequestStartTimePolicy (this, stub);
}

// ****************************************************************

POA_Messaging::RequestEndTimePolicy::RequestEndTimePolicy (void)
{
}

POA_Messaging::RequestEndTimePolicy::RequestEndTimePolicy (const RequestEndTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RequestEndTimePolicy::~RequestEndTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::RequestEndTimePolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestEndTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RequestEndTimePolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RequestEndTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RequestEndTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RequestEndTimePolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RequestEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestEndTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_RequestEndTimePolicy::_tao_collocated_RequestEndTimePolicy (
    POA_Messaging::RequestEndTimePolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RequestEndTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RequestEndTimePolicy_ptr POA_Messaging::_tao_collocated_RequestEndTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RequestEndTimePolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_RequestEndTimePolicy::end_time  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->end_time (
    ACE_TRY_ENV
  );
}


Messaging::RequestEndTimePolicy*
POA_Messaging::RequestEndTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RequestEndTimePolicy (this, stub);
}

// ****************************************************************

POA_Messaging::ReplyStartTimePolicy::ReplyStartTimePolicy (void)
{
}

POA_Messaging::ReplyStartTimePolicy::ReplyStartTimePolicy (const ReplyStartTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyStartTimePolicy::~ReplyStartTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::ReplyStartTimePolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyStartTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::ReplyStartTimePolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyStartTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyStartTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::ReplyStartTimePolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::ReplyStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyStartTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_ReplyStartTimePolicy::_tao_collocated_ReplyStartTimePolicy (
    POA_Messaging::ReplyStartTimePolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,ReplyStartTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyStartTimePolicy_ptr POA_Messaging::_tao_collocated_ReplyStartTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyStartTimePolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_ReplyStartTimePolicy::start_time  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->start_time (
    ACE_TRY_ENV
  );
}


Messaging::ReplyStartTimePolicy*
POA_Messaging::ReplyStartTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_ReplyStartTimePolicy (this, stub);
}

// ****************************************************************

POA_Messaging::ReplyEndTimePolicy::ReplyEndTimePolicy (void)
{
}

POA_Messaging::ReplyEndTimePolicy::ReplyEndTimePolicy (const ReplyEndTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyEndTimePolicy::~ReplyEndTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::ReplyEndTimePolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyEndTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::ReplyEndTimePolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyEndTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyEndTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::ReplyEndTimePolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::ReplyEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyEndTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_ReplyEndTimePolicy::_tao_collocated_ReplyEndTimePolicy (
    POA_Messaging::ReplyEndTimePolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,ReplyEndTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyEndTimePolicy_ptr POA_Messaging::_tao_collocated_ReplyEndTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyEndTimePolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_ReplyEndTimePolicy::end_time  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->end_time (
    ACE_TRY_ENV
  );
}


Messaging::ReplyEndTimePolicy*
POA_Messaging::ReplyEndTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_ReplyEndTimePolicy (this, stub);
}

// ****************************************************************

POA_Messaging::RelativeRequestTimeoutPolicy::RelativeRequestTimeoutPolicy (void)
{
}

POA_Messaging::RelativeRequestTimeoutPolicy::RelativeRequestTimeoutPolicy (const RelativeRequestTimeoutPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RelativeRequestTimeoutPolicy::~RelativeRequestTimeoutPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RelativeRequestTimeoutPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RelativeRequestTimeoutPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RelativeRequestTimeoutPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RelativeRequestTimeoutPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RelativeRequestTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0";
}

POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::_tao_collocated_RelativeRequestTimeoutPolicy (
    POA_Messaging::RelativeRequestTimeoutPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RelativeRequestTimeoutPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RelativeRequestTimeoutPolicy_ptr POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

TimeBase::TimeT POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::relative_expiry  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->relative_expiry (
    ACE_TRY_ENV
  );
}


Messaging::RelativeRequestTimeoutPolicy*
POA_Messaging::RelativeRequestTimeoutPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::RelativeRoundtripTimeoutPolicy::RelativeRoundtripTimeoutPolicy (void)
{
}

POA_Messaging::RelativeRoundtripTimeoutPolicy::RelativeRoundtripTimeoutPolicy (const RelativeRoundtripTimeoutPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RelativeRoundtripTimeoutPolicy::~RelativeRoundtripTimeoutPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RelativeRoundtripTimeoutPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RelativeRoundtripTimeoutPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RelativeRoundtripTimeoutPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RelativeRoundtripTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0";
}

POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::_tao_collocated_RelativeRoundtripTimeoutPolicy (
    POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RelativeRoundtripTimeoutPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

TimeBase::TimeT POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::relative_expiry  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->relative_expiry (
    ACE_TRY_ENV
  );
}


Messaging::RelativeRoundtripTimeoutPolicy*
POA_Messaging::RelativeRoundtripTimeoutPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::RoutingPolicy::RoutingPolicy (void)
{
}

POA_Messaging::RoutingPolicy::RoutingPolicy (const RoutingPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::RoutingPolicy::~RoutingPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RoutingPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RoutingPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::RoutingPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RoutingPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RoutingPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::RoutingPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::RoutingPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RoutingPolicy:1.0";
}

POA_Messaging::_tao_collocated_RoutingPolicy::_tao_collocated_RoutingPolicy (
    POA_Messaging::RoutingPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,RoutingPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RoutingPolicy_ptr POA_Messaging::_tao_collocated_RoutingPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RoutingPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

Messaging::RoutingTypeRange POA_Messaging::_tao_collocated_RoutingPolicy::routing_range  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->routing_range (
    ACE_TRY_ENV
  );
}


Messaging::RoutingPolicy*
POA_Messaging::RoutingPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_RoutingPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::MaxHopsPolicy::MaxHopsPolicy (void)
{
}

POA_Messaging::MaxHopsPolicy::MaxHopsPolicy (const MaxHopsPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::MaxHopsPolicy::~MaxHopsPolicy (void)
{
}

CORBA::Boolean POA_Messaging::MaxHopsPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/MaxHopsPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::MaxHopsPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/MaxHopsPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::MaxHopsPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::MaxHopsPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::MaxHopsPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/MaxHopsPolicy:1.0";
}

POA_Messaging::_tao_collocated_MaxHopsPolicy::_tao_collocated_MaxHopsPolicy (
    POA_Messaging::MaxHopsPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,MaxHopsPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::MaxHopsPolicy_ptr POA_Messaging::_tao_collocated_MaxHopsPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_MaxHopsPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

CORBA::UShort POA_Messaging::_tao_collocated_MaxHopsPolicy::max_hops  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->max_hops (
    ACE_TRY_ENV
  );
}


Messaging::MaxHopsPolicy*
POA_Messaging::MaxHopsPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_MaxHopsPolicy (this, stub);
}

// ****************************************************************

POA_Messaging::QueueOrderPolicy::QueueOrderPolicy (void)
{
}

POA_Messaging::QueueOrderPolicy::QueueOrderPolicy (const QueueOrderPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
    TAO_ServantBase (rhs)
{}

POA_Messaging::QueueOrderPolicy::~QueueOrderPolicy (void)
{
}

CORBA::Boolean POA_Messaging::QueueOrderPolicy::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/QueueOrderPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::QueueOrderPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/QueueOrderPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::QueueOrderPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::QueueOrderPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::QueueOrderPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/QueueOrderPolicy:1.0";
}

POA_Messaging::_tao_collocated_QueueOrderPolicy::_tao_collocated_QueueOrderPolicy (
    POA_Messaging::QueueOrderPolicy_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,QueueOrderPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::QueueOrderPolicy_ptr POA_Messaging::_tao_collocated_QueueOrderPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_QueueOrderPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

Messaging::Ordering POA_Messaging::_tao_collocated_QueueOrderPolicy::allowed_orders  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->allowed_orders (
    ACE_TRY_ENV
  );
}


Messaging::QueueOrderPolicy*
POA_Messaging::QueueOrderPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_QueueOrderPolicy (this, stub);
}

// ****************************************************************

#if defined (TAO_POLLER)
POA_Messaging::ReplyHandler::ReplyHandler (void)
{
}

POA_Messaging::ReplyHandler::ReplyHandler (const ReplyHandler& rhs)
  :   TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyHandler::~ReplyHandler (void)
{
}

CORBA::Boolean POA_Messaging::ReplyHandler::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyHandler:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::ReplyHandler::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyHandler:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyHandler_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::ReplyHandler::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
}

const char* POA_Messaging::ReplyHandler::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyHandler:1.0";
}

POA_Messaging::_tao_collocated_ReplyHandler::_tao_collocated_ReplyHandler (
    POA_Messaging::ReplyHandler_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,ReplyHandler) (),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyHandler_ptr POA_Messaging::_tao_collocated_ReplyHandler::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyHandler::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}


Messaging::ReplyHandler*
POA_Messaging::ReplyHandler::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_ReplyHandler (this, stub);
}

// ****************************************************************

class TAO_Messaging_Poller_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:37:20 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: /project/macarena/coryan/head/ACE_wrappers/bin/gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Messaging_Poller_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Messaging_Poller_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
     30, 30, 30, 30, 30,  0, 30,  0, 30, 10,
     30,  5, 30, 30, 30,  0, 30, 30, 30, 30,
     30, 30, 30, 30,  0, 30,  0, 30, 30, 30,
     30,  0, 30, 30, 30, 30, 30, 30,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Messaging_Poller_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 11,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 23,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 29,
      HASH_VALUE_RANGE = 25,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",}, {"",}, {"",}, {"",}, {"",},
      {"_is_a",  &POA_Messaging::Poller::_is_a_skel},
      {"is_ready",      &POA_Messaging::Poller::is_ready_skel},
      {"_get_target",   &POA_Messaging::Poller::_get_target_skel},
      {"_non_existent",  &POA_Messaging::Poller::_non_existent_skel},
      {"_get_op_name",  &POA_Messaging::Poller::_get_op_name_skel},
      {"_get_is_from_poller",   &POA_Messaging::Poller::_get_is_from_poller_skel},
      {"_get_operation_target",         &POA_Messaging::Poller::_get_operation_target_skel},
      {"_get_associated_handler",       &POA_Messaging::Poller::_get_associated_handler_skel},
      {"_set_associated_handler",       &POA_Messaging::Poller::_set_associated_handler_skel},
      {"_get_operation_name",   &POA_Messaging::Poller::_get_operation_name_skel},
      {"create_pollable_set",   &POA_Messaging::Poller::create_pollable_set_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,  -1,   6,  -1,  -1,   7,  -1,   8,
       -1, -12,  -2,   9,  -1,  10,  -1,  11,  -1, -37,  14,  -1,  -1,  -1,
       -1,  15,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int index = lookup[key];

          if (index >= 0 && index < MAX_HASH_VALUE)
            {
              const char *s = wordlist[index].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[index];
            }
          else if (index < 0 && index >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + index + (index > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 12:37:20 */
TAO_Messaging_Poller_Perfect_Hash_OpTable tao_Messaging_Poller_optable;
// skeleton constructor
POA_Messaging::Poller::Poller (void)
{
  this->optable_ = &tao_Messaging_Poller_optable;
}

// copy ctor
POA_Messaging::Poller::Poller (const Poller& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Pollable) (rhs),
    TAO_ServantBase (rhs)
{}
// skeleton destructor
POA_Messaging::Poller::~Poller (void)
{
}
void POA_Messaging::Poller::_get_operation_target_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::Object_var _tao_retval;
  _tao_retval = _tao_impl->operation_target (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

}

void POA_Messaging::Poller::_get_operation_name_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::String_var _tao_retval;
  _tao_retval = _tao_impl->operation_name (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

}

void POA_Messaging::Poller::_get_associated_handler_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  Messaging::ReplyHandler_var _tao_retval;
  _tao_retval = _tao_impl->associated_handler (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

}

void POA_Messaging::Poller::_set_associated_handler_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  Messaging::ReplyHandler_var associated_handler;
  if (!(
    (_tao_in >> associated_handler.out ())
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

  _tao_impl->associated_handler (
    associated_handler.in (),
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
}

void POA_Messaging::Poller::_get_is_from_poller_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  _tao_retval = _tao_impl->is_from_poller (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

}

void POA_Messaging::Poller::_get_target_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::Object_var _tao_retval;
  _tao_retval = _tao_impl->target (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

}

void POA_Messaging::Poller::_get_op_name_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::String_var _tao_retval;
  _tao_retval = _tao_impl->op_name (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO) );

}

void POA_Messaging::Poller::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel Messaging_Poller_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel Messaging_Poller_is_a_calldata =
  {"_is_a", 1, 2, Messaging_Poller_is_a_paramdata};
  POA_Messaging::Poller_ptr  _tao_impl = (POA_Messaging::Poller_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &Messaging_Poller_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &Messaging_Poller_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

CORBA::Boolean POA_Messaging::Poller::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/Poller:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Pollable:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void POA_Messaging::Poller::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel Messaging_Poller_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel Messaging_Poller_non_existent_calldata =
  {"_non_existent", 1, 1, Messaging_Poller_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &Messaging_Poller_non_existent_calldata,
    &_tao_retval
  );
}

void* POA_Messaging::Poller::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/Poller:1.0") == 0)
    return ACE_static_cast (POA_Messaging::Poller_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Pollable:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Pollable_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::Poller::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_Messaging::Poller::_interface_repository_id (void) const
{
  return "IDL:Messaging/Poller:1.0";
}

POA_Messaging::_tao_collocated_Poller::_tao_collocated_Poller (
    POA_Messaging::Poller_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,Poller) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Pollable) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::Poller_ptr POA_Messaging::_tao_collocated_Poller::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_Poller::_is_a (
    const char* logical_type_id,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      ACE_TRY_ENV
    );
}

CORBA::Object_ptr POA_Messaging::_tao_collocated_Poller::operation_target  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->operation_target (
    ACE_TRY_ENV
  );
}

char * POA_Messaging::_tao_collocated_Poller::operation_name  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->operation_name (
    ACE_TRY_ENV
  );
}

Messaging::ReplyHandler_ptr POA_Messaging::_tao_collocated_Poller::associated_handler  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->associated_handler (
    ACE_TRY_ENV
  );
}

void POA_Messaging::_tao_collocated_Poller::associated_handler  (
    Messaging::ReplyHandler_ptr associated_handler,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  this->servant_->associated_handler (
    associated_handler,
    ACE_TRY_ENV
  );
}

CORBA::Boolean POA_Messaging::_tao_collocated_Poller::is_from_poller  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->is_from_poller (
    ACE_TRY_ENV
  );
}

CORBA::Object_ptr POA_Messaging::_tao_collocated_Poller::target  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->target (
    ACE_TRY_ENV
  );
}

char * POA_Messaging::_tao_collocated_Poller::op_name  (
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return this->servant_->op_name (
    ACE_TRY_ENV
  );
}


Messaging::Poller*
POA_Messaging::Poller::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  return new POA_Messaging::_tao_collocated_Poller (this, stub);
}
#endif /* TAO_POLLER */
