/* -*- C++ -*- */
// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/MessagingC.h"

#if (TAO_HAS_CORBA_MESSAGING == 1)

#include "tao/MessagingS.h"
#include "tao/POA_CORBA.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"

#if !defined (__ACE_INLINE__)
#include "tao/MessagingC.i"
#endif /* !defined INLINE */

ACE_RCSID(tao, MessagingC, "$Id$")

static const CORBA::Long _oc_Messaging_RebindMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x62696e64), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/RebindMode:1.0
  11, ACE_NTOHL (0x52656269), ACE_NTOHL (0x6e644d6f), ACE_NTOHL (0x64650000),  // name = RebindMode
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RebindMode (CORBA::tk_alias, sizeof (_oc_Messaging_RebindMode), (char *) &_oc_Messaging_RebindMode, 0, sizeof (Messaging::RebindMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RebindMode, &_tc_TAO_tc_Messaging_RebindMode)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, TRANSPARENT, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, NO_REBIND, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, NO_RECONNECT, 2)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_SyncScope[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5379), ACE_NTOHL (0x6e635363), ACE_NTOHL (0x6f70653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/SyncScope:1.0
  10, ACE_NTOHL (0x53796e63), ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65000000),  // name = SyncScope
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_SyncScope (CORBA::tk_alias, sizeof (_oc_Messaging_SyncScope), (char *) &_oc_Messaging_SyncScope, 0, sizeof (Messaging::SyncScope));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SyncScope, &_tc_TAO_tc_Messaging_SyncScope)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_NONE, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_WITH_TRANSPORT, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_WITH_SERVER, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_WITH_TARGET, 3)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_EAGER_BUFFERING, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_DELAYED_BUFFERING, -1)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_RoutingType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/RoutingType:1.0
  12, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706500),  // name = RoutingType
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RoutingType (CORBA::tk_alias, sizeof (_oc_Messaging_RoutingType), (char *) &_oc_Messaging_RoutingType, 0, sizeof (Messaging::RoutingType));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RoutingType, &_tc_TAO_tc_Messaging_RoutingType)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ROUTE_NONE, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ROUTE_FORWARD, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ROUTE_STORE_AND_FORWARD, 2)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_Timeout[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  26, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5469), ACE_NTOHL (0x6d656f75), ACE_NTOHL (0x743a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/Timeout:1.0
  8, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x6f757400),  // name = Timeout
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Timeout (CORBA::tk_alias, sizeof (_oc_Messaging_Timeout), (char *) &_oc_Messaging_Timeout, 0, sizeof (Messaging::Timeout));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Timeout, &_tc_TAO_tc_Messaging_Timeout)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_Priority[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Priority:1.0
  9, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x0),  // name = Priority
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Priority (CORBA::tk_alias, sizeof (_oc_Messaging_Priority), (char *) &_oc_Messaging_Priority, 0, sizeof (Messaging::Priority));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Priority, &_tc_TAO_tc_Messaging_Priority)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_Ordering[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f4f72), ACE_NTOHL (0x64657269), ACE_NTOHL (0x6e673a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Ordering:1.0
  9, ACE_NTOHL (0x4f726465), ACE_NTOHL (0x72696e67), ACE_NTOHL (0x0),  // name = Ordering
  CORBA::tk_ushort,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Ordering (CORBA::tk_alias, sizeof (_oc_Messaging_Ordering), (char *) &_oc_Messaging_Ordering, 0, sizeof (Messaging::Ordering));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Ordering, &_tc_TAO_tc_Messaging_Ordering)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_ANY, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_TEMPORAL, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_PRIORITY, 4)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_DEADLINE, 8)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REBIND_POLICY_TYPE,
                      TAO_MESSAGING_REBIND_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::RebindPolicy_ptr Messaging::RebindPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RebindPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RebindPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RebindPolicy::_nil ());
  if (is_a == 0)
    return Messaging::RebindPolicy::_nil ();
  return Messaging::RebindPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RebindPolicy_ptr Messaging::RebindPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RebindPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RebindPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RebindPolicy::_nil ());

  Messaging::RebindPolicy_ptr retval =
    Messaging::RebindPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RebindPolicy (
          ACE_reinterpret_cast (POA_Messaging::RebindPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RebindPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RebindPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RebindPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RebindPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RebindPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RebindPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x62696e64), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RebindPolicy:1.0
  13, ACE_NTOHL (0x52656269), ACE_NTOHL (0x6e64506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = RebindPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RebindPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RebindPolicy), (char *) &_oc_Messaging_RebindPolicy, 0, sizeof (Messaging::RebindPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RebindPolicy, &_tc_TAO_tc_Messaging_RebindPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, SYNC_SCOPE_POLICY_TYPE,
                      TAO_MESSAGING_SYNC_SCOPE_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::SyncScopePolicy_ptr Messaging::SyncScopePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::SyncScopePolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/SyncScopePolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::SyncScopePolicy::_nil ());
  if (is_a == 0)
    return Messaging::SyncScopePolicy::_nil ();
  return Messaging::SyncScopePolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::SyncScopePolicy_ptr Messaging::SyncScopePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::SyncScopePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/SyncScopePolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::SyncScopePolicy::_nil ());

  Messaging::SyncScopePolicy_ptr retval =
    Messaging::SyncScopePolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_SyncScopePolicy (
          ACE_reinterpret_cast (POA_Messaging::SyncScopePolicy_ptr,
                                servant),
          stub
        ),
      Messaging::SyncScopePolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::SyncScopePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/SyncScopePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::SyncScopePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/SyncScopePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_SyncScopePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5379), ACE_NTOHL (0x6e635363), ACE_NTOHL (0x6f706550), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/SyncScopePolicy:1.0
  16, ACE_NTOHL (0x53796e63), ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65506f6c), ACE_NTOHL (0x69637900),  // name = SyncScopePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_SyncScopePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_SyncScopePolicy), (char *) &_oc_Messaging_SyncScopePolicy, 0, sizeof (Messaging::SyncScopePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SyncScopePolicy, &_tc_TAO_tc_Messaging_SyncScopePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_PRIORITY_POLICY_TYPE,
                      TAO_MESSAGING_REQUEST_PRIORITY_POLICY_TYPE)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_PriorityRange[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74795261), ACE_NTOHL (0x6e67653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/PriorityRange:1.0
  14, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x52616e67), ACE_NTOHL (0x65000000),  // name = PriorityRange
  2, // member count
    4, ACE_NTOHL (0x6d696e00),  // name = min
    CORBA::tk_alias, // typecode kind for typedefs
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Priority:1.0
      9, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x0),  // name = Priority
      CORBA::tk_short,

    4, ACE_NTOHL (0x6d617800),  // name = max
    CORBA::tk_alias, // typecode kind for typedefs
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Priority:1.0
      9, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x0),  // name = Priority
      CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PriorityRange (CORBA::tk_struct, sizeof (_oc_Messaging_PriorityRange), (char *) &_oc_Messaging_PriorityRange, 0, sizeof (Messaging::PriorityRange));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PriorityRange, &_tc_TAO_tc_Messaging_PriorityRange)
TAO_NAMESPACE_END
Messaging::RequestPriorityPolicy_ptr Messaging::RequestPriorityPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestPriorityPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RequestPriorityPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RequestPriorityPolicy::_nil ());
  if (is_a == 0)
    return Messaging::RequestPriorityPolicy::_nil ();
  return Messaging::RequestPriorityPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RequestPriorityPolicy_ptr Messaging::RequestPriorityPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RequestPriorityPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RequestPriorityPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RequestPriorityPolicy::_nil ());

  Messaging::RequestPriorityPolicy_ptr retval =
    Messaging::RequestPriorityPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RequestPriorityPolicy (
          ACE_reinterpret_cast (POA_Messaging::RequestPriorityPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RequestPriorityPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RequestPriorityPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestPriorityPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RequestPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestPriorityPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RequestPriorityPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74507269), ACE_NTOHL (0x6f726974), ACE_NTOHL (0x79506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/RequestPriorityPolicy:1.0
  22, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737450), ACE_NTOHL (0x72696f72), ACE_NTOHL (0x69747950), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = RequestPriorityPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RequestPriorityPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RequestPriorityPolicy), (char *) &_oc_Messaging_RequestPriorityPolicy, 0, sizeof (Messaging::RequestPriorityPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestPriorityPolicy, &_tc_TAO_tc_Messaging_RequestPriorityPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REPLY_PRIORITY_POLICY_TYPE,
                      TAO_MESSAGING_REPLY_PRIORITY_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::ReplyPriorityPolicy_ptr Messaging::ReplyPriorityPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyPriorityPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/ReplyPriorityPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::ReplyPriorityPolicy::_nil ());
  if (is_a == 0)
    return Messaging::ReplyPriorityPolicy::_nil ();
  return Messaging::ReplyPriorityPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::ReplyPriorityPolicy_ptr Messaging::ReplyPriorityPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::ReplyPriorityPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyPriorityPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::ReplyPriorityPolicy::_nil ());

  Messaging::ReplyPriorityPolicy_ptr retval =
    Messaging::ReplyPriorityPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_ReplyPriorityPolicy (
          ACE_reinterpret_cast (POA_Messaging::ReplyPriorityPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::ReplyPriorityPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::ReplyPriorityPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyPriorityPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::ReplyPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyPriorityPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyPriorityPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7950), ACE_NTOHL (0x72696f72), ACE_NTOHL (0x69747950), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/ReplyPriorityPolicy:1.0
  20, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79507269), ACE_NTOHL (0x6f726974), ACE_NTOHL (0x79506f6c), ACE_NTOHL (0x69637900),  // name = ReplyPriorityPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyPriorityPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyPriorityPolicy), (char *) &_oc_Messaging_ReplyPriorityPolicy, 0, sizeof (Messaging::ReplyPriorityPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyPriorityPolicy, &_tc_TAO_tc_Messaging_ReplyPriorityPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_START_TIME_POLICY_TYPE,
                      TAO_MESSAGING_REQUEST_START_TIME_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::RequestStartTimePolicy_ptr Messaging::RequestStartTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestStartTimePolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RequestStartTimePolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RequestStartTimePolicy::_nil ());
  if (is_a == 0)
    return Messaging::RequestStartTimePolicy::_nil ();
  return Messaging::RequestStartTimePolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RequestStartTimePolicy_ptr Messaging::RequestStartTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RequestStartTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RequestStartTimePolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RequestStartTimePolicy::_nil ());

  Messaging::RequestStartTimePolicy_ptr retval =
    Messaging::RequestStartTimePolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RequestStartTimePolicy (
          ACE_reinterpret_cast (POA_Messaging::RequestStartTimePolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RequestStartTimePolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RequestStartTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestStartTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RequestStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestStartTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RequestStartTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74537461), ACE_NTOHL (0x72745469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/RequestStartTimePolicy:1.0
  23, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737453), ACE_NTOHL (0x74617274), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = RequestStartTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RequestStartTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RequestStartTimePolicy), (char *) &_oc_Messaging_RequestStartTimePolicy, 0, sizeof (Messaging::RequestStartTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestStartTimePolicy, &_tc_TAO_tc_Messaging_RequestStartTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_END_TIME_POLICY_TYPE,
                      TAO_MESSAGING_REQUEST_END_TIME_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::RequestEndTimePolicy_ptr Messaging::RequestEndTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestEndTimePolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RequestEndTimePolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RequestEndTimePolicy::_nil ());
  if (is_a == 0)
    return Messaging::RequestEndTimePolicy::_nil ();
  return Messaging::RequestEndTimePolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RequestEndTimePolicy_ptr Messaging::RequestEndTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RequestEndTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RequestEndTimePolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RequestEndTimePolicy::_nil ());

  Messaging::RequestEndTimePolicy_ptr retval =
    Messaging::RequestEndTimePolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RequestEndTimePolicy (
          ACE_reinterpret_cast (POA_Messaging::RequestEndTimePolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RequestEndTimePolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RequestEndTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestEndTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RequestEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestEndTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RequestEndTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74456e64), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RequestEndTimePolicy:1.0
  21, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737445), ACE_NTOHL (0x6e645469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = RequestEndTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RequestEndTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RequestEndTimePolicy), (char *) &_oc_Messaging_RequestEndTimePolicy, 0, sizeof (Messaging::RequestEndTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestEndTimePolicy, &_tc_TAO_tc_Messaging_RequestEndTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REPLY_START_TIME_POLICY_TYPE,
                      TAO_MESSAGING_REPLY_START_TIME_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::ReplyStartTimePolicy_ptr Messaging::ReplyStartTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyStartTimePolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/ReplyStartTimePolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::ReplyStartTimePolicy::_nil ());
  if (is_a == 0)
    return Messaging::ReplyStartTimePolicy::_nil ();
  return Messaging::ReplyStartTimePolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::ReplyStartTimePolicy_ptr Messaging::ReplyStartTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::ReplyStartTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyStartTimePolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::ReplyStartTimePolicy::_nil ());

  Messaging::ReplyStartTimePolicy_ptr retval =
    Messaging::ReplyStartTimePolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_ReplyStartTimePolicy (
          ACE_reinterpret_cast (POA_Messaging::ReplyStartTimePolicy_ptr,
                                servant),
          stub
        ),
      Messaging::ReplyStartTimePolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::ReplyStartTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyStartTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::ReplyStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyStartTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyStartTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7953), ACE_NTOHL (0x74617274), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/ReplyStartTimePolicy:1.0
  21, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79537461), ACE_NTOHL (0x72745469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = ReplyStartTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyStartTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyStartTimePolicy), (char *) &_oc_Messaging_ReplyStartTimePolicy, 0, sizeof (Messaging::ReplyStartTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyStartTimePolicy, &_tc_TAO_tc_Messaging_ReplyStartTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REPLY_END_TIME_POLICY_TYPE,
                      TAO_MESSAGING_REPLY_END_TIME_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::ReplyEndTimePolicy_ptr Messaging::ReplyEndTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyEndTimePolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/ReplyEndTimePolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::ReplyEndTimePolicy::_nil ());
  if (is_a == 0)
    return Messaging::ReplyEndTimePolicy::_nil ();
  return Messaging::ReplyEndTimePolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::ReplyEndTimePolicy_ptr Messaging::ReplyEndTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::ReplyEndTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyEndTimePolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::ReplyEndTimePolicy::_nil ());

  Messaging::ReplyEndTimePolicy_ptr retval =
    Messaging::ReplyEndTimePolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_ReplyEndTimePolicy (
          ACE_reinterpret_cast (POA_Messaging::ReplyEndTimePolicy_ptr,
                                servant),
          stub
        ),
      Messaging::ReplyEndTimePolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::ReplyEndTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyEndTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::ReplyEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyEndTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyEndTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7945), ACE_NTOHL (0x6e645469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/ReplyEndTimePolicy:1.0
  19, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79456e64), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = ReplyEndTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyEndTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyEndTimePolicy), (char *) &_oc_Messaging_ReplyEndTimePolicy, 0, sizeof (Messaging::ReplyEndTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyEndTimePolicy, &_tc_TAO_tc_Messaging_ReplyEndTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, RELATIVE_REQ_TIMEOUT_POLICY_TYPE,
                      TAO_MESSAGING_RELATIVE_REQ_TIMEOUT_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::RelativeRequestTimeoutPolicy_ptr Messaging::RelativeRequestTimeoutPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRequestTimeoutPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RelativeRequestTimeoutPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RelativeRequestTimeoutPolicy::_nil ());
  if (is_a == 0)
    return Messaging::RelativeRequestTimeoutPolicy::_nil ();
  return Messaging::RelativeRequestTimeoutPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RelativeRequestTimeoutPolicy_ptr Messaging::RelativeRequestTimeoutPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRequestTimeoutPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RelativeRequestTimeoutPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RelativeRequestTimeoutPolicy::_nil ());

  Messaging::RelativeRequestTimeoutPolicy_ptr retval =
    Messaging::RelativeRequestTimeoutPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy (
          ACE_reinterpret_cast (POA_Messaging::RelativeRequestTimeoutPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RelativeRequestTimeoutPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RelativeRequestTimeoutPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RelativeRequestTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RelativeRequestTimeoutPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x6c617469), ACE_NTOHL (0x76655265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x7454696d), ACE_NTOHL (0x656f7574), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RelativeRequestTimeoutPolicy:1.0
  29, ACE_NTOHL (0x52656c61), ACE_NTOHL (0x74697665), ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737454), ACE_NTOHL (0x696d656f), ACE_NTOHL (0x7574506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = RelativeRequestTimeoutPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RelativeRequestTimeoutPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RelativeRequestTimeoutPolicy), (char *) &_oc_Messaging_RelativeRequestTimeoutPolicy, 0, sizeof (Messaging::RelativeRequestTimeoutPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RelativeRequestTimeoutPolicy, &_tc_TAO_tc_Messaging_RelativeRequestTimeoutPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, RELATIVE_RT_TIMEOUT_POLICY_TYPE,
                      TAO_MESSAGING_RELATIVE_RT_TIMEOUT_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::RelativeRoundtripTimeoutPolicy_ptr Messaging::RelativeRoundtripTimeoutPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RelativeRoundtripTimeoutPolicy::_nil
                    ());
  if (is_a == 0)
    return Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  return Messaging::RelativeRoundtripTimeoutPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RelativeRoundtripTimeoutPolicy_ptr Messaging::RelativeRoundtripTimeoutPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RelativeRoundtripTimeoutPolicy::_nil ());

  Messaging::RelativeRoundtripTimeoutPolicy_ptr retval =
    Messaging::RelativeRoundtripTimeoutPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy (
          ACE_reinterpret_cast (POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RelativeRoundtripTimeoutPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RelativeRoundtripTimeoutPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RelativeRoundtripTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RelativeRoundtripTimeoutPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x6c617469), ACE_NTOHL (0x7665526f), ACE_NTOHL (0x756e6474), ACE_NTOHL (0x72697054), ACE_NTOHL (0x696d656f), ACE_NTOHL (0x7574506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0
  31, ACE_NTOHL (0x52656c61), ACE_NTOHL (0x74697665), ACE_NTOHL (0x526f756e), ACE_NTOHL (0x64747269), ACE_NTOHL (0x7054696d), ACE_NTOHL (0x656f7574), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = RelativeRoundtripTimeoutPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RelativeRoundtripTimeoutPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RelativeRoundtripTimeoutPolicy), (char *) &_oc_Messaging_RelativeRoundtripTimeoutPolicy, 0, sizeof (Messaging::RelativeRoundtripTimeoutPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RelativeRoundtripTimeoutPolicy, &_tc_TAO_tc_Messaging_RelativeRoundtripTimeoutPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ROUTING_POLICY_TYPE,
                      TAO_MESSAGING_ROUTING_POLICY_TYPE)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_RoutingTypeRange[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x6552616e), ACE_NTOHL (0x67653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RoutingTypeRange:1.0
  17, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706552), ACE_NTOHL (0x616e6765), ACE_NTOHL (0x0),  // name = RoutingTypeRange
  2, // member count
    4, ACE_NTOHL (0x6d696e00),  // name = min
    CORBA::tk_alias, // typecode kind for typedefs
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/RoutingType:1.0
      12, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706500),  // name = RoutingType
      CORBA::tk_short,

    4, ACE_NTOHL (0x6d617800),  // name = max
    CORBA::tk_alias, // typecode kind for typedefs
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/RoutingType:1.0
      12, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706500),  // name = RoutingType
      CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RoutingTypeRange (CORBA::tk_struct, sizeof (_oc_Messaging_RoutingTypeRange), (char *) &_oc_Messaging_RoutingTypeRange, 0, sizeof (Messaging::RoutingTypeRange));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RoutingTypeRange, &_tc_TAO_tc_Messaging_RoutingTypeRange)
TAO_NAMESPACE_END
Messaging::RoutingPolicy_ptr Messaging::RoutingPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RoutingPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/RoutingPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::RoutingPolicy::_nil ());
  if (is_a == 0)
    return Messaging::RoutingPolicy::_nil ();
  return Messaging::RoutingPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::RoutingPolicy_ptr Messaging::RoutingPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::RoutingPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RoutingPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::RoutingPolicy::_nil ());

  Messaging::RoutingPolicy_ptr retval =
    Messaging::RoutingPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_RoutingPolicy (
          ACE_reinterpret_cast (POA_Messaging::RoutingPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::RoutingPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::RoutingPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RoutingPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::RoutingPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RoutingPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RoutingPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/RoutingPolicy:1.0
  14, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6750), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = RoutingPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RoutingPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RoutingPolicy), (char *) &_oc_Messaging_RoutingPolicy, 0, sizeof (Messaging::RoutingPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RoutingPolicy, &_tc_TAO_tc_Messaging_RoutingPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, MAX_HOPS_POLICY_TYPE,
                      TAO_MESSAGING_MAX_HOPS_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::MaxHopsPolicy_ptr Messaging::MaxHopsPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::MaxHopsPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/MaxHopsPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::MaxHopsPolicy::_nil ());
  if (is_a == 0)
    return Messaging::MaxHopsPolicy::_nil ();
  return Messaging::MaxHopsPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::MaxHopsPolicy_ptr Messaging::MaxHopsPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::MaxHopsPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/MaxHopsPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::MaxHopsPolicy::_nil ());

  Messaging::MaxHopsPolicy_ptr retval =
    Messaging::MaxHopsPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_MaxHopsPolicy (
          ACE_reinterpret_cast (POA_Messaging::MaxHopsPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::MaxHopsPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::MaxHopsPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/MaxHopsPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::MaxHopsPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/MaxHopsPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_MaxHopsPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f4d61), ACE_NTOHL (0x78486f70), ACE_NTOHL (0x73506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/MaxHopsPolicy:1.0
  14, ACE_NTOHL (0x4d617848), ACE_NTOHL (0x6f707350), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = MaxHopsPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_MaxHopsPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_MaxHopsPolicy), (char *) &_oc_Messaging_MaxHopsPolicy, 0, sizeof (Messaging::MaxHopsPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MaxHopsPolicy, &_tc_TAO_tc_Messaging_MaxHopsPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, QUEUE_ORDER_POLICY_TYPE,
                      TAO_MESSAGING_QUEUE_ORDER_POLICY_TYPE)
TAO_NAMESPACE_END
Messaging::QueueOrderPolicy_ptr Messaging::QueueOrderPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::QueueOrderPolicy::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/QueueOrderPolicy:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::QueueOrderPolicy::_nil ());
  if (is_a == 0)
    return Messaging::QueueOrderPolicy::_nil ();
  return Messaging::QueueOrderPolicy::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::QueueOrderPolicy_ptr Messaging::QueueOrderPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::QueueOrderPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/QueueOrderPolicy:1.0");
  if (servant == 0)
    ACE_THROW_RETURN (CORBA::MARSHAL (), Messaging::QueueOrderPolicy::_nil ());

  Messaging::QueueOrderPolicy_ptr retval =
    Messaging::QueueOrderPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_QueueOrderPolicy (
          ACE_reinterpret_cast (POA_Messaging::QueueOrderPolicy_ptr,
                                servant),
          stub
        ),
      Messaging::QueueOrderPolicy::_nil ()
    );

  return retval;
}

CORBA::Boolean Messaging::QueueOrderPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/QueueOrderPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::QueueOrderPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/QueueOrderPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_QueueOrderPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5175), ACE_NTOHL (0x6575654f), ACE_NTOHL (0x72646572), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/QueueOrderPolicy:1.0
  17, ACE_NTOHL (0x51756575), ACE_NTOHL (0x654f7264), ACE_NTOHL (0x6572506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = QueueOrderPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_QueueOrderPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_QueueOrderPolicy), (char *) &_oc_Messaging_QueueOrderPolicy, 0, sizeof (Messaging::QueueOrderPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_QueueOrderPolicy, &_tc_TAO_tc_Messaging_QueueOrderPolicy)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_PolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/PolicyValue:1.0
  12, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = PolicyValue
  2, // member count
    6, ACE_NTOHL (0x70747970), ACE_NTOHL (0x65000000),  // name = ptype
    CORBA::tk_alias, // typecode kind for typedefs
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyType:1.0
      11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70650000),  // name = PolicyType
      CORBA::tk_ulong,

    7, ACE_NTOHL (0x7076616c), ACE_NTOHL (0x75650000),  // name = pvalue
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

    0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PolicyValue (CORBA::tk_struct, sizeof (_oc_Messaging_PolicyValue), (char *) &_oc_Messaging_PolicyValue, 0, sizeof (Messaging::PolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyValue, &_tc_TAO_tc_Messaging_PolicyValue)
TAO_NAMESPACE_END

#if !defined (_MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CS_)
#define _MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CS_

// *************************************************************
// Messaging::PolicyValue::_tao_seq_Octet
// *************************************************************

Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (void)
{}
Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max) // uses max size
  : TAO_Unbounded_Sequence<CORBA::Octet> (max)
{}
Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : TAO_Unbounded_Sequence<CORBA::Octet> (max, length, buffer, release)
{}
Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (const _tao_seq_Octet &seq) // copy ctor
  : TAO_Unbounded_Sequence<CORBA::Octet> (seq)
{}
Messaging::PolicyValue::_tao_seq_Octet::~_tao_seq_Octet (void) // dtor
{}

static const CORBA::Long _oc_Messaging_PolicyValue__tao_seq_Octet[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PolicyValue__tao_seq_Octet (CORBA::tk_sequence, sizeof (_oc_Messaging_PolicyValue__tao_seq_Octet), (char *) &_oc_Messaging_PolicyValue__tao_seq_Octet, 0, sizeof (Messaging::PolicyValue::_tao_seq_Octet));
CORBA::TypeCode_ptr Messaging::PolicyValue::_tc__tao_seq_Octet = &_tc_TAO_tc_Messaging_PolicyValue__tao_seq_Octet;

// *************************************************************
// Messaging::PolicyValueSeq
// *************************************************************

Messaging::PolicyValueSeq::PolicyValueSeq (void)
{}
Messaging::PolicyValueSeq::PolicyValueSeq (CORBA::ULong max) // uses max size
  : TAO_Unbounded_Sequence<Messaging::PolicyValue> (max)
{}
Messaging::PolicyValueSeq::PolicyValueSeq (CORBA::ULong max, CORBA::ULong length, Messaging::PolicyValue *buffer, CORBA::Boolean release)
  : TAO_Unbounded_Sequence<Messaging::PolicyValue> (max, length, buffer, release)
{}
Messaging::PolicyValueSeq::PolicyValueSeq (const PolicyValueSeq &seq) // copy ctor
  : TAO_Unbounded_Sequence<Messaging::PolicyValue> (seq)
{}
Messaging::PolicyValueSeq::~PolicyValueSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_Messaging_PolicyValueSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/PolicyValueSeq:1.0
  15, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756553), ACE_NTOHL (0x65710000),  // name = PolicyValueSeq
  CORBA::tk_sequence, // typecode kind
  192, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    176, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/PolicyValue:1.0
      12, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = PolicyValue
      2, // member count
        6, ACE_NTOHL (0x70747970), ACE_NTOHL (0x65000000),  // name = ptype
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyType:1.0
          11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70650000),  // name = PolicyType
          CORBA::tk_ulong,

        7, ACE_NTOHL (0x7076616c), ACE_NTOHL (0x75650000),  // name = pvalue
        CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

        0,
      0
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PolicyValueSeq (CORBA::tk_alias, sizeof (_oc_Messaging_PolicyValueSeq), (char *) &_oc_Messaging_PolicyValueSeq, 0, sizeof (Messaging::PolicyValueSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyValueSeq, &_tc_TAO_tc_Messaging_PolicyValueSeq)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, TAG_POLICIES, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, INVOCATION_POLICIES, 2)
TAO_NAMESPACE_END

// ****************************************************************

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

// *************************************************************
// Messaging::ExceptionHolder::_tao_seq_Octet
// *************************************************************

Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (void)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max) // uses max size
  : TAO_Unbounded_Sequence<CORBA::Octet> (max)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : TAO_Unbounded_Sequence<CORBA::Octet> (max, length, buffer, release)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (const _tao_seq_Octet &seq) // copy ctor
  : TAO_Unbounded_Sequence<CORBA::Octet> (seq)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::~_tao_seq_Octet (void) // dtor
{}

static const CORBA::Long _oc_Messaging_ExceptionHolder__tao_seq_Octet[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,
    0,
};


Messaging::ExceptionHolder* Messaging::ExceptionHolder::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ExceptionHolder* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Messaging::ExceptionHolder::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Messaging::ExceptionHolder::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

CORBA::Boolean Messaging::ExceptionHolder::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Messaging_ExceptionHolder (strm);
}

CORBA::Boolean Messaging::ExceptionHolder::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Messaging_ExceptionHolder (strm);
}

CORBA::Boolean Messaging::ExceptionHolder::_tao_unmarshal (TAO_InputCDR &strm, Messaging::ExceptionHolder *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          Messaging::ExceptionHolder::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Messaging::ExceptionHolder::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Messaging::ExceptionHolder::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Messaging::ExceptionHolder::_downcast (base);
  // %! unmarshal_post
  return 1;
}


#if !defined (_MESSAGING_EXCEPTIONHOLDER___INIT_CS_)
#define _MESSAGING_EXCEPTIONHOLDER___INIT_CS_

Messaging::ExceptionHolder_init::~ExceptionHolder_init ()
{
}

const char*
Messaging::ExceptionHolder_init::tao_repository_id ()
{
  return Messaging::ExceptionHolder::_tao_obv_static_repository_id ();
}


#endif /* end #if !defined */


// ****************************************************************


Messaging::ReplyHandler_ptr Messaging::ReplyHandler::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyHandler::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/ReplyHandler:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::ReplyHandler::_nil ());
  if (is_a == 0)
    return Messaging::ReplyHandler::_nil ();
  return Messaging::ReplyHandler::_unchecked_narrow (obj, ACE_TRY_ENV);
}


Messaging::ReplyHandler_ptr Messaging::ReplyHandler::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyHandler::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_Messaging_ReplyHandler_Stub_Factory_function_pointer != 0)
    {
      ReplyHandler_ptr retv = _TAO_collocation_Messaging_ReplyHandler_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  Messaging::ReplyHandler_ptr retval = 0;
  ACE_NEW_RETURN (retval, Messaging::ReplyHandler (stub), 0);
  return retval;
}



CORBA::Boolean Messaging::ReplyHandler::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyHandler:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::ReplyHandler::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyHandler:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyHandler[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7948), ACE_NTOHL (0x616e646c), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/ReplyHandler:1.0
  13, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x7948616e), ACE_NTOHL (0x646c6572), ACE_NTOHL (0x0),  // name = ReplyHandler,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyHandler (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyHandler), (char *) &_oc_Messaging_ReplyHandler, 0, sizeof (Messaging::ReplyHandler));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyHandler, &_tc_TAO_tc_Messaging_ReplyHandler)
TAO_NAMESPACE_END

CORBA::Boolean
OBV_Messaging::ExceptionHolder::_tao_marshal__Messaging_ExceptionHolder (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);

}
CORBA::Boolean OBV_Messaging::ExceptionHolder::_tao_unmarshal__Messaging_ExceptionHolder (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);

}
// accessor to set the member
void
OBV_Messaging::ExceptionHolder::is_system_exception (CORBA::Boolean val) // set
{
  // set the value
  this->_pd_is_system_exception = val;
}
// retrieve the member
CORBA::Boolean
OBV_Messaging::ExceptionHolder::is_system_exception (void) const
{
  return this->_pd_is_system_exception;
}

// accessor to set the member
void
OBV_Messaging::ExceptionHolder::byte_order (CORBA::Boolean val) // set
{
  // set the value
  this->_pd_byte_order = val;
}
// retrieve the member
CORBA::Boolean
OBV_Messaging::ExceptionHolder::byte_order (void) const
{
  return this->_pd_byte_order;
}

// accessor to set the member
void
OBV_Messaging::ExceptionHolder::marshaled_exception (const Messaging::ExceptionHolder::_tao_seq_Octet &val)
{
  ACE_NEW (
      this->_pd_marshaled_exception,
      /*Messaging::ExceptionHolder::*/_tao_seq_Octet (val)
    );
}
// readonly get method
const Messaging::ExceptionHolder::_tao_seq_Octet &
OBV_Messaging::ExceptionHolder::marshaled_exception (void) const
{
  return *this->_pd_marshaled_exception;
}
// read/write get method
Messaging::ExceptionHolder::_tao_seq_Octet &
OBV_Messaging::ExceptionHolder::marshaled_exception (void)
{
  return *this->_pd_marshaled_exception;
}


#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#if (TAO_HAS_AMI_POLLER == 1)

Messaging::Poller_ptr Messaging::Poller::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::Poller::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:Messaging/Poller:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Messaging::Poller::_nil ());
  if (is_a == 0)
    return Messaging::Poller::_nil ();
  return Messaging::Poller::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Messaging::Poller_ptr Messaging::Poller::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  if (CORBA::is_nil (obj))
    return Messaging::Poller::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/Poller:1.0");
  if (servant == 0)
    {
      Messaging::Poller_ptr rval = Messaging::Poller::_nil ();

      ACE_NEW_RETURN (rval,
                      Messaging::Poller (stub),
                      Messaging::Poller::_nil ());

      return rval;
    }

  Messaging::Poller_ptr retval =
    Messaging::Poller::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_Messaging::_tao_collocated_Poller (
          ACE_reinterpret_cast (POA_Messaging::Poller_ptr,
                                servant),
          stub
        ),
      Messaging::Poller::_nil ()
    );

  return retval;
}

CORBA::Object_ptr Messaging::Poller::operation_target (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::Object_ptr _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""operation_target",
      21,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

char * Messaging::Poller::operation_name (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    char *_tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""operation_name",
      19,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

Messaging::ReplyHandler_ptr Messaging::Poller::associated_handler (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::ReplyHandler_ptr _tao_retval = Messaging::ReplyHandler::_nil ();

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""associated_handler",
      23,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void Messaging::Poller::associated_handler (
    Messaging::ReplyHandler_ptr associated_handler,
    CORBA::Environment &ACE_TRY_ENV
  )
{

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""associated_handler",
      23,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << associated_handler)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean Messaging::Poller::is_from_poller (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::Boolean _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_from_poller",
      19,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Object_ptr Messaging::Poller::target (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::Object_ptr _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""target",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

char * Messaging::Poller::op_name (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    char *_tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""op_name",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean Messaging::Poller::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/Poller:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Pollable:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV); // remote call
}

const char* Messaging::Poller::_interface_repository_id (void) const
{
  return "IDL:Messaging/Poller:1.0";
}

static const CORBA::Long _oc_Messaging_Poller[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  25, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c6c6572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/Poller:1.0
  7, ACE_NTOHL (0x506f6c6c), ACE_NTOHL (0x65720000),  // name = Poller,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Poller (CORBA::tk_objref, sizeof (_oc_Messaging_Poller), (char *) &_oc_Messaging_Poller, 0, sizeof (Messaging::Poller));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Poller, &_tc_TAO_tc_Messaging_Poller)
TAO_NAMESPACE_END

#endif /* TAO_HAS_AMI_POLLER == 1 */

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, Messaging::RebindPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RebindPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RebindPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RebindPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RebindPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RebindPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RebindPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RebindPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RebindPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RebindPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::SyncScopePolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::SyncScopePolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_SyncScopePolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::SyncScopePolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::SyncScopePolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_SyncScopePolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::SyncScopePolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_SyncScopePolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::SyncScopePolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::SyncScopePolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const Messaging::PriorityRange &_tao_elem) // copying
{
  Messaging::PriorityRange *_any_val = 0;
  ACE_NEW (_any_val, Messaging::PriorityRange (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        Messaging::_tc_PriorityRange,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::PriorityRange *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        Messaging::_tc_PriorityRange,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::PriorityRange *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_PriorityRange, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PriorityRange *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PriorityRange, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_PriorityRange,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Messaging::PriorityRange *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_PriorityRange, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PriorityRange *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PriorityRange, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(Messaging::PriorityRange *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_PriorityRange,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (Messaging::PriorityRange *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (Messaging::PriorityRange *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (Messaging::PriorityRange *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RequestPriorityPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RequestPriorityPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RequestPriorityPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RequestPriorityPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RequestPriorityPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RequestPriorityPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RequestPriorityPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RequestPriorityPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RequestPriorityPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RequestPriorityPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::ReplyPriorityPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::ReplyPriorityPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_ReplyPriorityPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::ReplyPriorityPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::ReplyPriorityPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_ReplyPriorityPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::ReplyPriorityPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_ReplyPriorityPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::ReplyPriorityPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::ReplyPriorityPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RequestStartTimePolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RequestStartTimePolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RequestStartTimePolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RequestStartTimePolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RequestStartTimePolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RequestStartTimePolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RequestStartTimePolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RequestStartTimePolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RequestStartTimePolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RequestStartTimePolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RequestEndTimePolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RequestEndTimePolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RequestEndTimePolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RequestEndTimePolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RequestEndTimePolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RequestEndTimePolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RequestEndTimePolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RequestEndTimePolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RequestEndTimePolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RequestEndTimePolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::ReplyStartTimePolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::ReplyStartTimePolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_ReplyStartTimePolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::ReplyStartTimePolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::ReplyStartTimePolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_ReplyStartTimePolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::ReplyStartTimePolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_ReplyStartTimePolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::ReplyStartTimePolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::ReplyStartTimePolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::ReplyEndTimePolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::ReplyEndTimePolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_ReplyEndTimePolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::ReplyEndTimePolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::ReplyEndTimePolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_ReplyEndTimePolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::ReplyEndTimePolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_ReplyEndTimePolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::ReplyEndTimePolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::ReplyEndTimePolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RelativeRequestTimeoutPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RelativeRequestTimeoutPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RelativeRequestTimeoutPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RelativeRequestTimeoutPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RelativeRequestTimeoutPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RelativeRequestTimeoutPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RelativeRequestTimeoutPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RelativeRequestTimeoutPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RelativeRequestTimeoutPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RelativeRequestTimeoutPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RelativeRoundtripTimeoutPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RelativeRoundtripTimeoutPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RelativeRoundtripTimeoutPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RelativeRoundtripTimeoutPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RelativeRoundtripTimeoutPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RelativeRoundtripTimeoutPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RelativeRoundtripTimeoutPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  return 0;
}

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, const Messaging::RoutingTypeRange &_tao_elem) // copying
{
  Messaging::RoutingTypeRange *_any_val = 0;
  ACE_NEW (_any_val, Messaging::RoutingTypeRange (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        Messaging::_tc_RoutingTypeRange,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RoutingTypeRange *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        Messaging::_tc_RoutingTypeRange,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RoutingTypeRange *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RoutingTypeRange, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::RoutingTypeRange *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::RoutingTypeRange, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_RoutingTypeRange,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Messaging::RoutingTypeRange *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RoutingTypeRange, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::RoutingTypeRange *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::RoutingTypeRange, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(Messaging::RoutingTypeRange *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_RoutingTypeRange,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (Messaging::RoutingTypeRange *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (Messaging::RoutingTypeRange *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (Messaging::RoutingTypeRange *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, Messaging::RoutingPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::RoutingPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_RoutingPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RoutingPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::RoutingPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_RoutingPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::RoutingPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_RoutingPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::RoutingPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::RoutingPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::MaxHopsPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::MaxHopsPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_MaxHopsPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::MaxHopsPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::MaxHopsPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_MaxHopsPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::MaxHopsPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_MaxHopsPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::MaxHopsPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::MaxHopsPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::QueueOrderPolicy_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::QueueOrderPolicy::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_QueueOrderPolicy, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::QueueOrderPolicy_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::QueueOrderPolicy::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_QueueOrderPolicy, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::QueueOrderPolicy::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_QueueOrderPolicy,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::QueueOrderPolicy::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::QueueOrderPolicy::_nil ();
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const Messaging::PolicyValue &_tao_elem) // copying
{
  Messaging::PolicyValue *_any_val = 0;
  ACE_NEW (_any_val, Messaging::PolicyValue (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        Messaging::_tc_PolicyValue,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::PolicyValue *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        Messaging::_tc_PolicyValue,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::PolicyValue *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_PolicyValue, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PolicyValue *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PolicyValue, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_PolicyValue,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Messaging::PolicyValue *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_PolicyValue, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PolicyValue *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PolicyValue, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(Messaging::PolicyValue *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_PolicyValue,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (Messaging::PolicyValue *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (Messaging::PolicyValue *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (Messaging::PolicyValue *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (
    CORBA::Any &_tao_any,
    const Messaging::PolicyValueSeq &_tao_elem
  ) // copying
{
  Messaging::PolicyValueSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, Messaging::PolicyValueSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          Messaging::_tc_PolicyValueSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::PolicyValueSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        Messaging::_tc_PolicyValueSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::PolicyValueSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_PolicyValueSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PolicyValueSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PolicyValueSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_PolicyValueSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Messaging::PolicyValueSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_PolicyValueSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PolicyValueSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PolicyValueSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(Messaging::PolicyValueSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Messaging::_tc_PolicyValueSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (Messaging::PolicyValueSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (Messaging::PolicyValueSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (Messaging::PolicyValueSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)

Messaging::ReplyHandler_ptr (*_TAO_collocation_Messaging_ReplyHandler_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

void operator<<= (CORBA::Any &_tao_any, Messaging::ReplyHandler_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::ReplyHandler::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_ReplyHandler, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::ReplyHandler_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::ReplyHandler::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_ReplyHandler, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::ReplyHandler::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_ReplyHandler,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::ReplyHandler::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::ReplyHandler::_nil ();
  return 0;
}

#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER */

// ****************************************************************

#if (TAO_HAS_AMI_POLLER == 1)

void operator<<= (CORBA::Any &_tao_any, Messaging::Poller_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::Poller::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          Messaging::_tc_Poller, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::Poller_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::Poller::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Messaging::_tc_Poller, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = Messaging::Poller::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          Messaging::_tc_Poller,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = Messaging::Poller::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = Messaging::Poller::_nil ();
  return 0;
}

#endif /* TAO_HAS_AMI_POLLER == 1 */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

  template class TAO_Unbounded_Sequence<Messaging::PolicyValue>;

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)
  template class TAO_Object_Field_T<Messaging::ReplyHandler,Messaging::ReplyHandler_var>;
  template class TAO_Object_Manager<Messaging::ReplyHandler,Messaging::ReplyHandler_var>;
#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#if (TAO_HAS_AMI_POLLER == 1)
  template class TAO_Object_Field_T<Messaging::Poller,Messaging::Poller_var>;
  template class TAO_Object_Manager<Messaging::Poller,Messaging::Poller_var>;
#endif /* TAO_HAS_AMI_POLLER == 1 */

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

#pragma instantiate TAO_Unbounded_Sequence<Messaging::PolicyValue>

#if (TAO_HAS_AMI_CALLBACK == 1) || (TAO_HAS_AMI_POLLER == 1)
#  pragma instantiate TAO_Object_Field_T<Messaging::ReplyHandler,Messaging::ReplyHandler_var>
#  pragma instantiate TAO_Object_Manager<Messaging::ReplyHandler,Messaging::ReplyHandler_var>
#endif /* TAO_HAS_AMI_CALLBACK == 1 || TAO_HAS_AMI_POLLER == 1 */

#if (TAO_HAS_AMI_POLLER == 1)
#  pragma instantiate TAO_Object_Field_T<Messaging::Poller,Messaging::Poller_var>
#  pragma instantiate TAO_Object_Manager<Messaging::Poller,Messaging::Poller_var>
#endif /* TAO_HAS_AMI_POLLER == 1 */

#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_CORBA_MESSAGING == 1 */
