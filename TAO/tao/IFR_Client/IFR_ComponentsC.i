// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


#if !defined (_IR_REPOSITORYIDSEQ_CI_)
#define _IR_REPOSITORYIDSEQ_CI_

// *************************************************************
// Inline operations for class IR::RepositoryIdSeq_var
// *************************************************************

ACE_INLINE
IR::RepositoryIdSeq_var::RepositoryIdSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::RepositoryIdSeq_var::RepositoryIdSeq_var (RepositoryIdSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::RepositoryIdSeq_var::RepositoryIdSeq_var (const ::IR::RepositoryIdSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::RepositoryIdSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::RepositoryIdSeq_var::~RepositoryIdSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::RepositoryIdSeq_var &
IR::RepositoryIdSeq_var::operator= (RepositoryIdSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::RepositoryIdSeq_var &
IR::RepositoryIdSeq_var::operator= (const ::IR::RepositoryIdSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          RepositoryIdSeq *deep_copy =
            new RepositoryIdSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              RepositoryIdSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::RepositoryIdSeq *
IR::RepositoryIdSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::RepositoryIdSeq *
IR::RepositoryIdSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::RepositoryIdSeq_var::operator const ::IR::RepositoryIdSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::RepositoryIdSeq_var::operator ::IR::RepositoryIdSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::RepositoryIdSeq_var::operator ::IR::RepositoryIdSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::RepositoryIdSeq_var::operator ::IR::RepositoryIdSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR::RepositoryIdSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::RepositoryIdSeq &
IR::RepositoryIdSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::RepositoryIdSeq &
IR::RepositoryIdSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::RepositoryIdSeq *&
IR::RepositoryIdSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::RepositoryIdSeq *
IR::RepositoryIdSeq_var::_retn (void)
{
  ::IR::RepositoryIdSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::RepositoryIdSeq *
IR::RepositoryIdSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::RepositoryIdSeq_out
// *************************************************************

ACE_INLINE
IR::RepositoryIdSeq_out::RepositoryIdSeq_out (RepositoryIdSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::RepositoryIdSeq_out::RepositoryIdSeq_out (RepositoryIdSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::RepositoryIdSeq_out::RepositoryIdSeq_out (const ::IR::RepositoryIdSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (RepositoryIdSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::RepositoryIdSeq_out &
IR::RepositoryIdSeq_out::operator= (const ::IR::RepositoryIdSeq_out &p)
{
  this->ptr_ = ACE_const_cast (RepositoryIdSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::RepositoryIdSeq_out &
IR::RepositoryIdSeq_out::operator= (RepositoryIdSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::RepositoryIdSeq_out::operator ::IR::RepositoryIdSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::RepositoryIdSeq *&
IR::RepositoryIdSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::RepositoryIdSeq *
IR::RepositoryIdSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
IR::RepositoryIdSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_COMPONENTDEFSEQ_CI_

ACE_INLINE IR::ComponentDef **
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::ComponentDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::ComponentDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::ComponentDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (IR::ComponentDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::ComponentDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::ComponentDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (this->maximum_);
    IR::ComponentDef ** const tmp2 = ACE_reinterpret_cast (IR::ComponentDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::ComponentDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::ComponentDef **tmp = ACE_reinterpret_cast (IR::ComponentDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ComponentDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::ComponentDef **tmp1 = ACE_reinterpret_cast (IR::ComponentDef **, this->buffer_);
  IR::ComponentDef ** const tmp2 = ACE_reinterpret_cast (IR::ComponentDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::ComponentDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::ComponentDef ** const tmp = ACE_reinterpret_cast (IR::ComponentDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::ComponentDef,IR::ComponentDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::ComponentDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::ComponentDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::ComponentDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::ComponentDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::ComponentDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::ComponentDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_COMPONENTDEFSEQ_CI_)
#define _IR_COMPONENTDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::ComponentDefSeq_var
// *************************************************************

ACE_INLINE
IR::ComponentDefSeq_var::ComponentDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::ComponentDefSeq_var::ComponentDefSeq_var (ComponentDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::ComponentDefSeq_var::ComponentDefSeq_var (const ::IR::ComponentDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::ComponentDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::ComponentDefSeq_var::~ComponentDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::ComponentDefSeq_var &
IR::ComponentDefSeq_var::operator= (ComponentDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::ComponentDefSeq_var &
IR::ComponentDefSeq_var::operator= (const ::IR::ComponentDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ComponentDefSeq *deep_copy =
            new ComponentDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ComponentDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::ComponentDefSeq *
IR::ComponentDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDefSeq *
IR::ComponentDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::ComponentDefSeq_var::operator const ::IR::ComponentDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ComponentDefSeq_var::operator ::IR::ComponentDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ComponentDefSeq_var::operator ::IR::ComponentDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::ComponentDefSeq_var::operator ::IR::ComponentDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::ComponentDef, IR::ComponentDef_var>
IR::ComponentDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::ComponentDefSeq &
IR::ComponentDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::ComponentDefSeq &
IR::ComponentDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::ComponentDefSeq *&
IR::ComponentDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDefSeq *
IR::ComponentDefSeq_var::_retn (void)
{
  ::IR::ComponentDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::ComponentDefSeq *
IR::ComponentDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::ComponentDefSeq_out
// *************************************************************

ACE_INLINE
IR::ComponentDefSeq_out::ComponentDefSeq_out (ComponentDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::ComponentDefSeq_out::ComponentDefSeq_out (ComponentDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::ComponentDefSeq_out::ComponentDefSeq_out (const ::IR::ComponentDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::ComponentDefSeq_out &
IR::ComponentDefSeq_out::operator= (const ::IR::ComponentDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::ComponentDefSeq_out &
IR::ComponentDefSeq_out::operator= (ComponentDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::ComponentDefSeq_out::operator ::IR::ComponentDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDefSeq *&
IR::ComponentDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDefSeq *
IR::ComponentDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::ComponentDef, IR::ComponentDef_var>
IR::ComponentDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PROVIDESDEFSEQ_CI_

ACE_INLINE IR::ProvidesDef **
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::ProvidesDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::ProvidesDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::ProvidesDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (IR::ProvidesDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::ProvidesDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::ProvidesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (this->maximum_);
    IR::ProvidesDef ** const tmp2 = ACE_reinterpret_cast (IR::ProvidesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::ProvidesDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::ProvidesDef **tmp = ACE_reinterpret_cast (IR::ProvidesDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ProvidesDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::ProvidesDef **tmp1 = ACE_reinterpret_cast (IR::ProvidesDef **, this->buffer_);
  IR::ProvidesDef ** const tmp2 = ACE_reinterpret_cast (IR::ProvidesDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::ProvidesDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::ProvidesDef ** const tmp = ACE_reinterpret_cast (IR::ProvidesDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::ProvidesDef,IR::ProvidesDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::ProvidesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::ProvidesDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::ProvidesDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::ProvidesDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::ProvidesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::ProvidesDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PROVIDESDEFSEQ_CI_)
#define _IR_PROVIDESDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::ProvidesDefSeq_var
// *************************************************************

ACE_INLINE
IR::ProvidesDefSeq_var::ProvidesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::ProvidesDefSeq_var::ProvidesDefSeq_var (ProvidesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::ProvidesDefSeq_var::ProvidesDefSeq_var (const ::IR::ProvidesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::ProvidesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDefSeq_var::~ProvidesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::ProvidesDefSeq_var &
IR::ProvidesDefSeq_var::operator= (ProvidesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::ProvidesDefSeq_var &
IR::ProvidesDefSeq_var::operator= (const ::IR::ProvidesDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ProvidesDefSeq *deep_copy =
            new ProvidesDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ProvidesDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::ProvidesDefSeq *
IR::ProvidesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDefSeq *
IR::ProvidesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::ProvidesDefSeq_var::operator const ::IR::ProvidesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ProvidesDefSeq_var::operator ::IR::ProvidesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ProvidesDefSeq_var::operator ::IR::ProvidesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::ProvidesDefSeq_var::operator ::IR::ProvidesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::ProvidesDef, IR::ProvidesDef_var>
IR::ProvidesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::ProvidesDefSeq &
IR::ProvidesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::ProvidesDefSeq &
IR::ProvidesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::ProvidesDefSeq *&
IR::ProvidesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDefSeq *
IR::ProvidesDefSeq_var::_retn (void)
{
  ::IR::ProvidesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::ProvidesDefSeq *
IR::ProvidesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::ProvidesDefSeq_out
// *************************************************************

ACE_INLINE
IR::ProvidesDefSeq_out::ProvidesDefSeq_out (ProvidesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDefSeq_out::ProvidesDefSeq_out (ProvidesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDefSeq_out::ProvidesDefSeq_out (const ::IR::ProvidesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ProvidesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::ProvidesDefSeq_out &
IR::ProvidesDefSeq_out::operator= (const ::IR::ProvidesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::ProvidesDefSeq_out &
IR::ProvidesDefSeq_out::operator= (ProvidesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::ProvidesDefSeq_out::operator ::IR::ProvidesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDefSeq *&
IR::ProvidesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDefSeq *
IR::ProvidesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::ProvidesDef, IR::ProvidesDef_var>
IR::ProvidesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_USESDEFSEQ_CI_

ACE_INLINE IR::UsesDef **
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::UsesDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::UsesDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::UsesDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (IR::UsesDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::UsesDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::UsesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (this->maximum_);
    IR::UsesDef ** const tmp2 = ACE_reinterpret_cast (IR::UsesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::UsesDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::UsesDef **tmp = ACE_reinterpret_cast (IR::UsesDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::UsesDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::UsesDef **tmp1 = ACE_reinterpret_cast (IR::UsesDef **, this->buffer_);
  IR::UsesDef ** const tmp2 = ACE_reinterpret_cast (IR::UsesDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::UsesDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::UsesDef ** const tmp = ACE_reinterpret_cast (IR::UsesDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::UsesDef,IR::UsesDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::UsesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::UsesDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::UsesDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::UsesDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::UsesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::UsesDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_USESDEFSEQ_CI_)
#define _IR_USESDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::UsesDefSeq_var
// *************************************************************

ACE_INLINE
IR::UsesDefSeq_var::UsesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::UsesDefSeq_var::UsesDefSeq_var (UsesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::UsesDefSeq_var::UsesDefSeq_var (const ::IR::UsesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::UsesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDefSeq_var::~UsesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::UsesDefSeq_var &
IR::UsesDefSeq_var::operator= (UsesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::UsesDefSeq_var &
IR::UsesDefSeq_var::operator= (const ::IR::UsesDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsesDefSeq *deep_copy =
            new UsesDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              UsesDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::UsesDefSeq *
IR::UsesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDefSeq *
IR::UsesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::UsesDefSeq_var::operator const ::IR::UsesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::UsesDefSeq_var::operator ::IR::UsesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::UsesDefSeq_var::operator ::IR::UsesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::UsesDefSeq_var::operator ::IR::UsesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::UsesDef, IR::UsesDef_var>
IR::UsesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::UsesDefSeq &
IR::UsesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::UsesDefSeq &
IR::UsesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::UsesDefSeq *&
IR::UsesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDefSeq *
IR::UsesDefSeq_var::_retn (void)
{
  ::IR::UsesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::UsesDefSeq *
IR::UsesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::UsesDefSeq_out
// *************************************************************

ACE_INLINE
IR::UsesDefSeq_out::UsesDefSeq_out (UsesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDefSeq_out::UsesDefSeq_out (UsesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDefSeq_out::UsesDefSeq_out (const ::IR::UsesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UsesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::UsesDefSeq_out &
IR::UsesDefSeq_out::operator= (const ::IR::UsesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::UsesDefSeq_out &
IR::UsesDefSeq_out::operator= (UsesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::UsesDefSeq_out::operator ::IR::UsesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDefSeq *&
IR::UsesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDefSeq *
IR::UsesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::UsesDef, IR::UsesDef_var>
IR::UsesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_HOMEDEFSEQ_CI_

ACE_INLINE IR::HomeDef **
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::HomeDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::HomeDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::HomeDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (IR::HomeDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::HomeDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq(const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::HomeDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (this->maximum_);
    IR::HomeDef ** const tmp2 = ACE_reinterpret_cast (IR::HomeDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::HomeDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::HomeDef **tmp = ACE_reinterpret_cast (IR::HomeDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::HomeDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::HomeDef **tmp1 = ACE_reinterpret_cast (IR::HomeDef **, this->buffer_);
  IR::HomeDef ** const tmp2 = ACE_reinterpret_cast (IR::HomeDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::HomeDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::HomeDef ** const tmp = ACE_reinterpret_cast (IR::HomeDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::HomeDef,IR::HomeDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::HomeDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::HomeDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::HomeDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::HomeDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::HomeDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::HomeDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_HOMEDEFSEQ_CI_)
#define _IR_HOMEDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::HomeDefSeq_var
// *************************************************************

ACE_INLINE
IR::HomeDefSeq_var::HomeDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::HomeDefSeq_var::HomeDefSeq_var (HomeDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::HomeDefSeq_var::HomeDefSeq_var (const ::IR::HomeDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::HomeDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::HomeDefSeq_var::~HomeDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::HomeDefSeq_var &
IR::HomeDefSeq_var::operator= (HomeDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::HomeDefSeq_var &
IR::HomeDefSeq_var::operator= (const ::IR::HomeDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HomeDefSeq *deep_copy =
            new HomeDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              HomeDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::HomeDefSeq *
IR::HomeDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDefSeq *
IR::HomeDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::HomeDefSeq_var::operator const ::IR::HomeDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::HomeDefSeq_var::operator ::IR::HomeDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::HomeDefSeq_var::operator ::IR::HomeDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::HomeDefSeq_var::operator ::IR::HomeDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::HomeDef, IR::HomeDef_var>
IR::HomeDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::HomeDefSeq &
IR::HomeDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::HomeDefSeq &
IR::HomeDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::HomeDefSeq *&
IR::HomeDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDefSeq *
IR::HomeDefSeq_var::_retn (void)
{
  ::IR::HomeDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::HomeDefSeq *
IR::HomeDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::HomeDefSeq_out
// *************************************************************

ACE_INLINE
IR::HomeDefSeq_out::HomeDefSeq_out (HomeDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::HomeDefSeq_out::HomeDefSeq_out (HomeDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::HomeDefSeq_out::HomeDefSeq_out (const ::IR::HomeDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::HomeDefSeq_out &
IR::HomeDefSeq_out::operator= (const ::IR::HomeDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (HomeDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::HomeDefSeq_out &
IR::HomeDefSeq_out::operator= (HomeDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::HomeDefSeq_out::operator ::IR::HomeDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDefSeq *&
IR::HomeDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDefSeq *
IR::HomeDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::HomeDef, IR::HomeDef_var>
IR::HomeDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_EMITSDEFSEQ_CI_

ACE_INLINE IR::EmitsDef **
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::EmitsDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::EmitsDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::EmitsDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (IR::EmitsDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::EmitsDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq(const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::EmitsDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (this->maximum_);
    IR::EmitsDef ** const tmp2 = ACE_reinterpret_cast (IR::EmitsDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::EmitsDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::EmitsDef **tmp = ACE_reinterpret_cast (IR::EmitsDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::EmitsDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::EmitsDef **tmp1 = ACE_reinterpret_cast (IR::EmitsDef **, this->buffer_);
  IR::EmitsDef ** const tmp2 = ACE_reinterpret_cast (IR::EmitsDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::EmitsDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::EmitsDef ** const tmp = ACE_reinterpret_cast (IR::EmitsDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::EmitsDef,IR::EmitsDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::EmitsDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::EmitsDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::EmitsDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::EmitsDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::EmitsDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::EmitsDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_EMITSDEFSEQ_CI_)
#define _IR_EMITSDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::EmitsDefSeq_var
// *************************************************************

ACE_INLINE
IR::EmitsDefSeq_var::EmitsDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::EmitsDefSeq_var::EmitsDefSeq_var (EmitsDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::EmitsDefSeq_var::EmitsDefSeq_var (const ::IR::EmitsDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::EmitsDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::EmitsDefSeq_var::~EmitsDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::EmitsDefSeq_var &
IR::EmitsDefSeq_var::operator= (EmitsDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::EmitsDefSeq_var &
IR::EmitsDefSeq_var::operator= (const ::IR::EmitsDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          EmitsDefSeq *deep_copy =
            new EmitsDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              EmitsDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::EmitsDefSeq *
IR::EmitsDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::EmitsDefSeq *
IR::EmitsDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::EmitsDefSeq_var::operator const ::IR::EmitsDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::EmitsDefSeq_var::operator ::IR::EmitsDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::EmitsDefSeq_var::operator ::IR::EmitsDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::EmitsDefSeq_var::operator ::IR::EmitsDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::EmitsDef, IR::EmitsDef_var>
IR::EmitsDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::EmitsDefSeq &
IR::EmitsDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::EmitsDefSeq &
IR::EmitsDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::EmitsDefSeq *&
IR::EmitsDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::EmitsDefSeq *
IR::EmitsDefSeq_var::_retn (void)
{
  ::IR::EmitsDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::EmitsDefSeq *
IR::EmitsDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::EmitsDefSeq_out
// *************************************************************

ACE_INLINE
IR::EmitsDefSeq_out::EmitsDefSeq_out (EmitsDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::EmitsDefSeq_out::EmitsDefSeq_out (EmitsDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::EmitsDefSeq_out::EmitsDefSeq_out (const ::IR::EmitsDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EmitsDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::EmitsDefSeq_out &
IR::EmitsDefSeq_out::operator= (const ::IR::EmitsDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (EmitsDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::EmitsDefSeq_out &
IR::EmitsDefSeq_out::operator= (EmitsDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::EmitsDefSeq_out::operator ::IR::EmitsDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::EmitsDefSeq *&
IR::EmitsDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::EmitsDefSeq *
IR::EmitsDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::EmitsDef, IR::EmitsDef_var>
IR::EmitsDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_PUBLISHESDEFSEQ_CI_

ACE_INLINE IR::PublishesDef **
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::PublishesDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::PublishesDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::PublishesDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (IR::PublishesDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::PublishesDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::PublishesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (this->maximum_);
    IR::PublishesDef ** const tmp2 = ACE_reinterpret_cast (IR::PublishesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::PublishesDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::PublishesDef **tmp = ACE_reinterpret_cast (IR::PublishesDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::PublishesDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::PublishesDef **tmp1 = ACE_reinterpret_cast (IR::PublishesDef **, this->buffer_);
  IR::PublishesDef ** const tmp2 = ACE_reinterpret_cast (IR::PublishesDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::PublishesDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::PublishesDef ** const tmp = ACE_reinterpret_cast (IR::PublishesDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::PublishesDef,IR::PublishesDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::PublishesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::PublishesDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::PublishesDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::PublishesDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::PublishesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::PublishesDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PUBLISHESDEFSEQ_CI_)
#define _IR_PUBLISHESDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::PublishesDefSeq_var
// *************************************************************

ACE_INLINE
IR::PublishesDefSeq_var::PublishesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::PublishesDefSeq_var::PublishesDefSeq_var (PublishesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::PublishesDefSeq_var::PublishesDefSeq_var (const ::IR::PublishesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::PublishesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::PublishesDefSeq_var::~PublishesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::PublishesDefSeq_var &
IR::PublishesDefSeq_var::operator= (PublishesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::PublishesDefSeq_var &
IR::PublishesDefSeq_var::operator= (const ::IR::PublishesDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          PublishesDefSeq *deep_copy =
            new PublishesDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              PublishesDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::PublishesDefSeq *
IR::PublishesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::PublishesDefSeq *
IR::PublishesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::PublishesDefSeq_var::operator const ::IR::PublishesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::PublishesDefSeq_var::operator ::IR::PublishesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::PublishesDefSeq_var::operator ::IR::PublishesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::PublishesDefSeq_var::operator ::IR::PublishesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::PublishesDef, IR::PublishesDef_var>
IR::PublishesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::PublishesDefSeq &
IR::PublishesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::PublishesDefSeq &
IR::PublishesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::PublishesDefSeq *&
IR::PublishesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::PublishesDefSeq *
IR::PublishesDefSeq_var::_retn (void)
{
  ::IR::PublishesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::PublishesDefSeq *
IR::PublishesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::PublishesDefSeq_out
// *************************************************************

ACE_INLINE
IR::PublishesDefSeq_out::PublishesDefSeq_out (PublishesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::PublishesDefSeq_out::PublishesDefSeq_out (PublishesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::PublishesDefSeq_out::PublishesDefSeq_out (const ::IR::PublishesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PublishesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::PublishesDefSeq_out &
IR::PublishesDefSeq_out::operator= (const ::IR::PublishesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (PublishesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::PublishesDefSeq_out &
IR::PublishesDefSeq_out::operator= (PublishesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::PublishesDefSeq_out::operator ::IR::PublishesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::PublishesDefSeq *&
IR::PublishesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::PublishesDefSeq *
IR::PublishesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::PublishesDef, IR::PublishesDef_var>
IR::PublishesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_CONSUMESDEFSEQ_CI_

ACE_INLINE IR::ConsumesDef **
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::ConsumesDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::ConsumesDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::ConsumesDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (IR::ConsumesDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::ConsumesDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::ConsumesDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (this->maximum_);
    IR::ConsumesDef ** const tmp2 = ACE_reinterpret_cast (IR::ConsumesDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::ConsumesDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::ConsumesDef **tmp = ACE_reinterpret_cast (IR::ConsumesDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::ConsumesDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::ConsumesDef **tmp1 = ACE_reinterpret_cast (IR::ConsumesDef **, this->buffer_);
  IR::ConsumesDef ** const tmp2 = ACE_reinterpret_cast (IR::ConsumesDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::ConsumesDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::ConsumesDef ** const tmp = ACE_reinterpret_cast (IR::ConsumesDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::ConsumesDef,IR::ConsumesDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::ConsumesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::ConsumesDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::ConsumesDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::ConsumesDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::ConsumesDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::ConsumesDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_CONSUMESDEFSEQ_CI_)
#define _IR_CONSUMESDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::ConsumesDefSeq_var
// *************************************************************

ACE_INLINE
IR::ConsumesDefSeq_var::ConsumesDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::ConsumesDefSeq_var::ConsumesDefSeq_var (ConsumesDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::ConsumesDefSeq_var::ConsumesDefSeq_var (const ::IR::ConsumesDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::ConsumesDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::ConsumesDefSeq_var::~ConsumesDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::ConsumesDefSeq_var &
IR::ConsumesDefSeq_var::operator= (ConsumesDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::ConsumesDefSeq_var &
IR::ConsumesDefSeq_var::operator= (const ::IR::ConsumesDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ConsumesDefSeq *deep_copy =
            new ConsumesDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ConsumesDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::ConsumesDefSeq *
IR::ConsumesDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::ConsumesDefSeq *
IR::ConsumesDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::ConsumesDefSeq_var::operator const ::IR::ConsumesDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ConsumesDefSeq_var::operator ::IR::ConsumesDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ConsumesDefSeq_var::operator ::IR::ConsumesDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::ConsumesDefSeq_var::operator ::IR::ConsumesDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::ConsumesDef, IR::ConsumesDef_var>
IR::ConsumesDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::ConsumesDefSeq &
IR::ConsumesDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::ConsumesDefSeq &
IR::ConsumesDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::ConsumesDefSeq *&
IR::ConsumesDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::ConsumesDefSeq *
IR::ConsumesDefSeq_var::_retn (void)
{
  ::IR::ConsumesDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::ConsumesDefSeq *
IR::ConsumesDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::ConsumesDefSeq_out
// *************************************************************

ACE_INLINE
IR::ConsumesDefSeq_out::ConsumesDefSeq_out (ConsumesDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::ConsumesDefSeq_out::ConsumesDefSeq_out (ConsumesDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::ConsumesDefSeq_out::ConsumesDefSeq_out (const ::IR::ConsumesDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConsumesDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::ConsumesDefSeq_out &
IR::ConsumesDefSeq_out::operator= (const ::IR::ConsumesDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumesDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::ConsumesDefSeq_out &
IR::ConsumesDefSeq_out::operator= (ConsumesDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::ConsumesDefSeq_out::operator ::IR::ConsumesDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::ConsumesDefSeq *&
IR::ConsumesDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::ConsumesDefSeq *
IR::ConsumesDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::ConsumesDef, IR::ConsumesDef_var>
IR::ConsumesDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FACTORYDEFSEQ_CI_

ACE_INLINE IR::FactoryDef **
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::FactoryDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::FactoryDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::FactoryDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (IR::FactoryDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::FactoryDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq(const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::FactoryDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (this->maximum_);
    IR::FactoryDef ** const tmp2 = ACE_reinterpret_cast (IR::FactoryDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::FactoryDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::FactoryDef **tmp = ACE_reinterpret_cast (IR::FactoryDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FactoryDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::FactoryDef **tmp1 = ACE_reinterpret_cast (IR::FactoryDef **, this->buffer_);
  IR::FactoryDef ** const tmp2 = ACE_reinterpret_cast (IR::FactoryDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::FactoryDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::FactoryDef ** const tmp = ACE_reinterpret_cast (IR::FactoryDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::FactoryDef,IR::FactoryDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::FactoryDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::FactoryDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::FactoryDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::FactoryDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::FactoryDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::FactoryDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_FACTORYDEFSEQ_CI_)
#define _IR_FACTORYDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::FactoryDefSeq_var
// *************************************************************

ACE_INLINE
IR::FactoryDefSeq_var::FactoryDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::FactoryDefSeq_var::FactoryDefSeq_var (FactoryDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::FactoryDefSeq_var::FactoryDefSeq_var (const ::IR::FactoryDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::FactoryDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::FactoryDefSeq_var::~FactoryDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::FactoryDefSeq_var &
IR::FactoryDefSeq_var::operator= (FactoryDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::FactoryDefSeq_var &
IR::FactoryDefSeq_var::operator= (const ::IR::FactoryDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          FactoryDefSeq *deep_copy =
            new FactoryDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              FactoryDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::FactoryDefSeq *
IR::FactoryDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::FactoryDefSeq *
IR::FactoryDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::FactoryDefSeq_var::operator const ::IR::FactoryDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::FactoryDefSeq_var::operator ::IR::FactoryDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::FactoryDefSeq_var::operator ::IR::FactoryDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::FactoryDefSeq_var::operator ::IR::FactoryDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::FactoryDef, IR::FactoryDef_var>
IR::FactoryDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::FactoryDefSeq &
IR::FactoryDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::FactoryDefSeq &
IR::FactoryDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::FactoryDefSeq *&
IR::FactoryDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::FactoryDefSeq *
IR::FactoryDefSeq_var::_retn (void)
{
  ::IR::FactoryDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::FactoryDefSeq *
IR::FactoryDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::FactoryDefSeq_out
// *************************************************************

ACE_INLINE
IR::FactoryDefSeq_out::FactoryDefSeq_out (FactoryDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::FactoryDefSeq_out::FactoryDefSeq_out (FactoryDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::FactoryDefSeq_out::FactoryDefSeq_out (const ::IR::FactoryDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FactoryDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::FactoryDefSeq_out &
IR::FactoryDefSeq_out::operator= (const ::IR::FactoryDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (FactoryDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::FactoryDefSeq_out &
IR::FactoryDefSeq_out::operator= (FactoryDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::FactoryDefSeq_out::operator ::IR::FactoryDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::FactoryDefSeq *&
IR::FactoryDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::FactoryDefSeq *
IR::FactoryDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::FactoryDef, IR::FactoryDef_var>
IR::FactoryDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_IR_FINDERDEFSEQ_CI_

ACE_INLINE IR::FinderDef **
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (CORBA::ULong nelems)
{
  IR::FinderDef **buf = 0;
  
  ACE_NEW_RETURN (buf, IR::FinderDef*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = IR::FinderDef::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (IR::FinderDef **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::FinderDef* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq(const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::FinderDef **tmp1 = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (this->maximum_);
    IR::FinderDef ** const tmp2 = ACE_reinterpret_cast (IR::FinderDef ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = IR::FinderDef::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::operator= (const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    IR::FinderDef **tmp = ACE_reinterpret_cast (IR::FinderDef **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR::FinderDef::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::FinderDef **tmp1 = ACE_reinterpret_cast (IR::FinderDef **, this->buffer_);
  IR::FinderDef ** const tmp2 = ACE_reinterpret_cast (IR::FinderDef ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = IR::FinderDef::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var>
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  IR::FinderDef ** const tmp = ACE_reinterpret_cast (IR::FinderDef ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<IR::FinderDef,IR::FinderDef_var> (tmp + index, this->release_);
}

ACE_INLINE IR::FinderDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::FinderDef **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::FinderDef**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::FinderDef**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::FinderDef* *
IR::_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::FinderDef ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_FINDERDEFSEQ_CI_)
#define _IR_FINDERDEFSEQ_CI_

// *************************************************************
// Inline operations for class IR::FinderDefSeq_var
// *************************************************************

ACE_INLINE
IR::FinderDefSeq_var::FinderDefSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::FinderDefSeq_var::FinderDefSeq_var (FinderDefSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::FinderDefSeq_var::FinderDefSeq_var (const ::IR::FinderDefSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::FinderDefSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::FinderDefSeq_var::~FinderDefSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::FinderDefSeq_var &
IR::FinderDefSeq_var::operator= (FinderDefSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::FinderDefSeq_var &
IR::FinderDefSeq_var::operator= (const ::IR::FinderDefSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          FinderDefSeq *deep_copy =
            new FinderDefSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              FinderDefSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::FinderDefSeq *
IR::FinderDefSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::FinderDefSeq *
IR::FinderDefSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::FinderDefSeq_var::operator const ::IR::FinderDefSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::FinderDefSeq_var::operator ::IR::FinderDefSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::FinderDefSeq_var::operator ::IR::FinderDefSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::FinderDefSeq_var::operator ::IR::FinderDefSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::FinderDef, IR::FinderDef_var>
IR::FinderDefSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::IR::FinderDefSeq &
IR::FinderDefSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::FinderDefSeq &
IR::FinderDefSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::FinderDefSeq *&
IR::FinderDefSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::FinderDefSeq *
IR::FinderDefSeq_var::_retn (void)
{
  ::IR::FinderDefSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::FinderDefSeq *
IR::FinderDefSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::FinderDefSeq_out
// *************************************************************

ACE_INLINE
IR::FinderDefSeq_out::FinderDefSeq_out (FinderDefSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::FinderDefSeq_out::FinderDefSeq_out (FinderDefSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::FinderDefSeq_out::FinderDefSeq_out (const ::IR::FinderDefSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FinderDefSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::FinderDefSeq_out &
IR::FinderDefSeq_out::operator= (const ::IR::FinderDefSeq_out &p)
{
  this->ptr_ = ACE_const_cast (FinderDefSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::FinderDefSeq_out &
IR::FinderDefSeq_out::operator= (FinderDefSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::FinderDefSeq_out::operator ::IR::FinderDefSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::FinderDefSeq *&
IR::FinderDefSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::FinderDefSeq *
IR::FinderDefSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<IR::FinderDef, IR::FinderDef_var>
IR::FinderDefSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (_IR_COMPONENTREPOSITORY___CI_)
#define _IR_COMPONENTREPOSITORY___CI_

ACE_INLINE
IR::ComponentRepository::ComponentRepository (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_ComponentRepository_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined (_IR_PROVIDESDEF___CI_)
#define _IR_PROVIDESDEF___CI_

ACE_INLINE
IR::ProvidesDef::ProvidesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_ProvidesDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class IR::ProvidesDescription_var
// *************************************************************

ACE_INLINE
IR::ProvidesDescription_var::ProvidesDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::ProvidesDescription_var::ProvidesDescription_var (ProvidesDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::ProvidesDescription_var::ProvidesDescription_var (const ::IR::ProvidesDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::ProvidesDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDescription_var::~ProvidesDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::ProvidesDescription_var &
IR::ProvidesDescription_var::operator= (ProvidesDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::ProvidesDescription_var &
IR::ProvidesDescription_var::operator= (const ::IR::ProvidesDescription_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ProvidesDescription *deep_copy =
            new ProvidesDescription (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ProvidesDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::ProvidesDescription *
IR::ProvidesDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescription *
IR::ProvidesDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR::ProvidesDescription_var::operator const ::IR::ProvidesDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR::ProvidesDescription_var::operator ::IR::ProvidesDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR::ProvidesDescription_var::operator ::IR::ProvidesDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::ProvidesDescription_var::operator ::IR::ProvidesDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR::ProvidesDescription &
IR::ProvidesDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescription &
IR::ProvidesDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::ProvidesDescription *&
IR::ProvidesDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescription *
IR::ProvidesDescription_var::_retn (void)
{
  ::IR::ProvidesDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::ProvidesDescription *
IR::ProvidesDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::ProvidesDescription_out
// *************************************************************

ACE_INLINE
IR::ProvidesDescription_out::ProvidesDescription_out (::IR::ProvidesDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDescription_out::ProvidesDescription_out (ProvidesDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDescription_out::ProvidesDescription_out (const ::IR::ProvidesDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ProvidesDescription_out&, p).ptr_)
{}

ACE_INLINE IR::ProvidesDescription_out &
IR::ProvidesDescription_out::operator= (const ::IR::ProvidesDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR::ProvidesDescription_out &
IR::ProvidesDescription_out::operator= (ProvidesDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::ProvidesDescription_out::operator ::IR::ProvidesDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescription *&
IR::ProvidesDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescription *
IR::ProvidesDescription_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (_IR_USESDEF___CI_)
#define _IR_USESDEF___CI_

ACE_INLINE
IR::UsesDef::UsesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_UsesDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class IR::UsesDescription_var
// *************************************************************

ACE_INLINE
IR::UsesDescription_var::UsesDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::UsesDescription_var::UsesDescription_var (UsesDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::UsesDescription_var::UsesDescription_var (const ::IR::UsesDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::UsesDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDescription_var::~UsesDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::UsesDescription_var &
IR::UsesDescription_var::operator= (UsesDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::UsesDescription_var &
IR::UsesDescription_var::operator= (const ::IR::UsesDescription_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsesDescription *deep_copy =
            new UsesDescription (*p.ptr_);
          
          if (deep_copy != 0)
            {
              UsesDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::UsesDescription *
IR::UsesDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescription *
IR::UsesDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR::UsesDescription_var::operator const ::IR::UsesDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR::UsesDescription_var::operator ::IR::UsesDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR::UsesDescription_var::operator ::IR::UsesDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::UsesDescription_var::operator ::IR::UsesDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR::UsesDescription &
IR::UsesDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::UsesDescription &
IR::UsesDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::UsesDescription *&
IR::UsesDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescription *
IR::UsesDescription_var::_retn (void)
{
  ::IR::UsesDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::UsesDescription *
IR::UsesDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::UsesDescription_out
// *************************************************************

ACE_INLINE
IR::UsesDescription_out::UsesDescription_out (::IR::UsesDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDescription_out::UsesDescription_out (UsesDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDescription_out::UsesDescription_out (const ::IR::UsesDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UsesDescription_out&, p).ptr_)
{}

ACE_INLINE IR::UsesDescription_out &
IR::UsesDescription_out::operator= (const ::IR::UsesDescription_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR::UsesDescription_out &
IR::UsesDescription_out::operator= (UsesDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::UsesDescription_out::operator ::IR::UsesDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescription *&
IR::UsesDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescription *
IR::UsesDescription_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_PROVIDESDESCSEQ_CI_

// = Static operations.
ACE_INLINE IR::ProvidesDescription *
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (CORBA::ULong size)
// Allocate storage for the sequence.
{
  IR::ProvidesDescription *retval = 0;
  ACE_NEW_RETURN (retval, IR::ProvidesDescription[size], 0);
  return retval;
}

ACE_INLINE void IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (IR::ProvidesDescription *buffer)
// Free the sequence.
{
  delete [] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Default constructor.
{
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::ProvidesDescription *data,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs)
// Copy constructor.
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::ProvidesDescription *tmp1 = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (this->maximum_);
    IR::ProvidesDescription * const tmp2 = ACE_reinterpret_cast (IR::ProvidesDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq &
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::operator= (const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs)
// Assignment operator.
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    if (this->maximum_ < rhs.maximum_)
    {
      // free the old buffer
      IR::ProvidesDescription *tmp = ACE_reinterpret_cast (IR::ProvidesDescription *, this->buffer_);
      _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::ProvidesDescription *tmp1 = ACE_reinterpret_cast (IR::ProvidesDescription *, this->buffer_);
  IR::ProvidesDescription * const tmp2 = ACE_reinterpret_cast (IR::ProvidesDescription * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    tmp1[i] = tmp2[i];
  
  return *this;
}

// = Accessors.
ACE_INLINE IR::ProvidesDescription &
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::operator[] (CORBA::ULong i)
// operator []
{
  ACE_ASSERT (i < this->maximum_);
  IR::ProvidesDescription* tmp = ACE_reinterpret_cast(IR::ProvidesDescription*,this->buffer_);
  return tmp[i];
}

ACE_INLINE const IR::ProvidesDescription &
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::operator[] (CORBA::ULong i) const
// operator []
{
  ACE_ASSERT (i < this->maximum_);
  IR::ProvidesDescription * const tmp = ACE_reinterpret_cast (IR::ProvidesDescription* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE IR::ProvidesDescription *
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::ProvidesDescription *result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (this->length_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::ProvidesDescription*, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::ProvidesDescription*,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::ProvidesDescription *
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::ProvidesDescription * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE void
IR::_TAO_Unbounded_Sequence_IR_ProvidesDescSeq::replace (CORBA::ULong max,
CORBA::ULong length,
IR::ProvidesDescription *data,
CORBA::Boolean release)
{
  this->maximum_ = max;
  this->length_ = length;
  if (this->buffer_ && this->release_ == 1)
  {
    IR::ProvidesDescription *tmp = ACE_reinterpret_cast(IR::ProvidesDescription*,this->buffer_);
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
  }
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_PROVIDESDESCSEQ_CI_)
#define _IR_PROVIDESDESCSEQ_CI_

// *************************************************************
// Inline operations for class IR::ProvidesDescSeq_var
// *************************************************************

ACE_INLINE
IR::ProvidesDescSeq_var::ProvidesDescSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::ProvidesDescSeq_var::ProvidesDescSeq_var (ProvidesDescSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::ProvidesDescSeq_var::ProvidesDescSeq_var (const ::IR::ProvidesDescSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::ProvidesDescSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDescSeq_var::~ProvidesDescSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::ProvidesDescSeq_var &
IR::ProvidesDescSeq_var::operator= (ProvidesDescSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::ProvidesDescSeq_var &
IR::ProvidesDescSeq_var::operator= (const ::IR::ProvidesDescSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ProvidesDescSeq *deep_copy =
            new ProvidesDescSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ProvidesDescSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::ProvidesDescSeq *
IR::ProvidesDescSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescSeq *
IR::ProvidesDescSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::ProvidesDescSeq_var::operator const ::IR::ProvidesDescSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ProvidesDescSeq_var::operator ::IR::ProvidesDescSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::ProvidesDescSeq_var::operator ::IR::ProvidesDescSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::ProvidesDescSeq_var::operator ::IR::ProvidesDescSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR::ProvidesDescription &
IR::ProvidesDescSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR::ProvidesDescription &
IR::ProvidesDescSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR::ProvidesDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR::ProvidesDescSeq &
IR::ProvidesDescSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescSeq &
IR::ProvidesDescSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::ProvidesDescSeq *&
IR::ProvidesDescSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescSeq *
IR::ProvidesDescSeq_var::_retn (void)
{
  ::IR::ProvidesDescSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::ProvidesDescSeq *
IR::ProvidesDescSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::ProvidesDescSeq_out
// *************************************************************

ACE_INLINE
IR::ProvidesDescSeq_out::ProvidesDescSeq_out (ProvidesDescSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDescSeq_out::ProvidesDescSeq_out (ProvidesDescSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::ProvidesDescSeq_out::ProvidesDescSeq_out (const ::IR::ProvidesDescSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ProvidesDescSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::ProvidesDescSeq_out &
IR::ProvidesDescSeq_out::operator= (const ::IR::ProvidesDescSeq_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDescSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::ProvidesDescSeq_out &
IR::ProvidesDescSeq_out::operator= (ProvidesDescSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::ProvidesDescSeq_out::operator ::IR::ProvidesDescSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescSeq *&
IR::ProvidesDescSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::ProvidesDescSeq *
IR::ProvidesDescSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR::ProvidesDescription &
IR::ProvidesDescSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_IR_USESDESCSEQ_CI_

// = Static operations.
ACE_INLINE IR::UsesDescription *
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (CORBA::ULong size)
// Allocate storage for the sequence.
{
  IR::UsesDescription *retval = 0;
  ACE_NEW_RETURN (retval, IR::UsesDescription[size], 0);
  return retval;
}

ACE_INLINE void IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (IR::UsesDescription *buffer)
// Free the sequence.
{
  delete [] buffer;
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Default constructor.
{
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (maximum))
{
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  IR::UsesDescription *data,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::_TAO_Unbounded_Sequence_IR_UsesDescSeq (const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs)
// Copy constructor.
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    IR::UsesDescription *tmp1 = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (this->maximum_);
    IR::UsesDescription * const tmp2 = ACE_reinterpret_cast (IR::UsesDescription * ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq &
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::operator= (const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs)
// Assignment operator.
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    if (this->maximum_ < rhs.maximum_)
    {
      // free the old buffer
      IR::UsesDescription *tmp = ACE_reinterpret_cast (IR::UsesDescription *, this->buffer_);
      _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  IR::UsesDescription *tmp1 = ACE_reinterpret_cast (IR::UsesDescription *, this->buffer_);
  IR::UsesDescription * const tmp2 = ACE_reinterpret_cast (IR::UsesDescription * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    tmp1[i] = tmp2[i];
  
  return *this;
}

// = Accessors.
ACE_INLINE IR::UsesDescription &
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::operator[] (CORBA::ULong i)
// operator []
{
  ACE_ASSERT (i < this->maximum_);
  IR::UsesDescription* tmp = ACE_reinterpret_cast(IR::UsesDescription*,this->buffer_);
  return tmp[i];
}

ACE_INLINE const IR::UsesDescription &
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::operator[] (CORBA::ULong i) const
// operator []
{
  ACE_ASSERT (i < this->maximum_);
  IR::UsesDescription * const tmp = ACE_reinterpret_cast (IR::UsesDescription* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE IR::UsesDescription *
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::get_buffer (CORBA::Boolean orphan)
{
  IR::UsesDescription *result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (this->length_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (IR::UsesDescription*, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(IR::UsesDescription*,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const IR::UsesDescription *
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const IR::UsesDescription * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE void
IR::_TAO_Unbounded_Sequence_IR_UsesDescSeq::replace (CORBA::ULong max,
CORBA::ULong length,
IR::UsesDescription *data,
CORBA::Boolean release)
{
  this->maximum_ = max;
  this->length_ = length;
  if (this->buffer_ && this->release_ == 1)
  {
    IR::UsesDescription *tmp = ACE_reinterpret_cast(IR::UsesDescription*,this->buffer_);
    _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
  }
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_IR_USESDESCSEQ_CI_)
#define _IR_USESDESCSEQ_CI_

// *************************************************************
// Inline operations for class IR::UsesDescSeq_var
// *************************************************************

ACE_INLINE
IR::UsesDescSeq_var::UsesDescSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::UsesDescSeq_var::UsesDescSeq_var (UsesDescSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::UsesDescSeq_var::UsesDescSeq_var (const ::IR::UsesDescSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::UsesDescSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDescSeq_var::~UsesDescSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::UsesDescSeq_var &
IR::UsesDescSeq_var::operator= (UsesDescSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::UsesDescSeq_var &
IR::UsesDescSeq_var::operator= (const ::IR::UsesDescSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsesDescSeq *deep_copy =
            new UsesDescSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              UsesDescSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::UsesDescSeq *
IR::UsesDescSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescSeq *
IR::UsesDescSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
IR::UsesDescSeq_var::operator const ::IR::UsesDescSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
IR::UsesDescSeq_var::operator ::IR::UsesDescSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
IR::UsesDescSeq_var::operator ::IR::UsesDescSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::UsesDescSeq_var::operator ::IR::UsesDescSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE IR::UsesDescription &
IR::UsesDescSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const IR::UsesDescription &
IR::UsesDescSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const IR::UsesDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::IR::UsesDescSeq &
IR::UsesDescSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::UsesDescSeq &
IR::UsesDescSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::UsesDescSeq *&
IR::UsesDescSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescSeq *
IR::UsesDescSeq_var::_retn (void)
{
  ::IR::UsesDescSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::UsesDescSeq *
IR::UsesDescSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::UsesDescSeq_out
// *************************************************************

ACE_INLINE
IR::UsesDescSeq_out::UsesDescSeq_out (UsesDescSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDescSeq_out::UsesDescSeq_out (UsesDescSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::UsesDescSeq_out::UsesDescSeq_out (const ::IR::UsesDescSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UsesDescSeq_out&, p).ptr_)
{}

ACE_INLINE ::IR::UsesDescSeq_out &
IR::UsesDescSeq_out::operator= (const ::IR::UsesDescSeq_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDescSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::IR::UsesDescSeq_out &
IR::UsesDescSeq_out::operator= (UsesDescSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::UsesDescSeq_out::operator ::IR::UsesDescSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescSeq *&
IR::UsesDescSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::UsesDescSeq *
IR::UsesDescSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE IR::UsesDescription &
IR::UsesDescSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (_IR_EVENTDEF___CI_)
#define _IR_EVENTDEF___CI_

ACE_INLINE
IR::EventDef::EventDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_EventDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class IR::EventDescription_var
// *************************************************************

ACE_INLINE
IR::EventDescription_var::EventDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::EventDescription_var::EventDescription_var (EventDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::EventDescription_var::EventDescription_var (const ::IR::EventDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::EventDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::EventDescription_var::~EventDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::EventDescription_var &
IR::EventDescription_var::operator= (EventDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::EventDescription_var &
IR::EventDescription_var::operator= (const ::IR::EventDescription_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          EventDescription *deep_copy =
            new EventDescription (*p.ptr_);
          
          if (deep_copy != 0)
            {
              EventDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::EventDescription *
IR::EventDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::EventDescription *
IR::EventDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR::EventDescription_var::operator const ::IR::EventDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR::EventDescription_var::operator ::IR::EventDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR::EventDescription_var::operator ::IR::EventDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::EventDescription_var::operator ::IR::EventDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR::EventDescription &
IR::EventDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::EventDescription &
IR::EventDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::EventDescription *&
IR::EventDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::EventDescription *
IR::EventDescription_var::_retn (void)
{
  ::IR::EventDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::EventDescription *
IR::EventDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::EventDescription_out
// *************************************************************

ACE_INLINE
IR::EventDescription_out::EventDescription_out (::IR::EventDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::EventDescription_out::EventDescription_out (EventDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::EventDescription_out::EventDescription_out (const ::IR::EventDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EventDescription_out&, p).ptr_)
{}

ACE_INLINE IR::EventDescription_out &
IR::EventDescription_out::operator= (const ::IR::EventDescription_out &p)
{
  this->ptr_ = ACE_const_cast (EventDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR::EventDescription_out &
IR::EventDescription_out::operator= (EventDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::EventDescription_out::operator ::IR::EventDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::EventDescription *&
IR::EventDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::EventDescription *
IR::EventDescription_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (_IR_EMITSDEF___CI_)
#define _IR_EMITSDEF___CI_

ACE_INLINE
IR::EmitsDef::EmitsDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_EmitsDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined (_IR_PUBLISHESDEF___CI_)
#define _IR_PUBLISHESDEF___CI_

ACE_INLINE
IR::PublishesDef::PublishesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_PublishesDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined (_IR_CONSUMESDEF___CI_)
#define _IR_CONSUMESDEF___CI_

ACE_INLINE
IR::ConsumesDef::ConsumesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_ConsumesDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined (_IR_COMPONENTDEF___CI_)
#define _IR_COMPONENTDEF___CI_

ACE_INLINE
IR::ComponentDef::ComponentDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_ComponentDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class IR::ComponentDescription_var
// *************************************************************

ACE_INLINE
IR::ComponentDescription_var::ComponentDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::ComponentDescription_var::ComponentDescription_var (ComponentDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::ComponentDescription_var::ComponentDescription_var (const ::IR::ComponentDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::ComponentDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::ComponentDescription_var::~ComponentDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::ComponentDescription_var &
IR::ComponentDescription_var::operator= (ComponentDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::ComponentDescription_var &
IR::ComponentDescription_var::operator= (const ::IR::ComponentDescription_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ComponentDescription *deep_copy =
            new ComponentDescription (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ComponentDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::ComponentDescription *
IR::ComponentDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDescription *
IR::ComponentDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR::ComponentDescription_var::operator const ::IR::ComponentDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR::ComponentDescription_var::operator ::IR::ComponentDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR::ComponentDescription_var::operator ::IR::ComponentDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::ComponentDescription_var::operator ::IR::ComponentDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR::ComponentDescription &
IR::ComponentDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::ComponentDescription &
IR::ComponentDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::ComponentDescription *&
IR::ComponentDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDescription *
IR::ComponentDescription_var::_retn (void)
{
  ::IR::ComponentDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::ComponentDescription *
IR::ComponentDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::ComponentDescription_out
// *************************************************************

ACE_INLINE
IR::ComponentDescription_out::ComponentDescription_out (::IR::ComponentDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::ComponentDescription_out::ComponentDescription_out (ComponentDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::ComponentDescription_out::ComponentDescription_out (const ::IR::ComponentDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentDescription_out&, p).ptr_)
{}

ACE_INLINE IR::ComponentDescription_out &
IR::ComponentDescription_out::operator= (const ::IR::ComponentDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR::ComponentDescription_out &
IR::ComponentDescription_out::operator= (ComponentDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::ComponentDescription_out::operator ::IR::ComponentDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDescription *&
IR::ComponentDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::ComponentDescription *
IR::ComponentDescription_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (_IR_PRIMARYKEYDEF___CI_)
#define _IR_PRIMARYKEYDEF___CI_

ACE_INLINE
IR::PrimaryKeyDef::PrimaryKeyDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_PrimaryKeyDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class IR::PrimaryKeyDescription_var
// *************************************************************

ACE_INLINE
IR::PrimaryKeyDescription_var::PrimaryKeyDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::PrimaryKeyDescription_var::PrimaryKeyDescription_var (PrimaryKeyDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::PrimaryKeyDescription_var::PrimaryKeyDescription_var (const ::IR::PrimaryKeyDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::PrimaryKeyDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::PrimaryKeyDescription_var::~PrimaryKeyDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::PrimaryKeyDescription_var &
IR::PrimaryKeyDescription_var::operator= (PrimaryKeyDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::PrimaryKeyDescription_var &
IR::PrimaryKeyDescription_var::operator= (const ::IR::PrimaryKeyDescription_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          PrimaryKeyDescription *deep_copy =
            new PrimaryKeyDescription (*p.ptr_);
          
          if (deep_copy != 0)
            {
              PrimaryKeyDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::PrimaryKeyDescription *
IR::PrimaryKeyDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::PrimaryKeyDescription *
IR::PrimaryKeyDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR::PrimaryKeyDescription_var::operator const ::IR::PrimaryKeyDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR::PrimaryKeyDescription_var::operator ::IR::PrimaryKeyDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR::PrimaryKeyDescription_var::operator ::IR::PrimaryKeyDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::PrimaryKeyDescription_var::operator ::IR::PrimaryKeyDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR::PrimaryKeyDescription &
IR::PrimaryKeyDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::PrimaryKeyDescription &
IR::PrimaryKeyDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::PrimaryKeyDescription *&
IR::PrimaryKeyDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::PrimaryKeyDescription *
IR::PrimaryKeyDescription_var::_retn (void)
{
  ::IR::PrimaryKeyDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::PrimaryKeyDescription *
IR::PrimaryKeyDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::PrimaryKeyDescription_out
// *************************************************************

ACE_INLINE
IR::PrimaryKeyDescription_out::PrimaryKeyDescription_out (::IR::PrimaryKeyDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::PrimaryKeyDescription_out::PrimaryKeyDescription_out (PrimaryKeyDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::PrimaryKeyDescription_out::PrimaryKeyDescription_out (const ::IR::PrimaryKeyDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PrimaryKeyDescription_out&, p).ptr_)
{}

ACE_INLINE IR::PrimaryKeyDescription_out &
IR::PrimaryKeyDescription_out::operator= (const ::IR::PrimaryKeyDescription_out &p)
{
  this->ptr_ = ACE_const_cast (PrimaryKeyDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR::PrimaryKeyDescription_out &
IR::PrimaryKeyDescription_out::operator= (PrimaryKeyDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::PrimaryKeyDescription_out::operator ::IR::PrimaryKeyDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::PrimaryKeyDescription *&
IR::PrimaryKeyDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::PrimaryKeyDescription *
IR::PrimaryKeyDescription_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined (_IR_FACTORYDEF___CI_)
#define _IR_FACTORYDEF___CI_

ACE_INLINE
IR::FactoryDef::FactoryDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_FactoryDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined (_IR_FINDERDEF___CI_)
#define _IR_FINDERDEF___CI_

ACE_INLINE
IR::FinderDef::FinderDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_FinderDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined (_IR_HOMEDEF___CI_)
#define _IR_HOMEDEF___CI_

ACE_INLINE
IR::HomeDef::HomeDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->IR_HomeDef_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for class IR::HomeDescription_var
// *************************************************************

ACE_INLINE
IR::HomeDescription_var::HomeDescription_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
IR::HomeDescription_var::HomeDescription_var (HomeDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
IR::HomeDescription_var::HomeDescription_var (const ::IR::HomeDescription_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::IR::HomeDescription (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
IR::HomeDescription_var::~HomeDescription_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE IR::HomeDescription_var &
IR::HomeDescription_var::operator= (HomeDescription *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::IR::HomeDescription_var &
IR::HomeDescription_var::operator= (const ::IR::HomeDescription_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HomeDescription *deep_copy =
            new HomeDescription (*p.ptr_);
          
          if (deep_copy != 0)
            {
              HomeDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::IR::HomeDescription *
IR::HomeDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDescription *
IR::HomeDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
IR::HomeDescription_var::operator const ::IR::HomeDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
IR::HomeDescription_var::operator ::IR::HomeDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
IR::HomeDescription_var::operator ::IR::HomeDescription &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
IR::HomeDescription_var::operator ::IR::HomeDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::IR::HomeDescription &
IR::HomeDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::IR::HomeDescription &
IR::HomeDescription_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::IR::HomeDescription *&
IR::HomeDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDescription *
IR::HomeDescription_var::_retn (void)
{
  ::IR::HomeDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::IR::HomeDescription *
IR::HomeDescription_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class IR::HomeDescription_out
// *************************************************************

ACE_INLINE
IR::HomeDescription_out::HomeDescription_out (::IR::HomeDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
IR::HomeDescription_out::HomeDescription_out (HomeDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
IR::HomeDescription_out::HomeDescription_out (const ::IR::HomeDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeDescription_out&, p).ptr_)
{}

ACE_INLINE IR::HomeDescription_out &
IR::HomeDescription_out::operator= (const ::IR::HomeDescription_out &p)
{
  this->ptr_ = ACE_const_cast (HomeDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE IR::HomeDescription_out &
IR::HomeDescription_out::operator= (HomeDescription *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
IR::HomeDescription_out::operator ::IR::HomeDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDescription *&
IR::HomeDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::IR::HomeDescription *
IR::HomeDescription_out::operator-> (void)
{
  return this->ptr_;
}


#if !defined _TAO_CDR_OP_IR_RepositoryIdSeq_I_
#define _TAO_CDR_OP_IR_RepositoryIdSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::RepositoryIdSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::RepositoryIdSeq &
  );

#endif /* _TAO_CDR_OP_IR_RepositoryIdSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ComponentDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ComponentDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_ComponentDefSeq_I_
#define _TAO_CDR_OP_IR_ComponentDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::ComponentDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::ComponentDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ComponentDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ProvidesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ProvidesDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_ProvidesDefSeq_I_
#define _TAO_CDR_OP_IR_ProvidesDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::ProvidesDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::ProvidesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ProvidesDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::UsesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::UsesDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_UsesDefSeq_I_
#define _TAO_CDR_OP_IR_UsesDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::UsesDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::UsesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_UsesDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::HomeDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::HomeDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_HomeDefSeq_I_
#define _TAO_CDR_OP_IR_HomeDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::HomeDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::HomeDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_HomeDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::EventDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::EventDef_ptr &
  );

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::EmitsDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::EmitsDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_EmitsDefSeq_I_
#define _TAO_CDR_OP_IR_EmitsDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::EmitsDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::EmitsDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_EmitsDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::PublishesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::PublishesDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_PublishesDefSeq_I_
#define _TAO_CDR_OP_IR_PublishesDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::PublishesDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::PublishesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_PublishesDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ConsumesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ConsumesDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_ConsumesDefSeq_I_
#define _TAO_CDR_OP_IR_ConsumesDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::ConsumesDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::ConsumesDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_ConsumesDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::FactoryDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::FactoryDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_FactoryDefSeq_I_
#define _TAO_CDR_OP_IR_FactoryDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::FactoryDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::FactoryDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_FactoryDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::FinderDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::FinderDef_ptr &
  );


#if !defined _TAO_CDR_OP_IR_FinderDefSeq_I_
#define _TAO_CDR_OP_IR_FinderDefSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::FinderDefSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::FinderDefSeq &
  );

#endif /* _TAO_CDR_OP_IR_FinderDefSeq_I_ */

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::PrimaryKeyDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::PrimaryKeyDef_ptr &
  );

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR::ComponentRepository_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR::ComponentRepository_ptr &
  );

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR::ProvidesDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.interface_type.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR::ProvidesDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.interface_type.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR::UsesDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.interface_type.in ()) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_multiple))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR::UsesDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.interface_type.out ()) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_multiple))
  )
    return 1;
  else
    return 0;
  
}


#if !defined _TAO_CDR_OP_IR_ProvidesDescSeq_I_
#define _TAO_CDR_OP_IR_ProvidesDescSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::ProvidesDescSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::ProvidesDescSeq &
  );

#endif /* _TAO_CDR_OP_IR_ProvidesDescSeq_I_ */


#if !defined _TAO_CDR_OP_IR_UsesDescSeq_I_
#define _TAO_CDR_OP_IR_UsesDescSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const IR::UsesDescSeq &
  );
CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    IR::UsesDescSeq &
  );

#endif /* _TAO_CDR_OP_IR_UsesDescSeq_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR::EventDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.value.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR::EventDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.value.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR::ComponentDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.base_component.in ()) &&
    (strm << _tao_aggregate.supports_interfaces) &&
    (strm << _tao_aggregate.provides_interfaces) &&
    (strm << _tao_aggregate.uses_interfaces) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << _tao_aggregate.emits_events) &&
    (strm << _tao_aggregate.publishes_events) &&
    (strm << _tao_aggregate.consumes_events) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR::ComponentDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.base_component.out ()) &&
    (strm >> _tao_aggregate.supports_interfaces) &&
    (strm >> _tao_aggregate.provides_interfaces) &&
    (strm >> _tao_aggregate.uses_interfaces) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> _tao_aggregate.emits_events) &&
    (strm >> _tao_aggregate.publishes_events) &&
    (strm >> _tao_aggregate.consumes_events) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR::PrimaryKeyDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.primary_key.in ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR::PrimaryKeyDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.primary_key.out ())
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const IR::HomeDescription &_tao_aggregate)
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.base_home.in ()) &&
    (strm << _tao_aggregate.managed_component.in ()) &&
    (strm << _tao_aggregate.primary_key_def.in ()) &&
    (strm << _tao_aggregate.factories) &&
    (strm << _tao_aggregate.finders) &&
    (strm << _tao_aggregate.operations) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, IR::HomeDescription &_tao_aggregate)
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.base_home.out ()) &&
    (strm >> _tao_aggregate.managed_component.out ()) &&
    (strm >> _tao_aggregate.primary_key_def.out ()) &&
    (strm >> _tao_aggregate.factories) &&
    (strm >> _tao_aggregate.finders) &&
    (strm >> _tao_aggregate.operations) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_basic))
  )
    return 1;
  else
    return 0;
  
}

