/* -*- C++ -*- $Id$ */

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "DynamicAny.h"

#if !defined (__ACE_INLINE__)
#include "DynamicAnyC.i"
#endif /* !defined INLINE */


// default constructor
DynamicAny::DynAny::DynAny ()
{}

// destructor
DynamicAny::DynAny::~DynAny (void)
{}

DynamicAny::DynAny_ptr DynamicAny::DynAny::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynAny::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynAny_ptr DynamicAny::DynAny::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynAny::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynAny_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynAny::_narrow
                  )
              )
        );
}

DynamicAny::DynAny_ptr
DynamicAny::DynAny::_duplicate (DynAny_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynAny::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynAny::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynAny:1.0";
}

// Default constructor.
DynamicAny::DynAny::InvalidValue::InvalidValue (void)
  : CORBA_UserException ("IDL:DynamicAny/DynAny/InvalidValue:1.0")
{
}

// Destructor - all members are of self managing types.
DynamicAny::DynAny::InvalidValue::~InvalidValue (void)
{
}

// Copy constructor.
DynamicAny::DynAny::InvalidValue::InvalidValue (const ::DynamicAny::DynAny::InvalidValue &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
DynamicAny::DynAny::InvalidValue&
DynamicAny::DynAny::InvalidValue::operator= (const ::DynamicAny::DynAny::InvalidValue &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
DynamicAny::DynAny::InvalidValue *
DynamicAny::DynAny::InvalidValue::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:DynamicAny/DynAny/InvalidValue:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (InvalidValue *, exc);
    }
  else
    {
      return 0;
    }
}

void DynamicAny::DynAny::InvalidValue::_raise ()
{
  TAO_RAISE (*this);
}

void DynamicAny::DynAny::InvalidValue::_tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void DynamicAny::DynAny::InvalidValue::_tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *DynamicAny::DynAny::InvalidValue::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::DynAny::InvalidValue, 0);
  return retval;
}

// Default constructor.
DynamicAny::DynAny::TypeMismatch::TypeMismatch (void)
  : CORBA_UserException ("IDL:DynamicAny/DynAny/TypeMismatch:1.0")
{
}

// Destructor - all members are of self managing types.
DynamicAny::DynAny::TypeMismatch::~TypeMismatch (void)
{
}

// Copy constructor.
DynamicAny::DynAny::TypeMismatch::TypeMismatch (const ::DynamicAny::DynAny::TypeMismatch &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
DynamicAny::DynAny::TypeMismatch&
DynamicAny::DynAny::TypeMismatch::operator= (const ::DynamicAny::DynAny::TypeMismatch &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
DynamicAny::DynAny::TypeMismatch *
DynamicAny::DynAny::TypeMismatch::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:DynamicAny/DynAny/TypeMismatch:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (TypeMismatch *, exc);
    }
  else
    {
      return 0;
    }
}

void DynamicAny::DynAny::TypeMismatch::_raise ()
{
  TAO_RAISE (*this);
}

void DynamicAny::DynAny::TypeMismatch::_tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void DynamicAny::DynAny::TypeMismatch::_tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *DynamicAny::DynAny::TypeMismatch::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::DynAny::TypeMismatch, 0);
  return retval;
}


// default constructor
DynamicAny::DynFixed::DynFixed ()
{}

// destructor
DynamicAny::DynFixed::~DynFixed (void)
{}

DynamicAny::DynFixed_ptr DynamicAny::DynFixed::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynFixed::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynFixed_ptr DynamicAny::DynFixed::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynFixed::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynFixed_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynFixed::_narrow
                  )
              )
        );
}

DynamicAny::DynFixed_ptr
DynamicAny::DynFixed::_duplicate (DynFixed_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynFixed::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynFixed)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynFixed::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynFixed:1.0";
}


// default constructor
DynamicAny::DynEnum::DynEnum ()
{}

// destructor
DynamicAny::DynEnum::~DynEnum (void)
{}

DynamicAny::DynEnum_ptr DynamicAny::DynEnum::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynEnum::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynEnum_ptr DynamicAny::DynEnum::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynEnum::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynEnum_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynEnum::_narrow
                  )
              )
        );
}

DynamicAny::DynEnum_ptr
DynamicAny::DynEnum::_duplicate (DynEnum_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynEnum::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynEnum)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynEnum::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynEnum:1.0";
}

static const CORBA::Long _oc_DynamicAny_FieldName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f46), ACE_NTOHL (0x69656c64), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:DynamicAny/FieldName:1.0
  10, ACE_NTOHL (0x4669656c), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x65000000),  // name = FieldName
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_DynamicAny_FieldName (CORBA::tk_alias, sizeof (_oc_DynamicAny_FieldName), (char *) &_oc_DynamicAny_FieldName, 0, sizeof (DynamicAny::FieldName));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (DynamicAny)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FieldName, &_tc_TAO_tc_DynamicAny_FieldName)
TAO_NAMESPACE_END
static const CORBA::Long _oc_DynamicAny_NameValuePair[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f4e), ACE_NTOHL (0x616d6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x50616972), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:DynamicAny/NameValuePair:1.0
  14, ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65506169), ACE_NTOHL (0x72000000),  // name = NameValuePair
  2, // member count
  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f46), ACE_NTOHL (0x69656c64), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:DynamicAny/FieldName:1.0
    10, ACE_NTOHL (0x4669656c), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x65000000),  // name = FieldName
    CORBA::tk_string, 
    0U, // string length

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_DynamicAny_NameValuePair (CORBA::tk_struct, sizeof (_oc_DynamicAny_NameValuePair), (char *) &_oc_DynamicAny_NameValuePair, 0, sizeof (DynamicAny::NameValuePair));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (DynamicAny)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NameValuePair, &_tc_TAO_tc_DynamicAny_NameValuePair)
TAO_NAMESPACE_END
void DynamicAny::NameValuePair::_tao_any_destructor (void *x)
{
  NameValuePair *tmp = ACE_static_cast (NameValuePair*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEVALUEPAIRSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEVALUEPAIRSEQ_CS_

  void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::_allocate_buffer (CORBA::ULong length)
  {
    DynamicAny::NameValuePair* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      DynamicAny::NameValuePair *old = ACE_reinterpret_cast (DynamicAny::NameValuePair *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    DynamicAny::NameValuePair *tmp = ACE_reinterpret_cast (DynamicAny::NameValuePair *,this->buffer_);
    
    _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq::~_TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_NAMEVALUEPAIRSEQ_CS_)
#define _DYNAMICANY_NAMEVALUEPAIRSEQ_CS_

// *************************************************************
// DynamicAny::NameValuePairSeq
// *************************************************************

DynamicAny::NameValuePairSeq::NameValuePairSeq (void)
{}
DynamicAny::NameValuePairSeq::NameValuePairSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<DynamicAny::NameValuePair>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
DynamicAny::NameValuePairSeq::NameValuePairSeq (CORBA::ULong max, CORBA::ULong length, DynamicAny::NameValuePair *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<DynamicAny::NameValuePair>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
DynamicAny::NameValuePairSeq::NameValuePairSeq (const NameValuePairSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_NameValuePairSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<DynamicAny::NameValuePair>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
DynamicAny::NameValuePairSeq::~NameValuePairSeq (void) // dtor
{}
void DynamicAny::NameValuePairSeq::_tao_any_destructor (void *x)
{
  NameValuePairSeq *tmp = ACE_static_cast (NameValuePairSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_DynamicAny_NameValuePairSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f4e), ACE_NTOHL (0x616d6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x50616972), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:DynamicAny/NameValuePairSeq:1.0
  17, ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65506169), ACE_NTOHL (0x72536571), ACE_NTOHL (0x0),  // name = NameValuePairSeq
  CORBA::tk_sequence, // typecode kind
  180, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    164, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f4e), ACE_NTOHL (0x616d6556), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x50616972), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:DynamicAny/NameValuePair:1.0
      14, ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65506169), ACE_NTOHL (0x72000000),  // name = NameValuePair
      2, // member count
      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f46), ACE_NTOHL (0x69656c64), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:DynamicAny/FieldName:1.0
        10, ACE_NTOHL (0x4669656c), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x65000000),  // name = FieldName
        CORBA::tk_string, 
        0U, // string length

      6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_DynamicAny_NameValuePairSeq (CORBA::tk_alias, sizeof (_oc_DynamicAny_NameValuePairSeq), (char *) &_oc_DynamicAny_NameValuePairSeq, 0, sizeof (DynamicAny::NameValuePairSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (DynamicAny)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NameValuePairSeq, &_tc_TAO_tc_DynamicAny_NameValuePairSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEDYNANYPAIRSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_NAMEDYNANYPAIRSEQ_CS_

  void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::_allocate_buffer (CORBA::ULong length)
  {
    DynamicAny::NameDynAnyPair* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      DynamicAny::NameDynAnyPair *old = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    DynamicAny::NameDynAnyPair *tmp = ACE_reinterpret_cast (DynamicAny::NameDynAnyPair *,this->buffer_);
    
    _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq::~_TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_NAMEDYNANYPAIRSEQ_CS_)
#define _DYNAMICANY_NAMEDYNANYPAIRSEQ_CS_

// *************************************************************
// DynamicAny::NameDynAnyPairSeq
// *************************************************************

DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (void)
{}
DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<DynamicAny::NameDynAnyPair>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (CORBA::ULong max, CORBA::ULong length, DynamicAny::NameDynAnyPair *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<DynamicAny::NameDynAnyPair>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
DynamicAny::NameDynAnyPairSeq::NameDynAnyPairSeq (const NameDynAnyPairSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_NameDynAnyPairSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<DynamicAny::NameDynAnyPair>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
DynamicAny::NameDynAnyPairSeq::~NameDynAnyPairSeq (void) // dtor
{}
void DynamicAny::NameDynAnyPairSeq::_tao_any_destructor (void *x)
{
  NameDynAnyPairSeq *tmp = ACE_static_cast (NameDynAnyPairSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */


// default constructor
DynamicAny::DynStruct::DynStruct ()
{}

// destructor
DynamicAny::DynStruct::~DynStruct (void)
{}

DynamicAny::DynStruct_ptr DynamicAny::DynStruct::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynStruct::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynStruct_ptr DynamicAny::DynStruct::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynStruct::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynStruct_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynStruct::_narrow
                  )
              )
        );
}

DynamicAny::DynStruct_ptr
DynamicAny::DynStruct::_duplicate (DynStruct_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynStruct::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynStruct)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynStruct::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynStruct:1.0";
}


// default constructor
DynamicAny::DynUnion::DynUnion ()
{}

// destructor
DynamicAny::DynUnion::~DynUnion (void)
{}

DynamicAny::DynUnion_ptr DynamicAny::DynUnion::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynUnion::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynUnion_ptr DynamicAny::DynUnion::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynUnion::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynUnion_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynUnion::_narrow
                  )
              )
        );
}

DynamicAny::DynUnion_ptr
DynamicAny::DynUnion::_duplicate (DynUnion_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynUnion::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynUnion)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynUnion::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynUnion:1.0";
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_ANYSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_DYNAMICANY_ANYSEQ_CS_

  void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::Any* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_DynamicAny_AnySeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::Any *old = ACE_reinterpret_cast (CORBA::Any *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_DynamicAny_AnySeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::Any *tmp = ACE_reinterpret_cast (CORBA::Any *,this->buffer_);
    
    _TAO_Unbounded_Sequence_DynamicAny_AnySeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  DynamicAny::_TAO_Unbounded_Sequence_DynamicAny_AnySeq::~_TAO_Unbounded_Sequence_DynamicAny_AnySeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_ANYSEQ_CS_)
#define _DYNAMICANY_ANYSEQ_CS_

// *************************************************************
// DynamicAny::AnySeq
// *************************************************************

DynamicAny::AnySeq::AnySeq (void)
{}
DynamicAny::AnySeq::AnySeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_AnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
DynamicAny::AnySeq::AnySeq (CORBA::ULong max, CORBA::ULong length, CORBA::Any *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_AnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
DynamicAny::AnySeq::AnySeq (const AnySeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_DynamicAny_AnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
DynamicAny::AnySeq::~AnySeq (void) // dtor
{}
void DynamicAny::AnySeq::_tao_any_destructor (void *x)
{
  AnySeq *tmp = ACE_static_cast (AnySeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_DynamicAny_AnySeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  26, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x44796e61), ACE_NTOHL (0x6d696341), ACE_NTOHL (0x6e792f41), ACE_NTOHL (0x6e795365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:DynamicAny/AnySeq:1.0
  7, ACE_NTOHL (0x416e7953), ACE_NTOHL (0x65710000),  // name = AnySeq
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_any,

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_DynamicAny_AnySeq (CORBA::tk_alias, sizeof (_oc_DynamicAny_AnySeq), (char *) &_oc_DynamicAny_AnySeq, 0, sizeof (DynamicAny::AnySeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (DynamicAny)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AnySeq, &_tc_TAO_tc_DynamicAny_AnySeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_DYNAMICANY_DYNANYSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_DYNAMICANY_DYNANYSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_allocate_buffer (CORBA::ULong length)
  {
    DynamicAny::DynAny **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      DynamicAny::DynAny **old = ACE_reinterpret_cast (DynamicAny::DynAny**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = DynamicAny::DynAny::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    DynamicAny::DynAny **tmp = ACE_reinterpret_cast (DynamicAny::DynAny**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = DynamicAny::DynAny::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::~_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    DynamicAny::DynAny **tmp = ACE_reinterpret_cast (DynamicAny::DynAny**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = DynamicAny::DynAny::_nil ();
    }
  }
  void 
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    DynamicAny::DynAny **tmp = ACE_static_cast (DynamicAny::DynAny**, target);
    *tmp = DynamicAny::DynAny::_narrow (src, ACE_TRY_ENV);
    ACE_CHECK;
  }

  CORBA_Object*
  DynamicAny::_TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq::_upcast (void *src) const
  {
    DynamicAny::DynAny **tmp = ACE_static_cast (DynamicAny::DynAny**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_DYNAMICANY_DYNANYSEQ_CS_)
#define _DYNAMICANY_DYNANYSEQ_CS_

// *************************************************************
// DynamicAny::DynAnySeq
// *************************************************************

DynamicAny::DynAnySeq::DynAnySeq (void)
{}
DynamicAny::DynAnySeq::DynAnySeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<DynamicAny::DynAny,DynamicAny::DynAny_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
DynamicAny::DynAnySeq::DynAnySeq (CORBA::ULong max, CORBA::ULong length, DynamicAny::DynAny_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<DynamicAny::DynAny,DynamicAny::DynAny_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
DynamicAny::DynAnySeq::DynAnySeq (const DynAnySeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_DynamicAny_DynAnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<DynamicAny::DynAny,DynamicAny::DynAny_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
DynamicAny::DynAnySeq::~DynAnySeq (void) // dtor
{}
void DynamicAny::DynAnySeq::_tao_any_destructor (void *x)
{
  DynAnySeq *tmp = ACE_static_cast (DynAnySeq*,x);
  delete tmp;
}


#endif /* end #if !defined */


// default constructor
DynamicAny::DynSequence::DynSequence ()
{}

// destructor
DynamicAny::DynSequence::~DynSequence (void)
{}

DynamicAny::DynSequence_ptr DynamicAny::DynSequence::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynSequence::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynSequence_ptr DynamicAny::DynSequence::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynSequence::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynSequence_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynSequence::_narrow
                  )
              )
        );
}

DynamicAny::DynSequence_ptr
DynamicAny::DynSequence::_duplicate (DynSequence_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynSequence::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynSequence)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynSequence::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynSequence:1.0";
}


// default constructor
DynamicAny::DynArray::DynArray ()
{}

// destructor
DynamicAny::DynArray::~DynArray (void)
{}

DynamicAny::DynArray_ptr DynamicAny::DynArray::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynArray::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynArray_ptr DynamicAny::DynArray::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynArray::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynArray_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynArray::_narrow
                  )
              )
        );
}

DynamicAny::DynArray_ptr
DynamicAny::DynArray::_duplicate (DynArray_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynArray::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynArray)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynArray::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynArray:1.0";
}


// default constructor
DynamicAny::DynValue::DynValue ()
{}

// destructor
DynamicAny::DynValue::~DynValue (void)
{}

DynamicAny::DynValue_ptr DynamicAny::DynValue::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynValue::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynValue_ptr DynamicAny::DynValue::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynValue::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynValue_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynValue::_narrow
                  )
              )
        );
}

DynamicAny::DynValue_ptr
DynamicAny::DynValue::_duplicate (DynValue_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynValue::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynValue)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAny)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            DynamicAny::DynAny_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynValue::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynValue:1.0";
}


// default constructor
DynamicAny::DynAnyFactory::DynAnyFactory ()
{}

// destructor
DynamicAny::DynAnyFactory::~DynAnyFactory (void)
{}

DynamicAny::DynAnyFactory_ptr DynamicAny::DynAnyFactory::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return DynAnyFactory::_unchecked_narrow (obj, ACE_TRY_ENV);
}

DynamicAny::DynAnyFactory_ptr DynamicAny::DynAnyFactory::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return DynAnyFactory::_nil ();
  return
      ACE_reinterpret_cast
        (
          DynAnyFactory_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &DynAnyFactory::_narrow
                  )
              )
        );
}

DynamicAny::DynAnyFactory_ptr
DynamicAny::DynAnyFactory::_duplicate (DynAnyFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *DynamicAny::DynAnyFactory::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::DynamicAny, DynAnyFactory)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* DynamicAny::DynAnyFactory::_interface_repository_id (void) const
{
  return "IDL:DynamicAny/DynAnyFactory:1.0";
}

// Default constructor.
DynamicAny::DynAnyFactory::InconsistentTypeCode::InconsistentTypeCode (void)
  : CORBA_UserException ("IDL:DynamicAny/DynAnyFactory/InconsistentTypeCode:1.0")
{
}

// Destructor - all members are of self managing types.
DynamicAny::DynAnyFactory::InconsistentTypeCode::~InconsistentTypeCode (void)
{
}

// Copy constructor.
DynamicAny::DynAnyFactory::InconsistentTypeCode::InconsistentTypeCode (const ::DynamicAny::DynAnyFactory::InconsistentTypeCode &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
DynamicAny::DynAnyFactory::InconsistentTypeCode&
DynamicAny::DynAnyFactory::InconsistentTypeCode::operator= (const ::DynamicAny::DynAnyFactory::InconsistentTypeCode &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
DynamicAny::DynAnyFactory::InconsistentTypeCode *
DynamicAny::DynAnyFactory::InconsistentTypeCode::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:DynamicAny/DynAnyFactory/InconsistentTypeCode:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (InconsistentTypeCode *, exc);
    }
  else
    {
      return 0;
    }
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_raise ()
{
  TAO_RAISE (*this);
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void DynamicAny::DynAnyFactory::InconsistentTypeCode::_tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *DynamicAny::DynAnyFactory::InconsistentTypeCode::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::DynamicAny::DynAnyFactory::InconsistentTypeCode, 0);
  return retval;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynAny,DynamicAny::DynAny_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynAny,DynamicAny::DynAny_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynFixed,DynamicAny::DynFixed_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynFixed,DynamicAny::DynFixed_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynEnum,DynamicAny::DynEnum_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynEnum,DynamicAny::DynEnum_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const DynamicAny::NameValuePair &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      DynamicAny::_tc_NameValuePair,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, DynamicAny::NameValuePair *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      DynamicAny::_tc_NameValuePair,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      DynamicAny::NameValuePair::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, DynamicAny::NameValuePair *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const DynamicAny::NameValuePair*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const DynamicAny::NameValuePair *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = 
      type->equivalent (DynamicAny::_tc_NameValuePair, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const DynamicAny::NameValuePair*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      DynamicAny::NameValuePair *tmp;
      ACE_NEW_RETURN (tmp, DynamicAny::NameValuePair, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            DynamicAny::_tc_NameValuePair,
            1,
            ACE_static_cast (void *, tmp),
            DynamicAny::NameValuePair::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const DynamicAny::NameValuePairSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        DynamicAny::_tc_NameValuePairSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, DynamicAny::NameValuePairSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      DynamicAny::_tc_NameValuePairSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      DynamicAny::NameValuePairSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, DynamicAny::NameValuePairSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const DynamicAny::NameValuePairSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const DynamicAny::NameValuePairSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = 
      type->equivalent (DynamicAny::_tc_NameValuePairSeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const DynamicAny::NameValuePairSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      DynamicAny::NameValuePairSeq *tmp;
      ACE_NEW_RETURN (tmp, DynamicAny::NameValuePairSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            DynamicAny::_tc_NameValuePairSeq,
            1,
            ACE_static_cast (void *, tmp),
            DynamicAny::NameValuePairSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynStruct,DynamicAny::DynStruct_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynStruct,DynamicAny::DynStruct_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynUnion,DynamicAny::DynUnion_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynUnion,DynamicAny::DynUnion_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (
    CORBA::Any &_tao_any,
    const DynamicAny::AnySeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        DynamicAny::_tc_AnySeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, DynamicAny::AnySeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      DynamicAny::_tc_AnySeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      DynamicAny::AnySeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, DynamicAny::AnySeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const DynamicAny::AnySeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const DynamicAny::AnySeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();

    CORBA::Boolean result = 
      type->equivalent (DynamicAny::_tc_AnySeq, ACE_TRY_ENV);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const DynamicAny::AnySeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      DynamicAny::AnySeq *tmp;
      ACE_NEW_RETURN (tmp, DynamicAny::AnySeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            DynamicAny::_tc_AnySeq,
            1,
            ACE_static_cast (void *, tmp),
            DynamicAny::AnySeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynSequence,DynamicAny::DynSequence_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynSequence,DynamicAny::DynSequence_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynArray,DynamicAny::DynArray_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynArray,DynamicAny::DynArray_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynValue,DynamicAny::DynValue_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynValue,DynamicAny::DynValue_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<DynamicAny::DynAnyFactory,DynamicAny::DynAnyFactory_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<DynamicAny::DynAnyFactory,DynamicAny::DynAnyFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DynamicAny::NameValuePairSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DynamicAny::NameValuePairSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DynamicAny::AnySeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DynamicAny::AnySeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

