// $Id$
//
// ============================================================================
//
// = LIBRARY
//    TAO
//
// = FILENAME
//    POAC.h
//
// = DESCRIPTION
//
//    POA stubs. This code generated by the The ACE ORB (TAO) IDL
//    Compiler and is not meant to be read.
//
// ============================================================================

#ifndef TAO_IDL_POAC_H
#define TAO_IDL_POAC_H

#include "tao/PolicyC.h"
#include "tao/CurrentC.h"
#include "tao/Exception.h"

class TAO_ServantBase;
class TAO_Local_ServantBase;
class TAO_DynamicImplementation;

class TAO_Export PortableServer{
public:

  typedef TAO_ServantBase ServantBase;
  typedef ServantBase *Servant;

  typedef TAO_Local_ServantBase LocalServantBase;
  typedef TAO_DynamicImplementation DynamicImplementation;


  class POA;

#if !defined (_PORTABLESERVER_POA___PTR_CH_)
#define _PORTABLESERVER_POA___PTR_CH_

  typedef POA *POA_ptr;

#endif /* end #if !defined */


#if !defined (_PORTABLESERVER_POA___VAR_CH_)
#define _PORTABLESERVER_POA___VAR_CH_

  class TAO_Export POA_var
  {
  public:
    POA_var (void); // default constructor
    POA_var (POA_ptr);
    POA_var (const POA_var &); // copy constructor
    ~POA_var (void); // destructor

    POA_var &operator= (POA_ptr);
    POA_var &operator= (const POA_var &);
    POA_ptr operator-> (void) const;

    operator const POA_ptr &() const;
    operator POA_ptr &();
    // in, inout, out, _retn
    POA_ptr in (void) const;
    POA_ptr &inout (void);
    POA_ptr &out (void);
    POA_ptr _retn (void);
    POA_ptr ptr (void) const;

  private:
    POA_ptr ptr_;
  };


#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA___OUT_CH_)
#define _PORTABLESERVER_POA___OUT_CH_

  class TAO_Export POA_out
  {
  public:
    POA_out (POA_ptr &);
    POA_out (POA_var &);
    POA_out (const POA_out &);
    POA_out &operator= (POA_out &);
    POA_out &operator= (const POA_var &);
    POA_out &operator= (POA_ptr);
    operator POA_ptr &();
    POA_ptr &ptr (void);
    POA_ptr operator-> (void);

  private:
    POA_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET_CH_)
#define _PORTABLESERVER__TAO_SEQ_OCTET_CH_

  // *************************************************************
  // _tao_seq_Octet
  // *************************************************************

  typedef TAO_Unbounded_Sequence<CORBA::Octet > _tao_seq_Octet;
  typedef _tao_seq_Octet* _tao_seq_Octet_ptr;
  static CORBA::TypeCode_ptr _tc__tao_seq_Octet;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET___VAR_CH_)
#define _PORTABLESERVER__TAO_SEQ_OCTET___VAR_CH_

  // *************************************************************
  // class PortableServer::_tao_seq_Octet_var
  // *************************************************************

  class TAO_Export _tao_seq_Octet_var
  {
  public:
    _tao_seq_Octet_var (void); // default constructor
    _tao_seq_Octet_var (_tao_seq_Octet *);
    _tao_seq_Octet_var (const _tao_seq_Octet_var &); // copy constructor
    ~_tao_seq_Octet_var (void); // destructor

    _tao_seq_Octet_var &operator= (_tao_seq_Octet *);
    _tao_seq_Octet_var &operator= (const _tao_seq_Octet_var &);
    _tao_seq_Octet *operator-> (void);
    const _tao_seq_Octet *operator-> (void) const;

    operator const _tao_seq_Octet &() const;
    operator _tao_seq_Octet &();
    operator _tao_seq_Octet &() const;
    CORBA::Octet &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const _tao_seq_Octet &in (void) const;
    _tao_seq_Octet &inout (void);
    _tao_seq_Octet *&out (void);
    _tao_seq_Octet *_retn (void);
    _tao_seq_Octet *ptr (void) const;

  private:
    _tao_seq_Octet *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET___OUT_CH_)
#define _PORTABLESERVER__TAO_SEQ_OCTET___OUT_CH_

  class TAO_Export _tao_seq_Octet_out
  {
  public:
    _tao_seq_Octet_out (_tao_seq_Octet *&);
    _tao_seq_Octet_out (_tao_seq_Octet_var &);
    _tao_seq_Octet_out (const _tao_seq_Octet_out &);
    _tao_seq_Octet_out &operator= (_tao_seq_Octet_out &);
    _tao_seq_Octet_out &operator= (_tao_seq_Octet *);
    operator _tao_seq_Octet *&();
    _tao_seq_Octet *&ptr (void);
    _tao_seq_Octet *operator-> (void);
    CORBA::Octet &operator[] (CORBA::ULong index);

  private:
    _tao_seq_Octet *&ptr_;
    // assignment from T_var not allowed
    void operator= (const _tao_seq_Octet_var &);
  };

#endif /* end #if !defined */

  typedef _tao_seq_Octet ObjectId;
  typedef _tao_seq_Octet_var ObjectId_var;
  typedef _tao_seq_Octet_out ObjectId_out;

  static CORBA::TypeCode_ptr _tc_ObjectId;


#if !defined (_PORTABLESERVER_FORWARDREQUEST___PTR_CH_)
#define _PORTABLESERVER_FORWARDREQUEST___PTR_CH_

  class ForwardRequest;
  typedef ForwardRequest *ForwardRequest_ptr;

#endif /* end #if !defined */


#if !defined (_PORTABLESERVER_FORWARDREQUEST_CH_)
#define _PORTABLESERVER_FORWARDREQUEST_CH_

  class TAO_Export ForwardRequest : public CORBA_UserException
  {
  public:
    ForwardRequest (void); // default ctor
    ForwardRequest (const ForwardRequest &); // copy ctor
    ~ForwardRequest (void); // dtor
    ForwardRequest &operator= (const ForwardRequest &);
    virtual void _raise (void);

    static ForwardRequest *_narrow (CORBA::Exception *);

    ForwardRequest(
        const CORBA::Object_ptr  _tao_forward_reference
      );

    CORBA::Object_var forward_reference;

    // = TAO extension
    static CORBA::Exception *_alloc (void);

#if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
  typedef ForwardRequest_ptr _ptr_type;
#endif /* __GNUC__ */
  // Useful for template programming.

  }; // exception PortableServer::ForwardRequest

  friend void operator<<= (CORBA::Any &, const ForwardRequest &); // copying version
  friend void operator<<= (CORBA::Any &, ForwardRequest*); // noncopying version
  friend CORBA::Boolean operator>>= (const CORBA::Any &, ForwardRequest *&);
  static CORBA::TypeCode_ptr _tc_ForwardRequest;


#endif /* end #if !defined */

  enum ThreadPolicyValue
  {
    ORB_CTRL_MODEL,
    SINGLE_THREAD_MODEL
  };

#if !defined (TAO_HAS_MINIMUM_CORBA)

  typedef ThreadPolicyValue &ThreadPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_ThreadPolicyValue;


#if !defined (_PORTABLESERVER_THREADPOLICY___PTR_CH_)
#define _PORTABLESERVER_THREADPOLICY___PTR_CH_

  class ThreadPolicy;
  typedef ThreadPolicy *ThreadPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_THREADPOLICY___VAR_CH_)
#define _PORTABLESERVER_THREADPOLICY___VAR_CH_

  class TAO_Export ThreadPolicy_var
  {
  public:
    ThreadPolicy_var (void); // default constructor
    ThreadPolicy_var (ThreadPolicy_ptr);
    ThreadPolicy_var (const ThreadPolicy_var &); // copy constructor
    ~ThreadPolicy_var (void); // destructor

    ThreadPolicy_var &operator= (ThreadPolicy_ptr);
    ThreadPolicy_var &operator= (const ThreadPolicy_var &);
    ThreadPolicy_ptr operator-> (void) const;

    operator const ThreadPolicy_ptr &() const;
    operator ThreadPolicy_ptr &();
    // in, inout, out, _retn
    ThreadPolicy_ptr in (void) const;
    ThreadPolicy_ptr &inout (void);
    ThreadPolicy_ptr &out (void);
    ThreadPolicy_ptr _retn (void);
    ThreadPolicy_ptr ptr (void) const;

  private:
    ThreadPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_THREADPOLICY___OUT_CH_)
#define _PORTABLESERVER_THREADPOLICY___OUT_CH_

  class TAO_Export ThreadPolicy_out
  {
  public:
    ThreadPolicy_out (ThreadPolicy_ptr &);
    ThreadPolicy_out (ThreadPolicy_var &);
    ThreadPolicy_out (const ThreadPolicy_out &);
    ThreadPolicy_out &operator= (ThreadPolicy_out &);
    ThreadPolicy_out &operator= (const ThreadPolicy_var &);
    ThreadPolicy_out &operator= (ThreadPolicy_ptr);
    operator ThreadPolicy_ptr &();
    ThreadPolicy_ptr &ptr (void);
    ThreadPolicy_ptr operator-> (void);

  private:
    ThreadPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_THREADPOLICY_CH_)
#define _PORTABLESERVER_THREADPOLICY_CH_

  class TAO_Export ThreadPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ThreadPolicy_ptr _ptr_type;
    typedef ThreadPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ThreadPolicy_ptr _duplicate (ThreadPolicy_ptr obj);
    static ThreadPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static ThreadPolicy_ptr _nil (void);

    virtual ThreadPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    ThreadPolicy (TAO_Stub *objref = 0,
                  TAO_ServantBase *servant = 0,
                  CORBA::Boolean collocated = 0);
  public:
    virtual ~ThreadPolicy (void);
  private:
    ThreadPolicy (const ThreadPolicy&);
    void operator= (const ThreadPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_ThreadPolicy;

#endif /* TAO_HAS_MINIMUM_CORBA */

  enum LifespanPolicyValue
  {
    TRANSIENT,
    PERSISTENT
  };
  typedef LifespanPolicyValue &LifespanPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_LifespanPolicyValue;


#if !defined (_PORTABLESERVER_LIFESPANPOLICY___PTR_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY___PTR_CH_

  class LifespanPolicy;
  typedef LifespanPolicy *LifespanPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_LIFESPANPOLICY___VAR_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY___VAR_CH_

  class TAO_Export LifespanPolicy_var
  {
  public:
    LifespanPolicy_var (void); // default constructor
    LifespanPolicy_var (LifespanPolicy_ptr);
    LifespanPolicy_var (const LifespanPolicy_var &); // copy constructor
    ~LifespanPolicy_var (void); // destructor

    LifespanPolicy_var &operator= (LifespanPolicy_ptr);
    LifespanPolicy_var &operator= (const LifespanPolicy_var &);
    LifespanPolicy_ptr operator-> (void) const;

    operator const LifespanPolicy_ptr &() const;
    operator LifespanPolicy_ptr &();
    // in, inout, out, _retn
    LifespanPolicy_ptr in (void) const;
    LifespanPolicy_ptr &inout (void);
    LifespanPolicy_ptr &out (void);
    LifespanPolicy_ptr _retn (void);
    LifespanPolicy_ptr ptr (void) const;

  private:
    LifespanPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_LIFESPANPOLICY___OUT_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY___OUT_CH_

  class TAO_Export LifespanPolicy_out
  {
  public:
    LifespanPolicy_out (LifespanPolicy_ptr &);
    LifespanPolicy_out (LifespanPolicy_var &);
    LifespanPolicy_out (const LifespanPolicy_out &);
    LifespanPolicy_out &operator= (LifespanPolicy_out &);
    LifespanPolicy_out &operator= (const LifespanPolicy_var &);
    LifespanPolicy_out &operator= (LifespanPolicy_ptr);
    operator LifespanPolicy_ptr &();
    LifespanPolicy_ptr &ptr (void);
    LifespanPolicy_ptr operator-> (void);

  private:
    LifespanPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_LIFESPANPOLICY_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY_CH_

  class TAO_Export LifespanPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef LifespanPolicy_ptr _ptr_type;
    typedef LifespanPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static LifespanPolicy_ptr _duplicate (LifespanPolicy_ptr obj);
    static LifespanPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static LifespanPolicy_ptr _nil (void);

    virtual LifespanPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    LifespanPolicy (
                    TAO_Stub *objref = 0,
                    TAO_ServantBase *servant = 0,
                    CORBA::Boolean collocated = 0
                    );
  public:
    virtual ~LifespanPolicy (void);
  private:
    LifespanPolicy (const LifespanPolicy&);
    void operator= (const LifespanPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_LifespanPolicy;

  enum IdUniquenessPolicyValue
  {
    UNIQUE_ID,
    MULTIPLE_ID
  };
  typedef IdUniquenessPolicyValue &IdUniquenessPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_IdUniquenessPolicyValue;


#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___PTR_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___PTR_CH_

  class IdUniquenessPolicy;
  typedef IdUniquenessPolicy *IdUniquenessPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___VAR_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___VAR_CH_

  class TAO_Export IdUniquenessPolicy_var
  {
  public:
    IdUniquenessPolicy_var (void); // default constructor
    IdUniquenessPolicy_var (IdUniquenessPolicy_ptr);
    IdUniquenessPolicy_var (const IdUniquenessPolicy_var &); // copy constructor
    ~IdUniquenessPolicy_var (void); // destructor

    IdUniquenessPolicy_var &operator= (IdUniquenessPolicy_ptr);
    IdUniquenessPolicy_var &operator= (const IdUniquenessPolicy_var &);
    IdUniquenessPolicy_ptr operator-> (void) const;

    operator const IdUniquenessPolicy_ptr &() const;
    operator IdUniquenessPolicy_ptr &();
    // in, inout, out, _retn
    IdUniquenessPolicy_ptr in (void) const;
    IdUniquenessPolicy_ptr &inout (void);
    IdUniquenessPolicy_ptr &out (void);
    IdUniquenessPolicy_ptr _retn (void);
    IdUniquenessPolicy_ptr ptr (void) const;

  private:
    IdUniquenessPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___OUT_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___OUT_CH_

  class TAO_Export IdUniquenessPolicy_out
  {
  public:
    IdUniquenessPolicy_out (IdUniquenessPolicy_ptr &);
    IdUniquenessPolicy_out (IdUniquenessPolicy_var &);
    IdUniquenessPolicy_out (const IdUniquenessPolicy_out &);
    IdUniquenessPolicy_out &operator= (IdUniquenessPolicy_out &);
    IdUniquenessPolicy_out &operator= (const IdUniquenessPolicy_var &);
    IdUniquenessPolicy_out &operator= (IdUniquenessPolicy_ptr);
    operator IdUniquenessPolicy_ptr &();
    IdUniquenessPolicy_ptr &ptr (void);
    IdUniquenessPolicy_ptr operator-> (void);

  private:
    IdUniquenessPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY_CH_

  class TAO_Export IdUniquenessPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef IdUniquenessPolicy_ptr _ptr_type;
    typedef IdUniquenessPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static IdUniquenessPolicy_ptr _duplicate (IdUniquenessPolicy_ptr obj);
    static IdUniquenessPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static IdUniquenessPolicy_ptr _nil (void);

    virtual IdUniquenessPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    IdUniquenessPolicy (
                        TAO_Stub *objref = 0,
                        TAO_ServantBase *servant = 0,
                        CORBA::Boolean collocated = 0
                        );
  public:
    virtual ~IdUniquenessPolicy (void);
  private:
    IdUniquenessPolicy (const IdUniquenessPolicy&);
    void operator= (const IdUniquenessPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_IdUniquenessPolicy;

  enum IdAssignmentPolicyValue
  {
    USER_ID,
    SYSTEM_ID
  };
  typedef IdAssignmentPolicyValue &IdAssignmentPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_IdAssignmentPolicyValue;


#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___PTR_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___PTR_CH_

  class IdAssignmentPolicy;
  typedef IdAssignmentPolicy *IdAssignmentPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___VAR_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___VAR_CH_

  class TAO_Export IdAssignmentPolicy_var
  {
  public:
    IdAssignmentPolicy_var (void); // default constructor
    IdAssignmentPolicy_var (IdAssignmentPolicy_ptr);
    IdAssignmentPolicy_var (const IdAssignmentPolicy_var &); // copy constructor
    ~IdAssignmentPolicy_var (void); // destructor

    IdAssignmentPolicy_var &operator= (IdAssignmentPolicy_ptr);
    IdAssignmentPolicy_var &operator= (const IdAssignmentPolicy_var &);
    IdAssignmentPolicy_ptr operator-> (void) const;

    operator const IdAssignmentPolicy_ptr &() const;
    operator IdAssignmentPolicy_ptr &();
    // in, inout, out, _retn
    IdAssignmentPolicy_ptr in (void) const;
    IdAssignmentPolicy_ptr &inout (void);
    IdAssignmentPolicy_ptr &out (void);
    IdAssignmentPolicy_ptr _retn (void);
    IdAssignmentPolicy_ptr ptr (void) const;

  private:
    IdAssignmentPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___OUT_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___OUT_CH_

  class TAO_Export IdAssignmentPolicy_out
  {
  public:
    IdAssignmentPolicy_out (IdAssignmentPolicy_ptr &);
    IdAssignmentPolicy_out (IdAssignmentPolicy_var &);
    IdAssignmentPolicy_out (const IdAssignmentPolicy_out &);
    IdAssignmentPolicy_out &operator= (IdAssignmentPolicy_out &);
    IdAssignmentPolicy_out &operator= (const IdAssignmentPolicy_var &);
    IdAssignmentPolicy_out &operator= (IdAssignmentPolicy_ptr);
    operator IdAssignmentPolicy_ptr &();
    IdAssignmentPolicy_ptr &ptr (void);
    IdAssignmentPolicy_ptr operator-> (void);

  private:
    IdAssignmentPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY_CH_

  class TAO_Export IdAssignmentPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef IdAssignmentPolicy_ptr _ptr_type;
    typedef IdAssignmentPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static IdAssignmentPolicy_ptr _duplicate (IdAssignmentPolicy_ptr obj);
    static IdAssignmentPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static IdAssignmentPolicy_ptr _nil (void);

    virtual IdAssignmentPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    IdAssignmentPolicy (
                        TAO_Stub *objref = 0,
                        TAO_ServantBase *servant = 0,
                        CORBA::Boolean collocated = 0
                        );
  public:
    virtual ~IdAssignmentPolicy (void);
  private:
    IdAssignmentPolicy (const IdAssignmentPolicy&);
    void operator= (const IdAssignmentPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_IdAssignmentPolicy;

  enum ImplicitActivationPolicyValue
  {
    IMPLICIT_ACTIVATION,
    NO_IMPLICIT_ACTIVATION
  };

#if !defined (TAO_HAS_MINIMUM_CORBA)

  typedef ImplicitActivationPolicyValue &ImplicitActivationPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_ImplicitActivationPolicyValue;


#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___PTR_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___PTR_CH_

  class ImplicitActivationPolicy;
  typedef ImplicitActivationPolicy *ImplicitActivationPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___VAR_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___VAR_CH_

  class TAO_Export ImplicitActivationPolicy_var
  {
  public:
    ImplicitActivationPolicy_var (void); // default constructor
    ImplicitActivationPolicy_var (ImplicitActivationPolicy_ptr);
    ImplicitActivationPolicy_var (const ImplicitActivationPolicy_var &); // copy constructor
    ~ImplicitActivationPolicy_var (void); // destructor

    ImplicitActivationPolicy_var &operator= (ImplicitActivationPolicy_ptr);
    ImplicitActivationPolicy_var &operator= (const ImplicitActivationPolicy_var &);
    ImplicitActivationPolicy_ptr operator-> (void) const;

    operator const ImplicitActivationPolicy_ptr &() const;
    operator ImplicitActivationPolicy_ptr &();
    // in, inout, out, _retn
    ImplicitActivationPolicy_ptr in (void) const;
    ImplicitActivationPolicy_ptr &inout (void);
    ImplicitActivationPolicy_ptr &out (void);
    ImplicitActivationPolicy_ptr _retn (void);
    ImplicitActivationPolicy_ptr ptr (void) const;

  private:
    ImplicitActivationPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___OUT_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___OUT_CH_

  class TAO_Export ImplicitActivationPolicy_out
  {
  public:
    ImplicitActivationPolicy_out (ImplicitActivationPolicy_ptr &);
    ImplicitActivationPolicy_out (ImplicitActivationPolicy_var &);
    ImplicitActivationPolicy_out (const ImplicitActivationPolicy_out &);
    ImplicitActivationPolicy_out &operator= (ImplicitActivationPolicy_out &);
    ImplicitActivationPolicy_out &operator= (const ImplicitActivationPolicy_var &);
    ImplicitActivationPolicy_out &operator= (ImplicitActivationPolicy_ptr);
    operator ImplicitActivationPolicy_ptr &();
    ImplicitActivationPolicy_ptr &ptr (void);
    ImplicitActivationPolicy_ptr operator-> (void);

  private:
    ImplicitActivationPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY_CH_

  class TAO_Export ImplicitActivationPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ImplicitActivationPolicy_ptr _ptr_type;
    typedef ImplicitActivationPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ImplicitActivationPolicy_ptr _duplicate (ImplicitActivationPolicy_ptr obj);
    static ImplicitActivationPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static ImplicitActivationPolicy_ptr _nil (void);

    virtual ImplicitActivationPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    ImplicitActivationPolicy (
                              TAO_Stub *objref = 0,
                              TAO_ServantBase *servant = 0,
                              CORBA::Boolean collocated = 0
                              );
  public:
    virtual ~ImplicitActivationPolicy (void);
  private:
    ImplicitActivationPolicy (const ImplicitActivationPolicy&);
    void operator= (const ImplicitActivationPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_ImplicitActivationPolicy;

#endif /* TAO_HAS_MINIMUM_CORBA */

  enum ServantRetentionPolicyValue
  {
    RETAIN,
    NON_RETAIN
  };

#if !defined (TAO_HAS_MINIMUM_CORBA)

  typedef ServantRetentionPolicyValue &ServantRetentionPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_ServantRetentionPolicyValue;


#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___PTR_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___PTR_CH_

  class ServantRetentionPolicy;
  typedef ServantRetentionPolicy *ServantRetentionPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___VAR_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___VAR_CH_

  class TAO_Export ServantRetentionPolicy_var
  {
  public:
    ServantRetentionPolicy_var (void); // default constructor
    ServantRetentionPolicy_var (ServantRetentionPolicy_ptr);
    ServantRetentionPolicy_var (const ServantRetentionPolicy_var &); // copy constructor
    ~ServantRetentionPolicy_var (void); // destructor

    ServantRetentionPolicy_var &operator= (ServantRetentionPolicy_ptr);
    ServantRetentionPolicy_var &operator= (const ServantRetentionPolicy_var &);
    ServantRetentionPolicy_ptr operator-> (void) const;

    operator const ServantRetentionPolicy_ptr &() const;
    operator ServantRetentionPolicy_ptr &();
    // in, inout, out, _retn
    ServantRetentionPolicy_ptr in (void) const;
    ServantRetentionPolicy_ptr &inout (void);
    ServantRetentionPolicy_ptr &out (void);
    ServantRetentionPolicy_ptr _retn (void);
    ServantRetentionPolicy_ptr ptr (void) const;

  private:
    ServantRetentionPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___OUT_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___OUT_CH_

  class TAO_Export ServantRetentionPolicy_out
  {
  public:
    ServantRetentionPolicy_out (ServantRetentionPolicy_ptr &);
    ServantRetentionPolicy_out (ServantRetentionPolicy_var &);
    ServantRetentionPolicy_out (const ServantRetentionPolicy_out &);
    ServantRetentionPolicy_out &operator= (ServantRetentionPolicy_out &);
    ServantRetentionPolicy_out &operator= (const ServantRetentionPolicy_var &);
    ServantRetentionPolicy_out &operator= (ServantRetentionPolicy_ptr);
    operator ServantRetentionPolicy_ptr &();
    ServantRetentionPolicy_ptr &ptr (void);
    ServantRetentionPolicy_ptr operator-> (void);

  private:
    ServantRetentionPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY_CH_

  class TAO_Export ServantRetentionPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantRetentionPolicy_ptr _ptr_type;
    typedef ServantRetentionPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantRetentionPolicy_ptr _duplicate (ServantRetentionPolicy_ptr obj);
    static ServantRetentionPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static ServantRetentionPolicy_ptr _nil (void);

    virtual ServantRetentionPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    ServantRetentionPolicy (
                            TAO_Stub *objref = 0,
                            TAO_ServantBase *servant = 0,
                            CORBA::Boolean collocated = 0
                            );
  public:
    virtual ~ServantRetentionPolicy (void);
  private:
    ServantRetentionPolicy (const ServantRetentionPolicy&);
    void operator= (const ServantRetentionPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_ServantRetentionPolicy;

#endif /* TAO_HAS_MINIMUM_CORBA */

  enum RequestProcessingPolicyValue
  {
    USE_ACTIVE_OBJECT_MAP_ONLY,
    USE_DEFAULT_SERVANT,
    USE_SERVANT_MANAGER
  };

#if !defined (TAO_HAS_MINIMUM_CORBA)

  typedef RequestProcessingPolicyValue &RequestProcessingPolicyValue_out;
  static CORBA::TypeCode_ptr _tc_RequestProcessingPolicyValue;


#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___PTR_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___PTR_CH_

  class RequestProcessingPolicy;
  typedef RequestProcessingPolicy *RequestProcessingPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___VAR_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___VAR_CH_

  class TAO_Export RequestProcessingPolicy_var
  {
  public:
    RequestProcessingPolicy_var (void); // default constructor
    RequestProcessingPolicy_var (RequestProcessingPolicy_ptr);
    RequestProcessingPolicy_var (const RequestProcessingPolicy_var &); // copy constructor
    ~RequestProcessingPolicy_var (void); // destructor

    RequestProcessingPolicy_var &operator= (RequestProcessingPolicy_ptr);
    RequestProcessingPolicy_var &operator= (const RequestProcessingPolicy_var &);
    RequestProcessingPolicy_ptr operator-> (void) const;

    operator const RequestProcessingPolicy_ptr &() const;
    operator RequestProcessingPolicy_ptr &();
    // in, inout, out, _retn
    RequestProcessingPolicy_ptr in (void) const;
    RequestProcessingPolicy_ptr &inout (void);
    RequestProcessingPolicy_ptr &out (void);
    RequestProcessingPolicy_ptr _retn (void);
    RequestProcessingPolicy_ptr ptr (void) const;

  private:
    RequestProcessingPolicy_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___OUT_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___OUT_CH_

  class TAO_Export RequestProcessingPolicy_out
  {
  public:
    RequestProcessingPolicy_out (RequestProcessingPolicy_ptr &);
    RequestProcessingPolicy_out (RequestProcessingPolicy_var &);
    RequestProcessingPolicy_out (const RequestProcessingPolicy_out &);
    RequestProcessingPolicy_out &operator= (RequestProcessingPolicy_out &);
    RequestProcessingPolicy_out &operator= (const RequestProcessingPolicy_var &);
    RequestProcessingPolicy_out &operator= (RequestProcessingPolicy_ptr);
    operator RequestProcessingPolicy_ptr &();
    RequestProcessingPolicy_ptr &ptr (void);
    RequestProcessingPolicy_ptr operator-> (void);

  private:
    RequestProcessingPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY_CH_

  class TAO_Export RequestProcessingPolicy: public virtual ACE_CORBA_1(Policy)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestProcessingPolicy_ptr _ptr_type;
    typedef RequestProcessingPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestProcessingPolicy_ptr _duplicate (RequestProcessingPolicy_ptr obj);
    static RequestProcessingPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static RequestProcessingPolicy_ptr _nil (void);

    virtual RequestProcessingPolicyValue value (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    RequestProcessingPolicy (
                             TAO_Stub *objref = 0,
                             TAO_ServantBase *servant = 0,
                             CORBA::Boolean collocated = 0
                             );
  public:
    virtual ~RequestProcessingPolicy (void);
  private:
    RequestProcessingPolicy (const RequestProcessingPolicy&);
    void operator= (const RequestProcessingPolicy&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_RequestProcessingPolicy;

#endif /* TAO_HAS_MINIMUM_CORBA */

#if !defined (_PORTABLESERVER_POAMANAGER___PTR_CH_)
#define _PORTABLESERVER_POAMANAGER___PTR_CH_

  class POAManager;
  typedef POAManager *POAManager_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER___VAR_CH_)
#define _PORTABLESERVER_POAMANAGER___VAR_CH_

  class TAO_Export POAManager_var
  {
  public:
    POAManager_var (void); // default constructor
    POAManager_var (POAManager_ptr);
    POAManager_var (const POAManager_var &); // copy constructor
    ~POAManager_var (void); // destructor

    POAManager_var &operator= (POAManager_ptr);
    POAManager_var &operator= (const POAManager_var &);
    POAManager_ptr operator-> (void) const;

    operator const POAManager_ptr &() const;
    operator POAManager_ptr &();
    // in, inout, out, _retn
    POAManager_ptr in (void) const;
    POAManager_ptr &inout (void);
    POAManager_ptr &out (void);
    POAManager_ptr _retn (void);
    POAManager_ptr ptr (void) const;

  private:
    POAManager_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER___OUT_CH_)
#define _PORTABLESERVER_POAMANAGER___OUT_CH_

  class TAO_Export POAManager_out
  {
  public:
    POAManager_out (POAManager_ptr &);
    POAManager_out (POAManager_var &);
    POAManager_out (const POAManager_out &);
    POAManager_out &operator= (POAManager_out &);
    POAManager_out &operator= (const POAManager_var &);
    POAManager_out &operator= (POAManager_ptr);
    operator POAManager_ptr &();
    POAManager_ptr &ptr (void);
    POAManager_ptr operator-> (void);

  private:
    POAManager_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER_CH_)
#define _PORTABLESERVER_POAMANAGER_CH_

  class TAO_Export POAManager: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef POAManager_ptr _ptr_type;
    typedef POAManager_var _var_type;
  #endif /* __GNUC__ */

    enum State {
      HOLDING,
      ACTIVE,
      DISCARDING,
      INACTIVE
    };

    // the static operations
    static POAManager_ptr _duplicate (POAManager_ptr obj);
    static POAManager_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static POAManager_ptr _nil (void);


#if !defined (_PORTABLESERVER_POAMANAGER_ADAPTERINACTIVE___PTR_CH_)
#define _PORTABLESERVER_POAMANAGER_ADAPTERINACTIVE___PTR_CH_

    class AdapterInactive;
    typedef AdapterInactive *AdapterInactive_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER_ADAPTERINACTIVE_CH_)
#define _PORTABLESERVER_POAMANAGER_ADAPTERINACTIVE_CH_

    class TAO_Export AdapterInactive : public CORBA_UserException
    {
    public:
      AdapterInactive (void); // default ctor
      AdapterInactive (const AdapterInactive &); // copy ctor
      ~AdapterInactive (void); // dtor
      AdapterInactive &operator= (const AdapterInactive &);
      virtual void _raise (void);
      static AdapterInactive *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);
    }; // exception PortableServer::POAManager::AdapterInactive

    friend void operator<<= (CORBA::Any &, const AdapterInactive &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterInactive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterInactive *&);
    static CORBA::TypeCode_ptr _tc_AdapterInactive;

#endif /* end #if !defined */

    virtual void  activate (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#if !defined (TAO_HAS_MINIMUM_CORBA)

    virtual void  hold_requests (CORBA::Boolean wait_for_completion, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  discard_requests (CORBA::Boolean wait_for_completion, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  deactivate (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_CORBA */

    virtual State get_state (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    POAManager (
                TAO_Stub *objref = 0,
                TAO_ServantBase *servant = 0,
                CORBA::Boolean collocated = 0
                );
  public:
    virtual ~POAManager (void);
  private:
    POAManager (const POAManager&);
    void operator= (const POAManager&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_POAManager;

#if !defined (TAO_HAS_MINIMUM_CORBA)

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___PTR_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___PTR_CH_

  class AdapterActivator;
  typedef AdapterActivator *AdapterActivator_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___VAR_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___VAR_CH_

  class TAO_Export AdapterActivator_var
  {
  public:
    AdapterActivator_var (void); // default constructor
    AdapterActivator_var (AdapterActivator_ptr);
    AdapterActivator_var (const AdapterActivator_var &); // copy constructor
    ~AdapterActivator_var (void); // destructor

    AdapterActivator_var &operator= (AdapterActivator_ptr);
    AdapterActivator_var &operator= (const AdapterActivator_var &);
    AdapterActivator_ptr operator-> (void) const;

    operator const AdapterActivator_ptr &() const;
    operator AdapterActivator_ptr &();
    // in, inout, out, _retn
    AdapterActivator_ptr in (void) const;
    AdapterActivator_ptr &inout (void);
    AdapterActivator_ptr &out (void);
    AdapterActivator_ptr _retn (void);
    AdapterActivator_ptr ptr (void) const;

  private:
    AdapterActivator_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___OUT_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___OUT_CH_

  class TAO_Export AdapterActivator_out
  {
  public:
    AdapterActivator_out (AdapterActivator_ptr &);
    AdapterActivator_out (AdapterActivator_var &);
    AdapterActivator_out (const AdapterActivator_out &);
    AdapterActivator_out &operator= (AdapterActivator_out &);
    AdapterActivator_out &operator= (const AdapterActivator_var &);
    AdapterActivator_out &operator= (AdapterActivator_ptr);
    operator AdapterActivator_ptr &();
    AdapterActivator_ptr &ptr (void);
    AdapterActivator_ptr operator-> (void);

  private:
    AdapterActivator_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR_CH_

  class TAO_Export AdapterActivator: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef AdapterActivator_ptr _ptr_type;
    typedef AdapterActivator_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static AdapterActivator_ptr _duplicate (AdapterActivator_ptr obj);
    static AdapterActivator_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static AdapterActivator_ptr _nil (void);

    virtual CORBA::Boolean  unknown_adapter (POA_ptr parent, const char *name, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    AdapterActivator (
                      TAO_Stub *objref = 0,
                      TAO_ServantBase *servant = 0,
                      CORBA::Boolean collocated = 0
                      );
  public:
    virtual ~AdapterActivator (void);
  private:
    AdapterActivator (const AdapterActivator&);
    void operator= (const AdapterActivator&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_AdapterActivator;


#if !defined (_PORTABLESERVER_SERVANTMANAGER___PTR_CH_)
#define _PORTABLESERVER_SERVANTMANAGER___PTR_CH_

  class ServantManager;
  typedef ServantManager *ServantManager_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTMANAGER___VAR_CH_)
#define _PORTABLESERVER_SERVANTMANAGER___VAR_CH_

  class TAO_Export ServantManager_var
  {
  public:
    ServantManager_var (void); // default constructor
    ServantManager_var (ServantManager_ptr);
    ServantManager_var (const ServantManager_var &); // copy constructor
    ~ServantManager_var (void); // destructor

    ServantManager_var &operator= (ServantManager_ptr);
    ServantManager_var &operator= (const ServantManager_var &);
    ServantManager_ptr operator-> (void) const;

    operator const ServantManager_ptr &() const;
    operator ServantManager_ptr &();
    // in, inout, out, _retn
    ServantManager_ptr in (void) const;
    ServantManager_ptr &inout (void);
    ServantManager_ptr &out (void);
    ServantManager_ptr _retn (void);
    ServantManager_ptr ptr (void) const;

  private:
    ServantManager_ptr ptr_;
  };

#endif /* end #if !defined */


#if !defined (_PORTABLESERVER_SERVANTMANAGER___OUT_CH_)
#define _PORTABLESERVER_SERVANTMANAGER___OUT_CH_

  class TAO_Export ServantManager_out
  {
  public:
    ServantManager_out (ServantManager_ptr &);
    ServantManager_out (ServantManager_var &);
    ServantManager_out (const ServantManager_out &);
    ServantManager_out &operator= (ServantManager_out &);
    ServantManager_out &operator= (const ServantManager_var &);
    ServantManager_out &operator= (ServantManager_ptr);
    operator ServantManager_ptr &();
    ServantManager_ptr &ptr (void);
    ServantManager_ptr operator-> (void);

  private:
    ServantManager_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTMANAGER_CH_)
#define _PORTABLESERVER_SERVANTMANAGER_CH_

  class TAO_Export ServantManager: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantManager_ptr _ptr_type;
    typedef ServantManager_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantManager_ptr _duplicate (ServantManager_ptr obj);
    static ServantManager_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static ServantManager_ptr _nil (void);

    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    ServantManager (
                    TAO_Stub *objref = 0,
                    TAO_ServantBase *servant = 0,
                    CORBA::Boolean collocated = 0
                    );
  public:
    virtual ~ServantManager (void);
  private:
    ServantManager (const ServantManager&);
    void operator= (const ServantManager&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_ServantManager;


#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___PTR_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___PTR_CH_

  class ServantActivator;
  typedef ServantActivator *ServantActivator_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___VAR_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___VAR_CH_

  class TAO_Export ServantActivator_var
  {
  public:
    ServantActivator_var (void); // default constructor
    ServantActivator_var (ServantActivator_ptr);
    ServantActivator_var (const ServantActivator_var &); // copy constructor
    ~ServantActivator_var (void); // destructor

    ServantActivator_var &operator= (ServantActivator_ptr);
    ServantActivator_var &operator= (const ServantActivator_var &);
    ServantActivator_ptr operator-> (void) const;

    operator const ServantActivator_ptr &() const;
    operator ServantActivator_ptr &();
    // in, inout, out, _retn
    ServantActivator_ptr in (void) const;
    ServantActivator_ptr &inout (void);
    ServantActivator_ptr &out (void);
    ServantActivator_ptr _retn (void);
    ServantActivator_ptr ptr (void) const;

  private:
    ServantActivator_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___OUT_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___OUT_CH_

  class TAO_Export ServantActivator_out
  {
  public:
    ServantActivator_out (ServantActivator_ptr &);
    ServantActivator_out (ServantActivator_var &);
    ServantActivator_out (const ServantActivator_out &);
    ServantActivator_out &operator= (ServantActivator_out &);
    ServantActivator_out &operator= (const ServantActivator_var &);
    ServantActivator_out &operator= (ServantActivator_ptr);
    operator ServantActivator_ptr &();
    ServantActivator_ptr &ptr (void);
    ServantActivator_ptr operator-> (void);

  private:
    ServantActivator_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTACTIVATOR_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR_CH_

  class TAO_Export ServantActivator: public virtual ServantManager
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantActivator_ptr _ptr_type;
    typedef ServantActivator_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantActivator_ptr _duplicate (ServantActivator_ptr obj);
    static ServantActivator_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static ServantActivator_ptr _nil (void);

    virtual Servant  incarnate (const ObjectId &oid, POA_ptr adapter, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  etherealize (const ObjectId &oid, POA_ptr adapter, Servant serv, CORBA::Boolean cleanup_in_progress, CORBA::Boolean remaining_activations, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    ServantActivator (
                      TAO_Stub *objref = 0,
                      TAO_ServantBase *servant = 0,
                      CORBA::Boolean collocated = 0
                      );
  public:
    virtual ~ServantActivator (void);
  private:
    ServantActivator (const ServantActivator&);
    void operator= (const ServantActivator&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_ServantActivator;


#if !defined (_PORTABLESERVER_SERVANTLOCATOR___PTR_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR___PTR_CH_

  class ServantLocator;
  typedef ServantLocator *ServantLocator_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTLOCATOR___VAR_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR___VAR_CH_

  class TAO_Export ServantLocator_var
  {
  public:
    ServantLocator_var (void); // default constructor
    ServantLocator_var (ServantLocator_ptr);
    ServantLocator_var (const ServantLocator_var &); // copy constructor
    ~ServantLocator_var (void); // destructor

    ServantLocator_var &operator= (ServantLocator_ptr);
    ServantLocator_var &operator= (const ServantLocator_var &);
    ServantLocator_ptr operator-> (void) const;

    operator const ServantLocator_ptr &() const;
    operator ServantLocator_ptr &();
    // in, inout, out, _retn
    ServantLocator_ptr in (void) const;
    ServantLocator_ptr &inout (void);
    ServantLocator_ptr &out (void);
    ServantLocator_ptr _retn (void);
    ServantLocator_ptr ptr (void) const;

  private:
    ServantLocator_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTLOCATOR___OUT_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR___OUT_CH_

  class TAO_Export ServantLocator_out
  {
  public:
    ServantLocator_out (ServantLocator_ptr &);
    ServantLocator_out (ServantLocator_var &);
    ServantLocator_out (const ServantLocator_out &);
    ServantLocator_out &operator= (ServantLocator_out &);
    ServantLocator_out &operator= (const ServantLocator_var &);
    ServantLocator_out &operator= (ServantLocator_ptr);
    operator ServantLocator_ptr &();
    ServantLocator_ptr &ptr (void);
    ServantLocator_ptr operator-> (void);

  private:
    ServantLocator_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTLOCATOR_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR_CH_

  class TAO_Export ServantLocator: public virtual ServantManager
  {
  public:

    typedef void *Cookie;

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantLocator_ptr _ptr_type;
    typedef ServantLocator_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantLocator_ptr _duplicate (ServantLocator_ptr obj);
    static ServantLocator_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static ServantLocator_ptr _nil (void);

    virtual Servant  preinvoke (const ObjectId &oid, POA_ptr adapter, const char *operation, Cookie & the_cookie, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  postinvoke (const ObjectId &oid, POA_ptr adapter, const char *operation, Cookie the_cookie, Servant the_servant, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    ServantLocator (
                    TAO_Stub *objref = 0,
                    TAO_ServantBase *servant = 0,
                    CORBA::Boolean collocated = 0
                    );
  public:
    virtual ~ServantLocator (void);
  private:
    ServantLocator (const ServantLocator&);
    void operator= (const ServantLocator&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_ServantLocator;

#endif /* TAO_HAS_MINIMUM_CORBA */

#if !defined (_PORTABLESERVER_POA___PTR_CH_)
#define _PORTABLESERVER_POA___PTR_CH_

  class POA;
  typedef POA *POA_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA___VAR_CH_)
#define _PORTABLESERVER_POA___VAR_CH_

  class TAO_Export POA_var
  {
  public:
    POA_var (void); // default constructor
    POA_var (POA_ptr);
    POA_var (const POA_var &); // copy constructor
    ~POA_var (void); // destructor

    POA_var &operator= (POA_ptr);
    POA_var &operator= (const POA_var &);
    POA_ptr operator-> (void) const;

    operator const POA_ptr &() const;
    operator POA_ptr &();
    // in, inout, out, _retn
    POA_ptr in (void) const;
    POA_ptr &inout (void);
    POA_ptr &out (void);
    POA_ptr _retn (void);
    POA_ptr ptr (void) const;

  private:
    POA_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA___OUT_CH_)
#define _PORTABLESERVER_POA___OUT_CH_

  class TAO_Export POA_out
  {
  public:
    POA_out (POA_ptr &);
    POA_out (POA_var &);
    POA_out (const POA_out &);
    POA_out &operator= (POA_out &);
    POA_out &operator= (const POA_var &);
    POA_out &operator= (POA_ptr);
    operator POA_ptr &();
    POA_ptr &ptr (void);
    POA_ptr operator-> (void);

  private:
    POA_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_CH_)
#define _PORTABLESERVER_POA_CH_

  class TAO_Export POA: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef POA_ptr _ptr_type;
    typedef POA_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static POA_ptr _duplicate (POA_ptr obj);
    static POA_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static POA_ptr _nil (void);


#if !defined (_PORTABLESERVER_POA_ADAPTERALREADYEXISTS___PTR_CH_)
#define _PORTABLESERVER_POA_ADAPTERALREADYEXISTS___PTR_CH_

    class AdapterAlreadyExists;
    typedef AdapterAlreadyExists *AdapterAlreadyExists_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_ADAPTERALREADYEXISTS_CH_)
#define _PORTABLESERVER_POA_ADAPTERALREADYEXISTS_CH_

    class TAO_Export AdapterAlreadyExists : public CORBA_UserException
    {
    public:
      AdapterAlreadyExists (void); // default ctor
      AdapterAlreadyExists (const AdapterAlreadyExists &); // copy ctor
      ~AdapterAlreadyExists (void); // dtor
      AdapterAlreadyExists &operator= (const AdapterAlreadyExists &);
      virtual void _raise (void);
      static AdapterAlreadyExists *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);
    }; // exception PortableServer::POA::AdapterAlreadyExists

    friend void operator<<= (CORBA::Any &, const AdapterAlreadyExists &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterAlreadyExists*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterAlreadyExists *&);
    static CORBA::TypeCode_ptr _tc_AdapterAlreadyExists;

#endif /* end #if !defined */

#if !defined (TAO_HAS_MINIMUM_CORBA)

#if !defined (_PORTABLESERVER_POA_ADAPTERINACTIVE___PTR_CH_)
#define _PORTABLESERVER_POA_ADAPTERINACTIVE___PTR_CH_

    class AdapterInactive;
    typedef AdapterInactive *AdapterInactive_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_ADAPTERINACTIVE_CH_)
#define _PORTABLESERVER_POA_ADAPTERINACTIVE_CH_

    class TAO_Export AdapterInactive : public CORBA_UserException
    {
    public:
      AdapterInactive (void); // default ctor
      AdapterInactive (const AdapterInactive &); // copy ctor
      ~AdapterInactive (void); // dtor
      AdapterInactive &operator= (const AdapterInactive &);
      virtual void _raise (void);
      static AdapterInactive *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef AdapterInactive_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::AdapterInactive

    friend void operator<<= (CORBA::Any &, const AdapterInactive &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterInactive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterInactive *&);
    static CORBA::TypeCode_ptr _tc_AdapterInactive;

#endif /* end #if !defined */

#endif /* TAO_HAS_MINIMUM_CORBA */

#if !defined (_PORTABLESERVER_POA_ADAPTERNONEXISTENT___PTR_CH_)
#define _PORTABLESERVER_POA_ADAPTERNONEXISTENT___PTR_CH_

    class AdapterNonExistent;
    typedef AdapterNonExistent *AdapterNonExistent_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_ADAPTERNONEXISTENT_CH_)
#define _PORTABLESERVER_POA_ADAPTERNONEXISTENT_CH_

    class TAO_Export AdapterNonExistent : public CORBA_UserException
    {
    public:
      AdapterNonExistent (void); // default ctor
      AdapterNonExistent (const AdapterNonExistent &); // copy ctor
      ~AdapterNonExistent (void); // dtor
      AdapterNonExistent &operator= (const AdapterNonExistent &);
      virtual void _raise (void);
      static AdapterNonExistent *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef AdapterNonExistent_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::AdapterNonExistent

    friend void operator<<= (CORBA::Any &, const AdapterNonExistent &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterNonExistent*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterNonExistent *&);
    static CORBA::TypeCode_ptr _tc_AdapterNonExistent;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_INVALIDPOLICY___PTR_CH_)
#define _PORTABLESERVER_POA_INVALIDPOLICY___PTR_CH_

    class InvalidPolicy;
    typedef InvalidPolicy *InvalidPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_INVALIDPOLICY_CH_)
#define _PORTABLESERVER_POA_INVALIDPOLICY_CH_

    class TAO_Export InvalidPolicy : public CORBA_UserException
    {
    public:
      InvalidPolicy (void); // default ctor
      InvalidPolicy (const InvalidPolicy &); // copy ctor
      ~InvalidPolicy (void); // dtor
      InvalidPolicy &operator= (const InvalidPolicy &);
      virtual void _raise (void);
      static InvalidPolicy *_narrow (CORBA::Exception *);

      InvalidPolicy(
          CORBA::UShort _tao_index
        );

      CORBA::UShort index;

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef InvalidPolicy_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::InvalidPolicy

    friend void operator<<= (CORBA::Any &, const InvalidPolicy &); // copying version
    friend void operator<<= (CORBA::Any &, InvalidPolicy*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, InvalidPolicy *&);
    static CORBA::TypeCode_ptr _tc_InvalidPolicy;

#endif /* end #if !defined */

#if !defined (TAO_HAS_MINIMUM_CORBA)

#if !defined (_PORTABLESERVER_POA_NOSERVANT___PTR_CH_)
#define _PORTABLESERVER_POA_NOSERVANT___PTR_CH_

    class NoServant;
    typedef NoServant *NoServant_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_NOSERVANT_CH_)
#define _PORTABLESERVER_POA_NOSERVANT_CH_

    class TAO_Export NoServant : public CORBA_UserException
    {
    public:
      NoServant (void); // default ctor
      NoServant (const NoServant &); // copy ctor
      ~NoServant (void); // dtor
      NoServant &operator= (const NoServant &);
      virtual void _raise (void);
      static NoServant *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef NoServant_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::NoServant

    friend void operator<<= (CORBA::Any &, const NoServant &); // copying version
    friend void operator<<= (CORBA::Any &, NoServant*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, NoServant *&);
    static CORBA::TypeCode_ptr _tc_NoServant;

#endif /* end #if !defined */

#endif /* TAO_HAS_MINIMUM_CORBA */

#if !defined (_PORTABLESERVER_POA_OBJECTALREADYACTIVE___PTR_CH_)
#define _PORTABLESERVER_POA_OBJECTALREADYACTIVE___PTR_CH_

    class ObjectAlreadyActive;
    typedef ObjectAlreadyActive *ObjectAlreadyActive_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_OBJECTALREADYACTIVE_CH_)
#define _PORTABLESERVER_POA_OBJECTALREADYACTIVE_CH_

    class TAO_Export ObjectAlreadyActive : public CORBA_UserException
    {
    public:
      ObjectAlreadyActive (void); // default ctor
      ObjectAlreadyActive (const ObjectAlreadyActive &); // copy ctor
      ~ObjectAlreadyActive (void); // dtor
      ObjectAlreadyActive &operator= (const ObjectAlreadyActive &);
      virtual void _raise (void);
      static ObjectAlreadyActive *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ObjectAlreadyActive_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::ObjectAlreadyActive

    friend void operator<<= (CORBA::Any &, const ObjectAlreadyActive &); // copying version
    friend void operator<<= (CORBA::Any &, ObjectAlreadyActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ObjectAlreadyActive *&);
    static CORBA::TypeCode_ptr _tc_ObjectAlreadyActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_OBJECTNOTACTIVE___PTR_CH_)
#define _PORTABLESERVER_POA_OBJECTNOTACTIVE___PTR_CH_

    class ObjectNotActive;
    typedef ObjectNotActive *ObjectNotActive_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_OBJECTNOTACTIVE_CH_)
#define _PORTABLESERVER_POA_OBJECTNOTACTIVE_CH_

    class TAO_Export ObjectNotActive : public CORBA_UserException
    {
    public:
      ObjectNotActive (void); // default ctor
      ObjectNotActive (const ObjectNotActive &); // copy ctor
      ~ObjectNotActive (void); // dtor
      ObjectNotActive &operator= (const ObjectNotActive &);
      virtual void _raise (void);
      static ObjectNotActive *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ObjectNotActive_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::ObjectNotActive

    friend void operator<<= (CORBA::Any &, const ObjectNotActive &); // copying version
    friend void operator<<= (CORBA::Any &, ObjectNotActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ObjectNotActive *&);
    static CORBA::TypeCode_ptr _tc_ObjectNotActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_SERVANTALREADYACTIVE___PTR_CH_)
#define _PORTABLESERVER_POA_SERVANTALREADYACTIVE___PTR_CH_

    class ServantAlreadyActive;
    typedef ServantAlreadyActive *ServantAlreadyActive_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_SERVANTALREADYACTIVE_CH_)
#define _PORTABLESERVER_POA_SERVANTALREADYACTIVE_CH_

    class TAO_Export ServantAlreadyActive : public CORBA_UserException
    {
    public:
      ServantAlreadyActive (void); // default ctor
      ServantAlreadyActive (const ServantAlreadyActive &); // copy ctor
      ~ServantAlreadyActive (void); // dtor
      ServantAlreadyActive &operator= (const ServantAlreadyActive &);
      virtual void _raise (void);
      static ServantAlreadyActive *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantAlreadyActive_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::ServantAlreadyActive

    friend void operator<<= (CORBA::Any &, const ServantAlreadyActive &); // copying version
    friend void operator<<= (CORBA::Any &, ServantAlreadyActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ServantAlreadyActive *&);
    static CORBA::TypeCode_ptr _tc_ServantAlreadyActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_SERVANTNOTACTIVE___PTR_CH_)
#define _PORTABLESERVER_POA_SERVANTNOTACTIVE___PTR_CH_

    class ServantNotActive;
    typedef ServantNotActive *ServantNotActive_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_SERVANTNOTACTIVE_CH_)
#define _PORTABLESERVER_POA_SERVANTNOTACTIVE_CH_

    class TAO_Export ServantNotActive : public CORBA_UserException
    {
    public:
      ServantNotActive (void); // default ctor
      ServantNotActive (const ServantNotActive &); // copy ctor
      ~ServantNotActive (void); // dtor
      ServantNotActive &operator= (const ServantNotActive &);
      virtual void _raise (void);
      static ServantNotActive *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantNotActive_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::ServantNotActive

    friend void operator<<= (CORBA::Any &, const ServantNotActive &); // copying version
    friend void operator<<= (CORBA::Any &, ServantNotActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ServantNotActive *&);
    static CORBA::TypeCode_ptr _tc_ServantNotActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_WRONGADAPTER___PTR_CH_)
#define _PORTABLESERVER_POA_WRONGADAPTER___PTR_CH_

    class WrongAdapter;
    typedef WrongAdapter *WrongAdapter_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_WRONGADAPTER_CH_)
#define _PORTABLESERVER_POA_WRONGADAPTER_CH_

    class TAO_Export WrongAdapter : public CORBA_UserException
    {
    public:
      WrongAdapter (void); // default ctor
      WrongAdapter (const WrongAdapter &); // copy ctor
      ~WrongAdapter (void); // dtor
      WrongAdapter &operator= (const WrongAdapter &);
      virtual void _raise (void);
      static WrongAdapter *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef WrongAdapter_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::WrongAdapter

    friend void operator<<= (CORBA::Any &, const WrongAdapter &); // copying version
    friend void operator<<= (CORBA::Any &, WrongAdapter*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, WrongAdapter *&);
    static CORBA::TypeCode_ptr _tc_WrongAdapter;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_WRONGPOLICY___PTR_CH_)
#define _PORTABLESERVER_POA_WRONGPOLICY___PTR_CH_

    class WrongPolicy;
    typedef WrongPolicy *WrongPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_WRONGPOLICY_CH_)
#define _PORTABLESERVER_POA_WRONGPOLICY_CH_

    class TAO_Export WrongPolicy : public CORBA_UserException
    {
    public:
      WrongPolicy (void); // default ctor
      WrongPolicy (const WrongPolicy &); // copy ctor
      ~WrongPolicy (void); // dtor
      WrongPolicy &operator= (const WrongPolicy &);
      virtual void _raise (void);
      static WrongPolicy *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef WrongPolicy_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::POA::WrongPolicy

    friend void operator<<= (CORBA::Any &, const WrongPolicy &); // copying version
    friend void operator<<= (CORBA::Any &, WrongPolicy*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, WrongPolicy *&);
    static CORBA::TypeCode_ptr _tc_WrongPolicy;

#endif /* end #if !defined */

    virtual POA_ptr  create_POA (const char *adapter_name, POAManager_ptr a_POAManager, const CORBA::PolicyList &policies, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual POA_ptr  find_POA (const char *adapter_name, CORBA::Boolean activate_it, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  destroy (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#if !defined (TAO_HAS_MINIMUM_CORBA)

    virtual ThreadPolicy_ptr  create_thread_policy (ThreadPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_CORBA */

    virtual LifespanPolicy_ptr  create_lifespan_policy (LifespanPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual IdUniquenessPolicy_ptr  create_id_uniqueness_policy (IdUniquenessPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual IdAssignmentPolicy_ptr  create_id_assignment_policy (IdAssignmentPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#if !defined (TAO_HAS_MINIMUM_CORBA)

    virtual ImplicitActivationPolicy_ptr  create_implicit_activation_policy (ImplicitActivationPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual ServantRetentionPolicy_ptr  create_servant_retention_policy (ServantRetentionPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual RequestProcessingPolicy_ptr  create_request_processing_policy (RequestProcessingPolicyValue value, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_CORBA */

    virtual char * the_name (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual POA_ptr  the_parent (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual POAManager_ptr  the_POAManager (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#if !defined (TAO_HAS_MINIMUM_CORBA)

    virtual AdapterActivator_ptr  the_activator (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void the_activator(AdapterActivator_ptr the_activator, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual ServantManager_ptr  get_servant_manager (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  set_servant_manager (ServantManager_ptr imgr, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual Servant  get_servant (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  set_servant (Servant p_servant, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_CORBA */

    virtual ObjectId * activate_object (Servant p_servant, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  activate_object_with_id (const ObjectId &id, Servant p_servant, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual void  deactivate_object (const ObjectId &oid, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Object_ptr  create_reference (const char *intf, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Object_ptr  create_reference_with_id (const ObjectId &oid, const char *intf, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual ObjectId * servant_to_id (Servant p_servant, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Object_ptr  servant_to_reference (Servant p_servant, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual Servant  reference_to_servant (CORBA::Object_ptr reference, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual ObjectId * reference_to_id (CORBA::Object_ptr reference, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual Servant  id_to_servant (const ObjectId &oid, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Object_ptr  id_to_reference (const ObjectId &oid, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    POA (
         TAO_Stub *objref = 0,
         TAO_ServantBase *servant = 0,
         CORBA::Boolean collocated = 0
         );
  public:
    virtual ~POA (void);
  private:
    POA (const POA&);
    void operator= (const POA&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_POA;


#if !defined (_PORTABLESERVER_CURRENT___PTR_CH_)
#define _PORTABLESERVER_CURRENT___PTR_CH_

  class Current;
  typedef Current *Current_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT___VAR_CH_)
#define _PORTABLESERVER_CURRENT___VAR_CH_

  class TAO_Export Current_var
  {
  public:
    Current_var (void); // default constructor
    Current_var (Current_ptr);
    Current_var (const Current_var &); // copy constructor
    ~Current_var (void); // destructor

    Current_var &operator= (Current_ptr);
    Current_var &operator= (const Current_var &);
    Current_ptr operator-> (void) const;

    operator const Current_ptr &() const;
    operator Current_ptr &();
    // in, inout, out, _retn
    Current_ptr in (void) const;
    Current_ptr &inout (void);
    Current_ptr &out (void);
    Current_ptr _retn (void);
    Current_ptr ptr (void) const;

  private:
    Current_ptr ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT___OUT_CH_)
#define _PORTABLESERVER_CURRENT___OUT_CH_

  class TAO_Export Current_out
  {
  public:
    Current_out (Current_ptr &);
    Current_out (Current_var &);
    Current_out (const Current_out &);
    Current_out &operator= (Current_out &);
    Current_out &operator= (const Current_var &);
    Current_out &operator= (Current_ptr);
    operator Current_ptr &();
    Current_ptr &ptr (void);
    Current_ptr operator-> (void);

  private:
    Current_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT_CH_)
#define _PORTABLESERVER_CURRENT_CH_

  class TAO_Export Current: public virtual ACE_CORBA_1(Current)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef Current_ptr _ptr_type;
    typedef Current_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static Current_ptr _duplicate (Current_ptr obj);
    static Current_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    static Current_ptr _nil (void);


#if !defined (_PORTABLESERVER_CURRENT_NOCONTEXT___PTR_CH_)
#define _PORTABLESERVER_CURRENT_NOCONTEXT___PTR_CH_

    class NoContext;
    typedef NoContext *NoContext_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT_NOCONTEXT_CH_)
#define _PORTABLESERVER_CURRENT_NOCONTEXT_CH_

    class TAO_Export NoContext : public CORBA_UserException
    {
    public:
      NoContext (void); // default ctor
      NoContext (const NoContext &); // copy ctor
      ~NoContext (void); // dtor
      NoContext &operator= (const NoContext &);
      virtual void _raise (void);
      static NoContext *_narrow (CORBA::Exception *);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef NoContext_ptr _ptr_type;
  #endif /* __GNUC__ */

    }; // exception PortableServer::Current::NoContext

    friend void operator<<= (CORBA::Any &, const NoContext &); // copying version
    friend void operator<<= (CORBA::Any &, NoContext*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, NoContext *&);
    static CORBA::TypeCode_ptr _tc_NoContext;

#endif /* end #if !defined */

    virtual POA_ptr  get_POA (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual ObjectId * get_object_id (CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &TAO_IN_ENV = CORBA::default_environment ());
  protected:
    Current (
             TAO_Stub *objref = 0,
             TAO_ServantBase *servant = 0,
             CORBA::Boolean collocated = 0
             );
  public:
    virtual ~Current (void);
  private:
    Current (const Current&);
    void operator= (const Current&);
  };

#endif /* end #if !defined */

  static CORBA::TypeCode_ptr _tc_Current;

  static char *ObjectId_to_string (const PortableServer::ObjectId &id);
  static CORBA::WChar *ObjectId_to_wstring (const PortableServer::ObjectId &id);
  static PortableServer::ObjectId *string_to_ObjectId (const char *id);
  static PortableServer::ObjectId *wstring_to_ObjectId (const CORBA::WChar *id);

};

#if defined (__ACE_INLINE__)
#include "POAC.i"
#endif /* defined INLINE */

#endif /* TAO_IDL_POAC_H */
