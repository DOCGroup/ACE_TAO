<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Mozilla/4.5 [en] (X11; I; SunOS 5.5.1 sun4u) [Netscape]">
<title>TAO IDL compiler User's Guide</title>

<style>
body {
  background-color: #ffffff;
  color: #000000;
}
table, th, td {
  border: 1px solid black;
}
.indent {
  margin-left: 2em;
}
.boxed {
  border: 1px solid black;
  border-radius: 0.3em;
  padding-right: 0.5em;
  padding-left: 0.5em;
  margin: 0.5em;
}
pre, code {
  background-color: #e3e3e3;
  border-radius: 0.2em;
  padding-right: 0.2em;
  padding-left: 0.2em;
}
</style>

</head>
<body>

<hr>
<h1>TAO IDL Compiler User's Guide</h1>

<h2>Scope</h2>
This document describes the options and features of
TAO IDL compiler.  It is not a reference manual or tutorial on OMG
IDL.  For more information on OMG IDL see the <A
HREF="http://www.omg.org/technology/documents/corba_spec_catalog.htm">
online CORBA specification</A> and the <A
HREF="http://www.triodia.com/staff/michi-henning.html">Advanced CORBA
Programming with C++</A> book.  More information on the design of
TAO's IDL compiler is also available <A
HREF="http://www.dre.vanderbilt.edu/~schmidt/PDF/ami1.pdf">online</A>.
Finally, comprehensive documentation on TAO's IDL compiler is
available in the OCI <A HREF="http://www.theaceorb.com/product/index.html">TAO
Developer's Guide</A>.<P>

<hr>
<h2>Optional CIAO Functionality</h2>

For users of the <b>Component Integrated ACE ORB</b>
(<a href="http://www.dre.vanderbilt.edu/~schmidt/CIAO.html"> CIAO</a>), it is
important to note that, in keeping with recent developments in
the OMG's Lightweight CORBA Component Model
(<a href="http://www.omg.org/technology/documents/formal/components.htm"> LwCCM</a>) specification,
CIAO's <i>Component Implementation Definition Language</i> (CIDL) compiler,
along with the .cidl files it processed, have been eliminated, and replaced
by additional functionality in the TAO IDL compiler. All the additional files
generated and command line options used are described below.

<hr>
<h2>Generated Files</h2>

The IDL compiler generates up to 16 files from each <code>.idl</code> file.  The
file names are obtained by taking the IDL <EM>basename</EM> and
appending the following suffixes (see the list of TAO's IDL compiler
<A HREF="#options">options</A> on how to get different suffixes for
these files:) <P>

<UL>
  <LI> <B><EM>Client stubs</EM></B>, <EM>i.e.</EM>, <code>*C.h</code>,
      <code>*C.inl</code>, and <code>*C.cpp</code>.  Pure client applications
      only need to <code>#include</code> and link with these files.
  <LI> <B><EM>Server skeletons</EM></B>, <EM>i.e.</EM>,  <code>*S.h</code>, and
      <code>*S.cpp</code>.  Servers need to <code>#include</code> and link
      with these files. Generation of these files may be suppressed with the <code>&#8209;SS</code> option.
  <LI> <B><EM>Server skeleton templates</EM></B>, <EM>i.e.</EM>, <code>*S_T.h</code>, <code>S_T.inl</code>,
      and <code>*S_T.cpp</code>.  Some C++ compilers do not like template
      and non-template code in the same files, so TAO's IDL compiler
      generates these files separately. These files define tie classes,
      used to enable servant inheritance trees, and are not generated by
      default.
  <LI> <B><EM>Anyop files</EM></B>, <EM>i.e.</EM>, <code>*A.h</code>,
       and <code>*A.cpp</code>. Optionally generated files containing
       typecode and Any insertion/extraction operator definitions.
       This option enables the contents of these files to remain
       unlinked if not used.
  <LI> <B><EM>CIAO servant files</EM></B>, <EM>i.e.</EM>, <code>*_svnt.h</code>,
      and <code>*_svnt.cpp</code>. Optionally generated files, containing component
      and home servant implementations, as well as factory functions to create
      components and homes.
  <LI> <B><EM>Executor IDL file</EM></B>, <EM>i.e.</EM>, <code>*E.idl</code>.
      IDL file containing local interfaces used for component and home
      executors, optionally generated.
  <LI> <B><EM>Executor implementation files</EM></B>, <EM>i.e.</EM>, <code>*_exec.h</code>,
      and <code>*_exec.cpp</code>. Optionally generated files containing executor implementation classes
      with empty function bodies for facet, supported and inherited operations,
      as well as factory functions to create component and home executors.
  <LI> <B><EM>Connector implementation files</EM></B>, <EM>i.e.</EM>, <code>*_conn.h</code>,
      and <code>*_conn.cpp</code>. Optionally generated files containing connector implementation classes
      with complete function bodies. The function implementations are specialized
      for DDS at present, but will be configurable to other connection mechanisms
      in the future.
  <LI> <B><EM>Export header files</EM></B>, <EM>i.e.</EM>, <code>*_export.h</code>.
      Optionally generated files defining export/import macros as well as
      corresponding macros related to singletons and tracing, all in terms of
      existing ACE macros. Note that, while these files must have the
      "_export.h" suffix, the base name of the file is usually not derived
      from the IDL filename, as is the stem of the other file groups above.
      There can be as many as 4 of these files per build, for stub, skeleton,
      servant, and executor export macros, and they may also be generated by
      the Perl script <code>generate_export_file.pl</code>, located in
      <code>$ACE_ROOT/bin</code>.
</UL>

TAO's IDL compiler creates separate <code>*.inl</code> and <code>*S_T.*</code>
files to improve the performance of the generated code.  For example,
the <code>*.inl</code> files enable you to compile with inlining enabled or
not, which is useful for trading-off compile-time and run-time
performance.  Fortunately, you need to <code>#include</code> only the
client stubs declared in the <code>*C.h</code> file and the skeletons in
the <code>*S.h</code> file in your code. Inline files are not generated
for CIAO servant or executor implementation code.<P>

<hr>
<h2 id="idl_env">Environment Variables</h2>

<table>
  <tr>
    <th>Variable</th>
    <th>Usage</th>
  </tr>
  <tr>
    <td><code>TAO_IDL_PREPROCESSOR</code></td>
    <td>Used to override the program name of the preprocessor that TAO_IDL
    uses.</td>
  </tr>
  <tr>
    <td><code>TAO_IDL_PREPROCESSOR_ARGS</code></td>
    <td>Used to override the flags passed to the preprocessor that TAO_IDL
        uses.  This can be used to alter the default options for the
        preprocessor and specify things like include directories and how
        the preprocessor is invoked.
    </td>
  </tr>
  <tr>
    <td><code>TAO_ROOT</code></td>
    <td>Used to determine where <code>orb.idl</code> is located.</td>
  </tr>
  <tr>
    <td><code>ACE_ROOT</code></td>
    <td>Used to determine where <code>gperf</code> is located.</td>
  </tr>
  <tr>
    <td><code>CIAO_ROOT</code></td>
    <td>Used to determine where <code>Components.idl</code> is located.</td>
  </tr>
</table>

<P>Because TAO_IDL doesn't have any code to implement a preprocessor, it has
to use an external one.  For convenience, it uses a built-in name for an external
preprocessor to call.  During compilation, this is how that default is set:</P>

<ol>
  <li>If the macro <code>TAO_IDL_PREPROCESSOR</code> is defined, then it will use that.</li>
  <li>Else if the macro <code>ACE_CC_PREPROCESSOR</code> is defined, then it will use that.</li>
  <li>Otherwise, it will use <code>cc</code></li>
</ol>

<p>And the same behavior occurs for the <code>TAO_IDL_PREPROCESSOR_ARGS</code> and
<code>ACE_CC_PREPROCESSOR_ARGS</code> macros.</p>

<P>Case 1 is used by the Makefile on most machines to specify the preprocessor.
Case 2 is used on Windows and platforms that need special arguments passed
to the preprocessor (MVS, etc.).  And case 3 isn't used at all,
but is included as a default case.</P>

<p>Since the default preprocessor may not always work when TAO_IDL is moved to
another machine or used in cross-compilation, it can be overridden at runtime
by setting the environment variables <code>TAO_IDL_PREPROCESSOR</code> and
<code>TAO_IDL_PREPROCESSOR_ARGS</code>.</p>

<P>If ACE_ROOT or TAO_ROOT are defined, then TAO_IDL
will use them to include the $(ACE_ROOT)/TAO/tao or $(TAO_ROOT)/tao
directories. This is to allow TAO_IDL to automatically find
&lt;orb.idl&gt; when it is included in an IDL file.  TAO_IDL will
display a warning message when neither is defined.</P>

<hr>
<h2>IDL Preprocessor Macros</h2>

<p>The preprocessor macros available in IDL include all the ones built-in to
the preprocessor when it's being used for C/C++. In addition to the ones
built-in to the preprocessor, the following are also defined by
<code>tao_idl</code>:</p>

<table>
  <tr>
    <th>Name</th>
    <th>Description</th>
  </tr>

  <tr>
    <td><code>__TAO_IDL</code></td>
    <td>
      <p>The version of ACE that <code>tao_idl</code> was built with. The format
      is one byte for each version field in hex format. For example, in a
      theoretical TAO version 3.2.1, which would correspond to ACE version
      7.3.1, <code>__TAO_IDL</code> would be <code>0x070201</code>.</p>

      <p>It's also possible to include <code>tao/Version.h</code> and use the
      same macros from that header file as you can use in C++.</p>
    </td>
  </tr>

  <tr id="tao_idl_idl_version">
    <td><code>__TAO_IDL_IDL_VERSION</code></td>
    <td>Version of the IDL specification the compiler that can be changed using
      <a href="#idl-version"><code>--idl-version</code></a>. Note that this
      doesn't mean that the compiler will support all those features of the
      IDL spec version. The format is the same as <code>__TAO_IDL</code>,
      which is three one-byte fields in a hex format. For example IDL version 3
      is <code>0x030000</code>.
    </td>
  </tr>
</table>

<hr>
<h2>Operation Demuxing Strategies</h2>

The server skeleton can use different demuxing strategies to match the
incoming operation with the correct operation at the servant.  TAO's
IDL compiler supports perfect hashing, binary search, and dynamic
hashing demuxing strategies.  By default, TAO's IDL compiler tries to
generate perfect hash functions, which is generally the most <A
HREF="http://www.dre.vanderbilt.edu/~schmidt/PDF/COOTS-99.pdf">efficient and
predictable operation demuxing technique</A>.  To generate perfect
hash functions, TAO's IDL compiler uses <a
href="http://www.dre.vanderbilt.edu/~schmidt/PDF/gperf.pdf">gperf </a>, which
is a general-purpose perfect hash function generator. <P>

To configure TAO's IDL compiler to support perfect hashing please do
the following:

<ul>
  <li>Enable <code>ACE_HAS_GPERF</code> when building ACE and TAO.
      This macro has been defined for the platforms where <code>gperf</code>
      has been tested, which includes most <A
      HREF="http://www.cs.wustl.edu/~schmidt/ACE-versions-i.html">platforms</A>
      that ACE runs on.</li>

  <li>Build the <code>gperf</code> in $ACE_ROOT/apps/gperf.  This build
      also leaves a copy/link of the ace_gperf program at the $ACE_ROOT/bin
      directory.</li>

  <li>Set the environment variable <code>$ACE_ROOT</code> appropriately or add
      <code>$ACE_ROOT/bin</code> to your search path.</li>

  <li>Use the <code>&#8209;g</code> option for the TAO IDL compiler or set
      your search path accordingly to install <code>ace_gperf</code> in a
      directory other than <code>$ACE_ROOT/bin</code>.
</ul>

Note that if you can't use perfect hashing for some reason the next
best operation demuxing strategy is binary search, which can be
configured using TAO's IDL compiler <A HREF="#options">options</A>.<P>

<hr>
<h2>AMI support</h2>

The TAO_IDL compiler generates AMI stubs and skeletons as
described in the CORBA 3.0.3 specification.

<hr>
<h2 id="collocation-stubs">Collocation Strategies</h2>

<p>
TAO_IDL can generate collocated stubs using two different collocation
strategies.  It also allows you to suppress/enable the generation of
the stubs of a particular strategy.  To gain great flexibility at
run-time, you can generate stubs for both collocation strategies
(using both '<a href="#Gp"><code>&#8209;Gp</code></a>' and '<a
href="#Gd"><code>&#8209;Gd</code></a>' flags at the same time) and defer the
determination of collocation strategy until run-time.  On the other
hand, if you want to minimize the footprint of your program, you might
want to pre-determine the collocation strategy you want and only
generate the right collocated stubs (or not generating any at all using
both  '<a href="#Sp"><code>&#8209;Sp</code></a>' and '<a
href="#Sd"><code>&#8209;Sd</code></a>' flags at the same time if
it's a pure client.)  See our <a
href="http://www.dre.vanderbilt.edu/~schmidt/PDF/C++-report-col18.pdf">collocation
paper</a> for a detail discussion on the collocation support in
TAO.</p>


<hr>
<h2 id="options">TAO's IDL Compiler Options</h2>

<p>
TAO's IDL compiler invokes your C (or C++)
preprocessor to resolve included IDL files.  It receives the common
options for preprocessors (such as <code>&#8209;D</code> or <code>&#8209;I</code>).  It
also receives other options that are specific to it.</p>

<table>
  <tr>
    <th>Option</th>
    <th>Description</th>
    <th>Remark</th>
  </tr>

  <tr id="u">
    <td><code>&#8209;h</code></br>
      <code>&#8209;&#8209;help</code></br>
      <code>&#8209;u</code></td>

    <td>The compiler prints out the arguments it supports and exits</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="V">
    <td><code>&#8209;V</code></br>
      <code>&#8209;&#8209;version</code></td>

    <td>The compiler printouts its version and exits</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="idl-version">
    <td><code>&#8209;&#8209;idl&#8209;version&nbsp;VERSION</code></td>

    <td>Set the IDL version to use. This will be available in IDL as the
      <a href="#tao_idl_idl_version"><code>__TAO_IDL_IDL_VERSION</code> macro</a>.</td>

    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;default&#8209;idl&#8209;version</code></td>

    <td>Prints the default IDL version for the compiler and exits. This will be
      available in IDL as the
      <a href="#tao_idl_idl_version"><code>__TAO_IDL_IDL_VERSION</code> macro</a>.</td>

    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;list&#8209;idl&#8209;versions</code></td>

    <td>Lists IDL versions the compiler supports and exits</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Wb">
    <td><code>&#8209;Wb,</code><i>option_list</i></EM</TD></td>

    <td>Pass options to the TAO IDL compiler backend.</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="skel_export_macro">
    <td></td>

    <td><code>skel_export_macro=</code><i>macro_name</i></td>

    <td>The compiler will emit <i>macro_name</i> right after each <code>class</code>
        or <code>extern</code> keyword in the generated skeleton header (*S.h)
        files. If CIAO servant code is being generated (see <code>&#8209;Gsv</code> option below),
        and <code>svnt_export_macro</code> (see below) isn't set, this macro will also
        appear in the generated CIAO servant (*_svnt.h) files, since skeleton and
        CIAO servant files are often compiled together.
        This macro is needed for Windows and newer versions of gcc, which require
        special directives to export symbols from DLLs, otherwise the definition
        is just a space.&nbsp;</td>
  </tr>

  <tr id="skel_export_include">
    <td></td>

    <td><code>skel_export_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the generated server header, this is usually a good
        place to define the server side export macro.</td>
  </tr>

  <tr id="stub_export_macro">
    <td></td>

    <td><code>stub_export_macro=</code><i>macro_name</i></td>

    <td>The compiler will emit <i>macro_name</i> right after each <code>class</code>
        or <code>extern</code> keyword in the generated stub code, this is
        needed for Windows and newer versions of gcc, which require special directives to
        export symbols from DLLs, otherwise the definition is just a
        space.&nbsp;</td>
  </tr>

  <tr id="stub_export_include">
    <td></td>

    <td><code>stub_export_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the client header, this is usually a good place to define the export
        macro.</td>
  </tr>

  <tr id="anyop_export_macro">
    <td></td>

    <td><code>anyop_export_macro=</code><i>macro_name</i></td>

    <td>The compiler will emit <i>macro_name</i> before each Any operator
        or <code>extern</code> typecode declaration in the generated stub code,
        this is needed for Windows and newer versions of gcc, which require special directives to
        export symbols from DLLs, otherwise the definition is just a
        space on Unix platforms. This option works only in conjunction with
        the -GA option, which generates Any operators and typecodes into a
        separate set of files.&nbsp;</td>
  </tr>

  <tr id="anyop_export_include">
    <td></td>

    <td><code>anyop_export_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the anyop file header, this is usually a good place to define the export
        macro. This option works in conjunction with the -GA option, which generates Any
        operators and typecodes into a separate set of files.</td>
  </tr>

  <tr id="svnt_export_macro"></a>
    <td></td>

    <td><code>svnt_export_macro=</code><i>macro_name</i></td>

    <td>The compiler will emit <i>macro_name</i> right after each <code>class</code>
        or <code>extern</code> keyword in the generated CIAO servant code, if such
        code is being generated (see <code>&#8209;Gsv</code> option below). Since skeleton
        and servant files are often compiled together, the value of
        <code>skel_export_macro</code> will appear here, if it is set and
        <code>svnt_export_macro</code> is not. These macros
        are needed for Windows and newer versions of gcc, which require special directives to
        export symbols from DLLs - otherwise the definition is just a space.&nbsp;</td>
  </tr>

  <tr id="svnt_export_include"></a>
    <td></td>

    <td><code>svnt_export_macro=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the CIAO servant file header, if this file is being generated
        (see <code>&#8209;Gsv</code> option below). This is usually a good place to define the export
        macro.</td>
  </tr>

  <tr id="exec_export_macro"></a>
    <td></td>

    <td><code>exec_export_macro=</code><i>macro_name</i></td>

    <td>The compiler will emit <i>macro_name</i> right after each <code>class</code>
        or <code>extern</code> keyword in the generated CIAO executor implementation header
        (*_exec.h) files, if such
        code is being generated (see <code>&#8209;Gex</code> option below). These macros
        are needed for Windows and newer versions of gcc, which require special directives to
        export symbols from DLLs - otherwise the definition is just a space.&nbsp;</td>
  </tr>

  <tr id="exec_export_include"></a>
    <td></td>

    <td><code>exec_export_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the CIAO executor implementation header (*_exec.h) file, if this file is being generated
        (see <code>&#8209;Gex</code> option below). This is usually a good place to define the export
        macro.</td>
  </tr>

  <tr id="conn_export_macro"></a>
    <td></td>

    <td><code>conn_export_macro=</code><i>macro_name</i></td>

    <td>The compiler will emit <i>macro_name</i> right after each <code>class</code>
        or <code>extern</code> keyword in the generated CIAO connector implementation header
        (*_conn.h) files, if such
        code is being generated (see <code>&#8209;Gcn</code> option below). These macros
        are needed for Windows and newer versions of gcc, which require special directives to
        export symbols from DLLs - otherwise the definition is just a space.&nbsp;</td>
  </tr>

  <tr id="conn_export_include"></a>
    <td></td>

    <td><code>conn_export_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the CIAO connector implementation header (*_conn.h) file, if this file is being generated
        (see <code>&#8209;Gcn</code> option below). This is usually a good place to define the export
        macro.</td>
  </tr>

  <tr id="export_macro">
    <td></td>

    <td><code>export_macro=</code><i>macro_name</i></td>

    <td>This option has the same effect as issuing<br>
        <code>&#8209;Wb,skel_export_macro=</code><i>macro_name</i><br>
        <code>&#8209;Wb,stub_export_macro=</code><i>macro_name</i><br>
        <code>&#8209;Wb,anyop_export_macro=</code><i>macro_name</i>.<br>
        <code>&#8209;Wb,svnt_export_macro=</code><i>macro_name</i><br>
        <code>&#8209;Wb,exec_export_macro=</code><i>macro_name</i><br>
        <code>&#8209;Wb,conn_export_macro=</code><i>macro_name</i><br>
        This option is useful when building a single DLL
        or when some code generation is suppressed or not triggered
        (see option <code>&#8209;SS</code> below). </td>
  </tr>

  <tr id="export_include">
    <td></td>

    <td><code>export_include=</code><i>include_path</i></td>

    <td>This option has the same effect as specifying<br>
        <code>&#8209;Wb,stub_export_include=</code><i>include_path</i><br>
        <code>&#8209;Wb,skel_export_include=</code><i>include_path</i><br>
        <code>&#8209;Wb,anyop_export_include=</code><i>include_path</i>.<br>
        <code>&#8209;Wb,svnt_export_include=</code><i>include_path</i><br>
        <code>&#8209;Wb,exec_export_include=</code><i>include_path</i><br>
        <code>&#8209;Wb,conn_export_include=</code><i>include_path</i><br>
        This option goes with the previous option to build a DLL containing
        all code generation, or when some code generation is suppressed
        (see option <code>&#8209;SS</code> below).</td>
  </tr>

  <tr id="pch_include">
    <td></td>

    <td><code>pch_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of all TAO IDL compiler generated files.  This can be used with a
        precompiled header mechanism, such as those provided by Borland
        C++Builder or MSVC++.</td>
  </tr>

  <tr id="obv_opt_accessor">
    <td></td>

    <td><code>obv_opt_accessor</code></td>

    <td>The IDL compiler will generate code to optimize access to base class data
        for valuetypes.</td>
  </tr>

  <tr id="pre_include">
    <td></td>

    <td><code>pre_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        top of the each header file, before any other include statements. For
        example, ace/pre.h, which pushes compiler options for the Borland C++
        Builder and MSVC++ compilers, is included in this manner in all
        IDL-generated files in the TAO libraries and CORBA services.</td>
  </tr>

  <tr id="post_include">
    <td></td>

    <td><code>post_include=</code><i>include_path</i></td>

    <td>The compiler will generate code to include <i>include_path</i> at the
        bottom of the each header file. For example, ace/post.h, which pops
        compiler options for the Borland C++ Builder and MSVC++ compilers, is
        included in this manner in all IDL-generated files in the TAO libraries
        and CORBA services.</td>
  </tr>

  <tr id="include_guard">
    <td></td>

    <td><code>include_guard=</code><i>define</i></td>

    <td>The compiler will generate code the define in the C.h file to prevent
        users from including the generated C.h file. Useful for regenerating
        the pidl files in the archive.</td>
  </tr>

  <tr id="safe_include">
    <td></td>

    <td><code>safe_include=</code><i>file</i></td>

    <td>File that the user should include instead of this generated C.h file.
        Useful for regenerating the pidl files in the archive.</td>
  </tr>

  <tr id="unique_include">
    <td></td>

    <td><code>unique_include=</code><i>file</i></td>

    <td>File that the user should include instead of the normal includes in the C.h file.
        Useful for regenerating the *_include pidl files in the archive.</td>
  </tr>

  <tr id="stripped_filename">
    <td></td>

    <td><code>stripped_filename=</code><i>file</i></td>

    <td>File that should be generated as stripped_filename instead of taking
        the stripped filename of the input file.</td>
  </tr>

  <tr id="ciao_container_type">
    <td></td>

    <td><code>ciao_container_type=</code><i>file</i></td>

    <td>Type of container we are going to use, Session by default.</td>
  </tr>

  <tr id="E">
    <td><code>&#8209;E</code></td>

    <td>Invoke only the preprocessor</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Wp">
    <td><code>&#8209;Wp,</code><i>option_list</i></EM</TD></td>

    <td>Pass options to the preprocessor.</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;syntax&#8209;only</code></td>

    <td>Parse input files, but exit without generating any files.</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="d">
    <td><code>&#8209;&#8209;dump </br> -d</code></td>

    <td>Causes output of a dump of the AST and exits before any files would be
      created.</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;dump&#8209;builtins</code></td>

    <td>Implies --dump, but also dumps IDL defined by the compiler.</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;just&#8209;dump&#8209;builtins</code></td>

    <td>Dumps IDL defined by the compiler but ignores any files passed and
      exits.</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="D">
    <td><code>&#8209;D</code><i>macro_definition</i></td>

    <td>It is passed to the preprocessor</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="U">
    <td><code>&#8209;U</code><i>macro_name</i></td>

    <td>It is passed to the preprocessor</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="I">
    <td><code>&#8209;I</code><i>include_path</i></td>

    <td>It is passed to the preprocessor</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="A">
    <td><code>&#8209;A</code><i>assertion</i></td>

    <td>It is passed to the preprocessor</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Y">
    <td><code>&#8209;Yp,<i>path</i></code></td>

    <td>Specifies the path for the C preprocessor</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="H perfect_hash">
    <td><code>&#8209;H perfect_hash</code></td>

    <td>To specify the IDL compiler to generate skeleton code that uses perfect
        hashed operation demuxing strategy, which is the default strategy. Perfect
        hashing uses <a href="http://www.dre.vanderbilt.edu/~schmidt/PDF/gperf.pdf">gperf
        </a>program,
        to generate demuxing methods.&nbsp;</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="H dynamic_hash">
    <td><code>&#8209;H dynamic_hash</code></td>

    <td>To specify the IDL compiler to generate skeleton code that uses dynamic
        hashed operation demuxing strategy.&nbsp;</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="H binary_search">
    <td><code>&#8209;H binary_search</code></td>

    <td>To specify the IDL compiler to generate skeleton code that uses binary
        search based operation demuxing strategy.&nbsp;</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="H linear_search">
    <td><code>&#8209;H linear_search</code></td>

    <td>To specify the IDL compiler to generate skeleton code that uses linear
        search based operation demuxing strategy.  Note that this option is for testing purposes only and should not be used for production code since it's inefficient.</td>
    <td>&nbsp;</td>
  </tr>


  <tr id="in">
    <TD><code>&#8209;in</code></TD>
    <TD> To generate #include statements with &lt;&gt;'s for the standard
        include files (e.g. tao/corba.h) indicating them as non-changing
        files</TD>
    <td>&nbsp;</td>
  </TR>


  <tr id="ic">
    <TD><code>&#8209;ic</code></TD>
    <TD> To generate #include statements with ""s for changing
        standard include files (e.g. tao/corba.h). </TD>
    <td>&nbsp;</td>
  </TR>

  <tr id="g">
    <td><code>&#8209;g </code><i>path</i></td>

    <td>To specify the path for the perfect hashing program (GPERF). Default
        is $ACE_ROOT/bin/ace_gperf.&nbsp;</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="iC">
    <TD><code>&#8209;iC </code><i>path</i></TD>
    <TD> Generate #included stubs in *A.h prefixed with this path. </TD>
    <td>Default is local filename only (no prefix).&nbsp;</td>
  </TR>

  <tr id="o">
    <td><code>&#8209;o </code><i>path</i></td>

    <td>To specify the output directory to IDL compiler as to where all the
        IDL-compiler-generated files are to be put. By default, all the files are
        put in the current directory from where&nbsp;<tao_idl>is called.&nbsp;</td>
    <td>If the specified directory does not exist, it will be created, if any path
        that may precede the directory name already exists. If the directory
        itself already exists, no action is taken.&nbsp;</td>
  </tr>

  <tr id="oS">
    <td><code>&#8209;oS </code><i>path</i></td>

    <td>Same as -o option but applies only to generated *S.* files&nbsp;</td>
    <td>Default is value of -o option or current directory&nbsp;</td>
  </tr>

  <tr id="oA">
    <td><code>&#8209;oA </code><i>path</i></td>

    <td>Same as -o option but applies only to generated *A.* files&nbsp;</td>
    <td>Default is value of -o option or current directory&nbsp;</td>
  </tr>

  <tr id="oE">
    <td><code>&#8209;oE </code><i>path</i></td>

    <td>Same as -o option but applies only to generated *_exec.* files&nbsp;</td>
    <td>Default is value of -o option or current directory&nbsp;</td>
  </tr>

  <tr id="oN">
    <td><code>&#8209;oN </code><i>path</i></td>

    <td>Do not overwrite *_exec.* files&nbsp;</td>
    <td>When -Gex option is used, executor implementation files shouldn't be overwritten
      if they are already in the output directory.&nbsp;</td>
  </tr>

  <tr id="hc">
    <td><code>&#8209;hc</code></td>

    <td>Client's header file name ending. Default is "C.h".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="hs">
    <td><code>&#8209;hs</code></td>

    <td>Server's header file name ending. Default is "S.h".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="hT">
    <td><code>&#8209;hT</code></td>

    <td>Server's template header file name ending. Default is "S_T.h".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="cs">
    <td><code>&#8209;cs</code></td>

    <td>Client stub's file name ending. Default is "C.cpp".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="ci">
    <td><code>&#8209;ci</code></td>

    <td>Client inline file name ending. Default is "C.inl".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="ss">
    <td><code>&#8209;ss</code></td>

    <td>Server skeleton file name ending. Default is "S.cpp".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="sT">
    <td><code>&#8209;sT</code></td>

    <td>Server template skeleton file name ending. Default is "S_T.cpp".</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="t">
    <td><code>&#8209;t</code></td>

    <td>Temporary directory to be used by the IDL compiler.
    </td>
    <td>Unix: use environment variable TEMPDIR if defined, else use /tmp/.
        Windows NT/2000/XP:
        use environment variable TMP or TEMP if defined, else use the
        Windows directory.
    </td>
  </tr>

  <tr id="Cw">
    <td><code>&#8209;Cw</code></td>

    <td>Output a warning if two identifiers in the same scope differ in
        spelling only by case (default is output of error message).</td>

    <td>This option has been added as a nicety for dealing with legacy
        IDL files, written when the CORBA rules for name resolution
        were not as stringent.</td>
  </tr>

  <tr id="Ce">
    <td><code>&#8209;Ce</code></td>

    <td>Output an error if two identifiers in the same scope differ in
        spelling only by case (default).</td>

    <td>&nbsp;</td>
  </tr>

  <tr id="ae">
    <td><code>&#8209;ae</code></td>

    <td>Output an error if an anonymous type is seen. Anonymous types are
        deprecated by the OMG spec (default is no output).</td>

    <td>This behavior can be selected globally by defining IDL_ANON_ERROR in
        config.h. It may then be overridden locally by
        <code>&#8209;aw</code> or <code>&#8209;as</code></td>
  </tr>

  <tr id="aw">
    <td><code>&#8209;aw</code></td>

    <td>Output a warning if an anonymous type is seen. Anonymous types are
        deprecated by the OMG spec (default is no output).</td>

    <td>This behavior can be selected globally by defining IDL_ANON_WARNING in
        config.h. It may then be overridden locally by
        <code>&#8209;ae</code> or <code>&#8209;as</code></td>
  </tr>

  <tr id="as">
    <td><code>&#8209;as</code></td>

    <td>Silence any diagnostic output for anonymous types (default).</td>

    <td>This behavior can be selected globally by defining IDL_ANON_SILENT in
        config.h. It may then be overridden locally by
        <code>&#8209;aw</code> or <code>&#8209;ae</code></td>
  </tr>

  <tr id="GC flag">
    <td><code>&#8209;GC </code></td>

    <td>Generate AMI stubs ("sendc_" methods, reply handler stubs, etc)</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="GH flag">
    <td><code>&#8209;GH </code></td>

    <td>Generate AMH stubs, skeletons, exception holders, etc.</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="GM flag">
    <td><code>&#8209;GM </code></td>

    <td>Generate AMI4CCM code</td>
    <td>*A.idl file (containing callback interface, "sendc_" methods
        and CCM connector) plus addition to CCM servant and executor</td>
  </tr>

  <tr id="Gp">
    <td><code>&#8209;Gp </code></td>

    <td>Generated collocated stubs that use <code>Thru_POA</code> collocation strategy (default)</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Gd">
    <td><code>&#8209;Gd </code></td>

    <td>Generated collocated stubs that use <code>Direct</code> collocation strategy</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Gce">
    <td><code>&#8209;Gce </code></td>

    <td>Generated code for CORBA/e. This reduces the size of the generated code</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Gmc">
    <td><code>&#8209;Gmc </code></td>

    <td>Generated code for Minimum CORBA. This reduces the size of the generated code</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Gcl">
    <td><code>&#8209;Gcl </code></td>

    <td>Generated code for LwCCM. This reduces the size of the generated code</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Gsp">
    <td><code>&#8209;Gsp </code></td>

    <td>Generate client smart proxies</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Gt">
    <td><code>&#8209;Gt</code></td>

    <td>Generate optimized TypeCodes</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="GX">
    <td><code>&#8209;GX</code></td>

    <td>Generate empty A.h file</td>
    <td>Used by TAO developers for generating an empty A.h file when the
        -GA option can't be used. Overrides -Sa and -St.
    </td>
  </tr>

  <tr id="Guc">
    <td><code>&#8209;Guc</code></td>

    <td>Generate uninlined constant if defined in a module</td>
    <td>Inlined (assigned a value in the C++ header file) by default, but this causes a
      problem with some compilers when using pre-compiled headers. Constants declared
    at global scope are always generated inline, while those declared in an interface
    or a valuetype never are - neither case is affected by this option.</td>
  </tr>

  <tr id="Gsd">
    <td><code>&#8209;Gsd</code></td>

    <td>Generate static description operations</td>
    <td>Generate static description operations to retrieve the repository id
        or interface name as string. Can be useful for template programming</td>
  </tr>

  <tr id="Gse">
    <td><code>&#8209;Gse</code></td>

    <td>Generate explicit export of sequence's template base class</td>
    <td>Occasionally needed as a workaround for a bug in Visual Studio
        (.NET 2002, .NET 2003 and Express 2005) where the template
        instantiation used for the base class isn't automatically exported</td>
  </tr>

  <tr>
    <td><code>&#8209;GI</code></td>

    <td>Generate boiler-plate files that contain empty servant implementations </td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GIh </code><i>arg</i></td>

    <td>Servant implementation header file name ending</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GIs </code><i>arg</i></td>

    <td>Servant implementation skeleton file name ending</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GIb </code><i>arg</i></td>

    <td>Prefix to the implementation class names</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GIe </code><i>arg</i></td>

    <td>Suffix to the implementation class names</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GIc</code></td>

    <td>Generate copy constructors in the servant implementation template files</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GIa</code></td>

    <td>Generate assignment operators in the servant implementation template files</td>
    <td>&nbsp;</td>
  </tr>

  <tr>
    <td><code>&#8209;GId</code></td>

    <td>Generate IDL compiler source file/line# debug info in implementation files</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="GT">
    <td><code>&#8209;GT</code></td>

    <td>Enable generation of the TIE classes, and the *S_T.* files that
    contain them.</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="GA">
    <td><code>&#8209;GA</code></td>

    <td>Generate type codes and Any operators in *A.h and *A.cpp</td>
    <td>Decouples client and server decisions to compile and link
        TypeCode- and Any-related code, which is generated in
        *C.h and *C.cpp by default. If -Sa or -St also appear, then
        an empty *A.h file is generated.</td>
  </tr>

  <tr id="Gos">
    <td><code>&#8209;Gos</code></td>

    <td>Generate std::ostream insertion operators for IDL declarations</td>
    <td>ORB IDL declarations (including the basic type sequences) don't
        have these operators generated by default, to avoid the increased
        footprint. To turn on this generation for ORB IDL files, set
        <code>gen_ostream=1</code> in your <i>default.features</i> MPC file.
        If this option is used on application IDL that references any of
        the predefined basic sequence IDL types, TAO must be compiled
        with the <code>gen_ostream</code> feature turned on.</td>
  </tr>

  <tr id="Gata">
    <td><code>&#8209;Gata</code></td>

    <td>Generate the AnyTypeCode_Adapter version of the Any insert policy</td>
    <td>When generating arg traits instantiations, this option forces
        (if Any support in general is not suppressed) the generation
        of <code>Any_Insert_Policy_AnyTypeCode_Adapter</code> for the
        last template parameter. This option is used when generating
        arg traits for the sequences of basic types in the ORB, so
        their arg traits may be included in files generated from
        application IDL whether Any support is suppressed in the
        application IDL processing or not.</td>
  </tr>

  <tr id="Gsv">
    <td><code>&#8209;Gsv</code></td>

    <td>Generate CIAO servant code for component and home IDL declarations</td>

    <td></td>
  </tr>

  <tr id="Gex">
    <td><code>&#8209;Gex</code></td>

    <td>Generate CIAO executor implementation code for component and home IDL declarations</td>
    <td>
    These files have empty function bodies for all facet, supported and inherited operations,
    to be filled in by the developer.</td>
  </tr>

  <tr id="Gexr">
    <td><code>&#8209;Gexr</code></td>

    <td>Generate CIAO executor implementation code for component and home IDL declarations, including
      an implementation of the ACE_Reactor</td>
    <td>When applying <code>&#8209;Gexr</code>, the TAO IDL compiler will generate an extra method which
      retrieves the ACE_Reactor from the ORB. One should use this option when an ACE_reactor.
      In code, use 'this-&gt;reactor ()' to get the ACE_Reactor. A CORBA::INTERNAL
      exception is thrown when the ACE_Reactor cannot be retrieved.<br/>
      The goal of this method is to prevent memory leaks.</td>
  </tr>

  <tr id="Gcn">
    <td><code>&#8209;Gcn</code></td>

    <td>Generate CIAO connector implementation code for connector IDL declarations</td>
    <td>Generate a complete implementation for each connector. Specialized at present
    for DDS connectors.</td>
  </tr>

  <tr id="Gts">
    <td><code>&#8209;Gts</code></td>

    <td>Generate DDS type support IDL in a separate IDL file</td>
    <td>Not used with OpenDDS, since OpenDDS's IDL processor does this already.</td>
  </tr>

  <tr id="Glem">
    <td><code>&#8209;Glem</code></td>

    <td>Generate CIAO executor IDL for component and home IDL declarations</td>

    <td></td>
  </tr>

  <tr id="Gsw">
    <td><code>&#8209;Gsw</code></td>

    <td>Generate CIAO servant code to support component swapping</td>
    <td>Modify the generated servant code and container file includes
    to support on-the-fly swapping of components.</td>
  </tr>

  <tr id="Gxhst">
    <td><code>&#8209;Gxhst</code></td>

    <td>Generate the stub export header file</td>
    <td>This is the file specified in <code>&#8209;Wb,stub_export_include=<i>include_path</i></code></td>
  </tr>

  <tr id="Gxhsk">
    <td><code>&#8209;Gxhsk</code></td>

    <td>Generate the skeleton export header file</td>
    <td>This is the file specified in <code>&#8209;Wb,skel_export_include=<i>include_path</i></code></td>
  </tr>

  <tr id="Gxhsv">
    <td><code>&#8209;Gxhsv</code></td>

    <td>Generate the CIAO servant export header file</td>
    <td>This is the file specified in <code>&#8209;Wb,svnt_export_include=<i>include_path</i></code></td>
  </tr>

  <tr id="Gxhex">
    <td><code>&#8209;Gxhex</code></td>

    <td>Generate the executor export header file</td>
    <td>This is the file specified in <code>&#8209;Wb,exec_export_include=<i>include_path</i></code></td>
  </tr>

  <tr id="Gxhcn">
    <td><code>&#8209;Gxhcn</code></td>

    <td>Generate the connector export header file</td>
    <td>This is the file specified in <code>&#8209;Wb,conn_export_include=<i>include_path</i></code></td>
  </tr>

  <tr id="Sa">
    <td><code>&#8209;Sa</code></td>

    <td>Suppress generation of the Any operators</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Sal">
    <td><code>&#8209;Sal</code></td>

    <td>Suppress generation of the Any operators for local interfaces only</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Sat">
    <td><code>&#8209;Sat</code></td>

    <td>Suppress generation of arg traits instantiations</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Sp">
    <td><code>&#8209;Sp</code></td>

    <td>Suppress generation of collocated stubs that use <code>Thru_POA</code> collocation strategy</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="Sd">
    <td><code>&#8209;Sd</code></td>

    <td>Suppress generation of collocated stubs that use <code>Direct</code> collocation strategy (default)</td>
    <td>&nbsp;</td>
  </tr>

  <tr id="St">
    <td><code>&#8209;St</code></td>

    <td>Suppress generation of typecodes</td>

    <td>Also suppresses the generation of the Any operators, since they need the
        associated typecode.</td>
  </tr>

  <tr id="Sm">
    <td><code>&#8209;Sm</code></td>

    <td>Suppress C++ code generation from CCM 'implied' IDL.</td>
    <td>This code generation is achieved by default using a 'preprocessing' visitor
        that modified the AST and is launched just before the code generating
        visitors. There is a new tool in CIAO that converts the entire IDL file
        into one containing explicit declarations of the implied IDL types.
        For such a file, we don't want the preprocessing visitor to be launched,
        so this command line option will suppress it.</td>
  </tr>

  <tr id="SS">
    <td><code>&#8209;SS</code></td>

    <td>Suppress generation of the skeleton implementation and inline file.</td>
    <td>This option doesn't check whether something is generated in the files. It
        just suppresses them without looking at any possible contents;</td>
  </tr>

  <tr id="Sci">
    <td><code>&#8209;Sci</code></td>

    <td>Suppress generation of the client inline file.</td>
    <td>This option doesn't check whether something is generated in the file. It
        just suppresses it without looking at any possible contents;</td>
  </tr>

  <tr id="Scc">
    <td><code>&#8209;Scc</code></td>

    <td>Suppress generation of the client stub file.</td>
    <td>This option doesn't check whether something is generated in the file. It
        just suppresses it without looking at any possible contents;</td>
  </tr>

  <tr id="Sch">
    <td><code>&#8209;Sch</code></td>

    <td>Suppress generation of the client header file.</td>
    <td>This option doesn't check whether something is generated in the file. It
        just suppresses it without looking at any possible contents;</td>
  </tr>

  <tr id="Ssi">
    <td><code>&#8209;Ssi</code></td>

    <td>Suppress generation of the servant inline file.</td>
    <td>This option doesn't check whether something is generated in the file. It
        just suppresses it without looking at any possible contents;</td>
  </tr>

  <tr id="SS">
    <td><code>&#8209;SS</code></td>

    <td>Suppress generation of the servant skeleton file.</td>
    <td>This option doesn't check whether something is generated in the file. It
        just suppresses it without looking at any possible contents;</td>
  </tr>

  <tr id="Ssh">
    <td><code>&#8209;Ssh</code></td>

    <td>Suppress generation of the servant header file.</td>
    <td>This option doesn't check whether something is generated in the file. It
        just suppresses it without looking at any possible contents;</td>
  </tr>

  <tr id="Ssvntc">
    <td><code>&#8209;Ssvntc</code></td>

    <td>Suppress generation of the servant implementation file (_svnt.cpp).</td>
    <td>This option doesn't check whether something is generated in the files. It
        just suppresses them without looking at any possible contents;</td>
  </tr>

  <tr id="Ssvntt">
    <td><code>&#8209;Ssvntt</code></td>

    <td>Suppress generation of the servant templated files (_svnt_T.{h,cpp}).</td>
    <td>This option doesn't check whether something is generated in the files. It
        just suppresses them without looking at any possible contents;</td>
  </tr>

  <tr id="Sorb">
    <td><code>&#8209;Sorb</code></td>

    <td>Suppress generation of the ORB.h include.</td>
    <td>This option is useful when regenerating pidl files in the core
  TAO libs to prevent cyclic includes;</td>
  </tr>

  <tr id="Se">
    <td><code>&#8209;Se</code></td>

    <td>Disable custom header file name endings for files
        that are found in TAO specific include directories
        (i.e. $TAO_ROOT, $TAO_ROOT/tao, $TAO_ROOT/orbsvcs,
        $TAO_ROOT/CIAO, $TAO_ROOT/CIAO/ciao, $TAO_ROOT/CIAO/ccm).</td>
    <td>This option is useful when used together with -hs or -hc. I.e. when user
        needs custom file name endings for his/her own files but still wants to
        use TAO specific files with their original endings;</td>
  </tr>

  <tr id="Sg">
    <td><code>&#8209;Sg</code></td>

    <td>Disable generation of unique preprocessor guards for generated
        header files. The guards will still be generated, but without
        the unique random extension.</td>
    <td>This option is useful when a system has several versions of a
        generated header file, and only the newest version is to be
        included by the preprocessor. The default behavior will
        generate a unique extension for each version, subverting
        the desired function of the preprocessor in such a system.</td>
  </tr>

  <tr id="Sfr">
    <td><code>&#8209;Sfr</code></td>

    <td>Disable CIAO servant code generation to register valuetype
        factories for events.</td>
    <td>By default, the generated CIAO servant constructor will register
        a valuetype factory with the container ORB for each eventtype
        used in an event source or sink port. However, if an eventtype
        has a factory function or other operation, the generated
        valuetype factory class will be abstract and must be overridden
        by the user, and registered in hand-written code.</td>
  </tr>
  <tr id="TS">
    <td><code>&#8209;TS <i>value</i></code></td>

    <td>Set tab size for generated files</td>
    <td>Default is 2 spaces</td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;unknown&#8209;annotations&nbsp;ARG</code></td>

    <td>
      Controls the reaction when encountering undefined annotations. The valid
      arguments to this option are <code>warn-once</code> (Default),
      <code>warn-all</code>, <code>error</code>, and <code>ignore</code>.
    </td>
    <td>
      The difference between <code>warn-once</code> and <code>warn-all</code>
      is that with <code>warn-once</code> using annotations the same local name
      will not be warned about more than once, while <code>warn-all</code> will
      warn with every usage.
    </td>
  </tr>

  <tr>
    <td><code>&#8209;&#8209;preprocessor&#8209;input&nbsp;KIND</code></td>

    <td>
      <p>Set the C preprocessor file input method. <code>KIND</code> must be
      <code>guess</code> (default), <code>direct&#8209;with&#8209;e</code>,
      <code>direct&#8209;without&#8209;e</code>, <code>direct&#8209;gcc</code>,
      or <code>copy</code>.</p>

      <p><code>direct-without-e</code> passes the IDL file path to the
      preprocessor directly. Most, if not all, standalone C preprocessors like
      GNU and Clang <code>cpp</code> or <code>mcpp</code> can use this.</p>

      <p><code>direct-with-e</code> is the same as
      <code>direct-without-e</code> except <code>&#8209;E</code> is also
      passed. <code>CL</code>, the Visual Studio C++ compiler can use this.</p>

      <p><code>direct&#8209;gcc</code> is same as
      <code>direct&#8209;with&#8209;e</code>, but it's for <code>g++</code> and
      <code>clang++</code> which also require <code>&#8209;x c++</code> to be
      passed.</p>

      <p><code>copy</code> makes a copy of the IDL file to a temporary location
      and passes that to the preprocessor.</p>

      <p><code>guess</code> picks one of the previous based on the name of the
      preprocessor.</p>
    </td>

    <td>
      Although <code>copy</code> should work with all compilers, it only
      approximates relative includes using <code>&#8209;I.</code>, which fails under
      certain conditions. Therefore the direct kinds are preferred by
      <code>guess</code>.
    </td>
  </tr>

</table> <P>

<hr>
Back to the TAO <A HREF="index.html">documentation</A>.

<!--#include virtual="/~schmidt/cgi-sig.html" -->

</body>
</html>
