<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
   <title>TAO Release Information and TODO List</title>
</head>
<body text="#000000" bgcolor="#FFFFFF">
<!--  -->
<center>
<hr></center>

<center>
<h3>
Release Information for The ACE ORB (TAO)</h3></center>
This document contains information on the following topics related to the
<a href="../../VERSION">current
release</a> of <a href="http://www.dre.vanderbilt.edu/TAO">TAO</a>:

<table BORDER=0 CELLSPACING=0 CELLPADDING=10 >
<tr>
<td VALIGN=TOP>
<b>ACE Related</b>
<br>
<ul>
<li>
<a href="#ace">ORB-related ACE Changes</a></li>
</ul>
</td>
<td VALIGN=TOP>

<b>Misc Entries</b>
<br>
<ul>

<li>
<a href="#CORBA-conformance">CORBA Standards Conformance</a></li>


<li>
<a href="#dove">The DOVE Demo</a></li>

<li>
<a href="TODO.html">TODO list</a></li>
</ul>
</td>

</table>

<table BORDER=0 CELLSPACING=0 CELLPADDING=10 >
<tr>
<td VALIGN=TOP>
<b>ORB Related</b>
<br>
<ul>
<li>
<a href="amh.html">Asynchronous Method Handling (AMH)</a></li>

<li>
<a href="#ami">Asynchronous Method Invocation (AMI)</a></li>

<li>
<a href="#csd">Custom Servant Dispatching (CSD)</a></li>

<li>
<a href="../dynany/index.html">Dynamic Any</a></li>

<li>
<a href="#leader">Global Resources and Leader-Follower Model</a></li>

<li>
<a href="#idl">IDL Compiler</a></li>

<li>
<a href="../implrepo/index.html">Implementation Repository</a></li>

<li>
<a href="../interfacerepo/index.html">Interface Repository</a></li>

<li>
<a href="#localobject">Local Interfaces</a></li>

<li>
<a href="#locate">Locate requests</a></li>
<li>
<a href="#forwarding">Location Forwarding</a></li>



<li>
<a href="#miop">Multicast InterORB Protocol (MIOP)</a></li>

<li>
<a href="orbcore.html">ORB Core</a></li>

<li>
<a href="OBV.html">Object-by-Value</a></li>

<li>
<a href="../poa_migration.html">POA Migration Notes</a></li>


<li>
<a href="#pp">Pluggable Protocols</a></li>

<li>
<a href="#interceptor">Portable Interceptors</a></li>

<li>
<a href="#poa">Portable Object Adapter (POA)</a></li>


<li>
<a href="../rtcorba/index.html">Real-Time CORBA</a></li>

<li>
<a href="#sciop">SCIOP Support in TAO</a></li>

<li>
<a href="#ipv6">IPv6 Support in TAO</a></li>

<li>
<a href="../Smart_Proxies.html">Smart Proxies</a></li>
</ul>
<td VALIGN=TOP>
<b>CORBA Services Related</b>
<br>
<ul>
<li>
<a href="#av">Audio/Video Streaming Service</a></li>
<li>
<a href="#cservices">Concurrency Service</a></li>
<li> Event Service
<ul>
<li>
<a href="#ec">CORBA Event Service</a></li>
<li>
<a href="ftrt_ec.html">Fault_Tolerant/Real_Time Event Service</a></li>
<li>
<a href="ec.html">Real-time Event Service</a></li>
</ul>

<li>
<a href="#fault_tolerance">Fault Tolerant Services&nbsp;</a></li>

<li>
<a href="#loadbalancer">Load Balancer Service</a></li>


<li>
<a href="#nservices">Naming Service&nbsp;</a></li>
<li>
Notification Service
<ul>
<li>
<a href="#notify">Notification Service</a></li>
<li>
<a href="#rt_notify">Real-Time Notification Service</a></li>
</ul>
<li>
<a href="PSS.html">Persistent State Service</a></li>
<li>
<a href="#pservices">Property Service</a></li>
<li>Scheduling Service
<ul>
<li>
<a href="#scheduling">Kokyu Scheduling Service</a></li>
<li>
<a href="rtc10_sched.html">RTCORBA 1.0 Scheduling Service</a></li>
</ul>

<li>
<a href="#security">Security Service</a></li>

<li>
<a href="#log">Telecom Log Service</a></li>
<li>
<a href="#ts">Time Service</a></li>
<li>
<a href="#tservices">Trading Service</a></li>



</ul>
</td>

<td VALIGN=TOP>
</td>
</tr>
</table>


<table BORDER=0 CELLSPACING=0 CELLPADDING=10 >
<tr>


</table>


A complete list of all modifications to TAO is available in the <a href="../../ChangeLogs">ChangeLogs</a>.
<p>
<hr>
<h3>
<a NAME="ace"></a>ACE Wrappers</h3>
Current status: (As of July 07, 2003.)
<ul>
<li>
The following changes are related to improving memory management of Event
Handlers when they interact with Reactors (and Timer Queues). When a handler
is registered with the Reactor, the Reactor increments the reference count
on the handler. The Reactor also increments this reference count when making
upcalls on the handler. The reference count is decremented when an upcall
completes or when the handler is removed from the Reactor.</li>

<p>This mechanism is similar to what happens between POAs and Servants
and it allows for the safe deletion of handlers. This mechanism is particularly
need for multi-threaded applications that can have multiple threads executing
upcalls on a handler that needs to be shutdown in a safe manner. The following
illustrates an example of how this mechanism works:
<ul>
<li>
When a handler is created, it reference count is one.</li>

<li>
After the handler is registered with the Reactor, it reference count becomes
two.</li>

<li>
At this point, the handler creator can let go of the handler reference,
bringing down the reference count to one.</li>

<li>
For each thread executing upcalls on the handler, the Reactor increments
the reference count by one. So if three threads were simultaneously making
upcalls on a handler, the reference count would be four.</li>

<li>
Assuming an external event (and thread) decides to close the handler. It
simply removes the handler from the Reactor. This decreases the reference
count to three.</li>

<li>
As each thread completes their upcall, the reference reduces.</li>

<li>
Once the final thread exits the upcall, the reference reaches zero, and
the handler is finally deleted.</li>
</ul>
This mechanism ensures that the handler is not deleted until the final
upcall thread exits the handler.
<p>Reference counting on handlers is optional and is disabled by default.
To enable reference counting on a handler, reset its reference counting
policy to "ENABLED".
<p>To facilitate reference counting of handlers, an ACE_Event_Handler_var
class was added. This class is akin to the PortableServer::ServantBase_var
class.
<p>Similar reference counting related changes were made to the Timer Queues
so that handlers can be used in a thread safe manner with the queues.
<p>The Connector implementation was completely revised to utilize the new
memory management mechanisms and remove existing concurrency bugs.
<p>Several new examples/tests were added: Reference_Counted_Event_Handler_Test,
MT_Reference_Counted_Event_Handler_Test, MT_Reference_Counted_Notify_Test,
Timer_Queue_Reference_Counting_Test, NonBlocking_Conn_Test, Reactor_Registration_Test,
WFMO_Reactor_Test, Timer_Cancellation_Test</ul>

<hr>
<h3>
<a NAME="idl"></a>IDL Compiler</h3>
Point of contact: <a href="mailto:j.parsons@vanderbilt.edu">Jeff Parsons</a>
<p>Current status: (As of November 13, 2006.)
<ul>
<li>
Generated code closely follows the C++ Mapping specified in the latest
C++ mapping for CORBA 3.0 (Document ptc/03-06-03).</li>

<li>
IDL compiler is now able to generate code that support native C++ exceptions
on the stubs and skeletons. With this strict mapping, the CORBA::Environment
parameter is no longer generated. The default behavior is to generate code
without the extra parameter on plaforms with native exceptions and with
the extra parameter in platforms without native exceptions. Use the -Ge
flag to override the defaults.</li>

<li>
We are now able to handle shared case labels and default label in unions.
In addition, whenever appropriate, we are also able to generate the "default
()" operation.</li>

<li>
We are now able to handle recursive types. We are also able to generate
optimized typecodes.</li>

<li>
Struct members of type strings and arrays of strings now use the managed
type instead of the _var type. This change was necessary to conform to
the IDL->C++ mapping.</li>

<li>
Fixed a large number of problems with anonymous arrays and sequences inside
structs and unions. The name of anonymous sequence needs to be fixed as
per latest C++ mapping spec.</li>

<li>
Compile problems with sequence of forward declared interfaces is fixed.
In addition, problems with sequence of CORBA::Objects is fixed. In this
specific case, we were not generating the _downcast and _upcast methods.</li>

<li>
Some more problems with the front-end have been fixed. In particular, oneway
operations with a "raises" clause or having an "inout", "out", or "return"
mode is flagged as an error.</li>

<li>
For platforms that support namespaces, we now allow reopening modules.</li>

<li>
Support for generating compiled marshaling code is added. Use the -Gc option.
However, this needs thorough testing before we can claim success. Unions
are still a problme with compiled marshaling.</li>

<li>
The problem of "#include"ing the relative path of the header files rather
than the paths of their corresponding IDL files has been fixed. tao_idl
now generates #include path names that are derived from the IDL files that
are #include'd in the main idl file.</li>

<li>
Added options to IDL compiler to specify file name endings for the IDL-generated
stubs, skeletons and the various header files. Please refer to the <a href="../compiler.html">IDL
compiler options</a> for details.</li>

<li>
Verified support for the "long long" and "unsigned long long" datatypes.
On platforms that do not support 64 bit longs we provided <i>partial</i>
emulation through ACE_U_LongLong.</li>

<li>
Perfect Hashed Operation Lookup Strategy has been added to the IDL Compiler.
-P flag to <tt>tao_idl</tt> enables the perfect hased lookup strategy.
This strategy uses <a href="http://www.cs.wustl.edu/~schmidt/gperf.ps.gz">GPERF</a>,
the GNU's Perfect Hash Function Generator written by Dr.Douglas C. Schmidt.
Right now, GPERF works only on Solaris. Any work on porting GPERF to other
platforms will be highly appreciated.</L1></li>

<li>
The &lt;&lt;= and >>= operators for user-defined types are now generated.</li>

<li>
Completely redesigned the IDL compiler using the Visitor patterns. Many
incomplete issues have been resolved. These include support for "sequence
of typecodes", passing object references as in, inout, and out parameters.
Code generation for sequences is also properly handled i.e., for a named
sequence such as <tt>typedef sequence&lt;char>CharSeq;</tt>, we now generate
a new class (and hence a type) called "class CharSeq". Arrays are still
being worked out and will be done soon. An important difference in the
generated code is that the skeletons now use a table driven approach very
similar to the stubs.</li>

<li>
Support for the "native" keyword added.</li>

<li>
The problem of incorrect code generation for typedefs defined in an imported
file is resolved.</li>

<li>
Problems when interfaces use single or multiple inheritance solved. The
problem was with the demultiplexing code, the generated operation tables,
and the dispatching mechanism. We are currently testing this with the Event
Channel code.</li>

<li>
The problems arising due to public virtual inheritance when casting from
an interface class to CORBA::Object_ptr has been solved. We do this casting
inside the stubs/skeletons rather than first converting an interface class
pointer to a void*, storing it in an Any, and casting it to CORBA::Object_ptr
in the encode/decode methods. The casting inside the stubs/skeletons work
because the compiler has knowledge of both types.</li>

<li>
Include files are handled properly. So are the definitions used inside
the include files that are used in the currently parsed files.</li>

<li>
Generates C++ stubs and skeletons that use TAO's
<a href="http://www.cs.wustl.edu/~schmidt/HICSS-97.ps.gz">
interpretive IIOP protocol engine</a>.</li>

<li>
Support dynamic libraries on NT, i.e., marking classes for DLL export was
added. Two backend options control the name of the export macro, and the
name of an extra include file were the macro is defined; the options are
<tt>-Wp,export_macro=MACRO_NAME-Wp,export_include=INCLUDE_NAME</tt>.</li>

<li>
The IDL compiler generates now source code for sequences. The user has
now the option to use these generated sequence classes or to use, as up
to now, the template instatiation. If TAO_LACKS_TEMPLATE_SPECIALIZATION
is defined, then template instantiation will be used, else not. The reason
for this was, that some C++ compilers did not support template instantiation
properly and sequences were based on templates. The generated source code
is mainly contained in the generated header file directly in the class
declaration.</li>

<li>
The IDL Compiler generates templates for servant implementations. The options
are -GI [ h | s | b | e | c ]</li>

<li>
The IDL compiler generates source code for the management and (de)marshaling
of wide characters and wide strings, enabling the sending and receiving
of Unicode over the wire. However, wide character and wide string literals
are not yet portable to Unix platforms (see entry under Future Work below).</li>

<li>
Since the CORBA spec requires that all enums be 32 bits, and some compilers
will try to use less space if the enum values are small enough, the IDL
compiler now appends&nbsp;<enum name>_TAO_ENUM_32BIT_ENFORCER = 0xFFFFFFFF
to every enum. This appended enum value is not part of the IDL compiler's
internal representation of the enum, so unions that use the enum as a discriminator
will not have incorrect _default() code generated for them.</li>

<li>
The IDL compiler generates a C++ ostream operator for IDL exceptions. So
far only the repository ID is output, but this may be enhanced when requirements
and/or desires become clearer.</li>

<li>
The IDL compiler has support for valuetypes (see release notes
for valuetypes for details). </li>

<li>
As part of the implementation of interceptors, the TAO IDL compiler now
generates interception points in the client and server, as well as the
prepare_header method in the stubs.</li>

<li>
Scoping and name resolution rules have changed in CORBA with version 2.3.
The IDL compiler now conforms to these new rules.</li>

<li>
IDL compiler now supports the CORBA AMI callback model, generating code
for reply handlers and reply stubs if the -GC command line option is used.
The TAO library must be compiled with TAO_HAS_CORBA_MESSAGING = 1. If this
is done, TAO_HAS_AMI_CALLBACK will automatically be defined to 1 as well.
IDL_HAS_VALUETYPE is defined to 1 by default.</li>

<li>
New command line option -So added to suppress generation of ostream operators
for exceptions.</li>

<li>
New command line option -Sc added to suppress generation of tie classes
and *S_T.* files. The default is still to generate them.</li>

<li>
IDL compiler now handles escaped identifiers (CORBA 2.3.1). An identifier
appearing in an IDL file with a leading underscore will appear in generated
code without the underscore. This enables the use of identifiers in generated
code identical to IDL keywords, as specified in CORBA 2.3.1. If the resulting
identifier matches a C++ keyword, "_cxx_" will be prepended in generated
code as before.</li>

<li>
The -St option to suppress generation of typecodes now also suppresses
the generation of the Any insertion and extraction operators. The extraction
operators require the associated typecode, so the generated code for those
operators would not compile when the -St option was used.</li>

<li>
Option -Ge 2 added which generates 'throw' instead of ACE_THROW_SPEC, ACE_THROW,
and ACE_RETHROW. Since the expansion of ACE_THROW_RETURN is platform-dependent,
it was left as is. Same for TAO_INTERCEPTOR_THROW, since it sometimes expands
to ACE_THROW_RETURN. Of course ACE_HAS_EXCEPTIONS must be defined for this
option to work.</li>

<li>
Removed generation of ostream operators for user exceptions, along with
the command line option to suppress this generation. The ostream operator
defined in the base class CORBA::Exception works fine and produces the
same output.</li>

<li>
The TAO IDL compiler is no longer monolithic. It is composed of a top-level
executable, a front end library and a back end library. This will enable
different back ends to be plugged in for code generation in different languages,
and for IfR administration. Different back ends may require a few changes
to the executable (described below), but the front end library can remain
unchanged. The chain of dependencies is as follows:</li>

<blockquote>FE : ACE
<br>BE : FE
<br>EXE : FE, BE</blockquote>
Executing the Makefile (or the TAO_IDL Compiler project in the MSVC 'tao_idl'
workspace) will build whatever is required in the proper order, as before.
Back end files, classes and functions required by the executable are as
follows:
<blockquote>be.h - file containing #includes of the major BE file headers.
<br>TAO_Codegen - class, holds output stream references for the various
generated files.
<br>TAO_CODEGEN - ACE_Singleton typedef of the above class.
<br>tao_cg - pointer to instance of TAO_CODEGEN.
<br>be_generator - class, inherits from AST_Generator in FE and generates
AST nodes.
<br>void BE_produce (void) - global function, starts AST traversal for
code generation.
<br>BE_GlobalData - class, holds default/command line arg settings specific
to BE.
<br>be_global - pointer to instance of above class.</blockquote>
All the code in the executable that may need to be modified for different
back ends in contained in the file drv_args.cpp. Code in this file processes
the command line arguments, outputs a usage message, and performs other
miscellaneous BE initialization.
<li>
The IDL compiler can how handle interfaces forward declared in one IDL
file and defined in another. It will handle interfaces that are mutually
dependent across two IDL files, as long as code generated from both IDL
files is included in the same C++ build.</li>

<li>
Generation of template tie class declarations has been moved from the *S.h
file to the *S_T.h file. The new SunCC 5.2 compiler does not require that
template source code be included in the header file, but it does require
that template declarations and implementations be in the same 'compilation
unit' that is, the same header/source file combination. Generated ifdef
guards prevent the compilation of tie class code if the target platform
does not support namespaces. For such platforms, TAO maps the IDL 'module'
keyword to a class instead of to 'namespace', and C++ does not allow template
class declarations to occur inside another class.</li>

<li>
IDL compiler can now process multiple IDL files per execution, on all platforms.
A separate process is spawned for each file. IDL files and command line
options may appear in any order on the command line. Any option not starting
with '-' will be treated as a filename.</li>

<li>
Support for value types has been expanded to include forward declared value
types, sequences of value types, and factory methods. Also, work to support
Anys and type codes for value types is in progress.</li>

<li>
Support for #pragma prefix has been revamped and improved to be compliant
(the prefix is now cleared when leaving the scope or the included IDL file
where it was defined), and support for #pragma version and #pragma ID has
been added.</li>

<li>
Support for forward declared structs and unions has been added. In compliance
with CORBA 2.6, such forward declarations must be fully defined in the
same compilation unit, and may be used only in sequence declarations, which
in turn may be used in the declaration of recursive structs and unions.
Use of a forward declared struct or union as an aggregate type member or
as an operation parameter will generat an error message.</li>

<li>
Support for enum constants has been added.</li>

<li>
The IDL compiler can now handle concatenation of string literals, for example</li>

<blockquote>const string foo = "hel" "lo " "the" "re";</blockquote>

<li>
Support for abstract interfaces has been added.</li>

<li>
Support for valuetypes has been expanded.</li>

<ul>
<li>
Forward declared valuetypes not defined in the same compilation unit</li>

<li>
Type codes for valuetypes</li>

<li>
Generation of Any insertion/extraction operators</li>

<li>
Abstract valuetypes</li>

<li>
Valuetype members of all IDL aggregate types</li>

<li>
Interface supports list</li>
</ul>

<li>
Support for the CCM extensions to IDL, which first appeared in CORBA 3.0
is complete, with the exception of support for the 'import' keyword.</li>

<li>
Generated code for constants defined in a module is now inlined
(value is assigned in the header file) by default, enabling such
constants to be referenced by name as array bounds, etc. either in
subsequent generated code or in application code. However, this inlining causes
a problem with some compilers when using pre-compiled headers, so the
option -Guc has been added to turn it off. NOTE: Constants
defined at global scope (always inlined) and constants defined inside an
interface or a valuetype (never inlined) are not affected by the option.
</li>

<li>
Generation of explicit template instantiations is now off by default. The
option -GT turns it on. If turned on, the generated explicit instantiations
are guarded by the same #ifdef preprocessor directives as before.
</li>

<li>
The mechanism for processing multiple IDL files in a single execution has
changed. Instead of spawning a separate process for each IDL file, the
IDL compiler now processes the files sequentially in a single process.
Note that, for each file, execution of the preprocessor spawns a new
process, as it always has.
</li>

<li>
Added command line option -Sm to suppress the action of CCM preprocessing
visitor, which is by default launched before the C++ generating visitors,
in order to add CCM equivalent IDL to the AST. There is a new tool in CIAO
which converts IDL files by replacing IDL3 constructs with equivalent IDL2
constructs, and if the IDL compiler is run on these files, we do not want
the CCM preprocessing to occur.
</li>

<li>
Changed the behavior of the -o option to create the specified directory
if it does not already exist. Only one level of directory can be created
with this option (any path prefix included must already exist).
If the specified directory already exists, no action is taken.
</li>

<li>
As part of the subsetting in TAO of Anys and TypeCodes, the generation of
these things in the IDL compiler has been further decoupled from other
code generation. Now the -GA option generates not only a *A.cpp file but
also a *A.h file, and in addition, the -oA option will create these files
in a directory different from that where the other generated files are
created.</li>

<li>
Generation of explicit template instantiations has been completely
removed, it is no longer available via the command line option -GT.</li>

<li>
Generation of Any insertion/extracion operators for local interfaces
has been enabled by default. An additional command line option -Sal
has also been added to suppress the generation of Any operators for
local interfaces only.</li>

<li>
Added new command line option -oS to specify output directory for
all skeleton files, including TIE class files, if generated. Overrides
-o option value, if any.</li>

<li>
Uninlined all generated TIE class code, since inlining could potentially
cause a problem for RTTI.</li>

<li>
Added new command line option <tt>-Gse</tt> that causes generation of
an explicit export of each sequence's template base class. This is
occasionally necessary as a workaround for a bug in Visual Studio
(.NET 2002, .NET 2003 and Express 2005) where the template instantiation
used for the base class isn't automatically exported. See
<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;309801">
KB 309801</a> for more info</li>

</ul>

<h4>
Known Issues:</h4>

<ul>
<li>
With Microsoft Visual C++, verison 6.0 and earlier, a problem has been
discovered when the IDL compiler is built using the Release version of
the MSVC project. For the Release version, the Optimizations box in the
C/C++ tab has 'Maximize Speed' selected. This setting turned out to cause
a problem when</li>

<p>const char *foo = ......
<p>occurs in the source code. The variable foo is sometimes not allocated
or assigned properly, and if foo is part of generated code, it will then
display as garbage or as an empty string (or substring). Two workarounds
have been found. One is to change the declaration of foo to be
<p>static const char *foo = ....
<p>and this has been done in all cases we could find in the IDL compiler
source code. Another way to avoid the problem is to change the Release
project Optimization setting to 'Minimize Size'. Reportedly the problem
has been fixed in MSVC version 7.0.

</ul>

<h4>
Future work:</h4>

<ul>
<li>
Implement the complete <a href="../ReleaseNotes/OBV.html">Object-by-Value</a>
specification. Originally implemented solely for use in holding exceptions
raised in <a href="../../../PDFs/ami1.pdf">asynchronous</a> invocations,
work is now ongoing to extend TAO's OBV implementation until it includes
the complete CORBA value type specification. Some of the items yet to be
implemented include:</li>

<ul>
<li>
Boxed value types</li>

<li>
Custom marshaling</li>

<li>
Truncation</li>

<li>
Marshaling of complex state (graphs with cycles)</li>

</ul>
For a complete description of value type semantics, see chapter 5 in the
CORBA specification.
<li>
The generated sequence classes should not be generated per sequence, but
per type and parent scope. Which means, that the overhead of having the
source code generated several times should be reduced. To do this, an
extra pass over the internal representation of the IDL file has to be done.</li>

<li>
Updated and portable support for wide characters and wide strings. The
original implementation supports Unicode only. At the time, the CORBA specification
required wide characters, whether standalone or in a wide string, to be
marshaled as 16-bit quantities. This is the same size as the native wchar_t
type on Win32 platforms. However, the wchar_t type on UNIX and related
platforms is 32 bits in size. In addition, the General Inter-ORB Protocol
(GIOP) version 1.2 has changed the CDR transfer syntax for wide characters.
In the new version, a wide character is marshaled as a single byte indicating
the size of the wide character representation, followed by the specified
nunber of bytes. The IDL compiler's handling of wide characters needs to
be updated, both to handle the GIOP 1.2 CDR transfer syntax, and to be
portable under previous versions of GIOP. For more information about GIOP
CDR transfer syntax, see section 15.3 in the CORBA specification. and for
information about the marshaling of IDL character types specifically, see
section 15.3.1.6.</li>

</ul>

<p><br><!--#include virtual="orbcore.html" -->
<hr>
<h3>
<a NAME="pp"></a>Pluggable Protocols</h3>
Point of contact: <a href="mailto:ossama@dre.vanderbilt.edu">Ossama Othman</a>
<p>The goal of the pluggable protocol effort is to (1) identify logical
communication layers in the ORB, (2) abstract out common features, (3)
define general interfaces, and (4) provide necessary mechanisms for implementing
different concrete ORB and transport protocols. TAO's pluggable protocol
framework will allow disparate communication mechanisms to be supported
transparently, each with its own set of requirements and strategies.
<p>For example, if the ORB is communicating over a system bus, such as
PCI or VME, and not all the features of GIOP/IIOP are necessary and a simpler,
optimized ORB and transport protocol can be defined and implemented. Similarly,
it should be straightforward to add support for new transport protocols
that use native ATM or shared memory as the underlying communication mechanism.
In all cases the ORB's interface to the application will remain compliant
with the OMG CORBA standard.
<p>There will be several stages of the development process: (1) basic pluggable
transport protocols framework, (2) support for multiple profiles, (4) add
example transport protocols, such as ATM and VME, and refine/optimize the
transport protocols framework, and (4) add support for pluggable ORB protocols,
e.g., replacements for GIOP. Each of these steps is outlined below:
<ul>
<li>
<b>Basic pluggable transport protocols framework</b>: We have added several
Bridge classes that decouple the transport-specific details from the rest
of TAO's ORB Core. This allows us to isolate the details of how messages
are communicated at the transport layer in a few classes. This design resulted
in the restructuring of the ORB Core and how requests are handled. For
instance, there is now the concept of communication layers: Objects (e.g.,
references, method invocations, etc.), ORB Messaging, Transport, and Network.
The Object layer is just the usual stubs and skeletons.</li>

<p>The common interfaces have been defined in the new abstract classes
that form the core of TAO's pluggable protocol framework, e.g.,
<tt>TAO_Connector</tt>,
<tt>TAO_Acceptor</tt>,
<tt>TAO_Profile</tt>
and <tt>TAO_Transport</tt>. Two new mechanisms for keeping track of supported
transport protocols are the
<tt>TAO_Connector_Registry</tt> and
<tt>TAO_Acceptor_Registry</tt>,
which are essentially Abstract Factories that produce the right types of
connector, acceptors, and transports.
<li>
<b>Multiple Profile</b> - Support for more than one profile per object.
This is important since there may be several different ways to access an
object. Each profile for an object may encode information pertaining to
QoS, network and transport protocols, addresses or routes.</li>

<li>
<b>Example Transport protocols</b> - Aside from IIOP, the following transport
protocols are distributed with TAO:</li>

<ol>
<li>
UIOP: GIOP over local IPC (UNIX domain sockets)</li>

<li>
SHMIOP: GIOP over shared memory</li>

<li>
SSLIOP: GIOP over SSL (Secure Socket Layer)</li>

<li>
SCIOP: GIOP over SCTP</LI>

<li>
COIOP: GIOP collocated only. Will only work in a collocated environment, no remote calls are possible</li>

<li>
DIOP: GIOP over UDP/IP unicast</li>

<li>
MIOP: GIOP over UDP/IP multicast</li>
</ol>
Other interesting transport protocols could be for ATM, Buses (VME or PCI),
TP4, and GSMP. TAO users have also created their own pluggable transport
protocols, such as a ScramNet pluggable protocol.
<li>
<b>Pluggable ORB protocols</b> - This step will add support for ORB protocols
besides GIOP. In particular, we will explore lightweight protocols using
shared memory and system buses like PCI or VME.</li>
</ul>
Current Status:
<ul>
<li>
The basic framework to support pluggable transport protocols has been completed.
The standard TAO regression tests <tt>Latency</tt>,
<tt>MT_Cubit</tt>,
<tt>Multiple_Inheritance</tt>,
<tt>CDR</tt> and
<tt>EC_Throughput</tt> can be used to verify performance
using the new framework.</li>

<li>
Multiple endpoint support in the ORB has been added. A list of TAO_Acceptors
is kept in the Acceptor Registry. When the ORB needs to create an IOR it
iterates over all the acceptors to do so. Using either multiple <tt><a href="../ORBEndpoint.html">-ORBEndpoint</a></tt>
options or several endpoints separated by semi-colons ';', the user can
specify what addresses the ORB should use. Each endpoint is specified in
URL format (ex: <tt>iiop://foo.bar.com:0</tt>), this format can be extended
to support different protocols.</li>

<li>
If the user does not specify a list of endpoints then the ORB creates a
default endpoint for each protocol configured, unless the pluggable protocol
explicitly prevents that in an effort to prevent resource leaks.</li>

<li>
Added support for multiple Connectors in the ORB, the ORB finds the correct
connector based on the tag for the profile.</li>

<li>
Added support for multiple profiles in the IORs, when the ORB demarshals
an IOR it queries the Connector Registry to create the right kind of profile
for the known protocols. If one of the protocols is unknown we create a
special profile class that can only be used for marshaling and demarshaling,
not communication.</li>

<li>
Enabled the UIOP protocol. This protocol uses local IPC (aka UNIX domain
sockets) as the transport mechanism. The protocol is loaded by default.</li>

<li>
Enabled the SHMIOP protocol. This protocol uses shared memory as the transport
mechanism. The protocol is loaded by default.</li>

<li>
An IIOP over SSL pluggable transport called "SSLIOP" has been implemented.
It provides secure communication between hosts that support IIOP over SSL,
and is meant to be a drop-in replacement for the IIOP pluggable transport.
TAO's SSLIOP pluggable transport implementation supports both the standard
IIOP transport protocol and the secure IIOP over SSL transport protocol.</li>

<p>No changes were made to the core TAO sources to provide to this SSL
support, nor does TAO contain any security related hooks. TAO's SSLIOP
implementation is completely self-contained. This ensures that the core
TAO sources remains free of export restrictions.
<li>
Protocols can be dynamically loaded into the ORB: The default resource
factory reads the protocol "names" from its list of arguments. These protocol
names are used to load an abstract factory via the service configurator.
This factory can create acceptors or connectors on demand. By default only
IIOP is loaded.</li>

<li>
The service configurator is now used to load protocol factories.</li>

<li>
Support for the <tt>-ORBHost</tt> and <tt>-ORBPort</tt> has been removed.
The new <tt><a href="../ORBEndpoint.html">-ORBEndpoint</a></tt> option
supersedes them, and provides the same functionality in a protocol-neutral
way. If the deprecated options are used, the ORB exits with a <tt>CORBA::BAD_PARAM</tt>
exception, indicating an unknown <tt>-ORB</tt> option.</li>

<li>
The <tt>-ORBPreconnect</tt> ORB option has been deprecated in favor of
the standard <tt>validate_connection</tt> run-time feature. Support for
this option will be removed from future releases.</li>

<li>
The URL style object reference format has been updated to conform with
the format that <tt>corbaloc</tt> uses. The BNF specification for <tt>corbaloc</tt>
is:</li>

<blockquote><tt>&lt;corbaloc> = "corbaloc:/"[&lt;obj_addr_list>]["/"&lt;key_string>]</tt>
<br><tt>&lt;obj_addr_list>= [&lt;obj_addr> ","]* &lt;obj_addr></tt>
<br><tt>&lt;obj_addr>= &lt;prot_addr> | &lt;future_prot_addr></tt>
<br><tt>&lt;prot_addr>= &lt;rir_prot_addr> | &lt;iiop_prot_addr></tt>
<br><tt>&lt;rir_prot_addr>= &lt;rir_prot_token>":"</tt>
<br><tt>&lt;iiop_prot_addr>= &lt;iiop_id>&lt;iiop_addr></tt>
<br><tt>&lt;iiop_id>= ":" | &lt;iiop_prot_token>":"</tt>
<br><tt>&lt;iiop_prot_token> = "iiop"</tt>
<br><tt>&lt;iiop_add> = [&lt;version> &lt;host> [":" &lt;port>]]</tt>
<br><tt>&lt;host> = DNS-style Host Name | ip_address</tt>
<br><tt>&lt;version> = &lt;major> "." &lt;minor> "@" | empty_string</tt>
<br><tt>&lt;port> = number</tt>
<br><tt>&lt;major> = number</tt>
<br><tt>&lt;minor> = number</tt>
<br><tt>&lt;future_prot_addr> = &lt;future_prot_id>&lt;future_prot_addr>
&lt;future_prot_id> = &lt;future_prot_token>":" &lt;future_prot_token>
= possible examples: "atm" | "dce" &lt;future_prot_addr> = protocol specific
address &lt;key_string> = &lt;string> | empty_string</tt></blockquote>
The <tt>uiop</tt> URL style object references syntax is:
<blockquote><tt>&lt;uioploc> = "uioploc://"[&lt;addr_list>]["|"&lt;key_string>]</tt>
<br><tt>&lt;addr_list>= [&lt;address> ","]* &lt;address></tt>
<br><tt>&lt;address> = [&lt;version> &lt;rendezvous point>]</tt>
<br><tt>&lt;rendezvous point> = Valid Filesystem Path</tt>
<br><tt>&lt;version> = &lt;major> "." &lt;minor> "@" | empty_string</tt>
<br><tt>&lt;major> = number</tt>
<br><tt>&lt;minor> = number</tt>
<br><tt>&lt;key_string> = &lt;string> | empty_string</tt></blockquote>
Note that the key string delimiter for <b><tt>uiop</tt></b> is a vertical
bar `<b><tt>|</tt></b>' (the command line "pipe" symbol) not a forward
slash `<tt>/</tt>'. A delimiter other than a forward slash is needed to
prevent ambiguities of where the rendezvous point ends and where the key
string begins since both may contain forward slashes in them. The new <tt>corbaloc:uiop</tt>
URL format may also be used.
<p>It should be noted that these formats have been superseded by the new
<tt>corbaloc</tt>
<a href="../INS.html">Interoperable Naming Service</a> support.
<li>
The <i>rendezvous point</i> for <tt>uiop</tt> is any valid path and filename
that the ORB has permission to read and write to. However, UIOP rendezvous
points have the same restrictions that local IPC has. The following are
some guidelines that will help ensure successful use TAO's UIOP pluggable
transport protocol:</li>

<blockquote>
<li>
To guarantee portability, local IPC rendezvous points (including the path
and filename) should not be longer than 99 characters long. Some platforms
may support longer rendezvous points, usually 108 characters including
the null terminator, but Posix.1g only requires that local IPC rendezvous
point arrays contain a maximum of <b>at least</b> 100 characters, including
the null terminator.</li>

<P>If an endpoint is longer than what the platform supports then
it will be truncated so that it fits, and a warning will be issued.
<li>
Avoid using <i>relative</i> paths in your UIOP endpoints. If possible,
use <b><i>absolute</i></b> paths instead. Imagine that the server is given
an endpoint to create using <tt>-ORBEndpoint uiop://foobar</tt>. A local
IPC rendezvous point called <tt>foobar</tt> will be created in the current
working directory. If the client is not started in the directory where
the <tt>foobar</tt> rendezvous point exists then the client will not be
able to communicate with the server since its point of communication, the
rendezvous point, was not found. On the other hand, if an absolute path
was used, the client would know exactly where to find the rendezvous point.</li>

<p>It is up to the user to make sure that a given UIOP endpoint is accessible
by both the server and the client.
<li>
It is important to be consistent in the use of absolute paths and relative
paths for rendezvous points. The two types of paths should not be used
for the same endpoint. For example, if <tt>uiop:///tmp/foo</tt> is specified
as the server endpoint and <tt>uiop://foo</tt> as a preconnect for a client
in <tt>/tmp</tt>, then the preconnection may be established but it is likely
it won't be used since the endpoint and preconnect are interpreted as different
strings, i.e. <tt>/tmp/foo</tt> and <tt>foo</tt> are not the same, lexicographically.
On the other hand, if both the endpoint and the preconnect are the same
string then a preconnection will be established and used successfully.</li>

</blockquote>
The <tt><a href="../ORBEndpoint.html">-ORBEndpoint</a></tt> option uses
a syntax similar to that of the URL style object reference shown above.
The only difference is that the object key delimiter and the object key
string are not specified.
<li>
Added documentation that describes how to implement pluggable transport
protocols for TAO. The document is available <a href="../pluggable_protocols/index.html">here</a>.</li>

<li>
TAO's IIOP pluggable protocol now supports automatic creation of profiles
for endpoints created on a host with multiple network interfaces. It should
no longer be necessary to manually specify an endpoint for each network
interface.</li>

<p>This means that server IORs will contain profiles for all of the default
endpoints created on each network interface the server is listening on,
if no explicit endpoints were specified.</ul>
Known Issues:
<ul>
<li>
</li>
</ul>
Critical Work:
<ul>
<li>
None.</li>

</ul>
Future Work:
<ul>
<li>
Complete support for multiple ORB messaging protocols.</li>

<li>
Long term work will include adding support for pluggable ORB protocols,
as well as transport protocols. This way we can develop optimal messaging
and transport protocols for a given platform.</li>
</ul>

<hr>
<h3>
<a NAME="poa"></a>Portable Object Adapter (POA)</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>
<p>The POA associates servants with the ORB and demultiplexes incoming
requests to servants.
<p>Current Status:
<ul>
<li>
TAO supports the POA spec. This section will carry updates as available.</li>
</ul>
Known issues:
<br>Future work:
<br>Recently completed work:
<ul>
<li>
ORB::shutdown now properly deactives all the POA Managers.</li>

<li>
POA Managers in TAO were previously ignored in the request processing path
on the server. This is now fixed such that their state is checked before
dispatching the client request to the servant. Only if the state is <tt>ACTIVE</tt>,
is the request dispatched to the servant. Otherwise, the request is rejected.
Since POA Managers start off in <tt>HOLDING</tt> state, make sure to
<tt>activate()</tt>
them before falling into the event loop.</li>

<li>
TAO's POA now properly supports both the threading policies: SINGLE_THREAD_MODEL
and ORB_CTRL_MODEL.</li>

<li>
The synchronization in the POA is now very optimal. For example, the locks
are not held across the invocation on the servant. The locks are also not
held across the invocation on the AdapterActivator and ServantManagers.
This allows us to use regular locks instead of recursive locks inside the
POA. This also allows multiple threads to dispatch requests on the same
POA simultaneous.</li>

<li>
Before 1.4.6 TAO supports reference counting between POA and servants, including
the new RefCountServantBase and ServantBase_var classes. RefCountServantBase
is a reference counted base class that was added to the CORBA specification
to avoid race conditions for servant deletion in threaded servers. <a href="ftp://ftp.omg.org/pub/docs/orbos/98-07-12.pdf">ftp://ftp.omg.org/pub/docs/orbos/98-07-12.pdf</a>
contains the relevant text. Check <a href="../poa_migration.html#Reference counting Servants">here</a>
on some hints to avoid trouble. From TAO 1.4.6 reference counting is always
enabled for servants and RefCountServantBase is a noop struct you don't
need anymore.</li>

<li>
The POA now supports active demultiplexing of servants in the SYSTEM_ID
and the USER_ID policy. This should make the POA faster and more predictable
since there is no hashing involved and the index of the slot where the
servant is registered is in the Object Key.</li>

<li>
Previously, the complete POA name was used as the POA identity. This scheme
was inefficient in many ways including: (a) the complete POA name can be
significantly large in size, and therefore, ineffient to pass with every
method call from the client to the server; (b) it is varible in size, and
therefore, does not lend itself to smart and effective parsing; (c) the
searching based on the complete POA name is very ineffient.</li>

<p>The new solution is to use an active demux table, and flatten the POA
hierarchy. This will help in the searching since active demuxing is fast
and predictable. This will also help in the parsing since the demux key
will be fixed size.
<p>Note that for persistent ids, we have to pass the complete POA name
in addition to the demux key in order to handle POA creation on demand.
<li>
There were some POA objects in a typical server that are not freed up properly,
resulting in a memory leak. This has now been fixed.</li>

<li>
Timestamps in persistent IORs were not required and have been removed.</li>

<li>
POA exceptions are not not system exceptions and have been removed from
the list of system exceptions.</li>

<li>
Vastly improved the ability of the POA to deal with user exceptions, memory
allocation failures, and constructor failures.</li>

<li>
We now support a minimum POA for the minimum CORBA specification. Recently,
this feature was enchanced such that the minimum CORBA footprint was further
reduced. In addition, minimum POA can be enabled/disable irrespective of
the minimum CORBA setting.</li>

<li>
We have decided not to support active demuxing for method name lookup.
The benefit of this optimization was questionable since the current perfect
hashing scheme provide very good and predictable behavior.</li>

<p>Also, note that this optimization will require many changes. We would
have to use the help of the IDL compiler to modify the object key that
is passed for every method call differently. Note that this scheme doesn't
work in the case of multiple inheritance or when the client stubs are not
TAO.
<li>
Improved the parsing of object keys belonging to the RootPOA. Since this
is the default POA and is commonly used, we have given it a reserved byte
in the object key in order to quickly identify it. With the reserved bit,
the active demux key for the RootPOA is not used, and no map lookups are
required.</li>

<li>
POA name separator was changed from '/' to '\0'. Since POA names are strings,
this makes a better choice since there is no chance of a conflict with
the string specified by the user.</li>

<li>
We have support for reactivating servants with system generated ids.</li>

<li>
The TAO specific synchronization POA policy has been removed.</li>

<li>
New examples have been added to show how servants can be dynamically loaded
from DLLs on demand.</li>

<li>
Support for collocation should be much better now because the POA can tell
if we created the object reference.</li>

<li>
After Nanbor's recent changes for collocation, we support the full semantics
of remote objects on a collocated object. The spec mandates that collocated
object should behave <i>exactly</i> like remote objects, which includes
going through the POA, running the Servant Managers, running the interceptors,
and expecting the reference counting behavior provided by the POA. Note
that the old scheme of direct call through to the servant is also still
available.</li>

</ul>

<hr>
<br><!--#include virtual="OBV.html" -->
<h3>
<a NAME="nservices"></a>CORBA Naming Service and Interoperable Naming Service</h3>
Points of contact: <a href="mailto:marina@cs.wustl.edu">Marina Spivak</a>
and <a href="mailto:vishal@cs.wustl.edu">Vishal Kachroo</a>
<p>OMG defined CORBA Naming Service (spec <a href="ftp://ftp.omg.org/pub/docs/formal/97-07-12.pdf">here</a>)
to provide a basic service location mechanism for CORBA systems. CosNaming
manages a hierarchy of name-to-object-reference mappings. Anything, but
typically the server process hosting an object, may bind an object reference
with a name in the Naming Service by providing the name and object reference.
Interested parties (typically clients) can then use the Naming Service
to resolve a name to an object reference.
<p>More recently, CORBA Naming Service was subsumed/extended by the CORBA
Interoperable Naming Service, a.k.a. INS (spec <a href="ftp://ftp.omg.org/pub/docs/orbos/98-10-11.pdf">here</a>).
INS inherits all the functionality from the original Naming Service specification
in addition to addressing some its shortcomings. In particular, INS defines
a standard way for clients and servers to locate the Naming Service itself.
It also allows the ORB to be administratively configured for bootstrapping
to services not set up with the orb at install time. <a href="../INS.html">This
page</a> provides a brief description of additional features INS provides,
and how they are implemented in TAO.
<p>Current status (as of 18 May 2001):
<ul>
<li>
The Naming Service now <i>does not</i> do listen for multicast discovery
as the default. Use <tt>-m1</tt> option to turn it on.</li>
</ul>
Recent work:
<ul>
<li>
Changed default for multicast discovery to</li>
</ul>
Features:
<ul>
<li>
Added support for Persistence (using memory-mapped files). Persistence
feature is optional, and is controlled by the command line argument.</li>

<li>
Updated the implementation of the Naming Service to use new ACE exception
macros.</li>

<li>
Added support for the InterOperable Naming Service, which enables the ORB
to support IORs in user-friendly <tt>corbaloc</tt> format. These features
allow the ORB to be configured to return arbitrary object references from
<tt>CORBA::ORB::resolve_initial_references</tt>
for non-locality-constrained objects. Two options -ORBInitRef and -ORBDefaultInitRef
have been added to the orb for bootstrapping to arbitrary services.</li>

<li>
Added support for the Naming service to act like an agent: to understand
IIOP request messages from clients and respond with reply messages with
a <tt>LOCATION_FORWARD/OBJECT_NOT_EXIST</tt> status. The Naming Service
can be configured through ORB options to register arbitrary services given
the URL-format IOR for the service. The <tt>resolve_initial_references
()</tt> resolves a service in the following order :</li>

<ol>
<li>
<tt>-ORBInitRef</tt></li>

<li>
<tt>-ORBDefaultInitRef</tt></li>

<li>
Multicast discovery</li>
</ol>

<li>
Added a test for the InterOperable Naming Service that works in conjunction
with the current TAO examples.</li>

<li>
Implementation of the CORBA INS spec is completed. The following features
are now supported:</li>

<ul>
<li>
corbaname format</li>

<li>
NamingServiceExt interface</li>
</ul>
</ul>
Future work:
<ul>
<li>
Support for a load balancing feature similar to the one present in ORBIX.
It will be possible to bind a group of objects under a single name, and
when a client attempts to resolve the name in question, a preset policy
(e.g., random, round robin, etc.) will determine which one of the object
references from the group will be returned.</li>

<li>
Support for the Naming Service to handle the IIOP LocateRequest messages
and respond with LocateReply messages with a
<tt>LOCATION_FORWARD/OBJECT_NOT_EXIST</tt>
status.</li>
</ul>

<hr>
<h3>
<a NAME="tservices"></a>CORBA Trading Service</h3>
Point of contact: <a href="mailto:sbw1@cs.wustl.edu">Seth Widoff</a>
<p>The <a href="http://www.omg.org/technology/documents/formal/trading_object_service.htm">Trading
Service</a> is an implementation of the COS Trading Service speficiation
that meets the Linked Trader conformance criteria --- it implements the
<tt>Lookup</tt>,
<tt>Register</tt>, <tt>Admin</tt>, and
<tt>Link</tt> interfaces, but not
the <tt>Proxy</tt> interface. Notably, the TAO trader supports the following
features:
<ul>
<li>
Multithreaded operation;</li>

<li>
Trader federations and distributed queries;</li>

<li>
Dynamic properties;</li>

<li>
Modifiable properties;</li>

<li>
All policies described in the specification;</li>

<li>
Preference sorting;</li>

<li>
Service type inheritance hierarchies and subtype searching.</li>
</ul>
<a href="trader.html">Trading Service documentation</a> is also available.
<p>Future Work:
<ul>
<li>
The Proxy Interface.</li>

<li>
Persistent storage of service types and offers.</li>
</ul>

<hr>
<h3>
<a NAME="pservices"></a>CORBA Property Service</h3>
Point of contact: <a href="mailto:alex@cs.wustl.edu">Alexander Babu Arulanthu</a>
<p>Current status (as of Mar 9th, 1999): All the interfaces of this service
have been implemented. Please go through the test examples at $TAO/orbsvcs/tests/CosPropertyService.
Property Service is has been used by the TAO's <a href="#av">Audio Video
Streaming Service</a>developed for TAO. For general documentation of the
Property Service, please read <a href="http://www.omg.org/technology/documents/formal/property_service.htm">The
Property Service Specification.</a>
<p>Recent Work:
<ul>
<li>
Changed the PropertyException from Exception to struct, according to the
OMG's changes.</li>

<li>
Changed the implementation to allocate storage for the Sequence out parameters,
eventhough their length is 0. This is according to the CORBA specification.</li>
</ul>

<hr>
<h3>
<a NAME="cservices"></a>CORBA Concurrency Service</h3>
Point of contact: <a href="mailto:tworm@cs.wustl.edu">Torben Worm</a>
<p>Current status (as of May 3rd): The <a href="http://www.omg.org/technology/documents/formal/concurrency_service.htm">Concurrency
Service</a> provides a mechanism that allows clients to acquire and release
various types of locks in a distributed system.
<ul>
<li>
A simple version of the Concurrency Service has been implemented, i.e.
a version without transactions. It is currently being tested.</li>
</ul>
Future Work:
<ul>
<li>
Implementation of the Concurrency Service with transactions</li>
</ul>

<hr WIDTH="100%">
<h3>
<a NAME="av"></a>CORBA Audio/Video Streaming Service</h3>
Point of contact: <a href="mailto:yamuna@oomworks.com">Yamuna Krishnamurthy</a>
<p>This is an implementation of the OMG spec addressing the <a href="http://www.omg.org/technology/documents/formal/audio.htm">Control
and Management of Audio/Video Streams</a>. For more documentation on TAO's
A/V Service please have a look <a href="http://www.cs.wustl.edu/~schmidt/av.html">here</a>.
<h4>
Current Status:</h4>
(as of July 30 2002)
<ul>
<li>
The audio/video streaming service has been implemented in the full profile.
The current implementation support all the flow related components like
flowEndpoint,FDev,FlowConnection,..,etc.</li>

<li>
Point-to_Point and Point-to-MultiPoint streams have been implemented.</li>

<li>
A Pluggable protocols framework has been implemented to flexibly add new
flow protocols like SFP, RTP and new transports like ATM. The current implementation
has protoocol implementations for SFP, RTP over UDP and Multicast UDP.
Please look at <tt><a href="../../orbsvcs/orbsvcs/AV/AV_Pluggable_Framework.html">orbsvcs/orbsvcs/AV/AV_Pluggable_Framework.html</a></tt>for
more documentation about the implementation.</li>

<li>
QoS_UDP pluggable protocol added which implements RSVP QoS support for
UDP streams.</li>

<li>
Diffserv support added to the UDP pluggable protocol by <a href="mailto:crodrigu@bbn.com">Craig
Rodrigues</a>.</li>

<li>
RTP/UDP support enhancements and RTCP control protocol support added by
<a href="mailto:rruff@scires.com">Rob
Ruff</a>.</li>
</ul>
Work in progress:
<ul>
<li>
Integration with <a href="http://www.dist-systems.bbn.com/projects/AIRES/UAV/">BBN
UAV software.</a></li>
</ul>

<hr>
<p><a NAME="ts"></a><b>CORBA Time Service</b>
<p>Point of contact: <a href="mailto:vishal@cs.wustl.edu">Vishal Kachroo</a>
<p>The <a href="ftp://ftp.omg.org/pub/docs/formal/97-02-22.pdf">Time Service</a>
allows clients to connect to Time Service Clerks and obtain globally synchronized
time. This time is calculated from the time obtained from one or more Time
Servers running on multiple machines in the network. The service uses the
TAO Implementation Repository to activate the time servers on demand.
<p>Current status (as of 10th Jan 1999):
<ul>
<li>
Implementation of a Distributed CORBA Time Service is complete.</li>
</ul>
Future work:
<ul>
<li>
Currently the average of the time obtained from the various servers is
considered the global notion of time. A better distributed time synchronization
algorithm can be used in the future.</li>

<li>
Implementation of the Timer Event Service.</li>
</ul>

<hr WIDTH="100%">
<h3>
<a NAME="ec"></a>CORBA Event Service</h3>

<h4>
Last updated: Fri Mar 5 20:38:26 CST 1999</h4>
Point of contact: <a href="mailto:pradeep@cs.wustl.edu">Pradeep Gore</a>
<p>The COS compliant Event Service implements the Event Service Specification:
<a href="ftp://ftp.omg.org/pub/docs/formal/97-12-11.pdf">(.pdf)</a>,
<a href="ftp://ftp.omg.org/pub/docs/formal/97-12-11.ps">(.ps)</a>
<br>The different command line and service configurator options used
for configuring the CORBA event services are located <A
href="../cec_options.html"> here</a>. This implementation is based on
the Real Time Event service.
<h3>
Features in this release:</h3>

<ul>There is a new implementation of the COS Event Service available. This
new implementation supports both the Push and Pull styles for event communication,
and it does not require the Real-time Event Service to work.
<p>A new testsuite for the COS Event Service has been started, they are
available at: <tt>$TAO_ROOT/orbsvcs/tests/CosEvent/</tt>
<p>A new example for the COS Event Service is provided in <tt>$TAO_ROOT/orbsvcs/examples/CosEC/Simple/</tt>
<p>A new binary to run the native COS Event Service was added, it is compiled
in: <tt>$TAO_ROOT/orbsvcs/CosEvent_Service/CosEvent_Service_Native</tt>
<li>
A simple test (<tt>$TAO_ROOT/orbsvcs/tests/CosEC_Basic</tt>) demonstrates
how to create and use the event channel.</li>

<li>
Event Service (<tt>$TAO_ROOT/orbsvcs/CosEvent_Service</tt>)The Event Service
creates a COS compliant event channel and registers it with the naming
service with the default name "CosEventChannel".</li>

<br>Please read the associated README for more details.
<li>
CosEC_Multiple: <tt>($TAO_ROOT/orbsvcs/tests/CosEC_Multiple)</tt>: This
test demonstrates how multiple CosEC's connect to one RtEC and how multiple
consumers and producers exchange events in this configuration.</li>
</ul>

<h3>
Known bugs:</h3>

<ul>
<li>
CosEC_Multiple: <tt>($TAO_ROOT/orbsvcs/tests/CosEC_Multiple)</tt>: Once
the tests are done, the control doesn't return to the shell, you have to
say CTRL-C to get back to the prompt.</li>
</ul>

<hr WIDTH="100%">
<h3>
<a NAME="log"></a>CORBA Telecom Log Service</h3>

<h4>
Last updated: Sun May 28 15:42:44 PDT 2006</h4>
Point of contact: <a href="mailto:jtc@acorntoolworks.com">J.T. Conklin</a>
<p>The CORBA <a href="ftp://ftp.omg.org/docs/formal/03-07-01.pdf">Telecom
Log Service</a> was updated in TAO 1.5.
<h3>
Features supported in the current version:</h3>

<ul>
<li>
The Log Service implementation under <tt>$TAO_ROOT/orbsvcs/orbsvcs/Log</tt>
implements the <tt>DsLogAdmin </tt>module.</li>

<li>
Support for the <tt>DsEventLogAdmin </tt>module, which uses the <a href="#ec">COS
Event Service</a> has been added.</li>

<li>
Support for the <tt>DsNotifyLogAdmin </tt>module, which uses the <a href="#notify">Notification
Service</a> has been added.</li>

<li>
Support for the <tt>RTEventLog </tt>module, which uses the <a href="ec.html">RTEvent
Service</a> has been added.</li>

<li>
Support for the <tt>DsLogNotification </tt>module for log- generated events
has been added.</li>

<li>
The Logging_Service (<tt>$TAO_ROOT/orbsvcs/Logging_Service</tt>) contains
4 separate services</li>

<ul>
<li>
tao_tls_basic <tt>$TAO_ROOT/orbsvcs/Logging_Service/tao_tls_basic</tt></li>

<li>
tao_tls_event <tt>$TAO_ROOT/orbsvcs/Logging_Service/tao_tls_event</tt></li>

<li>
tao_tls_notify <tt>$TAO_ROOT/orbsvcs/Logging_Service/tao_tls_notify</tt></li>

<li>
tao_tls_rtevent <tt>$TAO_ROOT/orbsvcs/Logging_Service/tao_tls_rtevent</tt></li></ul>

<li>
Each service registers with the Naming Service as
"BasicLogFactory", "EventLogFactory", "NotifyLogFactory" and
"RTEventLogFactory" respectively.</li>

<li>
Each service registers with the Interoperable Naming Service as
"BasicLogService", "EventLogService", "NotifyLogService" and
"RTEventLogService" respectively.</li>

<li>
The Log Service uses a dynamically loaded "plug-in" Strategy for storing and
querying log records.  The default Strategy stores Log records in memory and
supports the Extended Trader Constraint Language (ETCL) Query Language.</li>

<li>
There are now examples that demonstrate simple usage of the Log Services.
These are found in <tt>$TAO_ROOT/orbsvcs/examples/Log</tt> and the relevant
sub-directories.</li>

<br>A thorough test <tt>$TAO_ROOT/orbsvcs/tests/Log/Basic_Log_Test</tt>
tests most of the features of the basic logging service.</li>
</ul>

<h3>
Future work and enhancements:</h3>

<ul>
<li>
Provide Strategies that support persistent storage of log records.</li>

<li>
Change default Strategy to use Red-Black trees to optimize lookup on
frequently used query keys - namely record id's and time.</li>
</ul>

<hr WIDTH="100%">
<h3>
<a NAME="notify"></a>Notification Service</h3>

<h4>
Last updated:Thu Nov 21 18:41:11 2002</h4>
Point of contact: <a href="mailto:pradeep@oomworks.com">Pradeep Gore</a>
<p>TAO's CORBA <a href="ftp://ftp.omg.org/pub/docs/telecom/99-07-01.pdf">Notification
Service </a>implementation consists of the following (see the associated
README's for more information):
<ul>
<li>
The implementation of the interfaces in the Notification Service spec is
in <tt><a href="../../orbsvcs/orbsvcs/Notify">$TAO_ROOT/orbsvcs/orbsvcs/Notify
</a></tt>.</li>

<li>
The service driver is implemented in <tt><a href="../../orbsvcs/Notify_Service">$TAO_ROOT/orbsvcs/Notify_Service</a></tt>.</li>

<br>The various options of the Notify_Service are described <a href="notify.html#notify_Service">here
</a>.
<li>
The example in <tt><a href="../../orbsvcs/examples/Notify/Filter">$TAO_ROOT/orbsvcs/examples/Notify/Filter</a></tt>
shows a basic example of using filters.</li>

<li>
The example in <tt><a href="../../orbsvcs/examples/Notify/Subscribe">$TAO_ROOT/orbsvcs/examples/Notify/Subscribe</a></tt>shows
a basic example of how to use subscriptions.</li>

<li>
Feature unit tests are under <tt><a href="../../orbsvcs/tests/Notify">$TAO_ROOT/orbsvcs/tests/Notify</a></tt></li>

<li>
The <a href="notify.html#feature_matrix">Notification feature matrix </a>lists
the features implemented.</li>
</ul>
<i>Note that this implementation does not support Pull interfaces and Typed
Event style communication.</i>
<p>
<hr WIDTH="100%">
<h3>
<a NAME="rt_notify"></a>Real-Time Notification Service</h3>

<h4>
Last updated:Thu Jul 24 11:57:53 2003</h4>
Point of contact: <a href="mailto:pradeep@oomworks.com">Pradeep Gore</a>
<p>This is an extension to TAO's CORBA Notification Service with Real-Time
CORBA support.
<p><b>IDL Extensions:</b>
<ul>
<li>
<b>Interface Extensions:</b> The <a href="../../orbsvcs/orbsvcs/NotifyExt.idl">$TAO_ROOT/orbsvcs/orbsvcs/NotifyExt.idl</a>
extends the ConsumerAdmin and SupplierAdmin interfaces. The <tt>obtain_notification_push_supplier_with_qos</tt>
and <tt>obtain_notification_push_consumer_with_qos</tt> methods can be
used to specify QoS parameters.</li>

<li>
<b>QoS Definitions:</b></li>

<ul>
<li>
ThreadPoolParams: This specifies the parameters for creating a threadpool
in an RT POA.</li>

<li>
ThreadPoolLanesParams: This specifies the parameters for creating a threadpool
with lanes in an RT POA.</li>
</ul>
</ul>
<b>Tests and Examples:</b>
<ul>
<li>
The <tt><a href="../../orbsvcs/examples/Notify/Lanes">$TAO_ROOT/orbsvcs/examples/Notify/Lanes
</a></tt>example
shows how to use RTCORBA Lanes in RT Notification.</li>

<li>
The <tt><a href="../../orbsvcs/examples/Notify/ThreadPool">$TAO_ROOT/orbsvcs/examples/Notify/ThreadPool</a></tt>
example shows how to use RTCORBA ThreadPools in RT Notification.</li>
</ul>
The performance tests for RT Notification measure the throughput, latency
and jitter for various test configurations using Periodic Suppliers:
<ul>
<li>
<tt><a href="../../orbsvcs/tests/Notify/performance-tests/scripts/1_Path_Period_0_Lanes">$TAO_ROOT/tests/Notify/performance-tests/scripts/1_Path_Period_0_Lanes</a></tt></li>

<br>This configuration measures performance for a single data path when
the load is increased. The Supplier sends events in a single burst.
<li>
<tt><a href="../../orbsvcs/tests/Notify/performance-tests/scripts/3_Path_Period_10ms_Lanes">$TAO_ROOT/tests/Notify/performance-tests/scripts/3_Path_Period_10ms_Lanes</a></tt></li>

<br>This configuration measures performance for 3 data paths of high, ,medium
and low priorities when the Load is increased. The Suppliers send events
at 100Hz.
<li>
<tt><a href="../../orbsvcs/tests/Notify/performance-tests/scripts/Paths_vs_Throughput">$TAO_ROOT/tests/Notify/performance-tests/scripts/Paths_vs_Throughput</a></tt></li>

<br>This configuration has 1 high priority path ans several low priority
paths. we measure the performance of the high priority path as a function
of the number of low priority paths.
<li>
<tt><a href="../../orbsvcs/tests/Notify/performance-tests/scripts/Max_Throughput">$TAO_ROOT/tests/Notify/performance-tests/scripts/Max_Throughput</a></tt></li>

<br>This Configuration measures the performance obtained for a data path
using a Structured Event payload:
<ul>
<li>
directly between a Supplier and Consumer in separate processes.</li>

<li>
directly between a colocated Supplier and Consumer.</li>

<li>
between a Supplier and Consumer with a "Relay Consumer" as an intermidiary.</li>

<li>
between a a Supplier and Consumer using the Notification Service.</li>
</ul>
</ul>
<b>Test Framework:</b>
<br>The <tt><a href="../../orbsvcs/tests/Notify/lib">$TAO_ROOT/orbsvcs/tests/Notify/lib</a></tt>
contains a scripting based test framework which can be used to quickly
create test cases. The framemork and its options are described <a href="notify.html#test_framework">here.&nbsp;</a><!-- BEGIN: CORBA Security Service Release Notes -->
<hr WIDTH="100%">
<h3>
<a NAME="security"></a>CORBA Security Service</h3>
Point of contact: <a href="mailto:ossama@dre.vanderbilt.edu">Ossama Othman</a>
<p>Additional information is available
<a href="../Security/index.html">here</a>.

<h4>Security Service Overview</h4>

TAO's current Security Service support implements the core
functionality of the <a href="http://www.omg.org/cgi-bin/apps/doc?formal/02-03-11.pdf">CORBA Security Service v1.8</a>.
<p>
In particular, it implements the most of the CORBA <a href="../../orbsvcs/orbsvcs/SecurityLevel1.idl">SecurityLevel1 API</a>,
in addition to some of <a
        href="../../orbsvcs/orbsvcs/SecurityLevel2.idl">SecurityLevel2</a>.
Of the transport protocols described in the above specification, only
      SSLIOP is supported.  Documentation for TAO's SSLIOP pluggable
      transport is available <a href="../Security/index.html">here</a>.

<p>
The 1.8 specification defines the Common Secure Interoperability version
1 (CSIv1) protocol that is currently implemented in TAO.

<p>
There are basically two ways to use security in TAO:
<ol>
<li>
Use TAO's SSLIOP pluggable transport in TAO alone.  This allows one
to secure application requests without modifying the application code.
This is the easiest approach but is also the least flexible.
</li>
<li>
Use the Security Service API implemented by TAO in conjunction with
TAO's SSLIOP pluggable transport.  This provides the benefits of
secured application requests with the flexibility of disabling
security in some requests, if so desired.  This approach also allows
one to choose at run-time which X.509 certificates will be associated
with application requests, as opposed to setting configuring only one
SSL certificate at application start-up-time.  These things are
basically configured using the SecurityLevel2 or SecurityLevel3
defined policies:

<blockquote><code>
        SecurityLevel2::QOPPolicy<br>
        SecurityLevel2::EstablishTrustPolicy<br>
        SecurityLevel3::ContextEstablishmentPolicy<br>
</blockquote></code>
</li>
</ol>

<h4>Implemented Features</h4>
IIOP over SSL integration via TAO's <a href="../Security/SSLIOP.html">SSLIOP
pluggable transport</a>.
<ul>
<li>
Added an <tt>SSLIOP::Current</tt> implementation that can be used to obtain
the SSL session state for the current execution context. This is useful
for obtaining the SSL peer certificate chain associated with the current
request, for example.</li>

<li>
TAO's SSLIOP pluggable transport now registers a secure invocation server
request interceptor. It enforces secure invocation by rejecting requests
coming in on the insecure port if the server is configured to do so (default
behavior).</li>

<li>
Implemented <tt>SecurityLevel1</tt> for the SSLIOP security mechanism.</li>

<li>
The <tt>SecurityLevel2::QOPPolicy</tt> policy has been implemented. This
policy is used to set the desired invocation Quality-of-Protection (QoP).
It can be created using <tt>ORB::create_policy()</tt>, and used in conjunction
with the standard policy manipulation CORBA features (e.g. <tt>PolicyManager</tt>,
<tt>PolicyCurrent</tt>),
meaning that this policy can be set on a per-ORB, per-thread or per-object
basis.</li>

<p>This policy makes it possible to, for example, make both secure and
insecure invocations within the same client process.
<li>
TAO's SSLIOP pluggable transport implementation is now thread-safe.</li>

<li>
The <tt>SecurityLevel2::EstablishTrustPolicy</tt> policy has been implemented.
This policy is used to set the desired invocation level of establishment
of trust. It can be created using <tt>ORB::create_policy()</tt>, and used
in conjunction with the standard policy manipulation CORBA features (e.g.
<tt>PolicyManager</tt>,
<tt>PolicyCurrent</tt>), meaning that this policy can be set on a per-ORB,
per-thread or per-object basis.</li>

<p>This policy makes it possible to, for example, make authenticated and
non-authenticated invocations within the same client process.
<li>
Implemented <tt>SecurityLevel2::PrincipalAuthenticator</tt> support for
SSLIOP. In particular, a SSLIOP-specific <tt>SecurityReplaceable::Vault</tt>
implementation is now available.</li>
<li>
        Implemented basic (stateless) CSIv2 support.  Advanced CSIv2
        features, such as identity assertion, are currently under
        development.

</ul>
</ul>
<h4>Current Status</h4>
<ul>
<li>
        Began implementation of the interfaces in the
        <tt>SecurityReplaceable</tt> IDL module. They provide the
        ability to replace key security components in the ORB with
        another implementation with ease. Thus, the security
        components in the ORB become highly extensible.</li>
<li>
        Development of core <tt>SecurityLevel2</tt> interfaces such as
        <tt>Credentials</tt>, <tt>SecurityManager</tt>,
        and <tt>PrincipalAuthenticator</tt> has been halted in favor
        of Adiron's <tt>SecurityLevel3</tt> interfaces</li>
<li>
        Advanced CSIv2 features, such as identity assertion, are
        currently under testing.</li>
</ul>
<h4>Schedule</h4>
<ul>
<li>
<font color="#0000FF">August 2004</font></li>

<ul>
<li>
        Complete integration of the Common Secure Interoperability
        version 2 (CSIv2) protocol defined in the <a
          href="http://www.omg.org/cgi-bin/doc?formal/04-03-12">CORBA
          3.0.x</a> core specification, and the <a
          href="http://www.omg.org/technology/documents/formal/atlas.htm">Authorization Token Layer Acquisition Service (ATLAS)</a>.
        <p>
          CSIv2 and ATLAS address many of the shortcomings of the
          current CSIv1-based Security Service.  Overviews of each are
          available on the <a href="http://www.omg.org/technology/documents/formal/omg_security.htm">OMG Security</a> web page.
        <blockquote><em>
          Note that CSIv2 as defined by the CORBA 3.0.x specification
          has no API so TAO's implementation will use a slightly
          <a
            href="http://adiron.com/ORBAsec/3.5.0/docs/SL3/#SecurityLevel3API">modified API</a> currently used by several ORBs defined by Adiron LLC.
        </em></blockquote>

</li>
</ul>
<!--
  <LI>
    <FONT COLOR=BLUE>November 2002</FONT>
    <UL>
      <LI>
        Request authentication via
        <A HREF="http://web.mit.edu/kerberos/www/">Kerberos</A>, as
        detailed in the CORBA Security Service specification.  This
        requires the Common Secure Interoperability protocol (CSIv2),
        but initial experiments will be performed via TAO's existing
        SSLIOP pluggable transport.
      </LI>
      <LI>
        Partial implementation of the <CODE>SecurityLevel2</CODE>
        interfaces.  This includes the <CODE>Credential</CODE> and
        <CODE>Current</CODE> objects.
      </LI>
      <LI>
        Partial implementation of the <CODE>SecurityAdmin</CODE>
        interfaces.
      </LI>
      <LI>
        Begin implementation of <CODE>SecurityAudit</CODE> objects.
        As a side benefit, this project will allow us to research how
        to secure existing services such as
        <A HREF="ec.html">TAO's Real-Time Event Service</A>.
      </LI>
    </UL
  </LI>
<li>
<font color="#0000FF">December 2002</font></li>

<ul>
<li>
Begin implementation of the <i>Resource Access Decision (RAD) Facility</i>
specification for TAO.</li>
</ul>

<li>
<font color="#0000FF">February 2003</font></li>

<ul>
<li>
Begin implementation of the <i>Security Domain Membership Management (SDMM)</i>
specification for TAO. It is needed to support security domains.</li>
</ul>

<li>
<font color="#0000FF">April 2003</font></li>

<ul>
<li>
SSLIOP and SECIOP performance enhancements.</li>
</ul>
-->
</ul>
<!-- END: CORBA Security Service Release Notes -->

<!--#include virtual="ec.html" -->
<p>
<hr>
<h3>
<a NAME="scheduling"></a>TAO's Scheduling Service</h3>
Point of contact: <a href="mailto:cdgill@cs.wustl.edu">Chris Gill</a> and
<a href="mailto:levine@cs.wustl.edu">David
Levine</a>
<p>Currently Implemented Features:
<ul>
<li>
The scheduling service can be built to use either a null implementation
or a strategized implementation of the configuration scheduler.</li>

<li>
The null scheduler implementation, which is built by default, allows the
configuration scheduler to be used with applications that require a scheduling
service interface, but do not (at least in the current stage of their development,
in certain configurations, etc.) make use of the real-time scheduling features
it provides.</li>

<li>
The strategized scheduler implementation can be built by #defining TAO_USES_STRATEGY_SCHEDULER,
and the appropriate scheduling strategy macro (TAO_USES_RMS_SCHEDULING,
TAO_USES_EDF_SCHEDULING, TAO_USES_MUF_SCHEDULING, or TAO_USES_MUF_SCHEDULING)
in $ACE_ROOT/ace/config.h. This allows the configuration scheduler to be
used with applications that require a specific scheduling strategy. Each
scheduling strategy will produce a set of static scheduling priorities,
which it will assign to operations based on their RT_Infos. For each static
priority, a strategy will also determine the run-time (dynamic) scheduling
strategy to use for that priority level.</li>
</ul>
Future work:
<ul>
<li>
Implement heap-based dispatching queues.</li>

<li>
Add support for additional configurability, especially in the type of dispatching
strategy (list vs. heap) that will be used to dispatch operations at a
given static priority level.</li>

<li>
Benchmark the various alternative strategies to obtain performance profiles
across different operation loads and OS platforms.</li>

<li>
Add increased functionality. Requests and suggestions are welcome.</li>
</ul>

<hr>
<h3>
<a NAME="fault_tolerance"></a>TAO's support for FT services</h3>
Point of contact: <a href="mailto:bala@dre.vanderbilt.edu">Balachandran
Natarajan</a>
<h4>
Current Status:</h4>
TAO supports the ORB level requirements to achieve Fault Tolerance for
CORBA Objects. The details of the ORB level support is described in the
FT chapter of the
<a href="http://www.omg.org/cgi-bin/doc?formal/02-06-01">CORBA
3.0 specification</a>. Specifically TAO implements the sections 23.2.2,
23.2.3, 23.2.6 thru 23.2.8 of the document.

<p>
Basic support for <a href="ftcorba_services.html">FT CORBA services</a> has been added.
</p>

<h4>
Future Work:</h4>

<ul>
<li>
Implement 23.2.9 of the document.</li>
</ul>

<hr>
<h3>
<a NAME="loadbalancer"></a>Load Balancer</h3>
Point of contact: <a href="mailto:ossama@dre.vanderbilt.edu">Ossama Othman</a>
<h4>
Current Status:</h4>
TAO's
<a href="http://www.cs.wustl.edu/~schmidt/PDF/load_balancing.pdf">Load
Balancer</a> currently implements the latest revision of the OMG <i>Load
Balancing and Monitoring</i> proposed specification.
<p>It provides many features and advantages over the previous prototype.
Those features and advantages include:
<ul>
<li>
Multiple object group support</li>

<li>
Extensible load balancing strategies through IDL interfaces</li>

<li>
Extensible load monitoring</li>

<li>
Both "push" and "pull" style monitoring are supported</li>

<li>
Support for infrastructure and application controlled object group membership</li>

<li>
Improved server-side transparency</li>
</ul>
The current proposed <i>Load Balancing and Monitoring</i> specification
defines three built-in load balancing strategies. They are:
<ol>
<li>
<tt>RoundRobin</tt> <font color="#0000FF">(non-adaptive)</font></li>

<li>
<tt>Random</tt> <font color="#0000FF">(non-adaptive)</font></li>

<li>
<tt>LeastLoaded</tt> <font color="#0000FF">(adaptive)</font></li>

</ol>
TAO implements all of these and the following load balancing strategies:
<ol>
<li>
<tt>LoadAverage</tt> <font color="#0000FF">(adaptive)</font></li>

<li>
<tt>LoadMinimum</tt> <font color="#0000FF">(adaptive)</font></li>

</ol>
<h4>
Known Issues:</h4>

<ul>
<li>
CPU load monitoring is not working in Windows.
</li>
</ul>

<h4>
Recent Work:</h4>

<ul>
<li>
Implemented <tt>LoadAverage</tt> load balancing strategy.</li>

<li>
Implemented <tt>LoadMinimum</tt> load balancing strategy.</li>

<li>
Implemented a CPU load utilization monitor in Linux.
</li>
</ul>

<h4>
Future Work:</h4>

<ul>
<li>
Implement cooperative (distributed) load balancing support</li>

<li>
Integrate multicast support</li>
<li>
Implement a middleware load balancing performance measurement toolkit</li>
<li>
Implement self adaptive load balancing strategies</li>

</ul>

<hr>
<h3>
<a NAME="miop"></a>Multicast InterORB Protocol (MIOP)</h3>
Point of contact: <a href="mailto:fhunleth@cs.wustl.edu">Frank Hunleth</a>
<h4>
Current Status:</h4>
The final <a href="http://www.omg.org/cgi-bin/doc?ptc/2001-11-08">MIOP
specification</a> has recently been adopted by the OMG. TAO's MIOP support
(located in $TAO_ROOT/orbsvcs/orbsvcs/PortableGroup) enables servants to
receive requests sent to multicast addresses. This is performed by creating
a GroupId that identifies the multicast group and associating it with one
or more servants. Additionally, the Unreliable IP Multicast (UIPMC) pluggable
protocol is used to send and receive multicast requests. Multicast endpoints
can be created dynamically at runtime.
<h4>
Known Issues:</h4>

<ul>
<li>
MIOP packet reassembly is not performed yet, so the maximum request size
is limited to about 5-6kb depending on the platform.</li>
</ul>

<h4>
Recent Work:</h4>

<ul>
<li>
Initial check in of MIOP implementation.</li>
</ul>

<h4>
Future Work:</h4>

<ul>
<li>
Allow group references to be disassociated when no longer needed.</li>

<li>
Implement MIOP packet reassembly.</li>

<li>
Implement a Multicast Group Manager (MGM).</li>

<li>
Implement a Multicast Gateway (MG).</li>
</ul>

<hr>
<h3>
<a NAME="apps"></a>Test &amp; Performance Tests</h3>
[Note: This section is not uptodate. Use with caution. February 2004.]
<br>
Point of contact: <a href="mailto:naga@cs.wustl.edu">Nagarajan Surendran</a>
<p>Current Status:
<p>The TAO IDL_Cubit test application makes use of the Naming Service and
the server holds a TAO_Naming_Server component.Just running server and
client is enough to test the application.
<p>The various tests in the tests/POA test the different features of the
Portable Object Adapter interface like Explicit Activation, On Demand Activation,etc..
<p>MT_Cubit:
<p>Current status:
<p>The TAO MT_Cubit test application is meant to serve as a starting point
for real-time tests on the TAO system. It comprises the following parts:
<ul>
<li>
<i>Server.</i> The server creates multiple CORBA objects (servants), each
with different real-time priorities. This priority is implemented by using
real-time thread support provided by the operating system. Thus, requests
sent to a high-priority servant are handled by a high-priority real-time
thread, and those sent to a lower priority servant are handled by correspondingly
lower priority threads.</li>

<li>
<i>Client.</i> The client component binds to the servants, and sends a
stream of CORBA requests to the servants. It measures the response time,
i.e. the time taken for the request to complete successfully. In particular,
it measures the time taken for requests sent to the high priority servant
to complete. The volume of lower priority requests is configurable. The
client is thus able to measure the performance of the high-priority servant
in the presence of competition from several lower-priority servants.</li>
</ul>
Clearly, if the ORB endsystem handles the priorities of the various requests
correctly, increasing the volume of lower priority requests should not
affect the performance seen by the higher priority requests. The application
thus serves as a tool to measure and confirm this behavior.
<p>Future work:
<ul>
<li>
Study the impacts of scheduling &amp; concurrency strategies on performance.</li>

<li>
Evolve into a testbed for discovering sources of performance non-determinism
&amp; priority inversion.</li>
</ul>
Pluggable:
<p>Current status:
<p>The TAO Pluggable test utilizes ACE Timeprobes to time the latency at
various points in the ORB, especially that incurred by the Pluggable Protocols
implementation. Comparisons can be made not only between different layers
of the ORB, but also between different protocols as they become available.
<p>Future work:
<ul>
<li>
Add options to redirect the output to a file.</li>

<li>
Script or otherwise automate the piping of the output to a spreadsheet.</li>
</ul>

<hr>
<h3>
<a NAME="ace"></a>ORB-related ACE Changes</h3>
Points of contact: <a href="mailto:nanbor@cs.wustl.edu">Nanbor Wang</a>
and <a href="mailto:irfan@cs.wustl.edu">Irfan Pyrarli</a>
<p>Recently Completed Work:
<ul>
<li>
Added special declaration to OS.h for <tt>inet_ntoa</tt> and other functions
because VxWorks doesn't provide full argument prototypes for these library
functions.</li>

<li>
The current caching connector behaves properly in the face of a non-blocking
connect request. The "fix" is simply to not support non-blocking connects
through the cache. When the <tt>connect()</tt> fails with <tt>EWOULDBLOCK</tt>,
morph the error to -1 and clean up the request.</li>

<li>
Service handlers obtained from the caching connector are now cleaned up.
The application needs to be able to signal that it's not using it any longer,
and, when the application encounters an error, needs to effectively close
down that connection for good so that a new connection can be initiated.</li>

<br>Added the ability for a Svc_Handler to recycle itself. idle() can be
called when the Svc_Handler is done serving a particular connection and
can how be recycled. The Svc_Handler now also has a pointer to a recycler
that is responsible for managing the connections. The recycler is usually
a Cached_Connector.
<br>Added new class ACE_Recycling_Strategy. It defines the interface (and
default implementation) for specifying a recycling strategy for a Svc_Handler.
This strategy acts as a consular to the Svc_Handler, preparing it for the
tough times ahead when the Svc_Handler will be recycled.
<br>Added new class ACE_NOOP_Concurrency_Strategy. It implements a no-op
activation strategy in order to avoid calling open on a recycled svc_handler
multiple times.
<br>ACE_Cached_Connect_Strategy now implements the ACE_Connection_Recycling_Strategy
interface. This allows Svc_Handlers to cache themselves with ACE_Cached_Connect_Strategy
when they become idle. It also allows them to purge themselves from the
connection cache when the Svc_Handlers close down.
<br>Also added ~ACE_Cached_Connect_Strategy that will cleanup up the connection
cache.</ul>
Future work:
<blockquote><i>None currently scheduled.</i></blockquote>

<hr>
<h3>
<a NAME="dove"></a>The DOVE Demo</h3>
Points of contact: <a href="mailto:mk1@cs.wustl.edu">Michael Kircher</a>
and <a href="mailto:cdgill@cs.wustl.edu">Chris Gill</a>.
<p><a href="http://www.cs.wustl.edu/~schmidt/dove.html">DOVE</a> is documented
in detail <a href="http://www.cs.wustl.edu/~schmidt/Dove.ps.gz">online</a>.
This discussion focuses on the following goals:
<ul>
<li>
Have a DOVE Browser running using Java Beans as vizualization components.</li>

<li>
Have the Event Channel as DOVE Agent running with an Event Consumer in
the DOVE Browser.</li>

<li>
Having a DOVE Management Information Base (MIB), which dumps all events
transfered on the Event Channel into a file on persistent storage for later
reuse.</li>
</ul>
The DOVE Browser uses independent visualization components (Java Beans)
and the Event Channel as DOVE Agent. Connections can be established between
monitored metrics and the visualization components.
<p>We have three major components: Observables (monitored metrics), Observers
(a Java Bean for displaying the metric) and a DataHandler (for demultiplexing
the monitored metrics to the appropriate Observables). Each component inherits
from a base class, so that a certain behavior of the components can be
assured for each component. Relationships between components are based
on these base classes.
<p>The used Java Beans are required to conform to some standards, as they
have to support a function called "getProperty" which allows the DOVE Browser
to determine if the vizualization capabilities of a specific Java Bean
are sufficient to display the metric. A JavaBean is for example a Java
Panel which shows a Graph of the delivered doubles. So all metrics can
be displayed by this visualization component which can be expressed by
a single double.
<p>The DataHandler is connected to the Event Push Consumer (PUSH, because
we use the push concept of the Event Service). The Event Push Consumer
does not know what kind of data is transported. The only component knowing
all the details about the dependencies of the metrics is the DataHandler.
This separation allows easy extension and change of the demo.
<p><a href="http://students.cec.wustl.edu/~mk1/dove.html">Object Diagrams</a>
are available about this new concept.
<p>Event Service events are used as communication between DOVE Applications
and the DOVE Browser. The DOVE MIB analyses the event data field of all
events and stores this information into a file. The event data filed is
of type CORBA::Any and the DOVE MIB has no notion of what is conveyed in
this field. So the DOVE MIB has to discover the content via the embedded
type code information. Future work includes:
<ul>
<li>
Enhancing MIB functionality</li>

<li>
Monitoring the AV Streaming Service</li>
</ul>
For more information on the DOVE demo, please refer to: $TAO_ROOT/orbsvcs/tests/Simulator/README.
<p>
<hr>
<h3>
<a NAME="forwarding"></a>Location Forwarding</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>,
<a href="mailto:mk1@mk1.wustl.edu">Michael
Kircher</a>.
<p>For more information see <a href="../forwarding.html">Location forwarding</a>
<p>
<hr>
<h3>
<a NAME="leader"></a>Global Resources and Leader-Follower Model</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>,
<a href="mailto:mk1@mk1.wustl.edu">Michael
Kircher</a>.
<p>For more information see <a href="../leader_follower.html">Leader-follower
model</a>
<p>
<hr>
<h3>
<a NAME="locate"></a>Implementation of locate request</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>,
<a href="mailto:mk1@mk1.wustl.edu">Michael
Kircher</a>.
<p>For more information see <a href="../locate_request.html">Locate request</a>
<p>
<hr>
<h3>
<a NAME="ami"></a>Asynchronous Method Invocation</h3>
Points of contact: <a href="mailto:alex@cs.wustl.edu">Alexander Arulanthu</a>
, <a href="mailto:Michael.Kircher@mchp.siemens.de">Michael Kircher</a>
and
<a href="mailto:coryan@uci.edu">Carlos O'Ryan</a>
<p>Status:
<ul>We've implemented the callback model of the
<a href="http://www.omg.org/cgi-bin/doc?formal/01-12-60">CORBA
Messaging specification</a>. To activate the AMI for TAO and the TAO IDL
compiler define <tt>TAO_HAS_CORBA_MESSAGING</tt>,
<tt>TAO_HAS_AMI_CALLBACK</tt>
in your config.h file. The TAO IDL compiler can generate the AMI "callback"
stubs, ReplyHandler und reply stubs using the <tt>-GC</tt> switch.
<p>For an example see <tt>$TAO_ROOT/tests/AMI</tt> and <tt>$TAO_ROOT/examples/AMI</tt>.</ul>
Finished work:
<ul>
<li>
Redesign of the IDL compiler to make an additional pass over the AbstractSyntaxTree
and generate the implied-IDL code in memory. This reduced the amount of
AMI specific IDL compiler code dramatically.</li>

<li>
Support for exceptions</li>

<li>
Support for attributes</li>

<li>
Support for buffering and batching AMI calls. See <a href="../../examples/Buffered_AMI">Buffered
AMI</a> example for details.</li>

<li>
Support for deferred synchronous invocations.
<a href="mailto:j.parsons@vanderbilt.edu">Jeff
Parsons</a></li>

<li>
Support for timeouts in combination with AMI calls, response handler gets
CORBA::TIMEOUT exception on timeout</li>
<li>
The AMI support in TAO 1.4.7 is as described in the 2.6 spec, from 1.4.8 we support
by default the 3.0.3 described mapping.</li>
</ul>
Future Work:
<ul>
<li>
Implementation of the poller model.</li>
</ul>
<hr>
<h3>
<a NAME="csd"></a>Custom Servant Dispatching</h3>
Points of contact: <a href="mailto:bradley_t@ociweb.com">Tim Bradley</a>
<h4>
Current Status:</h4>
<ul>This Custom Servant Dispatching (CSD) feature provides user applications with the ability to implement and "plug-in" custom strategies to handle the dispatching of requests to servants.
<p>A concrete CSD Strategy implementation has also been added to serve as a "reference implementation".  This is being called the CSD Thread Pool Strategy (TP_Strategy).  The TP_Strategy provides a means to decouple the threads (ORB threads) that receive requests from the underlying transport from the thread that will ultimately dispatch the request to the target servant object.  The TP_Strategy implements a "request queue" as the integral part of the mechanism that allows an ORB thread to "hand-off" a request to one of the TP_Strategy object's worker threads.  The TP_Strategy reference implementation is provided as an example of how concrete CSD Strategy could be implemented.
<p>Two approaches are supported for applying CSD strategy to an application.
<ol>
<li>Explicitly calling CSD interfaces.
<p>Here is an example application code showing how a TP_Strategy object can be created and applied to a POA:

<pre>

  PortableServer::POA_var poa = ...; // create the poa.

  // Create a new TP_Strategy object and save it into a "smart pointer" variable.
  TAO::CSD::TP_Strategy_Handle csd_strategy = new TAO::CSD::TP_Strategy();

  // Set the number of threads before calling apply_to().
  csd_strategy->set_num_threads(2);

  // Set the servant serialization flag before calling apply_to().
  csd_strategy->set_servant_serialization (false);

  // Tell the strategy to apply itself to the poa.
  if (csd_strategy->apply_to(poa.in()) == false)
    {
      ACE_ERROR((LM_ERROR, "Failed to apply CSD strategy to the poa.\n"));
      return -1;
    }
</pre>
<li>Service Configurator

 <p>The format of the CSD specific parameters for creating the TP_Strategy service object is:
 <pre>-CSDtp &lt;poa_name&gt;:&lt;csd_thread_number&gt;:[OFF]</pre>

 <p>The last portion of the parameter is the servant serialization flag. It's only needed when the servant serialization needs be turned off, otherwise the servant serialization is always on. When servant serialization is on (the default), the TP_Strategy will serialize requests to any particular servant.  Requests to different servant objects can occur in parallel, but requests to any particular servant will be dispatched serially (ie, one at a time).

 <p>Here is an example of the svc.conf file.

 <pre>
  dynamic TAO_CSD_TP_Strategy_Factory Service_Object *
  TAO_CSD_ThreadPool:_make_TAO_CSD_TP_Strategy_Factory() "-CSDtp RootPOA:2"
 </pre>
</ol>
</ul>
<h4>
Known Issues:</h4>
<ul>
<li>
This feature is not currently tested for VxWorks.
</li>
<li>
This feature does not support the operation of the various server side 'Current' implementations (e.g. PICurrent, POACurrent, etc.). It should not be used by applications that require these to function correctly. See issues <a href="http://bugzilla.dre.vanderbilt.edu/show_bug.cgi?id=3087">3087</a> and <a href="http://bugzilla.dre.vanderbilt.edu/show_bug.cgi?id=3327">3327</a>.
</li>
</ul>
<hr>
<h3>
<a NAME="interceptor"></a>Portable Interceptors</h3>
Point of contact: <a href="mailto:ossama@dre.vanderbilt.edu">Ossama Othman</a>.
<p>For more information see <a href="../interceptors.html">Portable Interceptors</a>
<br>
<hr>
<h3>
<a NAME="localobject"></a>Local Interfaces</h3>
Point of contact: <a href="mailto:nanbor@cs.wustl.edu">Nanbor Wang</a>.
<p>Local interfaces are first defined in the CORBA Component Model specification.
For more information on using the local interfaces, please refers to Section
11.1.1 to 11.1.4 of the
<a href="http://www.omg.org/cgi-bin/doc?orbos/99-07-01/">spec</a>
and our short <a href="../LocalObject.html">guideline</a> on implementing
local objects.
<br>


<hr>
<h3>
<a NAME="sciop"></a>SCIOP Support in TAO</h3>
Point of contact: <a href="mailto:gthaker@atl.lmco.com">Gautam H. Thaker</a>, Lockheed Martin Advanced Technology Labs, Cherry Hill, NJ.


<p>TAO has support for OMG's GIOP SCTP Protocol mapping <a
href=http://www.omg.org/cgi-bin/doc?ptc/2003-08-20>spec</a>, except
that SCIOP protocol properties are not yet supported. Extensive
information about SCTP and how it may be used from both ACE and TAO is
available in several README files in $ACE_ROOT/performance-tests/SCTP/
directory. ACE+TAO's SCTP support can be used either with Linux's
OpenSS7 SCTP implementation or with Linux's LKSCTP SCTP
implementation.  <p> A paper describing the ACE+TAO SCTP
implementation and measured results are available <a
href=http://www.atl.external.lmco.com/projects/QoS/documents/DOA2003_97_Thaker.pdf>
online</a>.<P>

<hr>
<h3>
<a NAME="ipv6"></a>IPv6 Support in TAO</h3>
Point of contact: <a href="mailto:mcorino@remedy.nl">Martin Corino</a>, Remedy IT.


<p>TAO has support for IPv6 for IIOP under Windows and Linux.
To use this, add <code>ipv6</code> to your <code>default.features</code>
file and regenerate all makefiles. When using the automated tests, add IPV6
to the configs.
<p>
Finished work:
<li>Added IPv6 support to all IIOP related classes (parsers, connectors,
  acceptors)</li>
<li>Added IPv6 support to corbaloc and mcast URL parsers.</li>
<li>Implemented IPv6 support in the TAO_IOR_MCast utility class from TAO Svc
  Utils</li>
<p>

The following gotchas are known:
<li>In a localhost situation connecting a server listening at the IPv6 ANY address
  has the following problems:
On Linux this does not work when the client tries to connect to a
    LinkLocal address of one the local NICs,
on Windows this only works (locally) by using the 'localhost' address (either
    IPv4 or IPv6)
</li>
<li>Usage of the '-ORBObjRefStyle url' switch poses problems in localhost situations
  on Windows since this switch causes 'object_to_string' to only return the first server
  endpoint from the IOR profile as a corbaloc URL. In IPv6 servers this will (almost) allways be an IPv4 interface address of one
  of the local NICs. This will than cause problems when the server is listening at
  the IPv6 ANY address as described above.
</li>

<p>
Future work:
<li>IPv6 support for other protocols/strategies than IIOP (i.e. SHMIOP, UIOP,
  SCIOP, SSLIOP etc.; for this we excluded some regression tests in IPv6 builds for this
  reason)</li>

<li>IPv4 runtime dependencies in various CORBA services (f.i. Event service)
</li>


<P>



<hr>
<h3>
<a NAME="CORBA-conformance"></a>CORBA Standards Conformance</h3>
Here is a summary of TAO's conformance issues with CORBA latest CORBA specifications
(updated 9 August 2000):
<br>2.3.1 and 2.3 differ in very little, if at all, check:
<br><a href="ftp://ftp.omg.org/pub/docs/formal/99-10-07.pdf">ftp://ftp.omg.org/pub/docs/formal/99-10-07.pdf</a>
<br>and search for the change bars, meanwhile this can help:
<ul>
<li>
The full OBV (valueboxes, valuetypes in all sorts of things, value graphs,
Anys and value types, abstract interfaces, etc. etc.)</li>

<li>
The IfR database cannot be populated (so it is less than fully operational
;-))</li>

<li>
Fixed data types (who cares)</li>

<li>
GIOP fragments (1.1 and 1.2) are not completely tested.</li>

<li>
The old ServantManager interfaces (POA stuff)</li>

<li>
Domain Managers (useful for security, but otherwise nobody seems to care)</li>

<li>
I think our interpretation of codesets is compliant (we only support one
codeset), but would have to check.</li>
</ul>
Future Work (aka. known problems):
<ul>
<li>
Supposedly, any constructed types that contains local types become local
automatically. TAO_IDL currently doesn't handle the array type very well
if one is defined outside the scope of a local interface.</li>

<li>
Need to test local object support more systematically and comprehensively.
(Does TAO throw a MARSHAL exception when trying to marshal a local type?)</li>
</ul>

<hr>
<p>Back to the TAO <a href="../index.html">documentation index</a>.<!--#include virtual="/~schmidt/cgi-sig.html" -->
</body>
</html>
