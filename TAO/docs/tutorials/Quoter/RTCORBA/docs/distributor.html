<!-- $Id$ -->

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Stock Distributor implementation for the Stock Quoter Publisher/Subscriber Real-time CORBA Service</title>
</head>

<body
 text = "#000000"
 link = "#000fff"
 vLink= "#ff0f0f"
 aLink = "#0000ff"
 bgColor = "#ffffff">

<hr><h2>Stock Distributor implementation for the Stock Quoter Publisher/Subscriber Real-time CORBA Service</h2><hr>

<h3>Implementation of StockDistributorHome interface</h3>

This interface is used to create StockDistributor objects. <P>
The Stock_StockDistributorHome_i class is generated automatically by the IDL compiler (using the -GI flag),
which is a subclass of POA_Stock::StockDistributorHome class. <P>

<h4>Implementing the Constructor</h4>

The main steps of this function are described as follows: <P>

<li>Register the necessary factories and mappings with the specified orb.</li>

<PRE>
    Stock::StockName_init *stockname_factory = new Stock::StockName_init;
    orb->register_value_factory (stockname_factory->tao_repository_id (),
                                 stockname_factory
                                 ACE_ENV_ARG_PARAMETER);

    Stock::Cookie_init *cookie_factory = new Stock::Cookie_init;
    orb->register_value_factory (cookie_factory->tao_repository_id (),
                                 cookie_factory
                                 ACE_ENV_ARG_PARAMETER);

    Stock_PriorityMapping::register_mapping (orb);
</PRE>

<li>Get a reference to the RTORB object and use it to initialize the Stock database.</li>

<PRE>
    Stock_Database::instance ()->init (rt_orb);
</PRE>

<li>Initialize the Stock database.</li>

<PRE>
    Stock_Database::instance ()->init (rt_orb);
</PRE>

<li>Create a CORBA::PolicyList for the child POA.</li>

This step include several sub-stpes:
<OL>
<li>    Initialize a CORBA::PolicyList object.</li>
<li>    Create a CLIENT_PROPOGATED priority model policy and add it into the former CORBA::PolicyList object.</li>
<li>    Create a threadpool with lanes for the distributor. Since the brokers have various priorities,
create a lane for each priority.</li>
<li>    Create a thread pool policy using the former threadpool and add it into the former CORBA::PolicyList object.</li>
<li>    Create a child POA using the former CORBA::PolicyList and narrow it to RTPOA.</li>
</OL>

<PRE>
    CORBA::PolicyList stock_distributor_policies (2);
    stock_distributor_policies.length (2);

    stock_distributor_policies[0] = rt_orb->create_priority_model_policy (RTCORBA::CLIENT_PROPAGATED,
                                                                          Stock_PriorityMapping::MEDIUM);

    RTCORBA::ThreadpoolLanes lanes (5);
    lanes.length (5);
    for (CORBA::ULong i = 0; i < lanes.length (); i ++)
    {
      lanes[i].lane_priority = i;
      lanes[i].static_threads = 5;
      lanes[i].dynamic_threads = 2;
    }
    RTCORBA::ThreadpoolId threadpool_id = rt_orb->create_threadpool_with_lanes (1024 * 10, lanes, false, false, 0, 0);
    stock_distributor_policies[1] = rt_orb->create_threadpool_policy (threadpool_id);

    PortableServer::POA_var poa = _default_POA()->create_POA ("StockDistributor_POA",
                                                                    PortableServer::POAManager::_nil (),
                                                                    stock_distributor_policies);

    RTPortableServer::POA_var rt_poa = RTPortableServer::POA::_narrow (poa);
</PRE>

<li>Create a new instance of the StockDistributor object using the former CORBA::PolicyList.
Then activate it under the former RTPOA. </li>

<PRE>
    distributor_ = new Stock_StockDistributor_i (orb, stock_distributor_policies);
    rt_poa->activate_object (distributor_);
</PRE>

<h4>Implementing the create () member function</h4>

Return the StockDistributor object created by the Constructor.

<PRE>
    return Stock::StockDistributor::_duplicate (distributor_->_this ());
</PRE>

<hr><h3>Implementation of StockDistributor interface</h3>

This interface is used for Stock Distributor server. <P>
The Stock_StockDistributor_i class is generated automatically by the IDL compiler (using the -GI flag),
which is a subclass of POA_Stock::StockDistributor class. <P>

<h4>Implementing the Constructor</h4>

<PRE>
    Stock_StockDistributor_i (CORBA::ORB_ptr orb, CORBA::PolicyList &policy_list)
      : rate_(3000), active_ (false)
</PRE>

The "rate_" and "active_" are two private members of the Stock_StockDistributor_i class. They stand for the
notification rate and the active state of StockDistributor object. <P>

The main steps of this function are described as follows: <P>

<li>Create a child POA with the policies in the argument and narrow it to RTPOA.</li> <P>

<li>Create a new instance of the StockQuoter object and activate it under the former RTPOA.</li> <P>

<li>Get a reference to RTORB and use it to create a RTCOBRA::Mutex object.</li> <P>

<li>Seed the random number generator.</li> <P>

<h4>Implementing the Destructor</h4>

The main steps of this function are described as follows: <P>

<li>Set the active state of StockDistributor object to false.</li> <P>

<li>Destroy the Set the RTCOBRA::Mutex object.</li> <P>

<h4>Implementing the subscribe_notifier () member function</h4>

The main steps of this function are described as follows: <P>

<li>Lock the RTCOBRA::Mutex object.</li> <P>

<li>Generate an unique id and use it to create a new Cookie object.</li> <P>

<li>Insert the Cookie object as well as the StockNameConsumer object and its priority into the
StockDistributor object's subscribers' map.</li> <P>

<li>Unlock the RTCOBRA::Mutex object.</li> <P>

<li>Return the Cookie object.</li> <P>

<h4>Implementing the unsubscribe_notifier () member function</h4>

The main steps of this function are described as follows: <P>

<li>Lock the RTCOBRA::Mutex object.</li> <P>

<li>Search for the Cookie object in the argument in the StockDistributor object's subscribers' map.</li> <P>

<li>Erase the Cookie object from the StockDistributor object's subscribers' map.</li> <P>

<li>Unlock the RTCOBRA::Mutex object.</li> <P>

<li>Return the StockNameConsumer object related to the erased Cookie object.</li> <P>

<h4>Implementing the provide_quoter_info () member function</h4>

Return the StockQuoter object created by the Constructor.

<PRE>
    return Stock::StockQuoter::_duplicate (quoter_->_this ());
</PRE>

<h4>Implementing the start () member function</h4>

Set the active state of the StockDistributor object to true and create a thread to publish the stock information
to the Stock Broker clients. <P>

The main steps of this thread function are described as follows:  <P>
While the state of the StockDistributor object is active, continue the following looping:
<OL>
<li>    Lock the RTCOBRA::Mutex object.</li>
<li>    Publish the stock information to all the StockNameConsumer objects.</li>
<li>    Unlock the RTCOBRA::Mutex object.</li>
<li>    Sleep for the specified amount of seconds given in the notification rate.</li>
</OL>

<h4>Implementing the stop () member function</h4>

Set the active state of StockDistributor object to false.

<hr><b>Email: </b><a href="mailto:"</a<ADDRESS>shanshan.jiang@vanderbilt.edu</ADDRESS>

</body>

</html>
