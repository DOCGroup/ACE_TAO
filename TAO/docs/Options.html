<HTML>
<HEAD>
  <!-- $Id$ -->
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 2.0 Mac">
  <TITLE>Options for TAO Components</TITLE>
</HEAD>

<BODY text = "#000000"
link="#000fff"
vlink="#ff0f0f"
bgcolor="#ffffff">

<HR><P>
<H3 ALIGN=CENTER>Options for TAO Components</H3>

<H3>Overview</H3>
<blockquote>

<P>Certain components in TAO such as the ORB Core or Object Adapter
can be tuned by users by providing value for options or environment
variables to them.  These options are commonly specified as (1)
environment variables or (2) strings passed on the command-line.  They
are generally passed to component initialization methods for
consumption.</P>

<p>Both command-line options and environment variables are used to
control the global ORB features like the IOR format or ORB's
bootstraping methods.  Options in <code>svc.conf</code> file on the
other hand provides a mechanism to fine-tune the internal components
in TAO and they are specific to individual components.
<code>svc.conf</code> files are not required to run TAO programs.
However, if you know the behavior of your programs, you can tune-up
your programs and use various optimization provided by TAO thru the
use of svc.conf files.</p>

<P><EM>Programmer's Note:</EM> the internal structure for options is
the traditional <CODE>argc</CODE>/<CODE>argv</CODE> vector of strings
style popularized by C and Unix.  By convention, an initialization
method will consume, <EM>i.e.</EM>, remove from the vector, any
options that it recognizes.</P> </blockquote>

<HR><P>
<H3><A NAME="ev">Environment Variables</A></H3>

The following environment variables are supported by TAO:

<BLOCKQUOTE>
<P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING="0" >
<TR>
<TH>Environment Variable</TH>
<TH>Description</TH></TR>
<TR>
<TD><CODE>NameServiceIOR</CODE> <EM>which</EM></TD>
<TD>
Specifies which IOR the Naming Service is listening on.
</TD></TR>
<TR>
<TD><CODE>NameServicePort</CODE> <EM>which</EM></TD>
<TD>
Specifies which port the Naming Service is listening on for multicast
requests.
</TD></TR>
<TR>
<TD><CODE>TradingServiceIOR</CODE> <EM>which</EM></TD>
<TD>
Specifies which IOR the Trading Service is listening on.
</TD></TR>
<TR>
<TD><CODE>TradingServicePort</CODE> <EM>which</EM></TD>
<TD>
Specifies which port the Trading Service is listening on for multicast
requests.
</TD></TR>
</TABLE>
</P>
</BLOCKQUOTE>

<HR><P>

<H3>Types of Options</H3>

<blockquote>
<P>The following components can be tuned via options:</P>

<UL>
  <LI><A HREF="#ORB"><CODE>CORBA::ORB</CODE></A>
  <LI><A HREF="#ResourceFactory"><CODE>TAO_Resource_Factory</CODE></A>
  <LI><A HREF="#DefaultServer"><CODE>TAO_Default_Server_Strategy_Factory</CODE></A>
  <LI><A HREF="#DefaultClient" TARGET="_top"><CODE>TAO_Default_Client_Strategy_Factory</CODE></A>
</UL>

Typically, CORBA::ORB options are set via command line parameters,
while the rest of the options are set via the service configurator
(svc.conf) file.

</blockquote>

<blockquote>
<H3><CODE>CORBA::ORB</CODE><A NAME="ORB"></A></H3>

<blockquote>
<P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING=
"0">
<TR>
<TH>Option</TH>
<TH>Description</TH></TR>
<!-- <TR NAME="ORBsvcconf"> -->
<TD><CODE>-ORBSvcConf</CODE> <EM>config file name</EM></TD>
<TD>Specifies the name of the file from which it will read dynamic service configuration
directives <EM>ala</EM> ACE's Service Configurator.</TD></TR>
<TD><CODE>-ORBSvcConfDirective</CODE> <EM>directivestring</EM></TD>
<TD>Specifies a service configuration
directive, which is passed to ACE's Service Configurator.</TD></TR>
<TR>
<TD><CODE>-ORBDaemon</CODE></TD>
<TD>Specifies that the ORB should <I>daemonize</I> itself.</TD></TR>
<TR>
<TD><CODE>-ORBDebug</CODE></TD>
<TD>Turns on the output of debugging messages within ACE's Service Configurator
componentry.</TD></TR>
<TR>
<TD><CODE>-ORBDebugLevel</CODE> <EM>level</EM></TD>
<TD>Control the level of debugging in the ORB. Higher number produce
more output (try 10).
</TD></TR>
<TR>

<TD><CODE>-ORBEndpoint</CODE> <EM>endpoint</EM></TD> <TD><a
name="-ORBEndpoint"></a>Tells the ORB to listen for requests on the
interface specified by <I><EM>endpoint</EM></I>.  Endpoints are
specified using a URL style format.  An endpoint has the form:
<blockquote><CODE>
protocol://V.v@addr1,...,W.w@addrN
</CODE></blockquote>
where <CODE>V.v</CODE> and <CODE>W.w</CODE> are optional protcol versions for
each address.  An example of an IIOP endpoint is:
<blockquote><CODE>
iiop://<I><EM>hostname</EM></I>:<I><EM>port</EM></I>
</CODE></blockquote>
Sets of endpoints may be specified using multiple <CODE>-ORBEndpoint</CODE>
options or by delimiting endpoints with a semi-colon (;).  For example,
<blockquote><CODE>
-ORBEndpoint iiop://localhost:9999 -ORBEndpoint uiop:///tmp/mylocalsock
</CODE></blockquote>
is equivalent to:
<blockquote><CODE>
-ORBEndpoint 'iiop://localhost:9999;uiop:///tmp/mylocalsock'
</CODE></blockquote>
Notice the single quotes (') in the latter option specification.  Single
quotes are needed to prevent the shell from interpreting text after the
semi-colon as another command to run.<P>
If an endpoint is specified without an <CODE>addr</CODE> such as the following:
<blockquote><CODE>
-ORBEndpoint uiop://
</CODE></blockquote>
then a default endpoint will be created for the specified protocol.
</TD></TR>

<TR>

<TD><CODE>-ORBHost</CODE> <EM>hostname</EM></TD> <TD><a
name="-ORBHost"></a>Tells the ORB to listen for requests on the
interface associated with the host named
<I><EM>hostname</EM></I>.  This option is valid only for IIOP endpoints.<BR>
<STRONG>NOTE:</STRONG> This option has been superceded by the
<CODE>-ORBEndpoint</CODE> option. It will not be supported in the
future.</TD></TR>

<TR>

<TD><CODE>-ORBPort</CODE> <EM>portspec</EM></TD> <TD>Tells the ORB to
listen for requests on the port specified by
<I><EM>portspec</EM></I>. If not specified, the OS gets to choose a
random empty port.  This option is valid only for IIOP endpoints.<BR>
<STRONG>NOTE:</STRONG> This option has been superceded by the
<CODE>-ORBEndpoint</CODE> option. It will not be supported in the
future.</TD>

</TR>

<TR>
<TD><CODE>-ORBObjRefStyle</CODE> <EM>which</EM></TD>
<TD>Specifies the user-visible style of object references. The range of values
is <CODE>IOR</CODE>, which is the traditional nonsensical object reference,
or <CODE>URL</CODE>, which looks more like a URL.</TD></TR>
<TR>
<TD><CODE>-ORBRcvSock</CODE> <EM>receive buffer size</EM></TD>
<TD><A NAME="-ORBRcvSock"></a>Specify the size of the socket receive buffer as a positive, non-zero integer.
If not specified, the ACE_DEFAULT_MAX_SOCKET_BUFSIZ default is used.</TD></TR>
<TR>
<TD><CODE>-ORBSndSock</CODE> <EM>send buffer size</EM></TD>
<TD><A NAME="-ORBSndSock"></a>Specify the size of the socket send buffer as a positive, non-zero integer.
If not specified, the ACE_DEFAULT_MAX_SOCKET_BUFSIZ default is used.</TD></TR>
<TR>
<TD><CODE>-ORBNameServicePort</CODE> <EM>portspec</EM></TD>
<TD>Specifies which port the Naming Service is listening on for
multicast requests.</TD></TR>
<TR>
<TD><CODE>-ORBNameServiceIOR</CODE> <EM>ior</EM></TD>
<TD>Specifies the IOR for the Naming Service.</TD></TR>
<TR>
<TD><CODE>-ORBTradingServiceIOR</CODE> <EM>ior</EM></TD>
<TD>Specifies the IOR for the Trading Service.</TD></TR>
<TR>
<TD><CODE>-ORBTradingServicePort</CODE> <EM>portspec</EM></TD>
<TD>Specifies to which port the Trading Service is listening on for
    multicast requests.</TD></TR>
<TR>
<TD><CODE>-ORBImplRepoIOR</CODE> <EM>ior</EM></TD>
<TD>Specifies the IOR for the Implementation Repository.</TD></TR>
<TR>
<TD><CODE>-ORBImplRepoPort</CODE> <EM>portspec</EM></TD>
<TD>Specifies to which port the Implementation Repository is listening on for
    multicast requests.</TD></TR>
<TR>
<TD><CODE>-ORBCollocation</CODE> <EM>yes/no</EM></TD>
<TD>Specifies the use of collocation object optimization.  Default is yes.</TD></TR>
<TR>
  <TD>
      <CODE>-ORBCollocationStrategy</CODE> <EM>thru_poa/direct</EM>
  </TD>
  <TD>
      Specifies what kind of collocated object to use.  If the
      <em>thru_poa</em> strategy is used, TAO uses the collocation
      object implementation that respects POA's current state and
      policies.   When using the <em>direct</em> strategy, method
      invocations on collocated objects become direct calls to servant
      without checking POA's status.  Default is thru_poa.
  </TD>
</TR>
<TR>
  <TD>
      <CODE>-ORBGlobalCollocation</CODE> <EM>yes/no</EM>
  </TD>
  <TD>
      Specifies whether objects from different ORBs within the same
      process can be treated as collocated or not.  If no, only objects
      in the same ORB are treated as collocated.   Default is yes.
  </TD>
</TR>
<TR>
<TD><CODE>-ORBPreconnect</CODE> <EM>endpoint</EM></TD>
<TD><A name="-ORBPreconnect"></a>Pre-establishes a blocking connection to
each listed <EM>endpoint</EM>. If a connection cannot be established the
failed preconnection will be ignored and the next preconnection in the list
will be processed.  Successful and unsuccessful preconnections will be
displayed if a debugging level greater than or equal to one is specified by
using the <CODE>-ORBDebugLevel</CODE> option.  Listing the same combination
multiple times will properly establish multiple connections to that endpoint.
The <CODE>-ORBPreconnect</CODE> option uses the same endpoint format as the
<CODE>-ORBEndpoint</CODE> option.  Specifying IIOP endpoints using a comma
delimited list of <EM>host<STRONG>:</STRONG>port</EM> pairs is deprecated
and will not be supported in the future.</TD></TR>
<TR>
<TD><CODE>-ORBCDRTradeoff</CODE> <EM>maxsize</EM></TD>
<TD><A name="-ORBCDRTradeoff"></a>Control the strategy to tradeoff
between copy vs no copy marshalling of octet sequences.
If an octet sequence is smaller than <EM>maxsize</EM> and the current
message block contains enough space for it the octet sequence is
copied instead of appended to the CDR stream.</TD></TR>
<TR>
<TD><CODE>-ORBSkipServiceConfigOpen</CODE></TD>
<TD><A name="-ORBSkipServiceConfigOpen"></a>Do not call the <code>ACE_Service_Config::open</code>
method, which is necessary if the ORB is being linked dynamically via the ACE Service Configurator
which is not reentrant.</TD></TR>
<TR>
<TD><CODE>-ORBGIOPlite</CODE></TD>
<TD><A name="-ORBGIOPlite"></a>Enable a lightweight version of the
            GIOP protocol. This protocol removes some of the fields in
            the GIOP and the Request header. It only works on
            homogenous environments..</TD></TR>
<TR>
<TD><CODE>-ORBDottedDecimalAddresses</CODE> <EM>boolean (0 / 1)</EM></TD>
<TD><A name="-ORBDottedDecimalAddresses"></a> Use the dotted decimal
            notation for addresses.</TD></TR>
<TR>
<TD><CODE>-ORBInitRef</CODE> <EM>ObjectId=IOR</EM></TD>
<TD><A name="-ORBInitRef"></a> Allows specification of an arbitrary
    object reference for an initial service. The IOR could be in any
    one of the following formats : OMG IOR, URL, iioploc or
    file. iioploc is a multiple end-point IOR understood by the
    string_to_object () and used as a boot-strapping mechanism by the
    resolve_initial_references (). The mappings specified through this
    argument override the orb-install-time defaults. The
    file://<I>pathname</I> interprets the contents of the <I>pathname</I> file
    as an object reference in any of the above formats. </TD></TR>

<TR>
<TD><CODE>-ORBDefaultInitRef</CODE> <EM>IOR prefix</EM></TD>
<TD><A name="-ORBDefaultInitRef"></a> This argument allows resolution of initial references not explicitly specified with -ORBInitRef. It requires a URL prefix that, after appending a slash '/' and a simple object key, forms a new URL to identify an initial object reference. The URL prefix format currently supported is iioploc.</TD></TR>

<TR>
<TD><CODE>-ORBStdProfileComponents</CODE> <EM>boolean (0 / 1)</EM></TD>
<TD><A name="-ORBStdProfileComponents"></a> If <EM>0</EM> then the ORB
              does not generate the OMG standarized profile
              components, such as the ORB type and codesets.
              Notice that the presence of this components is optional
              in GIOP 1.1
              The default value is controlled by a compile-time flag
              (check orbconf.h).</TD></TR>

<TR>
<TD><CODE>-ORBResources</CODE> <EM>which</EM></TD>
<TD><A name=-ORBResources>Control the use of thread specific resources
                in the ORB.
                If (<em>which</em> = <code>global</code>) then the
                same set of resources are shared by all the threads
                that use that ORB.
                If (<em>which</em> = <code>tss</code>) then each that
                uses that ORB gets its own set of resources.
                Currently the resources are limited to the reactor.
            </TD></TR>
<TR>

</TABLE>
</P>
</blockquote>

<H3><CODE>TAO_Resource_Factory</CODE><A NAME="ResourceFactory"></A></H3>

<blockquote>
<P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING="0">
<TR>
<TH>Option</TH>
<TH>Description</TH></TR>
<TR>
<TD><CODE>-ORBResources</CODE> <EM>which</EM></TD>
<TD>Specify whether each thread uses a global
(<em>which</em> = <code>global</code>) or a thread-specific
(<em>which</em> = <code>tss</code>) instance for the resources it
              returns.
              <B>NOTE:</B> This option has been deprecated, use the
              same option on the <A HREF="#ORB">ORB parameters</A>.
</TD></TR>
<TR>
<TD><CODE>-ORBReactorLock</CODE> <EM>which</EM></TD>
<TD><a name="-ORBReactorLock"></a>Specify whether the ORB reactor is
              thread-safe
(<em>which</em> = <code>token</code>) or not
(<em>which</em> = <code>null</code>).  Default is <code>token</code>.
              <P>This option has been superseeded by
                <CODE>-ORBReactorType</CODE>
              </P>
</TD></TR>
<TR>
<TD><CODE>-ORBReactorType</CODE> <EM>which</EM></TD>
<TD><a name="-ORBColTable"></a>Specify what kind of reactor does the
              ORB use, the options are:
  <TABLE BORDER="1" CELLSPACING="2" CELLPADDING="0">
  <TR><TH><em>which</em></TH><TH>Reactor</TH></TR>
  <TR><TD><CODE>select_mt<CODE></TD><TD>Use the
                    <CODE>ACE_Select_Reactor</CODE> with the usual
                    locking mechanism for this platform</TD></TR>
  <TR><TD><CODE>select_st<CODE></TD><TD>Use the
                    <CODE>ACE_Select_Reactor</CODE> with null locks
                  </TD></TR>
  <TR><TD><CODE>fl<CODE></TD><TD>Use the
                    <CODE>ACE_FlReactor</CODE> only available if ACE
                    was compiled with support for the FL toolkit
                  </TD></TR>
  <TR><TD><CODE>xt<CODE></TD><TD>Use the
                    <CODE>ACE_XtReactor</CODE> only available if ACE
                    was compiled with support for the XWindows Toolkit
                  </TD></TR>
  <TR><TD><CODE>wfmo<CODE></TD><TD>Use the
                    <CODE>ACE_WFMO_Reactor</CODE> only available on
                    Win32 platforms.
                  </TD></TR>
  <TR><TD><CODE>msg_wfmo<CODE></TD><TD>Use the
                    <CODE>ACE_Msg_WFMO_Reactor</CODE> only available on
                    Win32 platforms.
                  </TD></TR>
  <TR><TD><CODE>tp<CODE></TD><TD>Use the
                    <CODE>ACE_TP_Reactor</CODE>, a select based
                    thread-pool reactor.
                  </TD></TR>
  </TABLE>
  The default is <code>select_mt</code></TD></TR>
<TR>
<TD><CODE>-ORBColTable</CODE> <EM>which</EM></TD>
<TD><a name="-ORBColTable"></a>Specify whether each ORB uses a global
(<em>which</em> = <code>global</code>) or a per-ORB
(<em>which</em> = <code>orb</code>) collocation table.</TD></TR>
<TR>
<TD><CODE>-ORBInputCDRAllocator</CODE> <EM>which</EM></TD>
<TD><a name="-ORBInputCDRAllocator"></a>
              Specify whether the ORB uses locked
              (<em>which</em> = <code>thread</code>)
              or lock-free (<em>which</em> = <code>null</code>)
              allocators for the incoming CDR buffers.
              Though <CODE>null</CODE> should give the
              optimal performance;
              we made the default <CODE>thread</CODE>.
              TAO optimizations for octet sequences will not work in all cases when
              if the allocator does not have locks (for example if the
              octet sequences are part of a return value.
              Using locked allocators also allows the users to
              take advantage of the TAO octet sequence
              extensions to preserve the buffer after the upcall.
            </TD></TR>
</TABLE>
</P>
</blockquote>

<H3><CODE>TAO_Default_Server_Strategy_Factory</CODE><A NAME="DefaultServer"></A></H3>

<p><em>Note:</em> <code>-ORBDemuxStrategy</code> flag has been changed to <code>-ORBSystemidPolicyDemuxStrategy</code> and <code>-ORBUseridPolicyDemuxStrategy</code>.
<p><em>Note:</em> <code>-ORBTableSize</code> flag has been changed to <code>-ORBActiveObjectMapSize</code>.

<blockquote>
<P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING="0" >
<TR>
<TH>Option</TH>
<TH>Description</TH></TR>
<TR>

<TD><CODE>-ORBConcurrency</CODE> <EM>which</EM></TD> <TD>Specify which
concurrency strategy to use.  Range of values is <code>reactive</code>
for a purely Reactor-driven concurrency strategy or
<code>thread-per-connection</code> for creating a new thread to
service each connection.</TD></TR> <TR>

<TD><CODE>-ORBActiveObjectMapSize</CODE> <EM>active object map
size</EM></TD> <TD>Specify the size of the active object map. If not
specified, the default value is 64.</TD></TR> <TR>

<TD><CODE>-ORBUseridPolicyDemuxStrategy</CODE> <EM>user id policy
based demultiplexing strategy</EM></TD> <TD>Specify the demultiplexing
lookup strategy to be used with the user id policy.  The
<EM>demultiplexing strategy</EM> can be one of <CODE>dynamic</CODE> or
<CODE>linear</CODE>.  This option defaults to use the
<CODE>dynamic</CODE> strategy. </TD></TR> <TR>

<TD><CODE>-ORBSystemidPolicyDemuxStrategy</CODE> <EM>system id policy
based demultiplexing strategy</EM></TD> <TD>Specify the demultiplexing
lookup strategy to be used with the system id policy. The
<EM>demultiplexing strategy</EM> can be one of <CODE>dynamic</CODE>,
<CODE>linear</CODE>, or <CODE>active</CODE>. This option defaults to
use the <CODE>active</CODE> strategy. </TD></TR> <TR>

<TD><CODE>-ORBUniqueidPolicyReverseDemuxStrategy</CODE> <EM>unique id
policy based reverse demultiplexing strategy</EM></TD> <TD>Specify the
reverse demultiplexing lookup strategy to be used with the unique id
policy. The <EM>reverse demultiplexing strategy</EM> can be one of
<CODE>dynamic</CODE> or <CODE>linear</CODE>. This option defaults to
use the <CODE>dynamic</CODE> strategy. </TD></TR> <TR>

<TD><CODE>-ORBAllowReactivationOfSystemids</CODE> <EM>allows
reactivation of system ids</EM></TD> <TD>Specify whether system ids
can be reactivated, i.e., once an id that was generated by the system
has be deactivated, will the user reactivate a new servant using the
old id.  If the user is not going to use this feature, the IORs can be
shortened, an extra comparison in the critical upcall path removed,
and some memory on the server side can be saved. The
<CODE>ORBallowreactivationofsystemids</CODE> can be <CODE>0</CODE> or
<CODE>1</CODE>. This option defaults to <CODE>1</CODE>. </TD></TR>
<TR>

<TD><CODE>-ORBActiveHintInIds</CODE> <EM>adds an active hint in
ids</EM></TD> <TD>Specify whether an active hint should be added to
ids. With active hints, ids can be found quickly.  However, they lead
to larger IORs. Note that this option is disregarded
<CODE>-ORBAllowReactivationOfSystemids</CODE> is set to
<CODE>0</CODE>. The <EM>-ORBActiveHintInIds</EM> can be <CODE>0</CODE>
or <CODE>1</CODE>. This option defaults to <CODE>1</CODE>. </TD></TR>
<TR>

<TD><CODE>-ORBPoaMapSize</CODE> <EM>poa map size</EM></TD> <TD>Specify
the size of the poa map. If not specified, the default value is
24.</TD></TR> <TR>

<TD><CODE>-ORBPersiententidPolicyDemuxStrategy</CODE> <EM>persistent
id policy based demultiplexing strategy</EM></TD> <TD>Specify the
demultiplexing lookup strategy to be used with the persistent id
policy.  The <EM>demultiplexing strategy</EM> can be one of
<CODE>dynamic</CODE> or <CODE>linear</CODE>.  This option defaults to
use the <CODE>dynamic</CODE> strategy. </TD></TR> <TR>

<TD><CODE>-ORBTransientidPolicyDemuxStrategy</CODE> <EM>transient id
policy based demultiplexing strategy</EM></TD> <TD>Specify the
demultiplexing lookup strategy to be used with the transient id
policy. The <EM>demultiplexing strategy</EM> can be one of
<CODE>dynamic</CODE>, <CODE>linear</CODE>, or
<CODE>active</CODE>. This option defaults to use the
<CODE>active</CODE> strategy. </TD></TR> <TR>

<TD><CODE>-ORBActiveHintInPOANames</CODE> <EM>adds an active hint in
poa names</EM></TD> <TD>Specify whether an active hint should be added
to poa names. With active hints, poa names can be found quickly.
However, they lead to larger IORs. The
<EM>-ORBActiveHintInPOANames</EM> can be <CODE>0</CODE> or
<CODE>1</CODE>. This option defaults to <CODE>1</CODE>. </TD></TR>
<TR>

<TD><CODE>-ORBThreadFlags</CODE> <EM>thread flags</EM></TD>
<TD>Specify the flags used for thread creation. Flags can be any
logical-OR combination of <CODE>THR_DETACHED</CODE>,
<CODE>THR_BOUND</CODE>, <CODE>THR_NEW_LWP</CODE>,
<CODE>THE_SUSPENDED</CODE>.</TD></TR> <TR>

<TD><CODE>-ORBPOALock</CODE> <EM>lock type</EM></TD> <TD><a
name="-ORBPOALock"></a>Specify the type of lock to be used for POA
accesses.  Possible values for <em>lock type</em> are
<code>thread</code>, which specifies that an inter-thread mutex is
used to guarantee exclusive acccess, and <code>null</code>, which
specifies that no locking be performed.  The default is
<code>thread</code>.</TD></TR> <TR>

<TD><CODE>-ORBColTblLock</CODE> <EM>lock type</EM></TD> <TD><a
name="-ORBColTblLock"></a>Specify the type of lock to be used for the
global collocation table.  Possible values for <em>lock type</em> are
<code>thread</code>, which specifies that an inter-thread mutex is
used to guarantee exclusive acccess, and <code>null</code>, which
specifies that no locking be performed.  The default is
<code>thread</code>.</TD></TR> <TR>

<TD><CODE>-ORBConnectorLock</CODE> <EM>lock type</EM></TD> <TD><a
name="-ORBConnectorLock"></a>Specify the type of lock to be used by
the connector.  Possible values for <em>lock type</em> are
<code>thread</code>, which specifies that an inter-thread mutex is
used to guarantee exclusive acccess, and <code>null</code>, which
specifies that no locking be performed.  The default is
<code>thread</code>.</TD></TR> <TR>

</TABLE>
</P>
</blockquote>

<H3><CODE>TAO_Default_Client_Strategy_Factory</CODE><A NAME="DefaultClient"></A></H3>

<BLOCKQUOTE>
<P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING="0" >
<TR>
<TH>Option</TH>
<TH>Description</TH></TR>
<TR>
<TD><CODE>-ORBIIOPProfileLock</CODE> <EM>which</EM></TD>
<TD>
Specify, whether to use a lock for accessing the IIOP Profile or not.
Default is <code>thread</code>, which means that a lock is used. The
second option is <code>null</code>, which means a null lock is used.
This makes sense in case of optiziations and is allowed when
no forwarding is used or only a single threaded client.
</TD></TR>
<TR>
<TD><CODE>-ORBClientConnectionHandler</CODE> <EM>MT / ST / RW</EM></TD>

<TD><A name="-ORBClientConnectionHandler"></a>

ST means use the single-threaded client connection handler, i.e., the
leader follower model will not be used.  However, ST does support
nested upcalls and handling of new requests while waiting for the
reply from a server. <p>

MT means use the multi-threaded client connection handler which uses
the leader follower model. This model allows the use of multiple
threads with a single Reactor.  <p>

RW selects a strategy that simply blocks in recv() when waiting for a
response from the server instead of waiting in the Reactor.  The RW
strategy only works when the application does not have to worry about
new request showing up when waiting for a response. Therefore, this
strategy is appropriate only for "pure" clients. Note that
applications with nested upcalls are not "pure" clients. Also note
that this strategy will only effect two way calls, since there is no
waiting for one way calls. This strategy can also be used in an
application that is both a client and a server if the server side is
handled by a separate thread and the client threads are "pure"
clients. <p>

Default for this option is MT.

</TD></TR>

<TR>
<TD><CODE>-ORBTransportMuxStrategy</CODE> <EM>EXCLUSIVE / MUXED</EM></TD>

<TD><A name="-ORBTransportMuxStrategy"></a>

EXCLUSIVE means that the Transport does not multiplex requests on a
    connection. At a time, there can be only one request pending on a
    connection.  <p>

MUXED means that Transport multiplexes more than one request at the
    same time on a connection. This is very important for getting the
    Asynchronous Method Invocation model to work. This is not
    implemented yet. <p>

Default for this option is EXCLUSIVE.

</TD></TR>




</TABLE>
</P>
</BLOCKQUOTE>
</blockquote>

<P><HR><P>
Back to the TAO <A HREF="components.html">components documentation</A>.

<!--#include virtual="/~schmidt/cgi-sig.html" -->
</HTML>
