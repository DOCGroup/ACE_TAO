// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.4.1
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:373


#include "TestC.h"
#include "tao/CDR.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "TestC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

FirstUnion::FirstUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = true;

}

FirstUnion::FirstUnion (const ::FirstUnion &u)
{
  this->disc_ = u.disc_;

  if (this->disc_)
    {
      this->u_.first_union_foo_ = u.u_.first_union_foo_;
    }

  if (!this->disc_)
    {
      this->u_.first_union_bar_ = u.u_.first_union_bar_;
    }

}

FirstUnion::~FirstUnion (void)
{
  // Finalize.
  this->_reset ();
}

FirstUnion &
FirstUnion::operator= (const ::FirstUnion &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;


  if (this->disc_)
    {
      this->u_.first_union_foo_ = u.u_.first_union_foo_;
    }

  if (!this->disc_)
    {
      this->u_.first_union_bar_ = u.u_.first_union_bar_;
    }

  return *this;
}

/// Reset method to reset old values of a union.
void FirstUnion::_reset (void)
{

  if (this->disc_)
    {

    }

  if (!this->disc_)
    {

    }

}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:94

FirstUnionArray_slice *
FirstUnionArray_dup (const FirstUnionArray_slice *_tao_src_array)
{
  FirstUnionArray_slice *_tao_dup_array =
    FirstUnionArray_alloc ();

  if (!_tao_dup_array)
    {
      return static_cast <FirstUnionArray_slice *> (0);
    }

  FirstUnionArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

FirstUnionArray_slice *
FirstUnionArray_alloc (void)
{
  FirstUnionArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, FirstUnion[2], 0);
  return retval;
}

void
FirstUnionArray_free (
    FirstUnionArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
FirstUnionArray_copy (
    FirstUnionArray_slice * _tao_to,
    const FirstUnionArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 2; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

SecondUnion::SecondUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = true;
  ACE_NEW (
    this->u_.second_union_struct_member_,
    MyStruct);
}

SecondUnion::SecondUnion (const ::SecondUnion &u)
{
  this->disc_ = u.disc_;

  if (this->disc_)
    {
      if (u.u_.second_union_struct_member_ == 0)
        {
          this->u_.second_union_struct_member_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.second_union_struct_member_,
              MyStruct (*u.u_.second_union_struct_member_)
            );
        }
    }

  if (!this->disc_)
    {
      this->u_.wibble_ = u.u_.wibble_;
    }

}

SecondUnion::~SecondUnion (void)
{
  // Finalize.
  this->_reset ();
}

SecondUnion &
SecondUnion::operator= (const ::SecondUnion &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;


  if (this->disc_)
    {
      if (u.u_.second_union_struct_member_ == 0)
        {
          this->u_.second_union_struct_member_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.second_union_struct_member_,
              MyStruct (*u.u_.second_union_struct_member_),
              *this
            );
        }
    }

  if (!this->disc_)
    {
      this->u_.wibble_ = u.u_.wibble_;
    }

  return *this;
}

/// Reset method to reset old values of a union.
void SecondUnion::_reset (void)
{

  if (this->disc_)
    {
      delete this->u_.second_union_struct_member_;
      this->u_.second_union_struct_member_ = 0;

    }

  if (!this->disc_)
    {

    }

}

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FirstUnion &_tao_union
  )
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if ( !(strm << tmp) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result = strm << _tao_union.first_union_foo ();
    }

  if (!_tao_union._d ())
    {
      result = strm << _tao_union.first_union_bar ();
    }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FirstUnion &_tao_union
  )
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if ( !(strm >> tmp) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  if (_tao_discriminant)
    {
      CORBA::Long _tao_union_tmp;
      result = strm >> _tao_union_tmp;

      if (result)
        {
          _tao_union.first_union_foo (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }

  if (!_tao_discriminant)
    {
      CORBA::Long _tao_union_tmp;
      result = strm >> _tao_union_tmp;

      if (result)
        {
          _tao_union.first_union_bar (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:163


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const FirstUnionArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;

  for ( ::CORBA::ULong i0 = 0; i0 < 2 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    FirstUnionArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;

  for ( ::CORBA::ULong i0 = 0; i0 < 2 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const MyStruct &_tao_aggregate)
{
  FirstUnionArray_forany _tao_aggregate_my_struct_foo
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((FirstUnionArray_slice*) (
      #else
      (const_cast<
          FirstUnionArray_slice*> (
      #endif
          _tao_aggregate.my_struct_foo
        )
    );
  return
    (strm << _tao_aggregate_my_struct_foo);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    MyStruct &_tao_aggregate)
{
  FirstUnionArray_forany _tao_aggregate_my_struct_foo
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((FirstUnionArray_slice*) (
      #else
      (const_cast<
          FirstUnionArray_slice*> (
      #endif
          _tao_aggregate.my_struct_foo
        )
    );
  return
    (strm >> _tao_aggregate_my_struct_foo);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SecondUnion &_tao_union
  )
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if ( !(strm << tmp) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result = strm << _tao_union.second_union_struct_member ();
    }

  if (!_tao_union._d ())
    {
      result = strm << _tao_union.wibble ();
    }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SecondUnion &_tao_union
  )
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if ( !(strm >> tmp) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  if (_tao_discriminant)
    {
      MyStruct _tao_union_tmp;
      result = strm >> _tao_union_tmp;

      if (result)
        {
          _tao_union.second_union_struct_member (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }

  if (!_tao_discriminant)
    {
      CORBA::Long _tao_union_tmp;
      result = strm >> _tao_union_tmp;

      if (result)
        {
          _tao_union.wibble (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



