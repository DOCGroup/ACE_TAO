// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.4.1
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:373


#include "TestC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "ace/OS_NS_string.h"
#include "ace/Auto_Ptr.h"

#if !defined (__ACE_INLINE__)
#include "TestC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Foo::Bar::A.

Foo::Bar::A_ptr
TAO::Objref_Traits<Foo::Bar::A>::duplicate (
    Foo::Bar::A_ptr p)
{
  return Foo::Bar::A::_duplicate (p);
}

void
TAO::Objref_Traits<Foo::Bar::A>::release (
    Foo::Bar::A_ptr p)
{
  ::CORBA::release (p);
}

Foo::Bar::A_ptr
TAO::Objref_Traits<Foo::Bar::A>::nil (void)
{
  return Foo::Bar::A::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Foo::Bar::A>::marshal (
    const Foo::Bar::A_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

::CORBA::Long
Foo::Bar::A::op1 (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

::CORBA::Long
Foo::Bar::A::op2 (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

Foo::Bar::A::A (void)
{
}

Foo::Bar::A::~A (void)
{
}

void
Foo::Bar::A::_tao_any_destructor (void *_tao_void_pointer)
{
  A *_tao_tmp_pointer =
    static_cast<A *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Foo::Bar::A_ptr
Foo::Bar::A::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<A>::narrow (
        _tao_objref,
        "IDL:Foo/Bar/A:1.0");
}

Foo::Bar::A_ptr
Foo::Bar::A::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<A>::unchecked_narrow (
        _tao_objref);
}

Foo::Bar::A_ptr
Foo::Bar::A::_nil (void)
{
  return 0;
}

Foo::Bar::A_ptr
Foo::Bar::A::_duplicate (A_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Foo::Bar::A::_tao_release (A_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Foo::Bar::A::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Foo/Bar/A:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Foo::Bar::A::_interface_repository_id (void) const
{
  return "IDL:Foo/Bar/A:1.0";
}

::CORBA::Boolean
Foo::Bar::A::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Foo_Bar_A (
    ::CORBA::tk_objref,
    "IDL:Foo/Bar/A:1.0",
    "A");


namespace Foo
{

  namespace Bar
  {
    ::CORBA::TypeCode_ptr const _tc_A =
      &_tao_tc_Foo_Bar_A;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Foo_Bar_AMH_AExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Foo_Bar_AMH_AExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Foo/Bar/AMH_AExceptionHolder:1.0",
    "AMH_AExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Foo_Bar_AMH_AExceptionHolder,
    0);


namespace Foo
{

  namespace Bar
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_AExceptionHolder =
      &_tao_tc_Foo_Bar_AMH_AExceptionHolder;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Foo::Bar::AMH_AExceptionHolder>::add_ref (
    Foo::Bar::AMH_AExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Foo::Bar::AMH_AExceptionHolder>::remove_ref (
    Foo::Bar::AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Foo::Bar::AMH_AExceptionHolder>::release (
    Foo::Bar::AMH_AExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

Foo::Bar::AMH_AExceptionHolder *
Foo::Bar::AMH_AExceptionHolder::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Foo::Bar::AMH_AExceptionHolder * > (v);
}

const char *
Foo::Bar::AMH_AExceptionHolder::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Foo::Bar::AMH_AExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Foo::Bar::AMH_AExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_AExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Foo::Bar::AMH_AExceptionHolder::_tao_type (void) const
{
  return ::Foo::Bar::_tc_AMH_AExceptionHolder;
}

Foo::Bar::AMH_AExceptionHolder::~AMH_AExceptionHolder (void)
{}

::CORBA::ValueBase *
Foo::Bar::AMH_AExceptionHolder::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_AExceptionHolder (),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
Foo::Bar::AMH_AExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_AExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_AExceptionHolder::_tao_match_formal_type (ptrdiff_t ) const
{
  return false;
}

::CORBA::Boolean
Foo::Bar::AMH_AExceptionHolder::_tao_marshal__Foo_Bar_AMH_AExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_AExceptionHolder::_tao_unmarshal__Foo_Bar_AMH_AExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_AExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_AExceptionHolder *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_AExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_AExceptionHolder::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:421

void
Foo::Bar::AMH_AExceptionHolder::raise_op1 (void)
{
auto_ptr< ::CORBA::Exception> safety (this->exception);
this->exception->_raise ();
}


// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:421

void
Foo::Bar::AMH_AExceptionHolder::raise_op2 (void)
{
auto_ptr< ::CORBA::Exception> safety (this->exception);
this->exception->_raise ();
}


// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Foo::Bar::AMH_AResponseHandler.

Foo::Bar::AMH_AResponseHandler_ptr
TAO::Objref_Traits<Foo::Bar::AMH_AResponseHandler>::duplicate (
    Foo::Bar::AMH_AResponseHandler_ptr p)
{
  return Foo::Bar::AMH_AResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Foo::Bar::AMH_AResponseHandler>::release (
    Foo::Bar::AMH_AResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Foo::Bar::AMH_AResponseHandler_ptr
TAO::Objref_Traits<Foo::Bar::AMH_AResponseHandler>::nil (void)
{
  return Foo::Bar::AMH_AResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Foo::Bar::AMH_AResponseHandler>::marshal (
    const Foo::Bar::AMH_AResponseHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

Foo::Bar::AMH_AResponseHandler::AMH_AResponseHandler (void)
{}

Foo::Bar::AMH_AResponseHandler::~AMH_AResponseHandler (void)
{
}

void
Foo::Bar::AMH_AResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_AResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_AResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Foo::Bar::AMH_AResponseHandler_ptr
Foo::Bar::AMH_AResponseHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref)
    );
}

Foo::Bar::AMH_AResponseHandler_ptr
Foo::Bar::AMH_AResponseHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AMH_AResponseHandler::_duplicate (
      dynamic_cast<AMH_AResponseHandler_ptr> (_tao_objref)
    );
}

Foo::Bar::AMH_AResponseHandler_ptr
Foo::Bar::AMH_AResponseHandler::_nil (void)
{
  return 0;
}

Foo::Bar::AMH_AResponseHandler_ptr
Foo::Bar::AMH_AResponseHandler::_duplicate (AMH_AResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Foo::Bar::AMH_AResponseHandler::_tao_release (AMH_AResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Foo::Bar::AMH_AResponseHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Foo/Bar/AMH_AResponseHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Foo::Bar::AMH_AResponseHandler::_interface_repository_id (void) const
{
  return "IDL:Foo/Bar/AMH_AResponseHandler:1.0";
}

::CORBA::Boolean
Foo::Bar::AMH_AResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Foo_Bar_AMH_AResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Foo/Bar/AMH_AResponseHandler:1.0",
    "AMH_AResponseHandler");


namespace Foo
{

  namespace Bar
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_AResponseHandler =
      &_tao_tc_Foo_Bar_AMH_AResponseHandler;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Foo::Bar::B.

Foo::Bar::B_ptr
TAO::Objref_Traits<Foo::Bar::B>::duplicate (
    Foo::Bar::B_ptr p)
{
  return Foo::Bar::B::_duplicate (p);
}

void
TAO::Objref_Traits<Foo::Bar::B>::release (
    Foo::Bar::B_ptr p)
{
  ::CORBA::release (p);
}

Foo::Bar::B_ptr
TAO::Objref_Traits<Foo::Bar::B>::nil (void)
{
  return Foo::Bar::B::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Foo::Bar::B>::marshal (
    const Foo::Bar::B_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

::CORBA::Long
Foo::Bar::B::op3 (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "op3",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

Foo::Bar::B::B (void)
{
}

Foo::Bar::B::~B (void)
{
}

void
Foo::Bar::B::_tao_any_destructor (void *_tao_void_pointer)
{
  B *_tao_tmp_pointer =
    static_cast<B *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Foo::Bar::B_ptr
Foo::Bar::B::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<B>::narrow (
        _tao_objref,
        "IDL:Foo/Bar/B:1.0");
}

Foo::Bar::B_ptr
Foo::Bar::B::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<B>::unchecked_narrow (
        _tao_objref);
}

Foo::Bar::B_ptr
Foo::Bar::B::_nil (void)
{
  return 0;
}

Foo::Bar::B_ptr
Foo::Bar::B::_duplicate (B_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Foo::Bar::B::_tao_release (B_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Foo::Bar::B::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Foo/Bar/B:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Foo::Bar::B::_interface_repository_id (void) const
{
  return "IDL:Foo/Bar/B:1.0";
}

::CORBA::Boolean
Foo::Bar::B::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Foo_Bar_B (
    ::CORBA::tk_objref,
    "IDL:Foo/Bar/B:1.0",
    "B");


namespace Foo
{

  namespace Bar
  {
    ::CORBA::TypeCode_ptr const _tc_B =
      &_tao_tc_Foo_Bar_B;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Foo_Bar_AMH_BExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Foo_Bar_AMH_BExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Foo/Bar/AMH_BExceptionHolder:1.0",
    "AMH_BExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Foo_Bar_AMH_BExceptionHolder,
    0);


namespace Foo
{

  namespace Bar
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_BExceptionHolder =
      &_tao_tc_Foo_Bar_AMH_BExceptionHolder;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Foo::Bar::AMH_BExceptionHolder>::add_ref (
    Foo::Bar::AMH_BExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Foo::Bar::AMH_BExceptionHolder>::remove_ref (
    Foo::Bar::AMH_BExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Foo::Bar::AMH_BExceptionHolder>::release (
    Foo::Bar::AMH_BExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

Foo::Bar::AMH_BExceptionHolder *
Foo::Bar::AMH_BExceptionHolder::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Foo::Bar::AMH_BExceptionHolder * > (v);
}

const char *
Foo::Bar::AMH_BExceptionHolder::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Foo::Bar::AMH_BExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Foo::Bar::AMH_BExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_BExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Foo::Bar::AMH_BExceptionHolder::_tao_type (void) const
{
  return ::Foo::Bar::_tc_AMH_BExceptionHolder;
}

Foo::Bar::AMH_BExceptionHolder::~AMH_BExceptionHolder (void)
{}

::CORBA::ValueBase *
Foo::Bar::AMH_BExceptionHolder::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_BExceptionHolder (),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
Foo::Bar::AMH_BExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_BExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_BExceptionHolder::_tao_match_formal_type (ptrdiff_t ) const
{
  return false;
}

::CORBA::Boolean
Foo::Bar::AMH_BExceptionHolder::_tao_marshal__Foo_Bar_AMH_BExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_BExceptionHolder::_tao_unmarshal__Foo_Bar_AMH_BExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Foo::Bar::AMH_BExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_BExceptionHolder *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_BExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_BExceptionHolder::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:421

void
Foo::Bar::AMH_BExceptionHolder::raise_op3 (void)
{
auto_ptr< ::CORBA::Exception> safety (this->exception);
this->exception->_raise ();
}


// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Foo::Bar::AMH_BResponseHandler.

Foo::Bar::AMH_BResponseHandler_ptr
TAO::Objref_Traits<Foo::Bar::AMH_BResponseHandler>::duplicate (
    Foo::Bar::AMH_BResponseHandler_ptr p)
{
  return Foo::Bar::AMH_BResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Foo::Bar::AMH_BResponseHandler>::release (
    Foo::Bar::AMH_BResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Foo::Bar::AMH_BResponseHandler_ptr
TAO::Objref_Traits<Foo::Bar::AMH_BResponseHandler>::nil (void)
{
  return Foo::Bar::AMH_BResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Foo::Bar::AMH_BResponseHandler>::marshal (
    const Foo::Bar::AMH_BResponseHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

Foo::Bar::AMH_BResponseHandler::AMH_BResponseHandler (void)
{}

Foo::Bar::AMH_BResponseHandler::~AMH_BResponseHandler (void)
{
}

void
Foo::Bar::AMH_BResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_BResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_BResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Foo::Bar::AMH_BResponseHandler_ptr
Foo::Bar::AMH_BResponseHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AMH_BResponseHandler::_duplicate (
      dynamic_cast<AMH_BResponseHandler_ptr> (_tao_objref)
    );
}

Foo::Bar::AMH_BResponseHandler_ptr
Foo::Bar::AMH_BResponseHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AMH_BResponseHandler::_duplicate (
      dynamic_cast<AMH_BResponseHandler_ptr> (_tao_objref)
    );
}

Foo::Bar::AMH_BResponseHandler_ptr
Foo::Bar::AMH_BResponseHandler::_nil (void)
{
  return 0;
}

Foo::Bar::AMH_BResponseHandler_ptr
Foo::Bar::AMH_BResponseHandler::_duplicate (AMH_BResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Foo::Bar::AMH_BResponseHandler::_tao_release (AMH_BResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Foo::Bar::AMH_BResponseHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Foo/Bar/AMH_BResponseHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Foo::Bar::AMH_BResponseHandler::_interface_repository_id (void) const
{
  return "IDL:Foo/Bar/AMH_BResponseHandler:1.0";
}

::CORBA::Boolean
Foo::Bar::AMH_BResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Foo_Bar_AMH_BResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Foo/Bar/AMH_BResponseHandler:1.0",
    "AMH_BResponseHandler");


namespace Foo
{

  namespace Bar
  {
    ::CORBA::TypeCode_ptr const _tc_AMH_BResponseHandler =
      &_tao_tc_Foo_Bar_AMH_BResponseHandler;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Baz::C.

Baz::C_ptr
TAO::Objref_Traits<Baz::C>::duplicate (
    Baz::C_ptr p)
{
  return Baz::C::_duplicate (p);
}

void
TAO::Objref_Traits<Baz::C>::release (
    Baz::C_ptr p)
{
  ::CORBA::release (p);
}

Baz::C_ptr
TAO::Objref_Traits<Baz::C>::nil (void)
{
  return Baz::C::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Baz::C>::marshal (
    const Baz::C_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

::CORBA::Long
Baz::C::op4 (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "op4",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

void
Baz::C::shutdown (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "shutdown",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_ONEWAY_INVOCATION,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);
}

Baz::C::C (void)
{
}

Baz::C::~C (void)
{
}

void
Baz::C::_tao_any_destructor (void *_tao_void_pointer)
{
  C *_tao_tmp_pointer =
    static_cast<C *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Baz::C_ptr
Baz::C::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<C>::narrow (
        _tao_objref,
        "IDL:Baz/C:1.0");
}

Baz::C_ptr
Baz::C::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<C>::unchecked_narrow (
        _tao_objref);
}

Baz::C_ptr
Baz::C::_nil (void)
{
  return 0;
}

Baz::C_ptr
Baz::C::_duplicate (C_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Baz::C::_tao_release (C_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Baz::C::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Foo/Bar/A:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:Foo/Bar/B:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:Baz/C:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Baz::C::_interface_repository_id (void) const
{
  return "IDL:Baz/C:1.0";
}

::CORBA::Boolean
Baz::C::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Baz_C (
    ::CORBA::tk_objref,
    "IDL:Baz/C:1.0",
    "C");


namespace Baz
{
  ::CORBA::TypeCode_ptr const _tc_C =
    &_tao_tc_Baz_C;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_fields_Baz_AMH_CExceptionHolder = 0;
static TAO::TypeCode::Value<char const *,
                     ::CORBA::TypeCode_ptr const *,
                     TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                     TAO::Null_RefCount_Policy>
  _tao_tc_Baz_AMH_CExceptionHolder (
    ::CORBA::tk_value,
    "IDL:Baz/AMH_CExceptionHolder:1.0",
    "AMH_CExceptionHolder",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Baz_AMH_CExceptionHolder,
    0);


namespace Baz
{
  ::CORBA::TypeCode_ptr const _tc_AMH_CExceptionHolder =
    &_tao_tc_Baz_AMH_CExceptionHolder;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Baz::AMH_CExceptionHolder>::add_ref (
    Baz::AMH_CExceptionHolder * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Baz::AMH_CExceptionHolder>::remove_ref (
    Baz::AMH_CExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Baz::AMH_CExceptionHolder>::release (
    Baz::AMH_CExceptionHolder * p)
{
  ::CORBA::remove_ref (p);
}

Baz::AMH_CExceptionHolder *
Baz::AMH_CExceptionHolder::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Baz::AMH_CExceptionHolder * > (v);
}

const char *
Baz::AMH_CExceptionHolder::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Baz::AMH_CExceptionHolder::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Baz::AMH_CExceptionHolder::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_CExceptionHolder *_tao_tmp_pointer =
    static_cast<AMH_CExceptionHolder *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Baz::AMH_CExceptionHolder::_tao_type (void) const
{
  return ::Baz::_tc_AMH_CExceptionHolder;
}

Baz::AMH_CExceptionHolder::~AMH_CExceptionHolder (void)
{}

::CORBA::ValueBase *
Baz::AMH_CExceptionHolder::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    AMH_CExceptionHolder (),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
Baz::AMH_CExceptionHolder::_tao_marshal_v (TAO_OutputCDR &) const
{
  return true;
}

::CORBA::Boolean
Baz::AMH_CExceptionHolder::_tao_unmarshal_v (TAO_InputCDR &)
{
  return true;
}

::CORBA::Boolean
Baz::AMH_CExceptionHolder::_tao_match_formal_type (ptrdiff_t ) const
{
  return false;
}

::CORBA::Boolean
Baz::AMH_CExceptionHolder::_tao_marshal__Baz_AMH_CExceptionHolder (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
Baz::AMH_CExceptionHolder::_tao_unmarshal__Baz_AMH_CExceptionHolder (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

::CORBA::Boolean
Baz::AMH_CExceptionHolder::_tao_unmarshal (
    TAO_InputCDR &strm,
    AMH_CExceptionHolder *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        AMH_CExceptionHolder::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = AMH_CExceptionHolder::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:421

void
Baz::AMH_CExceptionHolder::raise_op4 (void)
{
auto_ptr< ::CORBA::Exception> safety (this->exception);
this->exception->_raise ();
}


// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:421

void
Baz::AMH_CExceptionHolder::raise_shutdown (void)
{
auto_ptr< ::CORBA::Exception> safety (this->exception);
this->exception->_raise ();
}


// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Baz::AMH_CResponseHandler.

Baz::AMH_CResponseHandler_ptr
TAO::Objref_Traits<Baz::AMH_CResponseHandler>::duplicate (
    Baz::AMH_CResponseHandler_ptr p)
{
  return Baz::AMH_CResponseHandler::_duplicate (p);
}

void
TAO::Objref_Traits<Baz::AMH_CResponseHandler>::release (
    Baz::AMH_CResponseHandler_ptr p)
{
  ::CORBA::release (p);
}

Baz::AMH_CResponseHandler_ptr
TAO::Objref_Traits<Baz::AMH_CResponseHandler>::nil (void)
{
  return Baz::AMH_CResponseHandler::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Baz::AMH_CResponseHandler>::marshal (
    const Baz::AMH_CResponseHandler_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

Baz::AMH_CResponseHandler::AMH_CResponseHandler (void)
{}

Baz::AMH_CResponseHandler::~AMH_CResponseHandler (void)
{
}

void
Baz::AMH_CResponseHandler::_tao_any_destructor (void *_tao_void_pointer)
{
  AMH_CResponseHandler *_tao_tmp_pointer =
    static_cast<AMH_CResponseHandler *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Baz::AMH_CResponseHandler_ptr
Baz::AMH_CResponseHandler::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AMH_CResponseHandler::_duplicate (
      dynamic_cast<AMH_CResponseHandler_ptr> (_tao_objref)
    );
}

Baz::AMH_CResponseHandler_ptr
Baz::AMH_CResponseHandler::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return AMH_CResponseHandler::_duplicate (
      dynamic_cast<AMH_CResponseHandler_ptr> (_tao_objref)
    );
}

Baz::AMH_CResponseHandler_ptr
Baz::AMH_CResponseHandler::_nil (void)
{
  return 0;
}

Baz::AMH_CResponseHandler_ptr
Baz::AMH_CResponseHandler::_duplicate (AMH_CResponseHandler_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Baz::AMH_CResponseHandler::_tao_release (AMH_CResponseHandler_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Baz::AMH_CResponseHandler::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Baz/AMH_CResponseHandler:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* Baz::AMH_CResponseHandler::_interface_repository_id (void) const
{
  return "IDL:Baz/AMH_CResponseHandler:1.0";
}

::CORBA::Boolean
Baz::AMH_CResponseHandler::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Baz_AMH_CResponseHandler (
    ::CORBA::tk_local_interface,
    "IDL:Baz/AMH_CResponseHandler:1.0",
    "AMH_CResponseHandler");


namespace Baz
{
  ::CORBA::TypeCode_ptr const _tc_AMH_CResponseHandler =
    &_tao_tc_Baz_AMH_CResponseHandler;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Foo::Bar::AMH_AExceptionHolder::AMH_AExceptionHolder (void)
: require_truncation_ (false)
{}

OBV_Foo::Bar::AMH_AExceptionHolder::~AMH_AExceptionHolder (void)
{}

::CORBA::Boolean
OBV_Foo::Bar::AMH_AExceptionHolder::_tao_marshal__Foo_Bar_AMH_AExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Foo::Bar::AMH_AExceptionHolder::_tao_unmarshal__Foo_Bar_AMH_AExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Foo::Bar::AMH_BExceptionHolder::AMH_BExceptionHolder (void)
: require_truncation_ (false)
{}

OBV_Foo::Bar::AMH_BExceptionHolder::~AMH_BExceptionHolder (void)
{}

::CORBA::Boolean
OBV_Foo::Bar::AMH_BExceptionHolder::_tao_marshal__Foo_Bar_AMH_BExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Foo::Bar::AMH_BExceptionHolder::_tao_unmarshal__Foo_Bar_AMH_BExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Baz::AMH_CExceptionHolder::AMH_CExceptionHolder (void)
: require_truncation_ (false)
{}

OBV_Baz::AMH_CExceptionHolder::~AMH_CExceptionHolder (void)
{}

::CORBA::Boolean
OBV_Baz::AMH_CExceptionHolder::_tao_marshal__Baz_AMH_CExceptionHolder (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Baz::AMH_CExceptionHolder::_tao_unmarshal__Baz_AMH_CExceptionHolder (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::A>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Foo
{

  namespace Bar
  {


    /// Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        A_ptr _tao_elem)
    {
      A_ptr _tao_objptr =
        A::_duplicate (_tao_elem);
      _tao_any <<= &_tao_objptr;
    }

    /// Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        A_ptr *_tao_elem)
    {
      TAO::Any_Impl_T<A>::insert (
          _tao_any,
          A::_tao_any_destructor,
          _tc_A,
          *_tao_elem);
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        A_ptr &_tao_elem)
    {
      return
        TAO::Any_Impl_T<A>::extract (
            _tao_any,
            A::_tao_any_destructor,
            _tc_A,
            _tao_elem);
    }
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::A_ptr _tao_elem)
{
  Foo::Bar::A_ptr _tao_objptr =
    Foo::Bar::A::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::A_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Foo::Bar::A>::insert (
      _tao_any,
      Foo::Bar::A::_tao_any_destructor,
      Foo::Bar::_tc_A,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Foo::Bar::A_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Foo::Bar::A>::extract (
        _tao_any,
        Foo::Bar::A::_tao_any_destructor,
        Foo::Bar::_tc_A,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_AExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Foo
{

  namespace Bar
  {
    // Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_AExceptionHolder *_tao_elem
      )
    {
      #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
        AMH_AExceptionHolder *_tao_copy =
          _tao_elem ?
            AMH_AExceptionHolder::_downcast (_tao_elem->_copy_value ())
            : 0;
        _tao_any <<= &_tao_copy;
      #else
        ::CORBA::add_ref (_tao_elem);
        _tao_any <<= &_tao_elem;
      #endif
    }

    // Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_AExceptionHolder **_tao_elem
      )
    {
      TAO::Any_Impl_T<AMH_AExceptionHolder>::insert (
          _tao_any,
          AMH_AExceptionHolder::_tao_any_destructor,
          _tc_AMH_AExceptionHolder,
          *_tao_elem
        );
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        AMH_AExceptionHolder *&_tao_elem
      )
    {
      return
        TAO::Any_Impl_T<AMH_AExceptionHolder>::extract (
            _tao_any,
            AMH_AExceptionHolder::_tao_any_destructor,
            _tc_AMH_AExceptionHolder,
            _tao_elem
          );
    }


  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_AExceptionHolder *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Foo::Bar::AMH_AExceptionHolder *_tao_copy =
      _tao_elem ?
        Foo::Bar::AMH_AExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_AExceptionHolder **_tao_elem
  )
{
  TAO::Any_Impl_T<Foo::Bar::AMH_AExceptionHolder>::insert (
      _tao_any,
      Foo::Bar::AMH_AExceptionHolder::_tao_any_destructor,
      Foo::Bar::_tc_AMH_AExceptionHolder,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_AExceptionHolder *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Foo::Bar::AMH_AExceptionHolder>::extract (
        _tao_any,
        Foo::Bar::AMH_AExceptionHolder::_tao_any_destructor,
        Foo::Bar::_tc_AMH_AExceptionHolder,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_AResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_AResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_AResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Foo
{

  namespace Bar
  {


    /// Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_AResponseHandler_ptr _tao_elem)
    {
      AMH_AResponseHandler_ptr _tao_objptr =
        AMH_AResponseHandler::_duplicate (_tao_elem);
      _tao_any <<= &_tao_objptr;
    }

    /// Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_AResponseHandler_ptr *_tao_elem)
    {
      TAO::Any_Impl_T<AMH_AResponseHandler>::insert (
          _tao_any,
          AMH_AResponseHandler::_tao_any_destructor,
          _tc_AMH_AResponseHandler,
          *_tao_elem);
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        AMH_AResponseHandler_ptr &_tao_elem)
    {
      return
        TAO::Any_Impl_T<AMH_AResponseHandler>::extract (
            _tao_any,
            AMH_AResponseHandler::_tao_any_destructor,
            _tc_AMH_AResponseHandler,
            _tao_elem);
    }
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_AResponseHandler_ptr _tao_elem)
{
  Foo::Bar::AMH_AResponseHandler_ptr _tao_objptr =
    Foo::Bar::AMH_AResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_AResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Foo::Bar::AMH_AResponseHandler>::insert (
      _tao_any,
      Foo::Bar::AMH_AResponseHandler::_tao_any_destructor,
      Foo::Bar::_tc_AMH_AResponseHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_AResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Foo::Bar::AMH_AResponseHandler>::extract (
        _tao_any,
        Foo::Bar::AMH_AResponseHandler::_tao_any_destructor,
        Foo::Bar::_tc_AMH_AResponseHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::B>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Foo
{

  namespace Bar
  {


    /// Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        B_ptr _tao_elem)
    {
      B_ptr _tao_objptr =
        B::_duplicate (_tao_elem);
      _tao_any <<= &_tao_objptr;
    }

    /// Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        B_ptr *_tao_elem)
    {
      TAO::Any_Impl_T<B>::insert (
          _tao_any,
          B::_tao_any_destructor,
          _tc_B,
          *_tao_elem);
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        B_ptr &_tao_elem)
    {
      return
        TAO::Any_Impl_T<B>::extract (
            _tao_any,
            B::_tao_any_destructor,
            _tc_B,
            _tao_elem);
    }
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::B_ptr _tao_elem)
{
  Foo::Bar::B_ptr _tao_objptr =
    Foo::Bar::B::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::B_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Foo::Bar::B>::insert (
      _tao_any,
      Foo::Bar::B::_tao_any_destructor,
      Foo::Bar::_tc_B,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Foo::Bar::B_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Foo::Bar::B>::extract (
        _tao_any,
        Foo::Bar::B::_tao_any_destructor,
        Foo::Bar::_tc_B,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_BExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Foo
{

  namespace Bar
  {
    // Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_BExceptionHolder *_tao_elem
      )
    {
      #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
        AMH_BExceptionHolder *_tao_copy =
          _tao_elem ?
            AMH_BExceptionHolder::_downcast (_tao_elem->_copy_value ())
            : 0;
        _tao_any <<= &_tao_copy;
      #else
        ::CORBA::add_ref (_tao_elem);
        _tao_any <<= &_tao_elem;
      #endif
    }

    // Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_BExceptionHolder **_tao_elem
      )
    {
      TAO::Any_Impl_T<AMH_BExceptionHolder>::insert (
          _tao_any,
          AMH_BExceptionHolder::_tao_any_destructor,
          _tc_AMH_BExceptionHolder,
          *_tao_elem
        );
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        AMH_BExceptionHolder *&_tao_elem
      )
    {
      return
        TAO::Any_Impl_T<AMH_BExceptionHolder>::extract (
            _tao_any,
            AMH_BExceptionHolder::_tao_any_destructor,
            _tc_AMH_BExceptionHolder,
            _tao_elem
          );
    }


  }
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_BExceptionHolder *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Foo::Bar::AMH_BExceptionHolder *_tao_copy =
      _tao_elem ?
        Foo::Bar::AMH_BExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_BExceptionHolder **_tao_elem
  )
{
  TAO::Any_Impl_T<Foo::Bar::AMH_BExceptionHolder>::insert (
      _tao_any,
      Foo::Bar::AMH_BExceptionHolder::_tao_any_destructor,
      Foo::Bar::_tc_AMH_BExceptionHolder,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_BExceptionHolder *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Foo::Bar::AMH_BExceptionHolder>::extract (
        _tao_any,
        Foo::Bar::AMH_BExceptionHolder::_tao_any_destructor,
        Foo::Bar::_tc_AMH_BExceptionHolder,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_BResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_BResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Foo::Bar::AMH_BResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Foo
{

  namespace Bar
  {


    /// Copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_BResponseHandler_ptr _tao_elem)
    {
      AMH_BResponseHandler_ptr _tao_objptr =
        AMH_BResponseHandler::_duplicate (_tao_elem);
      _tao_any <<= &_tao_objptr;
    }

    /// Non-copying insertion.
    void
    operator<<= (
        ::CORBA::Any &_tao_any,
        AMH_BResponseHandler_ptr *_tao_elem)
    {
      TAO::Any_Impl_T<AMH_BResponseHandler>::insert (
          _tao_any,
          AMH_BResponseHandler::_tao_any_destructor,
          _tc_AMH_BResponseHandler,
          *_tao_elem);
    }

    ::CORBA::Boolean
    operator>>= (
        const ::CORBA::Any &_tao_any,
        AMH_BResponseHandler_ptr &_tao_elem)
    {
      return
        TAO::Any_Impl_T<AMH_BResponseHandler>::extract (
            _tao_any,
            AMH_BResponseHandler::_tao_any_destructor,
            _tc_AMH_BResponseHandler,
            _tao_elem);
    }
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_BResponseHandler_ptr _tao_elem)
{
  Foo::Bar::AMH_BResponseHandler_ptr _tao_objptr =
    Foo::Bar::AMH_BResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_BResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Foo::Bar::AMH_BResponseHandler>::insert (
      _tao_any,
      Foo::Bar::AMH_BResponseHandler::_tao_any_destructor,
      Foo::Bar::_tc_AMH_BResponseHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Foo::Bar::AMH_BResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Foo::Bar::AMH_BResponseHandler>::extract (
        _tao_any,
        Foo::Bar::AMH_BResponseHandler::_tao_any_destructor,
        Foo::Bar::_tc_AMH_BResponseHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Baz::C>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Baz
{


  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      C_ptr _tao_elem)
  {
    C_ptr _tao_objptr =
      C::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      C_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<C>::insert (
        _tao_any,
        C::_tao_any_destructor,
        _tc_C,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      C_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<C>::extract (
          _tao_any,
          C::_tao_any_destructor,
          _tc_C,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Baz::C_ptr _tao_elem)
{
  Baz::C_ptr _tao_objptr =
    Baz::C::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Baz::C_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Baz::C>::insert (
      _tao_any,
      Baz::C::_tao_any_destructor,
      Baz::_tc_C,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Baz::C_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Baz::C>::extract (
        _tao_any,
        Baz::C::_tao_any_destructor,
        Baz::_tc_C,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Baz::AMH_CExceptionHolder>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Baz
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMH_CExceptionHolder *_tao_elem
    )
  {
    #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
      AMH_CExceptionHolder *_tao_copy =
        _tao_elem ?
          AMH_CExceptionHolder::_downcast (_tao_elem->_copy_value ())
          : 0;
      _tao_any <<= &_tao_copy;
    #else
      ::CORBA::add_ref (_tao_elem);
      _tao_any <<= &_tao_elem;
    #endif
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMH_CExceptionHolder **_tao_elem
    )
  {
    TAO::Any_Impl_T<AMH_CExceptionHolder>::insert (
        _tao_any,
        AMH_CExceptionHolder::_tao_any_destructor,
        _tc_AMH_CExceptionHolder,
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMH_CExceptionHolder *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<AMH_CExceptionHolder>::extract (
          _tao_any,
          AMH_CExceptionHolder::_tao_any_destructor,
          _tc_AMH_CExceptionHolder,
          _tao_elem
        );
  }


}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Baz::AMH_CExceptionHolder *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Baz::AMH_CExceptionHolder *_tao_copy =
      _tao_elem ?
        Baz::AMH_CExceptionHolder::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Baz::AMH_CExceptionHolder **_tao_elem
  )
{
  TAO::Any_Impl_T<Baz::AMH_CExceptionHolder>::insert (
      _tao_any,
      Baz::AMH_CExceptionHolder::_tao_any_destructor,
      Baz::_tc_AMH_CExceptionHolder,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Baz::AMH_CExceptionHolder *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Baz::AMH_CExceptionHolder>::extract (
        _tao_any,
        Baz::AMH_CExceptionHolder::_tao_any_destructor,
        Baz::_tc_AMH_CExceptionHolder,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Baz::AMH_CResponseHandler>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}

namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Baz::AMH_CResponseHandler>::marshal_value (TAO_OutputCDR &)
  {
    return false;
  }

  template<>
  ::CORBA::Boolean
  Any_Impl_T<Baz::AMH_CResponseHandler>::demarshal_value (TAO_InputCDR &)
  {
    return false;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Baz
{


  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMH_CResponseHandler_ptr _tao_elem)
  {
    AMH_CResponseHandler_ptr _tao_objptr =
      AMH_CResponseHandler::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      AMH_CResponseHandler_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<AMH_CResponseHandler>::insert (
        _tao_any,
        AMH_CResponseHandler::_tao_any_destructor,
        _tc_AMH_CResponseHandler,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      AMH_CResponseHandler_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<AMH_CResponseHandler>::extract (
          _tao_any,
          AMH_CResponseHandler::_tao_any_destructor,
          _tc_AMH_CResponseHandler,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Baz::AMH_CResponseHandler_ptr _tao_elem)
{
  Baz::AMH_CResponseHandler_ptr _tao_objptr =
    Baz::AMH_CResponseHandler::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Baz::AMH_CResponseHandler_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Baz::AMH_CResponseHandler>::insert (
      _tao_any,
      Baz::AMH_CResponseHandler::_tao_any_destructor,
      Baz::_tc_AMH_CResponseHandler,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Baz::AMH_CResponseHandler_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Baz::AMH_CResponseHandler>::extract (
        _tao_any,
        Baz::AMH_CResponseHandler::_tao_any_destructor,
        Baz::_tc_AMH_CResponseHandler,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Foo::Bar::A_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Foo::Bar::A_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }

  typedef ::Foo::Bar::A RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Foo::Bar::AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Foo::Bar::AMH_AExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Foo::Bar::AMH_AExceptionHolder *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Foo::Bar::AMH_AExceptionHolder::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Foo::Bar::AMH_AExceptionHolder *&_tao_valuetype
  )
{
  return Foo::Bar::AMH_AExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Foo::Bar::AMH_AExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
OBV_Foo::Bar::AMH_AExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

void
OBV_Foo::Bar::AMH_AExceptionHolder::truncation_hook (void)
{
  this->require_truncation_ = true;
}



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Foo::Bar::B_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Foo::Bar::B_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }

  typedef ::Foo::Bar::B RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Foo::Bar::AMH_BExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Foo::Bar::AMH_BExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Foo::Bar::AMH_BExceptionHolder *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Foo::Bar::AMH_BExceptionHolder::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Foo::Bar::AMH_BExceptionHolder *&_tao_valuetype
  )
{
  return Foo::Bar::AMH_BExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Foo::Bar::AMH_BExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
OBV_Foo::Bar::AMH_BExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

void
OBV_Foo::Bar::AMH_BExceptionHolder::truncation_hook (void)
{
  this->require_truncation_ = true;
}



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Baz::C_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Baz::C_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }

  typedef ::Baz::C RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Baz::AMH_CExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Baz::AMH_CExceptionHolder * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Baz::AMH_CExceptionHolder *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Baz::AMH_CExceptionHolder::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Baz::AMH_CExceptionHolder *&_tao_valuetype
  )
{
  return Baz::AMH_CExceptionHolder::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Baz::AMH_CExceptionHolder::_tao_marshal_state (TAO_OutputCDR &, TAO_ChunkInfo&) const
{
  return true;
}

::CORBA::Boolean
OBV_Baz::AMH_CExceptionHolder::_tao_unmarshal_state (TAO_InputCDR &, TAO_ChunkInfo&)
{
  return true;
}

void
OBV_Baz::AMH_CExceptionHolder::truncation_hook (void)
{
  this->require_truncation_ = true;
}



