// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.4.1
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:373


#include "testC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "testC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_typecode/enum_typecode.cpp:29
static char const * const _tao_enumerators_UnionIecs_E_type_num[] =
  {
    "E_type_num_called_party_number",
    "E_type_num_calling_party_number",
    "E_type_num_inconnu"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_UnionIecs_E_type_num (
    "IDL:UnionIecs/E_type_num:1.0",
    "E_type_num",
    _tao_enumerators_UnionIecs_E_type_num,
    3);
  

namespace UnionIecs
{
  ::CORBA::TypeCode_ptr const _tc_E_type_num =
    &_tao_tc_UnionIecs_E_type_num;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_UnionIecs_T_champ_num (
    ::CORBA::tk_alias,
    "IDL:UnionIecs/T_champ_num:1.0",
    "T_champ_num",
    &CORBA::_tc_octet);
  

namespace UnionIecs
{
  ::CORBA::TypeCode_ptr const _tc_T_champ_num =
    &_tao_tc_UnionIecs_T_champ_num;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_UnionIecs_S_i_num[] =
      {
        { "type_num", &UnionIecs::_tc_E_type_num },
        { "nature", &UnionIecs::_tc_T_champ_num }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_UnionIecs_S_i_num (
  ::CORBA::tk_struct,
  "IDL:UnionIecs/S_i_num:1.0",
  "S_i_num",
  _tao_fields_UnionIecs_S_i_num,
  2);


namespace UnionIecs
{
  ::CORBA::TypeCode_ptr const _tc_S_i_num =
    &_tao_tc_UnionIecs_S_i_num;
}

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
UnionIecs::S_i_num::_tao_any_destructor (
    void *_tao_void_pointer)
{
  S_i_num *_tao_tmp_pointer =
    static_cast<S_i_num *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

UnionIecs::S_num::S_num (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = false;
}

UnionIecs::S_num::S_num (const ::UnionIecs::S_num &u)
{
  this->disc_ = u.disc_;
  
  if (this->disc_)
    {
      this->u_.num_ = u.u_.num_;
    }
  
}

UnionIecs::S_num::~S_num (void)
{
  // Finalize.
  this->_reset ();
}

void UnionIecs::S_num::_tao_any_destructor (void *_tao_void_pointer)
{
  S_num *tmp =
    static_cast<S_num *> (_tao_void_pointer);
  delete tmp;
}

UnionIecs::S_num &
UnionIecs::S_num::operator= (const ::UnionIecs::S_num &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  
  if (this->disc_)
    {
      this->u_.num_ = u.u_.num_;
    }
  
  return *this;
}

/// Reset method to reset old values of a union.
void UnionIecs::S_num::_reset (void)
{
  
  if (this->disc_)
    {
      
    }
  
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65

static TAO::TypeCode::Case_T<CORBA::Boolean, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_UnionIecs_S_num__0 (true, "num", &UnionIecs::_tc_S_i_num);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_UnionIecs_S_num[] =
  {
    &_tao_cases_UnionIecs_S_num__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_UnionIecs_S_num (
    "IDL:UnionIecs/S_num:1.0",
    "S_num",
    &CORBA::_tc_boolean,
    _tao_cases_UnionIecs_S_num,
    sizeof (_tao_cases_UnionIecs_S_num)/sizeof (_tao_cases_UnionIecs_S_num[0]),
    -1);
  

namespace UnionIecs
{
  ::CORBA::TypeCode_ptr const _tc_S_num =
    &_tao_tc_UnionIecs_S_num;
}

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace UnionIecs
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::UnionIecs::E_type_num _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::UnionIecs::E_type_num>::insert (
        _tao_any,
        ::UnionIecs::_tc_E_type_num,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::UnionIecs::E_type_num &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::UnionIecs::E_type_num>::extract (
          _tao_any,
          ::UnionIecs::_tc_E_type_num,
          _tao_elem 
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    UnionIecs::E_type_num _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<UnionIecs::E_type_num>::insert (
      _tao_any,
      UnionIecs::_tc_E_type_num,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    UnionIecs::E_type_num &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<UnionIecs::E_type_num>::extract (
        _tao_any,
        UnionIecs::_tc_E_type_num,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace UnionIecs
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::UnionIecs::S_i_num &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::UnionIecs::S_i_num>::insert_copy (
        _tao_any,
        ::UnionIecs::S_i_num::_tao_any_destructor,
        ::UnionIecs::_tc_S_i_num,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    UnionIecs::S_i_num *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::UnionIecs::S_i_num>::insert (
      _tao_any,
      ::UnionIecs::S_i_num::_tao_any_destructor,
      ::UnionIecs::_tc_S_i_num,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::UnionIecs::S_i_num *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::UnionIecs::S_i_num *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::UnionIecs::S_i_num *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::UnionIecs::S_i_num>::extract (
        _tao_any,
        ::UnionIecs::S_i_num::_tao_any_destructor,
        ::UnionIecs::_tc_S_i_num,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const UnionIecs::S_i_num &_tao_elem)
{
  TAO::Any_Dual_Impl_T<UnionIecs::S_i_num>::insert_copy (
    _tao_any,
    UnionIecs::S_i_num::_tao_any_destructor,
    UnionIecs::_tc_S_i_num,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  UnionIecs::S_i_num *_tao_elem)
{
  TAO::Any_Dual_Impl_T<UnionIecs::S_i_num>::insert (
    _tao_any,
    UnionIecs::S_i_num::_tao_any_destructor,
    UnionIecs::_tc_S_i_num,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  UnionIecs::S_i_num *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const UnionIecs::S_i_num *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const UnionIecs::S_i_num *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<UnionIecs::S_i_num>::extract (
      _tao_any,
      UnionIecs::S_i_num::_tao_any_destructor,
      UnionIecs::_tc_S_i_num,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace UnionIecs
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::UnionIecs::S_num &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::UnionIecs::S_num>::insert_copy (
        _tao_any,
        ::UnionIecs::S_num::_tao_any_destructor,
        ::UnionIecs::_tc_S_num,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::UnionIecs::S_num *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::UnionIecs::S_num>::insert (
      _tao_any,
      ::UnionIecs::S_num::_tao_any_destructor,
      ::UnionIecs::_tc_S_num,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::UnionIecs::S_num *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::UnionIecs::S_num *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::UnionIecs::S_num *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::UnionIecs::S_num>::extract (
        _tao_any,
        ::UnionIecs::S_num::_tao_any_destructor,
        ::UnionIecs::_tc_S_num,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const UnionIecs::S_num &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<UnionIecs::S_num>::insert_copy (
      _tao_any,
      UnionIecs::S_num::_tao_any_destructor,
      UnionIecs::_tc_S_num,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    UnionIecs::S_num *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<UnionIecs::S_num>::insert (
      _tao_any,
      UnionIecs::S_num::_tao_any_destructor,
      UnionIecs::_tc_S_num,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    UnionIecs::S_num *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const UnionIecs::S_num *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const UnionIecs::S_num *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<UnionIecs::S_num>::extract (
        _tao_any,
        UnionIecs::S_num::_tao_any_destructor,
        UnionIecs::_tc_S_num,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, UnionIecs::E_type_num _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, UnionIecs::E_type_num & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<UnionIecs::E_type_num> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const UnionIecs::S_i_num &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.type_num) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.nature));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    UnionIecs::S_i_num &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.type_num) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.nature));
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const UnionIecs::S_num &_tao_union
  )
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if ( !(strm << tmp) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result = strm << _tao_union.num ();
    }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    UnionIecs::S_num &_tao_union
  )
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if ( !(strm >> tmp) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  _tao_union._default ();
  _tao_union._d (_tao_discriminant);
  if (_tao_discriminant)
    {
      UnionIecs::S_i_num _tao_union_tmp;
      result = strm >> _tao_union_tmp;

      if (result)
        {
          _tao_union.num (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



