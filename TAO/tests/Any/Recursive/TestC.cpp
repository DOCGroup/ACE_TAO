// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.4.1
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:373


#include "TestC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Value_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Value_Field.h"
#include "tao/AnyTypeCode/Recursive_Type_TypeCode.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/ORB_Core.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "TestC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:98

Test::Recursive_Type_In_Any_Test_Failed::Recursive_Type_In_Any_Test_Failed (void)
  : ::CORBA::UserException (
        "IDL:Test/Recursive_Type_In_Any_Test_Failed:1.0",
        "Recursive_Type_In_Any_Test_Failed"
      )
{
}

Test::Recursive_Type_In_Any_Test_Failed::~Recursive_Type_In_Any_Test_Failed (void)
{
}

Test::Recursive_Type_In_Any_Test_Failed::Recursive_Type_In_Any_Test_Failed (const ::Test::Recursive_Type_In_Any_Test_Failed &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Test::Recursive_Type_In_Any_Test_Failed&
Test::Recursive_Type_In_Any_Test_Failed::operator= (const ::Test::Recursive_Type_In_Any_Test_Failed &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor (void *_tao_void_pointer)
{
  Recursive_Type_In_Any_Test_Failed *_tao_tmp_pointer =
    static_cast<Recursive_Type_In_Any_Test_Failed *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

Test::Recursive_Type_In_Any_Test_Failed *
Test::Recursive_Type_In_Any_Test_Failed::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<Recursive_Type_In_Any_Test_Failed *> (_tao_excp);
}

const Test::Recursive_Type_In_Any_Test_Failed *
Test::Recursive_Type_In_Any_Test_Failed::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const Recursive_Type_In_Any_Test_Failed *> (_tao_excp);
}

::CORBA::Exception *Test::Recursive_Type_In_Any_Test_Failed::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Test::Recursive_Type_In_Any_Test_Failed, 0);
  return retval;
}

::CORBA::Exception *
Test::Recursive_Type_In_Any_Test_Failed::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::Test::Recursive_Type_In_Any_Test_Failed (*this),
      0
    );
  return result;
}

void Test::Recursive_Type_In_Any_Test_Failed::_raise (void) const
{
  throw *this;
}

void Test::Recursive_Type_In_Any_Test_Failed::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void Test::Recursive_Type_In_Any_Test_Failed::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Test::Recursive_Type_In_Any_Test_Failed::_tao_type (void) const
{
  return ::Test::_tc_Recursive_Type_In_Any_Test_Failed;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const
    _tao_fields_Test_Recursive_Type_In_Any_Test_Failed = 0;

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_Recursive_Type_In_Any_Test_Failed (
  ::CORBA::tk_except,
  "IDL:Test/Recursive_Type_In_Any_Test_Failed:1.0",
  "Recursive_Type_In_Any_Test_Failed",
  _tao_fields_Test_Recursive_Type_In_Any_Test_Failed,
  0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Recursive_Type_In_Any_Test_Failed =
    &_tao_tc_Test_Recursive_Type_In_Any_Test_Failed;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_cs.cpp:98

Test::Demarshaling_From_Any_Failed::Demarshaling_From_Any_Failed (void)
  : ::CORBA::UserException (
        "IDL:Test/Demarshaling_From_Any_Failed:1.0",
        "Demarshaling_From_Any_Failed"
      )
{
}

Test::Demarshaling_From_Any_Failed::~Demarshaling_From_Any_Failed (void)
{
}

Test::Demarshaling_From_Any_Failed::Demarshaling_From_Any_Failed (const ::Test::Demarshaling_From_Any_Failed &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Test::Demarshaling_From_Any_Failed&
Test::Demarshaling_From_Any_Failed::operator= (const ::Test::Demarshaling_From_Any_Failed &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void Test::Demarshaling_From_Any_Failed::_tao_any_destructor (void *_tao_void_pointer)
{
  Demarshaling_From_Any_Failed *_tao_tmp_pointer =
    static_cast<Demarshaling_From_Any_Failed *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

Test::Demarshaling_From_Any_Failed *
Test::Demarshaling_From_Any_Failed::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<Demarshaling_From_Any_Failed *> (_tao_excp);
}

const Test::Demarshaling_From_Any_Failed *
Test::Demarshaling_From_Any_Failed::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const Demarshaling_From_Any_Failed *> (_tao_excp);
}

::CORBA::Exception *Test::Demarshaling_From_Any_Failed::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Test::Demarshaling_From_Any_Failed, 0);
  return retval;
}

::CORBA::Exception *
Test::Demarshaling_From_Any_Failed::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::Test::Demarshaling_From_Any_Failed (*this),
      0
    );
  return result;
}

void Test::Demarshaling_From_Any_Failed::_raise (void) const
{
  throw *this;
}

void Test::Demarshaling_From_Any_Failed::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void Test::Demarshaling_From_Any_Failed::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Test::Demarshaling_From_Any_Failed::_tao_type (void) const
{
  return ::Test::_tc_Demarshaling_From_Any_Failed;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const
    _tao_fields_Test_Demarshaling_From_Any_Failed = 0;

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_Demarshaling_From_Any_Failed (
  ::CORBA::tk_except,
  "IDL:Test/Demarshaling_From_Any_Failed:1.0",
  "Demarshaling_From_Any_Failed",
  _tao_fields_Test_Demarshaling_From_Any_Failed,
  0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Demarshaling_From_Any_Failed =
    &_tao_tc_Test_Demarshaling_From_Any_Failed;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVESTRUCTSEQ_CS_)
#define _TEST_RECURSIVESTRUCTSEQ_CS_

Test::RecursiveStructSeq::RecursiveStructSeq (void)
{}

Test::RecursiveStructSeq::RecursiveStructSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RecursiveStruct
      > (max)
{}

Test::RecursiveStructSeq::RecursiveStructSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::RecursiveStruct * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RecursiveStruct
      >
    (max, length, buffer, release)
{}

Test::RecursiveStructSeq::RecursiveStructSeq (
    const RecursiveStructSeq &seq)
  : ::TAO::unbounded_value_sequence<
        RecursiveStruct
      > (seq)
{}

Test::RecursiveStructSeq::~RecursiveStructSeq (void)
{}

void Test::RecursiveStructSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecursiveStructSeq * _tao_tmp_pointer =
    static_cast<RecursiveStructSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_RecursiveStructSeq_GUARD
#define _TAO_TYPECODE_Test_RecursiveStructSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_RecursiveStructSeq_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_RecursiveStruct,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_RecursiveStructSeq_0 =
        &Test_RecursiveStructSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_RecursiveStructSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveStructSeq (
    ::CORBA::tk_alias,
    "IDL:Test/RecursiveStructSeq:1.0",
    "RecursiveStructSeq",
    &TAO::TypeCode::tc_Test_RecursiveStructSeq_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveStructSeq =
    &_tao_tc_Test_RecursiveStructSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_RecursiveStruct[] =
      {
        { "recursive_structs", &Test::_tc_RecursiveStructSeq },
        { "i", &CORBA::_tc_long },
        { "recursive_structs_second", &Test::_tc_RecursiveStructSeq }
      };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Struct<
    char const *,
    ::CORBA::TypeCode_ptr const *,
    TAO::TypeCode::Struct_Field<
      char const *,
      ::CORBA::TypeCode_ptr const *> const *,
    TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *>
_tao_tc_Test_RecursiveStruct (
  ::CORBA::tk_struct,
  "IDL:Test/RecursiveStruct:1.0",
  "RecursiveStruct",
  _tao_fields_Test_RecursiveStruct,
  3);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveStruct =
    &_tao_tc_Test_RecursiveStruct;
}

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::RecursiveStruct::_tao_any_destructor (
    void *_tao_void_pointer)
{
  RecursiveStruct *_tao_tmp_pointer =
    static_cast<RecursiveStruct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_NESTEDRECURSIVESTRUCTSEQ_CS_)
#define _TEST_NESTEDRECURSIVESTRUCTSEQ_CS_

Test::NestedRecursiveStructSeq::NestedRecursiveStructSeq (void)
{}

Test::NestedRecursiveStructSeq::NestedRecursiveStructSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        NestedRecursiveStruct
      > (max)
{}

Test::NestedRecursiveStructSeq::NestedRecursiveStructSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::NestedRecursiveStruct * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        NestedRecursiveStruct
      >
    (max, length, buffer, release)
{}

Test::NestedRecursiveStructSeq::NestedRecursiveStructSeq (
    const NestedRecursiveStructSeq &seq)
  : ::TAO::unbounded_value_sequence<
        NestedRecursiveStruct
      > (seq)
{}

Test::NestedRecursiveStructSeq::~NestedRecursiveStructSeq (void)
{}

void Test::NestedRecursiveStructSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  NestedRecursiveStructSeq * _tao_tmp_pointer =
    static_cast<NestedRecursiveStructSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_NestedRecursiveStructSeq_GUARD
#define _TAO_TYPECODE_Test_NestedRecursiveStructSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_NestedRecursiveStructSeq_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_NestedRecursiveStruct,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_NestedRecursiveStructSeq_0 =
        &Test_NestedRecursiveStructSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_NestedRecursiveStructSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_NestedRecursiveStructSeq (
    ::CORBA::tk_alias,
    "IDL:Test/NestedRecursiveStructSeq:1.0",
    "NestedRecursiveStructSeq",
    &TAO::TypeCode::tc_Test_NestedRecursiveStructSeq_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_NestedRecursiveStructSeq =
    &_tao_tc_Test_NestedRecursiveStructSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_NestedRecursiveStruct[] =
      {
        { "ins", &Test::NestedRecursiveStruct::_tc_InnerStruct },
        { "i", &CORBA::_tc_long }
      };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Struct<
    char const *,
    ::CORBA::TypeCode_ptr const *,
    TAO::TypeCode::Struct_Field<
      char const *,
      ::CORBA::TypeCode_ptr const *> const *,
    TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *>
_tao_tc_Test_NestedRecursiveStruct (
  ::CORBA::tk_struct,
  "IDL:Test/NestedRecursiveStruct:1.0",
  "NestedRecursiveStruct",
  _tao_fields_Test_NestedRecursiveStruct,
  2);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_NestedRecursiveStruct =
    &_tao_tc_Test_NestedRecursiveStruct;
}

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::NestedRecursiveStruct::_tao_any_destructor (
    void *_tao_void_pointer)
{
  NestedRecursiveStruct *_tao_tmp_pointer =
    static_cast<NestedRecursiveStruct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_NestedRecursiveStruct_InnerStruct[] =
      {
        { "recursive_structs", &Test::_tc_NestedRecursiveStructSeq }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_NestedRecursiveStruct_InnerStruct (
  ::CORBA::tk_struct,
  "IDL:Test/NestedRecursiveStruct/InnerStruct:1.0",
  "InnerStruct",
  _tao_fields_Test_NestedRecursiveStruct_InnerStruct,
  1);

::CORBA::TypeCode_ptr const Test::NestedRecursiveStruct::_tc_InnerStruct =
  &_tao_tc_Test_NestedRecursiveStruct_InnerStruct;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor (
    void *_tao_void_pointer)
{
  InnerStruct *_tao_tmp_pointer =
    static_cast<InnerStruct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVEUNIONSEQ_CS_)
#define _TEST_RECURSIVEUNIONSEQ_CS_

Test::RecursiveUnionSeq::RecursiveUnionSeq (void)
{}

Test::RecursiveUnionSeq::RecursiveUnionSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RecursiveUnion
      > (max)
{}

Test::RecursiveUnionSeq::RecursiveUnionSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::RecursiveUnion * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RecursiveUnion
      >
    (max, length, buffer, release)
{}

Test::RecursiveUnionSeq::RecursiveUnionSeq (
    const RecursiveUnionSeq &seq)
  : ::TAO::unbounded_value_sequence<
        RecursiveUnion
      > (seq)
{}

Test::RecursiveUnionSeq::~RecursiveUnionSeq (void)
{}

void Test::RecursiveUnionSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecursiveUnionSeq * _tao_tmp_pointer =
    static_cast<RecursiveUnionSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_RecursiveUnionSeq_GUARD
#define _TAO_TYPECODE_Test_RecursiveUnionSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_RecursiveUnionSeq_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_RecursiveUnion,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_RecursiveUnionSeq_0 =
        &Test_RecursiveUnionSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_RecursiveUnionSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveUnionSeq (
    ::CORBA::tk_alias,
    "IDL:Test/RecursiveUnionSeq:1.0",
    "RecursiveUnionSeq",
    &TAO::TypeCode::tc_Test_RecursiveUnionSeq_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnionSeq =
    &_tao_tc_Test_RecursiveUnionSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::RecursiveUnion::RecursiveUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Test::RecursiveUnion::RecursiveUnion (const ::Test::RecursiveUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.recursive_unions_ == 0)
        {
          this->u_.recursive_unions_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.recursive_unions_,
              Test::RecursiveUnionSeq (*u.u_.recursive_unions_)
            );
        }
    }
    break;
    case 1:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 2:
    {
      if (u.u_.recursive_unions_second_ == 0)
        {
          this->u_.recursive_unions_second_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.recursive_unions_second_,
              Test::RecursiveUnionSeq (*u.u_.recursive_unions_second_)
            );
        }
    }
    break;
    default:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
  }
}

Test::RecursiveUnion::~RecursiveUnion (void)
{
  // Finalize.
  this->_reset ();
}

void Test::RecursiveUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  RecursiveUnion *tmp =
    static_cast<RecursiveUnion *> (_tao_void_pointer);
  delete tmp;
}

Test::RecursiveUnion &
Test::RecursiveUnion::operator= (const ::Test::RecursiveUnion &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.recursive_unions_ == 0)
        {
          this->u_.recursive_unions_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.recursive_unions_,
              Test::RecursiveUnionSeq (*u.u_.recursive_unions_),
              *this
            );
        }
    }
    break;
    case 1:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 2:
    {
      if (u.u_.recursive_unions_second_ == 0)
        {
          this->u_.recursive_unions_second_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.recursive_unions_second_,
              Test::RecursiveUnionSeq (*u.u_.recursive_unions_second_),
              *this
            );
        }
    }
    break;
    default:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::RecursiveUnion::_reset (void)
{
  switch (this->disc_)
  {

    case 0:
      delete this->u_.recursive_unions_;
      this->u_.recursive_unions_ = 0;

    break;

    case 1:

    break;

    case 2:
      delete this->u_.recursive_unions_second_;
      this->u_.recursive_unions_second_ = 0;

    break;

    default:

    break;

  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion__0 (0, "recursive_unions", &Test::_tc_RecursiveUnionSeq);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion__1 (1, "a", &CORBA::_tc_short);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion__2 (2, "recursive_unions_second", &Test::_tc_RecursiveUnionSeq);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion__3 (-32768, "i", &CORBA::_tc_long);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_RecursiveUnion[] =
  {
    &_tao_cases_Test_RecursiveUnion__0,
    &_tao_cases_Test_RecursiveUnion__1,
    &_tao_cases_Test_RecursiveUnion__2,
    &_tao_cases_Test_RecursiveUnion__3
  };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Union<char const *,
                              ::CORBA::TypeCode_ptr const *,
                              TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                              TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const * >

  _tao_tc_Test_RecursiveUnion (
    "IDL:Test/RecursiveUnion:1.0",
    "RecursiveUnion",
    &CORBA::_tc_short,
    _tao_cases_Test_RecursiveUnion,
    sizeof (_tao_cases_Test_RecursiveUnion)/sizeof (_tao_cases_Test_RecursiveUnion[0]),
    3);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnion =
    &_tao_tc_Test_RecursiveUnion;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVEUNIONSEQ2_CS_)
#define _TEST_RECURSIVEUNIONSEQ2_CS_

Test::RecursiveUnionSeq2::RecursiveUnionSeq2 (void)
{}

Test::RecursiveUnionSeq2::RecursiveUnionSeq2 (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RecursiveUnion2
      > (max)
{}

Test::RecursiveUnionSeq2::RecursiveUnionSeq2 (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::RecursiveUnion2 * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RecursiveUnion2
      >
    (max, length, buffer, release)
{}

Test::RecursiveUnionSeq2::RecursiveUnionSeq2 (
    const RecursiveUnionSeq2 &seq)
  : ::TAO::unbounded_value_sequence<
        RecursiveUnion2
      > (seq)
{}

Test::RecursiveUnionSeq2::~RecursiveUnionSeq2 (void)
{}

void Test::RecursiveUnionSeq2::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecursiveUnionSeq2 * _tao_tmp_pointer =
    static_cast<RecursiveUnionSeq2 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_RecursiveUnionSeq2_GUARD
#define _TAO_TYPECODE_Test_RecursiveUnionSeq2_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_RecursiveUnionSeq2_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_RecursiveUnion2,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_RecursiveUnionSeq2_0 =
        &Test_RecursiveUnionSeq2_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_RecursiveUnionSeq2_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveUnionSeq2 (
    ::CORBA::tk_alias,
    "IDL:Test/RecursiveUnionSeq2:1.0",
    "RecursiveUnionSeq2",
    &TAO::TypeCode::tc_Test_RecursiveUnionSeq2_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnionSeq2 =
    &_tao_tc_Test_RecursiveUnionSeq2;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_RecursiveUnion2_Innerstruct3a[] =
      {
        { "recursive_unions", &Test::_tc_RecursiveUnionSeq2 }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_RecursiveUnion2_Innerstruct3a (
  ::CORBA::tk_struct,
  "IDL:Test/RecursiveUnion2/Innerstruct3a:1.0",
  "Innerstruct3a",
  _tao_fields_Test_RecursiveUnion2_Innerstruct3a,
  1);

::CORBA::TypeCode_ptr const Test::RecursiveUnion2::_tc_Innerstruct3a =
  &_tao_tc_Test_RecursiveUnion2_Innerstruct3a;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::RecursiveUnion2::Innerstruct3a::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Innerstruct3a *_tao_tmp_pointer =
    static_cast<Innerstruct3a *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_RecursiveUnion2_Innerstruct3b[] =
      {
        { "recursive_unions_second", &Test::_tc_RecursiveUnionSeq2 }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_RecursiveUnion2_Innerstruct3b (
  ::CORBA::tk_struct,
  "IDL:Test/RecursiveUnion2/Innerstruct3b:1.0",
  "Innerstruct3b",
  _tao_fields_Test_RecursiveUnion2_Innerstruct3b,
  1);

::CORBA::TypeCode_ptr const Test::RecursiveUnion2::_tc_Innerstruct3b =
  &_tao_tc_Test_RecursiveUnion2_Innerstruct3b;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::RecursiveUnion2::Innerstruct3b::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Innerstruct3b *_tao_tmp_pointer =
    static_cast<Innerstruct3b *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::RecursiveUnion2::RecursiveUnion2 (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Test::RecursiveUnion2::RecursiveUnion2 (const ::Test::RecursiveUnion2 &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.insb_ == 0)
        {
          this->u_.insb_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.insb_,
              Test::RecursiveUnion2::Innerstruct3a (*u.u_.insb_)
            );
        }
    }
    break;
    case 1:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 2:
    {
      if (u.u_.insa_ == 0)
        {
          this->u_.insa_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.insa_,
              Test::RecursiveUnion2::Innerstruct3b (*u.u_.insa_)
            );
        }
    }
    break;
    default:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
  }
}

Test::RecursiveUnion2::~RecursiveUnion2 (void)
{
  // Finalize.
  this->_reset ();
}

void Test::RecursiveUnion2::_tao_any_destructor (void *_tao_void_pointer)
{
  RecursiveUnion2 *tmp =
    static_cast<RecursiveUnion2 *> (_tao_void_pointer);
  delete tmp;
}

Test::RecursiveUnion2 &
Test::RecursiveUnion2::operator= (const ::Test::RecursiveUnion2 &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.insb_ == 0)
        {
          this->u_.insb_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.insb_,
              Test::RecursiveUnion2::Innerstruct3a (*u.u_.insb_),
              *this
            );
        }
    }
    break;
    case 1:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 2:
    {
      if (u.u_.insa_ == 0)
        {
          this->u_.insa_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.insa_,
              Test::RecursiveUnion2::Innerstruct3b (*u.u_.insa_),
              *this
            );
        }
    }
    break;
    default:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::RecursiveUnion2::_reset (void)
{
  switch (this->disc_)
  {

    case 0:
      delete this->u_.insb_;
      this->u_.insb_ = 0;

    break;

    case 1:

    break;

    case 2:
      delete this->u_.insa_;
      this->u_.insa_ = 0;

    break;

    default:

    break;

  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion2__0 (0, "insb", &Test::RecursiveUnion2::_tc_Innerstruct3a);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion2__1 (1, "a", &CORBA::_tc_short);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion2__2 (2, "insa", &Test::RecursiveUnion2::_tc_Innerstruct3b);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion2__3 (-32768, "i", &CORBA::_tc_long);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_RecursiveUnion2[] =
  {
    &_tao_cases_Test_RecursiveUnion2__0,
    &_tao_cases_Test_RecursiveUnion2__1,
    &_tao_cases_Test_RecursiveUnion2__2,
    &_tao_cases_Test_RecursiveUnion2__3
  };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Union<char const *,
                              ::CORBA::TypeCode_ptr const *,
                              TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                              TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const * >

  _tao_tc_Test_RecursiveUnion2 (
    "IDL:Test/RecursiveUnion2:1.0",
    "RecursiveUnion2",
    &CORBA::_tc_short,
    _tao_cases_Test_RecursiveUnion2,
    sizeof (_tao_cases_Test_RecursiveUnion2)/sizeof (_tao_cases_Test_RecursiveUnion2[0]),
    3);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnion2 =
    &_tao_tc_Test_RecursiveUnion2;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVESTRUCTSEQ3_CS_)
#define _TEST_RECURSIVESTRUCTSEQ3_CS_

Test::RecursiveStructSeq3::RecursiveStructSeq3 (void)
{}

Test::RecursiveStructSeq3::RecursiveStructSeq3 (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RecursiveStruct3
      > (max)
{}

Test::RecursiveStructSeq3::RecursiveStructSeq3 (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::RecursiveStruct3 * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RecursiveStruct3
      >
    (max, length, buffer, release)
{}

Test::RecursiveStructSeq3::RecursiveStructSeq3 (
    const RecursiveStructSeq3 &seq)
  : ::TAO::unbounded_value_sequence<
        RecursiveStruct3
      > (seq)
{}

Test::RecursiveStructSeq3::~RecursiveStructSeq3 (void)
{}

void Test::RecursiveStructSeq3::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecursiveStructSeq3 * _tao_tmp_pointer =
    static_cast<RecursiveStructSeq3 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_RecursiveStructSeq3_GUARD
#define _TAO_TYPECODE_Test_RecursiveStructSeq3_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_RecursiveStructSeq3_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_RecursiveStruct3,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_RecursiveStructSeq3_0 =
        &Test_RecursiveStructSeq3_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_RecursiveStructSeq3_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveStructSeq3 (
    ::CORBA::tk_alias,
    "IDL:Test/RecursiveStructSeq3:1.0",
    "RecursiveStructSeq3",
    &TAO::TypeCode::tc_Test_RecursiveStructSeq3_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveStructSeq3 =
    &_tao_tc_Test_RecursiveStructSeq3;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::RecursiveUnion3::RecursiveUnion3 (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Test::RecursiveUnion3::RecursiveUnion3 (const ::Test::RecursiveUnion3 &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 1:
    {
      if (u.u_.b_ == 0)
        {
          this->u_.b_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.b_,
              Test::RecursiveStructSeq3 (*u.u_.b_)
            );
        }
    }
    break;
    case 2:
    {
      if (u.u_.c_ == 0)
        {
          this->u_.c_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.c_,
              Test::RecursiveStructSeq3 (*u.u_.c_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Test::RecursiveUnion3::~RecursiveUnion3 (void)
{
  // Finalize.
  this->_reset ();
}

void Test::RecursiveUnion3::_tao_any_destructor (void *_tao_void_pointer)
{
  RecursiveUnion3 *tmp =
    static_cast<RecursiveUnion3 *> (_tao_void_pointer);
  delete tmp;
}

Test::RecursiveUnion3 &
Test::RecursiveUnion3::operator= (const ::Test::RecursiveUnion3 &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 1:
    {
      if (u.u_.b_ == 0)
        {
          this->u_.b_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.b_,
              Test::RecursiveStructSeq3 (*u.u_.b_),
              *this
            );
        }
    }
    break;
    case 2:
    {
      if (u.u_.c_ == 0)
        {
          this->u_.c_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.c_,
              Test::RecursiveStructSeq3 (*u.u_.c_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::RecursiveUnion3::_reset (void)
{
  switch (this->disc_)
  {

    case 0:

    break;

    case 1:
      delete this->u_.b_;
      this->u_.b_ = 0;

    break;

    case 2:
      delete this->u_.c_;
      this->u_.c_ = 0;

    break;

    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion3__0 (0, "a", &CORBA::_tc_short);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion3__1 (1, "b", &Test::_tc_RecursiveStructSeq3);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnion3__2 (2, "c", &Test::_tc_RecursiveStructSeq3);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_RecursiveUnion3[] =
  {
    &_tao_cases_Test_RecursiveUnion3__0,
    &_tao_cases_Test_RecursiveUnion3__1,
    &_tao_cases_Test_RecursiveUnion3__2
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveUnion3 (
    "IDL:Test/RecursiveUnion3:1.0",
    "RecursiveUnion3",
    &CORBA::_tc_short,
    _tao_cases_Test_RecursiveUnion3,
    sizeof (_tao_cases_Test_RecursiveUnion3)/sizeof (_tao_cases_Test_RecursiveUnion3[0]),
    -1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnion3 =
    &_tao_tc_Test_RecursiveUnion3;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_RecursiveStruct3[] =
      {
        { "uni", &Test::_tc_RecursiveUnion3 }
      };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Struct<
    char const *,
    ::CORBA::TypeCode_ptr const *,
    TAO::TypeCode::Struct_Field<
      char const *,
      ::CORBA::TypeCode_ptr const *> const *,
    TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *>
_tao_tc_Test_RecursiveStruct3 (
  ::CORBA::tk_struct,
  "IDL:Test/RecursiveStruct3:1.0",
  "RecursiveStruct3",
  _tao_fields_Test_RecursiveStruct3,
  1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveStruct3 =
    &_tao_tc_Test_RecursiveStruct3;
}

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::RecursiveStruct3::_tao_any_destructor (
    void *_tao_void_pointer)
{
  RecursiveStruct3 *_tao_tmp_pointer =
    static_cast<RecursiveStruct3 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVEUNIONSEQNODEFAULT_CS_)
#define _TEST_RECURSIVEUNIONSEQNODEFAULT_CS_

Test::RecursiveUnionSeqNoDefault::RecursiveUnionSeqNoDefault (void)
{}

Test::RecursiveUnionSeqNoDefault::RecursiveUnionSeqNoDefault (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        RecursiveUnionNoDefault
      > (max)
{}

Test::RecursiveUnionSeqNoDefault::RecursiveUnionSeqNoDefault (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::RecursiveUnionNoDefault * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        RecursiveUnionNoDefault
      >
    (max, length, buffer, release)
{}

Test::RecursiveUnionSeqNoDefault::RecursiveUnionSeqNoDefault (
    const RecursiveUnionSeqNoDefault &seq)
  : ::TAO::unbounded_value_sequence<
        RecursiveUnionNoDefault
      > (seq)
{}

Test::RecursiveUnionSeqNoDefault::~RecursiveUnionSeqNoDefault (void)
{}

void Test::RecursiveUnionSeqNoDefault::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecursiveUnionSeqNoDefault * _tao_tmp_pointer =
    static_cast<RecursiveUnionSeqNoDefault *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_RecursiveUnionSeqNoDefault_GUARD
#define _TAO_TYPECODE_Test_RecursiveUnionSeqNoDefault_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_RecursiveUnionSeqNoDefault_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_RecursiveUnionNoDefault,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_RecursiveUnionSeqNoDefault_0 =
        &Test_RecursiveUnionSeqNoDefault_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_RecursiveUnionSeqNoDefault_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveUnionSeqNoDefault (
    ::CORBA::tk_alias,
    "IDL:Test/RecursiveUnionSeqNoDefault:1.0",
    "RecursiveUnionSeqNoDefault",
    &TAO::TypeCode::tc_Test_RecursiveUnionSeqNoDefault_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnionSeqNoDefault =
    &_tao_tc_Test_RecursiveUnionSeqNoDefault;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::RecursiveUnionNoDefault::RecursiveUnionNoDefault (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Test::RecursiveUnionNoDefault::RecursiveUnionNoDefault (const ::Test::RecursiveUnionNoDefault &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.recursive_unions_ == 0)
        {
          this->u_.recursive_unions_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.recursive_unions_,
              Test::RecursiveUnionSeqNoDefault (*u.u_.recursive_unions_)
            );
        }
    }
    break;
    case 1:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 2:
    {
      if (u.u_.recursive_unions_second_ == 0)
        {
          this->u_.recursive_unions_second_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.recursive_unions_second_,
              Test::RecursiveUnionSeqNoDefault (*u.u_.recursive_unions_second_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Test::RecursiveUnionNoDefault::~RecursiveUnionNoDefault (void)
{
  // Finalize.
  this->_reset ();
}

void Test::RecursiveUnionNoDefault::_tao_any_destructor (void *_tao_void_pointer)
{
  RecursiveUnionNoDefault *tmp =
    static_cast<RecursiveUnionNoDefault *> (_tao_void_pointer);
  delete tmp;
}

Test::RecursiveUnionNoDefault &
Test::RecursiveUnionNoDefault::operator= (const ::Test::RecursiveUnionNoDefault &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.recursive_unions_ == 0)
        {
          this->u_.recursive_unions_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.recursive_unions_,
              Test::RecursiveUnionSeqNoDefault (*u.u_.recursive_unions_),
              *this
            );
        }
    }
    break;
    case 1:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case 2:
    {
      if (u.u_.recursive_unions_second_ == 0)
        {
          this->u_.recursive_unions_second_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.recursive_unions_second_,
              Test::RecursiveUnionSeqNoDefault (*u.u_.recursive_unions_second_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::RecursiveUnionNoDefault::_reset (void)
{
  switch (this->disc_)
  {

    case 0:
      delete this->u_.recursive_unions_;
      this->u_.recursive_unions_ = 0;

    break;

    case 1:

    break;

    case 2:
      delete this->u_.recursive_unions_second_;
      this->u_.recursive_unions_second_ = 0;

    break;

    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnionNoDefault__0 (0, "recursive_unions", &Test::_tc_RecursiveUnionSeqNoDefault);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnionNoDefault__1 (1, "a", &CORBA::_tc_short);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_RecursiveUnionNoDefault__2 (2, "recursive_unions_second", &Test::_tc_RecursiveUnionSeqNoDefault);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_RecursiveUnionNoDefault[] =
  {
    &_tao_cases_Test_RecursiveUnionNoDefault__0,
    &_tao_cases_Test_RecursiveUnionNoDefault__1,
    &_tao_cases_Test_RecursiveUnionNoDefault__2
  };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Union<char const *,
                              ::CORBA::TypeCode_ptr const *,
                              TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                              TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const * >

  _tao_tc_Test_RecursiveUnionNoDefault (
    "IDL:Test/RecursiveUnionNoDefault:1.0",
    "RecursiveUnionNoDefault",
    &CORBA::_tc_short,
    _tao_cases_Test_RecursiveUnionNoDefault,
    sizeof (_tao_cases_Test_RecursiveUnionNoDefault)/sizeof (_tao_cases_Test_RecursiveUnionNoDefault[0]),
    -1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveUnionNoDefault =
    &_tao_tc_Test_RecursiveUnionNoDefault;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/enum_typecode.cpp:29
static char const * const _tao_enumerators_Test_VSort[] =
  {
    "UNKNOWN_TYPE",
    "RECURSIVE_TYPE",
    "LONG_STYPE",
    "BOOL_STYPE"

  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Test_VSort (
    "IDL:Test/VSort:1.0",
    "VSort",
    _tao_enumerators_Test_VSort,
    4);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_VSort =
    &_tao_tc_Test_VSort;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_VSORTRECURSIVEUNIONSEQ_CS_)
#define _TEST_VSORTRECURSIVEUNIONSEQ_CS_

Test::VSortRecursiveUnionSeq::VSortRecursiveUnionSeq (void)
{}

Test::VSortRecursiveUnionSeq::VSortRecursiveUnionSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        VSortRecursiveUnion
      > (max)
{}

Test::VSortRecursiveUnionSeq::VSortRecursiveUnionSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::VSortRecursiveUnion * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        VSortRecursiveUnion
      >
    (max, length, buffer, release)
{}

Test::VSortRecursiveUnionSeq::VSortRecursiveUnionSeq (
    const VSortRecursiveUnionSeq &seq)
  : ::TAO::unbounded_value_sequence<
        VSortRecursiveUnion
      > (seq)
{}

Test::VSortRecursiveUnionSeq::~VSortRecursiveUnionSeq (void)
{}

void Test::VSortRecursiveUnionSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  VSortRecursiveUnionSeq * _tao_tmp_pointer =
    static_cast<VSortRecursiveUnionSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_VSortRecursiveUnionSeq_GUARD
#define _TAO_TYPECODE_Test_VSortRecursiveUnionSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_VSortRecursiveUnionSeq_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_VSortRecursiveUnion,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_VSortRecursiveUnionSeq_0 =
        &Test_VSortRecursiveUnionSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_VSortRecursiveUnionSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_VSortRecursiveUnionSeq (
    ::CORBA::tk_alias,
    "IDL:Test/VSortRecursiveUnionSeq:1.0",
    "VSortRecursiveUnionSeq",
    &TAO::TypeCode::tc_Test_VSortRecursiveUnionSeq_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_VSortRecursiveUnionSeq =
    &_tao_tc_Test_VSortRecursiveUnionSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::VSortRecursiveUnion::VSortRecursiveUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = Test::UNKNOWN_TYPE;
}

Test::VSortRecursiveUnion::VSortRecursiveUnion (const ::Test::VSortRecursiveUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Test::RECURSIVE_TYPE:
    {
      if (u.u_.recursive_unions_ == 0)
        {
          this->u_.recursive_unions_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.recursive_unions_,
              Test::VSortRecursiveUnionSeq (*u.u_.recursive_unions_)
            );
        }
    }
    break;
    case Test::LONG_STYPE:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
    default:
    break;
  }
}

Test::VSortRecursiveUnion::~VSortRecursiveUnion (void)
{
  // Finalize.
  this->_reset ();
}

void Test::VSortRecursiveUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  VSortRecursiveUnion *tmp =
    static_cast<VSortRecursiveUnion *> (_tao_void_pointer);
  delete tmp;
}

Test::VSortRecursiveUnion &
Test::VSortRecursiveUnion::operator= (const ::Test::VSortRecursiveUnion &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case Test::RECURSIVE_TYPE:
    {
      if (u.u_.recursive_unions_ == 0)
        {
          this->u_.recursive_unions_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.recursive_unions_,
              Test::VSortRecursiveUnionSeq (*u.u_.recursive_unions_),
              *this
            );
        }
    }
    break;
    case Test::LONG_STYPE:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::VSortRecursiveUnion::_reset (void)
{
  switch (this->disc_)
  {

    case Test::RECURSIVE_TYPE:
      delete this->u_.recursive_unions_;
      this->u_.recursive_unions_ = 0;

    break;

    case Test::LONG_STYPE:

    break;

    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Case_T<Test::VSort, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_VSortRecursiveUnion__0 (Test::RECURSIVE_TYPE, "recursive_unions", &Test::_tc_VSortRecursiveUnionSeq);
static TAO::TypeCode::Case_T<Test::VSort, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_VSortRecursiveUnion__1 (Test::LONG_STYPE, "i", &CORBA::_tc_long);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_VSortRecursiveUnion[] =
  {
    &_tao_cases_Test_VSortRecursiveUnion__0,
    &_tao_cases_Test_VSortRecursiveUnion__1
  };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Union<char const *,
                              ::CORBA::TypeCode_ptr const *,
                              TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                              TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const * >

  _tao_tc_Test_VSortRecursiveUnion (
    "IDL:Test/VSortRecursiveUnion:1.0",
    "VSortRecursiveUnion",
    &Test::_tc_VSort,
    _tao_cases_Test_VSortRecursiveUnion,
    sizeof (_tao_cases_Test_VSortRecursiveUnion)/sizeof (_tao_cases_Test_VSortRecursiveUnion[0]),
    -1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_VSortRecursiveUnion =
    &_tao_tc_Test_VSortRecursiveUnion;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::EnumUnion::EnumUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = Test::UNKNOWN_TYPE;
}

Test::EnumUnion::EnumUnion (const ::Test::EnumUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Test::BOOL_STYPE:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case Test::LONG_STYPE:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
    default:
    break;
  }
}

Test::EnumUnion::~EnumUnion (void)
{
  // Finalize.
  this->_reset ();
}

void Test::EnumUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  EnumUnion *tmp =
    static_cast<EnumUnion *> (_tao_void_pointer);
  delete tmp;
}

Test::EnumUnion &
Test::EnumUnion::operator= (const ::Test::EnumUnion &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case Test::BOOL_STYPE:
    {
      this->u_.a_ = u.u_.a_;
    }
    break;
    case Test::LONG_STYPE:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::EnumUnion::_reset (void)
{
  switch (this->disc_)
  {

    case Test::BOOL_STYPE:

    break;

    case Test::LONG_STYPE:

    break;

    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65

static TAO::TypeCode::Case_T<Test::VSort, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_EnumUnion__0 (Test::BOOL_STYPE, "a", &CORBA::_tc_boolean);
static TAO::TypeCode::Case_T<Test::VSort, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_EnumUnion__1 (Test::LONG_STYPE, "i", &CORBA::_tc_long);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_EnumUnion[] =
  {
    &_tao_cases_Test_EnumUnion__0,
    &_tao_cases_Test_EnumUnion__1
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_EnumUnion (
    "IDL:Test/EnumUnion:1.0",
    "EnumUnion",
    &Test::_tc_VSort,
    _tao_cases_Test_EnumUnion,
    sizeof (_tao_cases_Test_EnumUnion)/sizeof (_tao_cases_Test_EnumUnion[0]),
    -1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_EnumUnion =
    &_tao_tc_Test_EnumUnion;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_INDIRECTLYRECURSIVEVALUETYPESEQ_CS_)
#define _TEST_INDIRECTLYRECURSIVEVALUETYPESEQ_CS_

Test::IndirectlyRecursiveValuetypeSeq::IndirectlyRecursiveValuetypeSeq (void)
{}

Test::IndirectlyRecursiveValuetypeSeq::IndirectlyRecursiveValuetypeSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        IndirectlyRecursiveValuetype,
        IndirectlyRecursiveValuetype_var
      > (max)
{}

Test::IndirectlyRecursiveValuetypeSeq::IndirectlyRecursiveValuetypeSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::IndirectlyRecursiveValuetype * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_valuetype_sequence<
        IndirectlyRecursiveValuetype,
        IndirectlyRecursiveValuetype_var
      >
    (max, length, buffer, release)
{}

Test::IndirectlyRecursiveValuetypeSeq::IndirectlyRecursiveValuetypeSeq (
    const IndirectlyRecursiveValuetypeSeq &seq)
  : ::TAO::unbounded_valuetype_sequence<
        IndirectlyRecursiveValuetype,
        IndirectlyRecursiveValuetype_var
      > (seq)
{}

Test::IndirectlyRecursiveValuetypeSeq::~IndirectlyRecursiveValuetypeSeq (void)
{}

void Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor (
    void * _tao_void_pointer)
{
  IndirectlyRecursiveValuetypeSeq * _tao_tmp_pointer =
    static_cast<IndirectlyRecursiveValuetypeSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_IndirectlyRecursiveValuetypeSeq_GUARD
#define _TAO_TYPECODE_Test_IndirectlyRecursiveValuetypeSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_IndirectlyRecursiveValuetypeSeq_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_IndirectlyRecursiveValuetype,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_IndirectlyRecursiveValuetypeSeq_0 =
        &Test_IndirectlyRecursiveValuetypeSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_IndirectlyRecursiveValuetypeSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_IndirectlyRecursiveValuetypeSeq (
    ::CORBA::tk_alias,
    "IDL:Test/IndirectlyRecursiveValuetypeSeq:1.0",
    "IndirectlyRecursiveValuetypeSeq",
    &TAO::TypeCode::tc_Test_IndirectlyRecursiveValuetypeSeq_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_IndirectlyRecursiveValuetypeSeq =
    &_tao_tc_Test_IndirectlyRecursiveValuetypeSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_Test_IndirectlyRecursiveValuetype[] =
  {
    { "recursive_valuetypes", &Test::_tc_IndirectlyRecursiveValuetypeSeq, ::CORBA::PUBLIC_MEMBER }

  };
static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Value<char const *,
                       ::CORBA::TypeCode_ptr const *,
                       TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                       TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * >

  _tao_tc_Test_IndirectlyRecursiveValuetype (
    ::CORBA::tk_value,
    "IDL:Test/IndirectlyRecursiveValuetype:1.0",
    "IndirectlyRecursiveValuetype",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Test_IndirectlyRecursiveValuetype,
    1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_IndirectlyRecursiveValuetype =
    &_tao_tc_Test_IndirectlyRecursiveValuetype;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Test::IndirectlyRecursiveValuetype>::add_ref (
    Test::IndirectlyRecursiveValuetype * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Test::IndirectlyRecursiveValuetype>::remove_ref (
    Test::IndirectlyRecursiveValuetype * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Test::IndirectlyRecursiveValuetype>::release (
    Test::IndirectlyRecursiveValuetype * p)
{
  ::CORBA::remove_ref (p);
}

Test::IndirectlyRecursiveValuetype *
Test::IndirectlyRecursiveValuetype::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Test::IndirectlyRecursiveValuetype * > (v);
}

const char *
Test::IndirectlyRecursiveValuetype::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Test::IndirectlyRecursiveValuetype::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Test::IndirectlyRecursiveValuetype::_tao_any_destructor (void *_tao_void_pointer)
{
  IndirectlyRecursiveValuetype *_tao_tmp_pointer =
    static_cast<IndirectlyRecursiveValuetype *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Test::IndirectlyRecursiveValuetype::_tao_type (void) const
{
  return ::Test::_tc_IndirectlyRecursiveValuetype;
}

Test::IndirectlyRecursiveValuetype::~IndirectlyRecursiveValuetype (void)
{}

::CORBA::Boolean
Test::IndirectlyRecursiveValuetype::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__Test_IndirectlyRecursiveValuetype (strm, ci);
}

::CORBA::Boolean
Test::IndirectlyRecursiveValuetype::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__Test_IndirectlyRecursiveValuetype (strm,ci);
}

::CORBA::Boolean
Test::IndirectlyRecursiveValuetype::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (Test::IndirectlyRecursiveValuetype::_downcast);
}

::CORBA::Boolean
Test::IndirectlyRecursiveValuetype::_tao_unmarshal (
    TAO_InputCDR &strm,
    IndirectlyRecursiveValuetype *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        IndirectlyRecursiveValuetype::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = IndirectlyRecursiveValuetype::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_init_cs.cpp:73

Test::IndirectlyRecursiveValuetype_init::IndirectlyRecursiveValuetype_init (void)
{
}

Test::IndirectlyRecursiveValuetype_init::~IndirectlyRecursiveValuetype_init (void)
{
}

Test::IndirectlyRecursiveValuetype_init *
Test::IndirectlyRecursiveValuetype_init::_downcast ( ::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast< ::Test::IndirectlyRecursiveValuetype_init * > (v);
}

const char*
Test::IndirectlyRecursiveValuetype_init::tao_repository_id (void)
{
  return ::Test::IndirectlyRecursiveValuetype::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Test::IndirectlyRecursiveValuetype_init::create_for_unmarshal (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Test::IndirectlyRecursiveValuetype,
      ::CORBA::NO_MEMORY ()
    );
  return ret_val;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_Test_DirectlyRecursiveValuetype[] =
  {
    { "recursive_valuetype", &Test::_tc_DirectlyRecursiveValuetype, ::CORBA::PUBLIC_MEMBER },
    { "recursive_valuetype_second", &Test::_tc_DirectlyRecursiveValuetype, ::CORBA::PUBLIC_MEMBER }

  };
static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Value<char const *,
                       ::CORBA::TypeCode_ptr const *,
                       TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                       TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * >

  _tao_tc_Test_DirectlyRecursiveValuetype (
    ::CORBA::tk_value,
    "IDL:Test/DirectlyRecursiveValuetype:1.0",
    "DirectlyRecursiveValuetype",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Test_DirectlyRecursiveValuetype,
    2);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_DirectlyRecursiveValuetype =
    &_tao_tc_Test_DirectlyRecursiveValuetype;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Test::DirectlyRecursiveValuetype>::add_ref (
    Test::DirectlyRecursiveValuetype * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Test::DirectlyRecursiveValuetype>::remove_ref (
    Test::DirectlyRecursiveValuetype * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Test::DirectlyRecursiveValuetype>::release (
    Test::DirectlyRecursiveValuetype * p)
{
  ::CORBA::remove_ref (p);
}

Test::DirectlyRecursiveValuetype *
Test::DirectlyRecursiveValuetype::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Test::DirectlyRecursiveValuetype * > (v);
}

const char *
Test::DirectlyRecursiveValuetype::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Test::DirectlyRecursiveValuetype::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Test::DirectlyRecursiveValuetype::_tao_any_destructor (void *_tao_void_pointer)
{
  DirectlyRecursiveValuetype *_tao_tmp_pointer =
    static_cast<DirectlyRecursiveValuetype *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Test::DirectlyRecursiveValuetype::_tao_type (void) const
{
  return ::Test::_tc_DirectlyRecursiveValuetype;
}

Test::DirectlyRecursiveValuetype::~DirectlyRecursiveValuetype (void)
{}

::CORBA::Boolean
Test::DirectlyRecursiveValuetype::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__Test_DirectlyRecursiveValuetype (strm, ci);
}

::CORBA::Boolean
Test::DirectlyRecursiveValuetype::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__Test_DirectlyRecursiveValuetype (strm,ci);
}

::CORBA::Boolean
Test::DirectlyRecursiveValuetype::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (Test::DirectlyRecursiveValuetype::_downcast);
}

::CORBA::Boolean
Test::DirectlyRecursiveValuetype::_tao_unmarshal (
    TAO_InputCDR &strm,
    DirectlyRecursiveValuetype *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        DirectlyRecursiveValuetype::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = DirectlyRecursiveValuetype::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_init_cs.cpp:73

Test::DirectlyRecursiveValuetype_init::DirectlyRecursiveValuetype_init (void)
{
}

Test::DirectlyRecursiveValuetype_init::~DirectlyRecursiveValuetype_init (void)
{
}

Test::DirectlyRecursiveValuetype_init *
Test::DirectlyRecursiveValuetype_init::_downcast ( ::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast< ::Test::DirectlyRecursiveValuetype_init * > (v);
}

const char*
Test::DirectlyRecursiveValuetype_init::tao_repository_id (void)
{
  return ::Test::DirectlyRecursiveValuetype::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Test::DirectlyRecursiveValuetype_init::create_for_unmarshal (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Test::DirectlyRecursiveValuetype,
      ::CORBA::NO_MEMORY ()
    );
  return ret_val;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/enum_typecode.cpp:29
static char const * const _tao_enumerators_Test_PositionEnum[] =
  {
    "unknownpos"

  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Test_PositionEnum (
    "IDL:Test/PositionEnum:1.0",
    "PositionEnum",
    _tao_enumerators_Test_PositionEnum,
    1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_PositionEnum =
    &_tao_tc_Test_PositionEnum;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_Position[] =
      {
        { "type", &Test::_tc_PositionEnum }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_Position (
  ::CORBA::tk_struct,
  "IDL:Test/Position:1.0",
  "Position",
  _tao_fields_Test_Position,
  1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Position =
    &_tao_tc_Test_Position;
}

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::Position::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Position *_tao_tmp_pointer =
    static_cast<Position *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_OctetSeq (
    ::CORBA::tk_alias,
    "IDL:Test/OctetSeq:1.0",
    "OctetSeq",
    &CORBA::_tc_OctetSeq);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_OctetSeq =
    &_tao_tc_Test_OctetSeq;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/enum_typecode.cpp:29
static char const * const _tao_enumerators_Test_ValueSort[] =
  {
    "POSITION_TYPE",
    "OCTET_SEQ_TYPE"

  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Test_ValueSort (
    "IDL:Test/ValueSort:1.0",
    "ValueSort",
    _tao_enumerators_Test_ValueSort,
    2);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_ValueSort =
    &_tao_tc_Test_ValueSort;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::NonRecursiveUnionWithEnum::NonRecursiveUnionWithEnum (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (Test::ValueSort) -1;
}

Test::NonRecursiveUnionWithEnum::NonRecursiveUnionWithEnum (const ::Test::NonRecursiveUnionWithEnum &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Test::POSITION_TYPE:
    {
      this->u_.position_val_ = u.u_.position_val_;
    }
    break;
    case Test::OCTET_SEQ_TYPE:
    {
      if (u.u_.octet_seq_val_ == 0)
        {
          this->u_.octet_seq_val_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.octet_seq_val_,
              Test::OctetSeq (*u.u_.octet_seq_val_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Test::NonRecursiveUnionWithEnum::~NonRecursiveUnionWithEnum (void)
{
  // Finalize.
  this->_reset ();
}

void Test::NonRecursiveUnionWithEnum::_tao_any_destructor (void *_tao_void_pointer)
{
  NonRecursiveUnionWithEnum *tmp =
    static_cast<NonRecursiveUnionWithEnum *> (_tao_void_pointer);
  delete tmp;
}

Test::NonRecursiveUnionWithEnum &
Test::NonRecursiveUnionWithEnum::operator= (const ::Test::NonRecursiveUnionWithEnum &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case Test::POSITION_TYPE:
    {
      this->u_.position_val_ = u.u_.position_val_;
    }
    break;
    case Test::OCTET_SEQ_TYPE:
    {
      if (u.u_.octet_seq_val_ == 0)
        {
          this->u_.octet_seq_val_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.octet_seq_val_,
              Test::OctetSeq (*u.u_.octet_seq_val_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::NonRecursiveUnionWithEnum::_reset (void)
{
  switch (this->disc_)
  {

    case Test::POSITION_TYPE:

    break;

    case Test::OCTET_SEQ_TYPE:
      delete this->u_.octet_seq_val_;
      this->u_.octet_seq_val_ = 0;

    break;

    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Case_T<Test::ValueSort, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_NonRecursiveUnionWithEnum__0 (Test::POSITION_TYPE, "position_val", &Test::_tc_Position);
static TAO::TypeCode::Case_T<Test::ValueSort, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_NonRecursiveUnionWithEnum__1 (Test::OCTET_SEQ_TYPE, "octet_seq_val", &Test::_tc_OctetSeq);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_NonRecursiveUnionWithEnum[] =
  {
    &_tao_cases_Test_NonRecursiveUnionWithEnum__0,
    &_tao_cases_Test_NonRecursiveUnionWithEnum__1
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_NonRecursiveUnionWithEnum (
    "IDL:Test/NonRecursiveUnionWithEnum:1.0",
    "NonRecursiveUnionWithEnum",
    &Test::_tc_ValueSort,
    _tao_cases_Test_NonRecursiveUnionWithEnum,
    sizeof (_tao_cases_Test_NonRecursiveUnionWithEnum)/sizeof (_tao_cases_Test_NonRecursiveUnionWithEnum[0]),
    -1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_NonRecursiveUnionWithEnum =
    &_tao_tc_Test_NonRecursiveUnionWithEnum;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/enum_typecode.cpp:29
static char const * const _tao_enumerators_Test_ValueSort2[] =
  {
    "SYMBOL_TYPE2"

  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Test_ValueSort2 (
    "IDL:Test/ValueSort2:1.0",
    "ValueSort2",
    _tao_enumerators_Test_ValueSort2,
    1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_ValueSort2 =
    &_tao_tc_Test_ValueSort2;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_Symbol2[] =
      {
        { "name", &CORBA::_tc_string }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_Symbol2 (
  ::CORBA::tk_struct,
  "IDL:Test/Symbol2:1.0",
  "Symbol2",
  _tao_fields_Test_Symbol2,
  1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Symbol2 =
    &_tao_tc_Test_Symbol2;
}

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::Symbol2::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Symbol2 *_tao_tmp_pointer =
    static_cast<Symbol2 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:76

Test::NonRecursiveUnionWithStringStruct::NonRecursiveUnionWithStringStruct (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (Test::ValueSort2) -1;
}

Test::NonRecursiveUnionWithStringStruct::NonRecursiveUnionWithStringStruct (const ::Test::NonRecursiveUnionWithStringStruct &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Test::SYMBOL_TYPE2:
    {
      if (u.u_.symbol_val_ == 0)
        {
          this->u_.symbol_val_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.symbol_val_,
              Test::Symbol2 (*u.u_.symbol_val_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Test::NonRecursiveUnionWithStringStruct::~NonRecursiveUnionWithStringStruct (void)
{
  // Finalize.
  this->_reset ();
}

void Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor (void *_tao_void_pointer)
{
  NonRecursiveUnionWithStringStruct *tmp =
    static_cast<NonRecursiveUnionWithStringStruct *> (_tao_void_pointer);
  delete tmp;
}

Test::NonRecursiveUnionWithStringStruct &
Test::NonRecursiveUnionWithStringStruct::operator= (const ::Test::NonRecursiveUnionWithStringStruct &u)
{
  if (&u == this)
    {
      return *this;
    }

  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case Test::SYMBOL_TYPE2:
    {
      if (u.u_.symbol_val_ == 0)
        {
          this->u_.symbol_val_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.symbol_val_,
              Test::Symbol2 (*u.u_.symbol_val_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }

  return *this;
}

/// Reset method to reset old values of a union.
void Test::NonRecursiveUnionWithStringStruct::_reset (void)
{
  switch (this->disc_)
  {

    case Test::SYMBOL_TYPE2:
      delete this->u_.symbol_val_;
      this->u_.symbol_val_ = 0;

    break;

    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65

static TAO::TypeCode::Case_T<Test::ValueSort2, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_NonRecursiveUnionWithStringStruct__0 (Test::SYMBOL_TYPE2, "symbol_val", &Test::_tc_Symbol2);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_NonRecursiveUnionWithStringStruct[] =
  {
    &_tao_cases_Test_NonRecursiveUnionWithStringStruct__0
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_NonRecursiveUnionWithStringStruct (
    "IDL:Test/NonRecursiveUnionWithStringStruct:1.0",
    "NonRecursiveUnionWithStringStruct",
    &Test::_tc_ValueSort2,
    _tao_cases_Test_NonRecursiveUnionWithStringStruct,
    sizeof (_tao_cases_Test_NonRecursiveUnionWithStringStruct)/sizeof (_tao_cases_Test_NonRecursiveUnionWithStringStruct[0]),
    -1);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_NonRecursiveUnionWithStringStruct =
    &_tao_tc_Test_NonRecursiveUnionWithStringStruct;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:48

// Traits specializations for Test::Hello.

Test::Hello_ptr
TAO::Objref_Traits<Test::Hello>::duplicate (
    Test::Hello_ptr p)
{
  return Test::Hello::_duplicate (p);
}

void
TAO::Objref_Traits<Test::Hello>::release (
    Test::Hello_ptr p)
{
  ::CORBA::release (p);
}

Test::Hello_ptr
TAO::Objref_Traits<Test::Hello>::nil (void)
{
  return Test::Hello::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Test::Hello>::marshal (
    const Test::Hello_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

::CORBA::Any *
Test::Hello::get_any (
  const ::CORBA::Any & the_any)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< ::CORBA::Any>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_the_any (the_any);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_the_any
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "get_any",
      7,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY

    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:88

void
Test::Hello::shutdown (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }

  TAO::Arg_Traits< void>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "shutdown",
      8,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_ONEWAY_INVOCATION,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);
}

Test::Hello::Hello (void)
{
}

Test::Hello::~Hello (void)
{
}

void
Test::Hello::_tao_any_destructor (void *_tao_void_pointer)
{
  Hello *_tao_tmp_pointer =
    static_cast<Hello *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Test::Hello_ptr
Test::Hello::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Hello>::narrow (
        _tao_objref,
        "IDL:Test/Hello:1.0");
}

Test::Hello_ptr
Test::Hello::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Hello>::unchecked_narrow (
        _tao_objref);
}

Test::Hello_ptr
Test::Hello::_nil (void)
{
  return 0;
}

Test::Hello_ptr
Test::Hello::_duplicate (Hello_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
Test::Hello::_tao_release (Hello_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Test::Hello::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:Test/Hello:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Test::Hello::_interface_repository_id (void) const
{
  return "IDL:Test/Hello:1.0";
}

::CORBA::Boolean
Test::Hello::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:70

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Test_Hello (
    ::CORBA::tk_objref,
    "IDL:Test/Hello:1.0",
    "Hello");


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Hello =
    &_tao_tc_Test_Hello;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVE2SEQ2_CS_)
#define _TEST_RECURSIVE2SEQ2_CS_

Test::Recursive2Seq2::Recursive2Seq2 (void)
{}

Test::Recursive2Seq2::Recursive2Seq2 (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        Recursive2,
        Recursive2_var
      > (max)
{}

Test::Recursive2Seq2::Recursive2Seq2 (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::Recursive2 * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_valuetype_sequence<
        Recursive2,
        Recursive2_var
      >
    (max, length, buffer, release)
{}

Test::Recursive2Seq2::Recursive2Seq2 (
    const Recursive2Seq2 &seq)
  : ::TAO::unbounded_valuetype_sequence<
        Recursive2,
        Recursive2_var
      > (seq)
{}

Test::Recursive2Seq2::~Recursive2Seq2 (void)
{}

void Test::Recursive2Seq2::_tao_any_destructor (
    void * _tao_void_pointer)
{
  Recursive2Seq2 * _tao_tmp_pointer =
    static_cast<Recursive2Seq2 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_Recursive2Seq2_GUARD
#define _TAO_TYPECODE_Test_Recursive2Seq2_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_Recursive2Seq2_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_Recursive2,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_Recursive2Seq2_0 =
        &Test_Recursive2Seq2_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_Recursive2Seq2_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_Recursive2Seq2 (
    ::CORBA::tk_alias,
    "IDL:Test/Recursive2Seq2:1.0",
    "Recursive2Seq2",
    &TAO::TypeCode::tc_Test_Recursive2Seq2_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Recursive2Seq2 =
    &_tao_tc_Test_Recursive2Seq2;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_Test_Recursive2[] =
  {
    { "insa", &Test::Recursive2::_tc_Innerstruct3a, ::CORBA::PUBLIC_MEMBER },
    { "a", &CORBA::_tc_short, ::CORBA::PUBLIC_MEMBER },
    { "insb", &Test::Recursive2::_tc_Innerstruct3b, ::CORBA::PUBLIC_MEMBER }

  };
static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Value<char const *,
                       ::CORBA::TypeCode_ptr const *,
                       TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                       TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * >

  _tao_tc_Test_Recursive2 (
    ::CORBA::tk_value,
    "IDL:Test/Recursive2:1.0",
    "Recursive2",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Test_Recursive2,
    3);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Recursive2 =
    &_tao_tc_Test_Recursive2;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Test::Recursive2>::add_ref (
    Test::Recursive2 * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Test::Recursive2>::remove_ref (
    Test::Recursive2 * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Test::Recursive2>::release (
    Test::Recursive2 * p)
{
  ::CORBA::remove_ref (p);
}

Test::Recursive2 *
Test::Recursive2::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Test::Recursive2 * > (v);
}

const char *
Test::Recursive2::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Test::Recursive2::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Test::Recursive2::_tao_any_destructor (void *_tao_void_pointer)
{
  Recursive2 *_tao_tmp_pointer =
    static_cast<Recursive2 *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Test::Recursive2::_tao_type (void) const
{
  return ::Test::_tc_Recursive2;
}

Test::Recursive2::~Recursive2 (void)
{}

::CORBA::Boolean
Test::Recursive2::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__Test_Recursive2 (strm, ci);
}

::CORBA::Boolean
Test::Recursive2::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__Test_Recursive2 (strm,ci);
}

::CORBA::Boolean
Test::Recursive2::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (Test::Recursive2::_downcast);
}

::CORBA::Boolean
Test::Recursive2::_tao_unmarshal (
    TAO_InputCDR &strm,
    Recursive2 *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        Recursive2::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Recursive2::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_Recursive2_Innerstruct3a[] =
      {
        { "recursive_unions", &Test::_tc_Recursive2Seq2 }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_Recursive2_Innerstruct3a (
  ::CORBA::tk_struct,
  "IDL:Test/Recursive2/Innerstruct3a:1.0",
  "Innerstruct3a",
  _tao_fields_Test_Recursive2_Innerstruct3a,
  1);

::CORBA::TypeCode_ptr const Test::Recursive2::_tc_Innerstruct3a =
  &_tao_tc_Test_Recursive2_Innerstruct3a;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::Recursive2::Innerstruct3a::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Innerstruct3a *_tao_tmp_pointer =
    static_cast<Innerstruct3a *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:86



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const
    _tao_fields_Test_Recursive2_Innerstruct3b[] =
      {
        { "recursive_second", &Test::_tc_Recursive2Seq2 }
      };

static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Test_Recursive2_Innerstruct3b (
  ::CORBA::tk_struct,
  "IDL:Test/Recursive2/Innerstruct3b:1.0",
  "Innerstruct3b",
  _tao_fields_Test_Recursive2_Innerstruct3b,
  1);

::CORBA::TypeCode_ptr const Test::Recursive2::_tc_Innerstruct3b =
  &_tao_tc_Test_Recursive2_Innerstruct3b;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_cs.cpp:56

void
Test::Recursive2::Innerstruct3b::_tao_any_destructor (
    void *_tao_void_pointer)
{
  Innerstruct3b *_tao_tmp_pointer =
    static_cast<Innerstruct3b *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_init_cs.cpp:73

Test::Recursive2_init::Recursive2_init (void)
{
}

Test::Recursive2_init::~Recursive2_init (void)
{
}

Test::Recursive2_init *
Test::Recursive2_init::_downcast ( ::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast< ::Test::Recursive2_init * > (v);
}

const char*
Test::Recursive2_init::tao_repository_id (void)
{
  return ::Test::Recursive2::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Test::Recursive2_init::create_for_unmarshal (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Test::Recursive2,
      ::CORBA::NO_MEMORY ()
    );
  return ret_val;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:70

#if !defined (_TEST_RECURSIVESEQ3_CS_)
#define _TEST_RECURSIVESEQ3_CS_

Test::RecursiveSeq3::RecursiveSeq3 (void)
{}

Test::RecursiveSeq3::RecursiveSeq3 (
    ::CORBA::ULong max)
  : ::TAO::unbounded_valuetype_sequence<
        Recursive3,
        Recursive3_var
      > (max)
{}

Test::RecursiveSeq3::RecursiveSeq3 (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    Test::Recursive3 * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_valuetype_sequence<
        Recursive3,
        Recursive3_var
      >
    (max, length, buffer, release)
{}

Test::RecursiveSeq3::RecursiveSeq3 (
    const RecursiveSeq3 &seq)
  : ::TAO::unbounded_valuetype_sequence<
        Recursive3,
        Recursive3_var
      > (seq)
{}

Test::RecursiveSeq3::~RecursiveSeq3 (void)
{}

void Test::RecursiveSeq3::_tao_any_destructor (
    void * _tao_void_pointer)
{
  RecursiveSeq3 * _tao_tmp_pointer =
    static_cast<RecursiveSeq3 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:49



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461


#ifndef _TAO_TYPECODE_Test_RecursiveSeq3_GUARD
#define _TAO_TYPECODE_Test_RecursiveSeq3_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Test_RecursiveSeq3_0 (
          ::CORBA::tk_sequence,
          &Test::_tc_Recursive3,
          0U);

      ::CORBA::TypeCode_ptr const tc_Test_RecursiveSeq3_0 =
        &Test_RecursiveSeq3_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Test_RecursiveSeq3_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_RecursiveSeq3 (
    ::CORBA::tk_alias,
    "IDL:Test/RecursiveSeq3:1.0",
    "RecursiveSeq3",
    &TAO::TypeCode::tc_Test_RecursiveSeq3_0);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_RecursiveSeq3 =
    &_tao_tc_Test_RecursiveSeq3;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/value_typecode.cpp:65



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:461

static TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const _tao_fields_Test_Recursive3[] =
  {
    { "seq1", &Test::_tc_RecursiveSeq3, ::CORBA::PUBLIC_MEMBER },
    { "a", &CORBA::_tc_short, ::CORBA::PUBLIC_MEMBER },
    { "seq2", &Test::_tc_RecursiveSeq3, ::CORBA::PUBLIC_MEMBER }

  };
static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Value<char const *,
                       ::CORBA::TypeCode_ptr const *,
                       TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const *,
                       TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Value_Field<char const *, ::CORBA::TypeCode_ptr const *> const * >

  _tao_tc_Test_Recursive3 (
    ::CORBA::tk_value,
    "IDL:Test/Recursive3:1.0",
    "Recursive3",
    ::CORBA::VM_NONE,
    &::CORBA::_tc_null,
    _tao_fields_Test_Recursive3,
    3);


namespace Test
{
  ::CORBA::TypeCode_ptr const _tc_Recursive3 =
    &_tao_tc_Test_Recursive3;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_cs.cpp:53

void
TAO::Value_Traits<Test::Recursive3>::add_ref (
    Test::Recursive3 * p)
{
  ::CORBA::add_ref (p);
}

void
TAO::Value_Traits<Test::Recursive3>::remove_ref (
    Test::Recursive3 * p)
{
  ::CORBA::remove_ref (p);
}

void
TAO::Value_Traits<Test::Recursive3>::release (
    Test::Recursive3 * p)
{
  ::CORBA::remove_ref (p);
}

Test::Recursive3 *
Test::Recursive3::_downcast ( ::CORBA::ValueBase *v)
{
  return dynamic_cast< ::Test::Recursive3 * > (v);
}

const char *
Test::Recursive3::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void
Test::Recursive3::_tao_obv_truncatable_repo_ids (Repository_Id_List& ids) const
{
  ids.push_back (this->_tao_obv_static_repository_id ());
}

void
Test::Recursive3::_tao_any_destructor (void *_tao_void_pointer)
{
  Recursive3 *_tao_tmp_pointer =
    static_cast<Recursive3 *> (_tao_void_pointer);
  ::CORBA::remove_ref (_tao_tmp_pointer);
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Test::Recursive3::_tao_type (void) const
{
  return ::Test::_tc_Recursive3;
}

Test::Recursive3::~Recursive3 (void)
{}

::CORBA::Boolean
Test::Recursive3::_tao_marshal_v (TAO_OutputCDR & strm) const
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_);
  return this->_tao_marshal__Test_Recursive3 (strm, ci);
}

::CORBA::Boolean
Test::Recursive3::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  TAO_ChunkInfo ci (this->is_truncatable_ || this->chunking_, 1);
  return this->_tao_unmarshal__Test_Recursive3 (strm,ci);
}

::CORBA::Boolean
Test::Recursive3::_tao_match_formal_type (ptrdiff_t formal_type_id) const
{
  return formal_type_id == reinterpret_cast<ptrdiff_t> (Test::Recursive3::_downcast);
}

::CORBA::Boolean
Test::Recursive3::_tao_unmarshal (
    TAO_InputCDR &strm,
    Recursive3 *&new_object
  )
{
  ::CORBA::ValueBase *base = 0;
  ::CORBA::Boolean is_indirected = false;
  ::CORBA::Boolean is_null_object = false;
  ::CORBA::Boolean const retval =
    ::CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        base,
        Recursive3::_tao_obv_static_repository_id (),
        is_null_object,
        is_indirected
      );

  ::CORBA::ValueBase_var owner (base);

  if (!retval)
    return false;

  if (is_null_object)
    return true;

  if (!is_indirected && !base->_tao_unmarshal_v (strm))
    return false;

  // Now base must point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Recursive3::_downcast (base);
  if (0 == new_object)
    return false;

  if (is_indirected)
    new_object->_add_ref ();

  owner._retn ();
  return true;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_init_cs.cpp:73

Test::Recursive3_init::Recursive3_init (void)
{
}

Test::Recursive3_init::~Recursive3_init (void)
{
}

Test::Recursive3_init *
Test::Recursive3_init::_downcast ( ::CORBA::ValueFactoryBase *v)
{
  return dynamic_cast< ::Test::Recursive3_init * > (v);
}

const char*
Test::Recursive3_init::tao_repository_id (void)
{
  return ::Test::Recursive3::_tao_obv_static_repository_id ();
}

::CORBA::ValueBase *
Test::Recursive3_init::create_for_unmarshal (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
      ret_val,
      OBV_Test::Recursive3,
      ::CORBA::NO_MEMORY ()
    );
  return ret_val;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Test::IndirectlyRecursiveValuetype::IndirectlyRecursiveValuetype (void)
: require_truncation_ (false)
{}

OBV_Test::IndirectlyRecursiveValuetype::IndirectlyRecursiveValuetype (
    const ::Test::IndirectlyRecursiveValuetypeSeq & _tao_init_recursive_valuetypes)
: require_truncation_ (false)
{
  recursive_valuetypes (_tao_init_recursive_valuetypes);
}

OBV_Test::IndirectlyRecursiveValuetype::~IndirectlyRecursiveValuetype (void)
{}

::CORBA::ValueBase *
OBV_Test::IndirectlyRecursiveValuetype::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    IndirectlyRecursiveValuetype (
      recursive_valuetypes ()
    ),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
OBV_Test::IndirectlyRecursiveValuetype::_tao_marshal__Test_IndirectlyRecursiveValuetype (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Test::IndirectlyRecursiveValuetype::_tao_unmarshal__Test_IndirectlyRecursiveValuetype (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:762

/// Accessor to set the member.
void
OBV_Test::IndirectlyRecursiveValuetype::recursive_valuetypes (const Test::IndirectlyRecursiveValuetypeSeq &val)
{
  this->_pd_recursive_valuetypes = val;
}

/// Readonly get method.
const Test::IndirectlyRecursiveValuetypeSeq &
OBV_Test::IndirectlyRecursiveValuetype::recursive_valuetypes (void) const
{
  return this->_pd_recursive_valuetypes;
}

/// Read/write get method.
Test::IndirectlyRecursiveValuetypeSeq &
OBV_Test::IndirectlyRecursiveValuetype::recursive_valuetypes (void)
{
  return this->_pd_recursive_valuetypes;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Test::DirectlyRecursiveValuetype::DirectlyRecursiveValuetype (void)
: require_truncation_ (false)
{}

OBV_Test::DirectlyRecursiveValuetype::DirectlyRecursiveValuetype (
    ::Test::DirectlyRecursiveValuetype * _tao_init_recursive_valuetype,
    ::Test::DirectlyRecursiveValuetype * _tao_init_recursive_valuetype_second)
: require_truncation_ (false)
{
  recursive_valuetype (_tao_init_recursive_valuetype);
  recursive_valuetype_second (_tao_init_recursive_valuetype_second);
}

OBV_Test::DirectlyRecursiveValuetype::~DirectlyRecursiveValuetype (void)
{}

::CORBA::ValueBase *
OBV_Test::DirectlyRecursiveValuetype::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    DirectlyRecursiveValuetype (
      (recursive_valuetype () ?
        Test::DirectlyRecursiveValuetype::_downcast (recursive_valuetype ()->_copy_value ())
        : 0),
      (recursive_valuetype_second () ?
        Test::DirectlyRecursiveValuetype::_downcast (recursive_valuetype_second ()->_copy_value ())
        : 0)
    ),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
OBV_Test::DirectlyRecursiveValuetype::_tao_marshal__Test_DirectlyRecursiveValuetype (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Test::DirectlyRecursiveValuetype::_tao_unmarshal__Test_DirectlyRecursiveValuetype (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:430

/// Accessor to set the member.
void
OBV_Test::DirectlyRecursiveValuetype::recursive_valuetype (Test::DirectlyRecursiveValuetype* val)
{
  ::CORBA::add_ref (val);
  this->_pd_recursive_valuetype = val;
}

/// Retrieve the member
Test::DirectlyRecursiveValuetype *
OBV_Test::DirectlyRecursiveValuetype::recursive_valuetype () const
{
  return this->_pd_recursive_valuetype.in ();
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:430

/// Accessor to set the member.
void
OBV_Test::DirectlyRecursiveValuetype::recursive_valuetype_second (Test::DirectlyRecursiveValuetype* val)
{
  ::CORBA::add_ref (val);
  this->_pd_recursive_valuetype_second = val;
}

/// Retrieve the member
Test::DirectlyRecursiveValuetype *
OBV_Test::DirectlyRecursiveValuetype::recursive_valuetype_second () const
{
  return this->_pd_recursive_valuetype_second.in ();
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Test::Recursive2::Recursive2 (void)
: require_truncation_ (false)
{}

OBV_Test::Recursive2::Recursive2 (
    const ::Test::Recursive2::Innerstruct3a & _tao_init_insa,
    ::CORBA::Short _tao_init_a,
    const ::Test::Recursive2::Innerstruct3b & _tao_init_insb)
: require_truncation_ (false)
{
  insa (_tao_init_insa);
  a (_tao_init_a);
  insb (_tao_init_insb);
}

OBV_Test::Recursive2::~Recursive2 (void)
{}

::CORBA::ValueBase *
OBV_Test::Recursive2::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    Recursive2 (
      insa (),
      a (),
      insb ()
    ),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
OBV_Test::Recursive2::_tao_marshal__Test_Recursive2 (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Test::Recursive2::_tao_unmarshal__Test_Recursive2 (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:1003

/// Accessor to set the member.
void
OBV_Test::Recursive2::insa (const Test::Recursive2::Innerstruct3a &val)
{
  this->_pd_insa = val;
}
/// Readonly get method.
const Test::Recursive2::Innerstruct3a &
OBV_Test::Recursive2::insa (void) const
{
  return this->_pd_insa;
}
/// Read/write get method.
Test::Recursive2::Innerstruct3a &
OBV_Test::Recursive2::insa (void)
{
  return this->_pd_insa;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:587

/// Accessor to set the member.
void
OBV_Test::Recursive2::a (const CORBA::Short val)
{
  // Set the value.
  this->_pd_a = val;
}

// Retrieve the member
::CORBA::Short
OBV_Test::Recursive2::a (void) const
{
  return this->_pd_a;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:1003

/// Accessor to set the member.
void
OBV_Test::Recursive2::insb (const Test::Recursive2::Innerstruct3b &val)
{
  this->_pd_insb = val;
}
/// Readonly get method.
const Test::Recursive2::Innerstruct3b &
OBV_Test::Recursive2::insb (void) const
{
  return this->_pd_insb;
}
/// Read/write get method.
Test::Recursive2::Innerstruct3b &
OBV_Test::Recursive2::insb (void)
{
  return this->_pd_insb;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/valuetype_obv_cs.cpp:44

OBV_Test::Recursive3::Recursive3 (void)
: require_truncation_ (false)
{}

OBV_Test::Recursive3::Recursive3 (
    const ::Test::RecursiveSeq3 & _tao_init_seq1,
    ::CORBA::Short _tao_init_a,
    const ::Test::RecursiveSeq3 & _tao_init_seq2)
: require_truncation_ (false)
{
  seq1 (_tao_init_seq1);
  a (_tao_init_a);
  seq2 (_tao_init_seq2);
}

OBV_Test::Recursive3::~Recursive3 (void)
{}

::CORBA::ValueBase *
OBV_Test::Recursive3::_copy_value (void)
{
  ::CORBA::ValueBase *ret_val = 0;
  ACE_NEW_THROW_EX (
    ret_val,
    Recursive3 (
      seq1 (),
      a (),
      seq2 ()
    ),
    ::CORBA::NO_MEMORY ()
  );
  return ret_val;
}

::CORBA::Boolean
OBV_Test::Recursive3::_tao_marshal__Test_Recursive3 (TAO_OutputCDR &strm, TAO_ChunkInfo& ci) const
{
  return _tao_marshal_state (strm, ci);
}

::CORBA::Boolean
OBV_Test::Recursive3::_tao_unmarshal__Test_Recursive3 (TAO_InputCDR &strm, TAO_ChunkInfo& ci)
{
  return _tao_unmarshal_state (strm, ci);
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:762

/// Accessor to set the member.
void
OBV_Test::Recursive3::seq1 (const Test::RecursiveSeq3 &val)
{
  this->_pd_seq1 = val;
}

/// Readonly get method.
const Test::RecursiveSeq3 &
OBV_Test::Recursive3::seq1 (void) const
{
  return this->_pd_seq1;
}

/// Read/write get method.
Test::RecursiveSeq3 &
OBV_Test::Recursive3::seq1 (void)
{
  return this->_pd_seq1;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:587

/// Accessor to set the member.
void
OBV_Test::Recursive3::a (const CORBA::Short val)
{
  // Set the value.
  this->_pd_a = val;
}

// Retrieve the member
::CORBA::Short
OBV_Test::Recursive3::a (void) const
{
  return this->_pd_a;
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/field_cs.cpp:762

/// Accessor to set the member.
void
OBV_Test::Recursive3::seq2 (const Test::RecursiveSeq3 &val)
{
  this->_pd_seq2 = val;
}

/// Readonly get method.
const Test::RecursiveSeq3 &
OBV_Test::Recursive3::seq2 (void) const
{
  return this->_pd_seq2;
}

/// Read/write get method.
Test::RecursiveSeq3 &
OBV_Test::Recursive3::seq2 (void)
{
  return this->_pd_seq2;
}

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<Test::Recursive_Type_In_Any_Test_Failed>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }

    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{


  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::Recursive_Type_In_Any_Test_Failed &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::Recursive_Type_In_Any_Test_Failed>::insert_copy (
        _tao_any,
        ::Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor,
        ::Test::_tc_Recursive_Type_In_Any_Test_Failed,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Test::Recursive_Type_In_Any_Test_Failed *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::Recursive_Type_In_Any_Test_Failed>::insert (
        _tao_any,
        ::Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor,
        ::Test::_tc_Recursive_Type_In_Any_Test_Failed,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Test::Recursive_Type_In_Any_Test_Failed *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::Test::Recursive_Type_In_Any_Test_Failed *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Test::Recursive_Type_In_Any_Test_Failed *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::Test::Recursive_Type_In_Any_Test_Failed>::extract (
          _tao_any,
          ::Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor,
          ::Test::_tc_Recursive_Type_In_Any_Test_Failed,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::Recursive_Type_In_Any_Test_Failed &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Recursive_Type_In_Any_Test_Failed>::insert_copy (
      _tao_any,
      Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor,
      Test::_tc_Recursive_Type_In_Any_Test_Failed,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Recursive_Type_In_Any_Test_Failed *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Recursive_Type_In_Any_Test_Failed>::insert (
      _tao_any,
      Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor,
      Test::_tc_Recursive_Type_In_Any_Test_Failed,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::Recursive_Type_In_Any_Test_Failed *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::Recursive_Type_In_Any_Test_Failed *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::Recursive_Type_In_Any_Test_Failed *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::Recursive_Type_In_Any_Test_Failed>::extract (
        _tao_any,
        Test::Recursive_Type_In_Any_Test_Failed::_tao_any_destructor,
        Test::_tc_Recursive_Type_In_Any_Test_Failed,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<Test::Demarshaling_From_Any_Failed>::demarshal_value (TAO_InputCDR & cdr)
  {
    ::CORBA::String_var id;

    if (!(cdr >> id.out ()))
      {
        return false;
      }

    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }

    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{


  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::Demarshaling_From_Any_Failed &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::Demarshaling_From_Any_Failed>::insert_copy (
        _tao_any,
        ::Test::Demarshaling_From_Any_Failed::_tao_any_destructor,
        ::Test::_tc_Demarshaling_From_Any_Failed,
        _tao_elem);
  }

  // Non-copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Test::Demarshaling_From_Any_Failed *_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::Demarshaling_From_Any_Failed>::insert (
        _tao_any,
        ::Test::Demarshaling_From_Any_Failed::_tao_any_destructor,
        ::Test::_tc_Demarshaling_From_Any_Failed,
        _tao_elem);
  }

  // Extraction to non-const pointer (deprecated).
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Test::Demarshaling_From_Any_Failed *&_tao_elem)
  {
    return _tao_any >>= const_cast<
        const ::Test::Demarshaling_From_Any_Failed *&> (
        _tao_elem);
  }

  // Extraction to const pointer.
  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      const ::Test::Demarshaling_From_Any_Failed *&_tao_elem)
  {
    return
      TAO::Any_Dual_Impl_T< ::Test::Demarshaling_From_Any_Failed>::extract (
          _tao_any,
          ::Test::Demarshaling_From_Any_Failed::_tao_any_destructor,
          ::Test::_tc_Demarshaling_From_Any_Failed,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::Demarshaling_From_Any_Failed &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Demarshaling_From_Any_Failed>::insert_copy (
      _tao_any,
      Test::Demarshaling_From_Any_Failed::_tao_any_destructor,
      Test::_tc_Demarshaling_From_Any_Failed,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Demarshaling_From_Any_Failed *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Demarshaling_From_Any_Failed>::insert (
      _tao_any,
      Test::Demarshaling_From_Any_Failed::_tao_any_destructor,
      Test::_tc_Demarshaling_From_Any_Failed,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::Demarshaling_From_Any_Failed *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::Demarshaling_From_Any_Failed *&> (
      _tao_elem);
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::Demarshaling_From_Any_Failed *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::Demarshaling_From_Any_Failed>::extract (
        _tao_any,
        Test::Demarshaling_From_Any_Failed::_tao_any_destructor,
        Test::_tc_Demarshaling_From_Any_Failed,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveStructSeq &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStructSeq>::insert_copy (
        _tao_any,
        ::Test::RecursiveStructSeq::_tao_any_destructor,
        ::Test::_tc_RecursiveStructSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveStructSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveStructSeq>::insert (
      _tao_any,
      ::Test::RecursiveStructSeq::_tao_any_destructor,
      ::Test::_tc_RecursiveStructSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveStructSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveStructSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveStructSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStructSeq>::extract (
        _tao_any,
        ::Test::RecursiveStructSeq::_tao_any_destructor,
        ::Test::_tc_RecursiveStructSeq,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveStructSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStructSeq>::insert_copy (
      _tao_any,
      Test::RecursiveStructSeq::_tao_any_destructor,
      Test::_tc_RecursiveStructSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveStructSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStructSeq>::insert (
      _tao_any,
      Test::RecursiveStructSeq::_tao_any_destructor,
      Test::_tc_RecursiveStructSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveStructSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveStructSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveStructSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveStructSeq>::extract (
        _tao_any,
        Test::RecursiveStructSeq::_tao_any_destructor,
        Test::_tc_RecursiveStructSeq,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveStruct &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStruct>::insert_copy (
        _tao_any,
        ::Test::RecursiveStruct::_tao_any_destructor,
        ::Test::_tc_RecursiveStruct,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    Test::RecursiveStruct *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveStruct>::insert (
      _tao_any,
      ::Test::RecursiveStruct::_tao_any_destructor,
      ::Test::_tc_RecursiveStruct,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveStruct *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveStruct *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveStruct *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStruct>::extract (
        _tao_any,
        ::Test::RecursiveStruct::_tao_any_destructor,
        ::Test::_tc_RecursiveStruct,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Test::RecursiveStruct &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStruct>::insert_copy (
    _tao_any,
    Test::RecursiveStruct::_tao_any_destructor,
    Test::_tc_RecursiveStruct,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Test::RecursiveStruct *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStruct>::insert (
    _tao_any,
    Test::RecursiveStruct::_tao_any_destructor,
    Test::_tc_RecursiveStruct,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  Test::RecursiveStruct *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveStruct *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Test::RecursiveStruct *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveStruct>::extract (
      _tao_any,
      Test::RecursiveStruct::_tao_any_destructor,
      Test::_tc_RecursiveStruct,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::NestedRecursiveStructSeq &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStructSeq>::insert_copy (
        _tao_any,
        ::Test::NestedRecursiveStructSeq::_tao_any_destructor,
        ::Test::_tc_NestedRecursiveStructSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::NestedRecursiveStructSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStructSeq>::insert (
      _tao_any,
      ::Test::NestedRecursiveStructSeq::_tao_any_destructor,
      ::Test::_tc_NestedRecursiveStructSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::NestedRecursiveStructSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::NestedRecursiveStructSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::NestedRecursiveStructSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStructSeq>::extract (
        _tao_any,
        ::Test::NestedRecursiveStructSeq::_tao_any_destructor,
        ::Test::_tc_NestedRecursiveStructSeq,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::NestedRecursiveStructSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::NestedRecursiveStructSeq>::insert_copy (
      _tao_any,
      Test::NestedRecursiveStructSeq::_tao_any_destructor,
      Test::_tc_NestedRecursiveStructSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::NestedRecursiveStructSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::NestedRecursiveStructSeq>::insert (
      _tao_any,
      Test::NestedRecursiveStructSeq::_tao_any_destructor,
      Test::_tc_NestedRecursiveStructSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::NestedRecursiveStructSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::NestedRecursiveStructSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::NestedRecursiveStructSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::NestedRecursiveStructSeq>::extract (
        _tao_any,
        Test::NestedRecursiveStructSeq::_tao_any_destructor,
        Test::_tc_NestedRecursiveStructSeq,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::NestedRecursiveStruct &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStruct>::insert_copy (
        _tao_any,
        ::Test::NestedRecursiveStruct::_tao_any_destructor,
        ::Test::_tc_NestedRecursiveStruct,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    Test::NestedRecursiveStruct *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStruct>::insert (
      _tao_any,
      ::Test::NestedRecursiveStruct::_tao_any_destructor,
      ::Test::_tc_NestedRecursiveStruct,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::NestedRecursiveStruct *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::NestedRecursiveStruct *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::NestedRecursiveStruct *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStruct>::extract (
        _tao_any,
        ::Test::NestedRecursiveStruct::_tao_any_destructor,
        ::Test::_tc_NestedRecursiveStruct,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Test::NestedRecursiveStruct &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::NestedRecursiveStruct>::insert_copy (
    _tao_any,
    Test::NestedRecursiveStruct::_tao_any_destructor,
    Test::_tc_NestedRecursiveStruct,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Test::NestedRecursiveStruct *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::NestedRecursiveStruct>::insert (
    _tao_any,
    Test::NestedRecursiveStruct::_tao_any_destructor,
    Test::_tc_NestedRecursiveStruct,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  Test::NestedRecursiveStruct *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::NestedRecursiveStruct *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Test::NestedRecursiveStruct *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::NestedRecursiveStruct>::extract (
      _tao_any,
      Test::NestedRecursiveStruct::_tao_any_destructor,
      Test::_tc_NestedRecursiveStruct,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::NestedRecursiveStruct::InnerStruct &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStruct::InnerStruct>::insert_copy (
        _tao_any,
        ::Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor,
        ::Test::NestedRecursiveStruct::_tc_InnerStruct,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    Test::NestedRecursiveStruct::InnerStruct *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStruct::InnerStruct>::insert (
      _tao_any,
      ::Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor,
      ::Test::NestedRecursiveStruct::_tc_InnerStruct,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::NestedRecursiveStruct::InnerStruct *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::NestedRecursiveStruct::InnerStruct *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::NestedRecursiveStruct::InnerStruct *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::NestedRecursiveStruct::InnerStruct>::extract (
        _tao_any,
        ::Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor,
        ::Test::NestedRecursiveStruct::_tc_InnerStruct,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Test::NestedRecursiveStruct::InnerStruct &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::NestedRecursiveStruct::InnerStruct>::insert_copy (
    _tao_any,
    Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor,
    Test::NestedRecursiveStruct::_tc_InnerStruct,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Test::NestedRecursiveStruct::InnerStruct *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::NestedRecursiveStruct::InnerStruct>::insert (
    _tao_any,
    Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor,
    Test::NestedRecursiveStruct::_tc_InnerStruct,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  Test::NestedRecursiveStruct::InnerStruct *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::NestedRecursiveStruct::InnerStruct *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Test::NestedRecursiveStruct::InnerStruct *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::NestedRecursiveStruct::InnerStruct>::extract (
      _tao_any,
      Test::NestedRecursiveStruct::InnerStruct::_tao_any_destructor,
      Test::NestedRecursiveStruct::_tc_InnerStruct,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnionSeq &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeq>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnionSeq::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeq>::insert (
      _tao_any,
      ::Test::RecursiveUnionSeq::_tao_any_destructor,
      ::Test::_tc_RecursiveUnionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnionSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnionSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeq>::extract (
        _tao_any,
        ::Test::RecursiveUnionSeq::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionSeq,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeq>::insert_copy (
      _tao_any,
      Test::RecursiveUnionSeq::_tao_any_destructor,
      Test::_tc_RecursiveUnionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnionSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeq>::insert (
      _tao_any,
      Test::RecursiveUnionSeq::_tao_any_destructor,
      Test::_tc_RecursiveUnionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnionSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnionSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeq>::extract (
        _tao_any,
        Test::RecursiveUnionSeq::_tao_any_destructor,
        Test::_tc_RecursiveUnionSeq,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnion &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnion::_tao_any_destructor,
        ::Test::_tc_RecursiveUnion,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion>::insert (
      _tao_any,
      ::Test::RecursiveUnion::_tao_any_destructor,
      ::Test::_tc_RecursiveUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion>::extract (
        _tao_any,
        ::Test::RecursiveUnion::_tao_any_destructor,
        ::Test::_tc_RecursiveUnion,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnion &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnion>::insert_copy (
      _tao_any,
      Test::RecursiveUnion::_tao_any_destructor,
      Test::_tc_RecursiveUnion,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnion>::insert (
      _tao_any,
      Test::RecursiveUnion::_tao_any_destructor,
      Test::_tc_RecursiveUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnion>::extract (
        _tao_any,
        Test::RecursiveUnion::_tao_any_destructor,
        Test::_tc_RecursiveUnion,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnionSeq2 &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeq2>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnionSeq2::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionSeq2,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionSeq2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeq2>::insert (
      _tao_any,
      ::Test::RecursiveUnionSeq2::_tao_any_destructor,
      ::Test::_tc_RecursiveUnionSeq2,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionSeq2 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnionSeq2 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnionSeq2 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeq2>::extract (
        _tao_any,
        ::Test::RecursiveUnionSeq2::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionSeq2,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionSeq2 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeq2>::insert_copy (
      _tao_any,
      Test::RecursiveUnionSeq2::_tao_any_destructor,
      Test::_tc_RecursiveUnionSeq2,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnionSeq2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeq2>::insert (
      _tao_any,
      Test::RecursiveUnionSeq2::_tao_any_destructor,
      Test::_tc_RecursiveUnionSeq2,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnionSeq2 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnionSeq2 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionSeq2 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeq2>::extract (
        _tao_any,
        Test::RecursiveUnionSeq2::_tao_any_destructor,
        Test::_tc_RecursiveUnionSeq2,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnion2 &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion2>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnion2::_tao_any_destructor,
        ::Test::_tc_RecursiveUnion2,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnion2 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion2>::insert (
      _tao_any,
      ::Test::RecursiveUnion2::_tao_any_destructor,
      ::Test::_tc_RecursiveUnion2,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnion2 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnion2 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnion2 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion2>::extract (
        _tao_any,
        ::Test::RecursiveUnion2::_tao_any_destructor,
        ::Test::_tc_RecursiveUnion2,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnion2 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnion2>::insert_copy (
      _tao_any,
      Test::RecursiveUnion2::_tao_any_destructor,
      Test::_tc_RecursiveUnion2,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnion2 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnion2>::insert (
      _tao_any,
      Test::RecursiveUnion2::_tao_any_destructor,
      Test::_tc_RecursiveUnion2,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnion2 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnion2 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnion2 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnion2>::extract (
        _tao_any,
        Test::RecursiveUnion2::_tao_any_destructor,
        Test::_tc_RecursiveUnion2,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveStructSeq3 &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStructSeq3>::insert_copy (
        _tao_any,
        ::Test::RecursiveStructSeq3::_tao_any_destructor,
        ::Test::_tc_RecursiveStructSeq3,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveStructSeq3 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveStructSeq3>::insert (
      _tao_any,
      ::Test::RecursiveStructSeq3::_tao_any_destructor,
      ::Test::_tc_RecursiveStructSeq3,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveStructSeq3 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveStructSeq3 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveStructSeq3 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStructSeq3>::extract (
        _tao_any,
        ::Test::RecursiveStructSeq3::_tao_any_destructor,
        ::Test::_tc_RecursiveStructSeq3,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveStructSeq3 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStructSeq3>::insert_copy (
      _tao_any,
      Test::RecursiveStructSeq3::_tao_any_destructor,
      Test::_tc_RecursiveStructSeq3,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveStructSeq3 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStructSeq3>::insert (
      _tao_any,
      Test::RecursiveStructSeq3::_tao_any_destructor,
      Test::_tc_RecursiveStructSeq3,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveStructSeq3 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveStructSeq3 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveStructSeq3 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveStructSeq3>::extract (
        _tao_any,
        Test::RecursiveStructSeq3::_tao_any_destructor,
        Test::_tc_RecursiveStructSeq3,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnion3 &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion3>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnion3::_tao_any_destructor,
        ::Test::_tc_RecursiveUnion3,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnion3 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion3>::insert (
      _tao_any,
      ::Test::RecursiveUnion3::_tao_any_destructor,
      ::Test::_tc_RecursiveUnion3,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnion3 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnion3 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnion3 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnion3>::extract (
        _tao_any,
        ::Test::RecursiveUnion3::_tao_any_destructor,
        ::Test::_tc_RecursiveUnion3,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnion3 &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnion3>::insert_copy (
      _tao_any,
      Test::RecursiveUnion3::_tao_any_destructor,
      Test::_tc_RecursiveUnion3,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnion3 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnion3>::insert (
      _tao_any,
      Test::RecursiveUnion3::_tao_any_destructor,
      Test::_tc_RecursiveUnion3,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnion3 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnion3 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnion3 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnion3>::extract (
        _tao_any,
        Test::RecursiveUnion3::_tao_any_destructor,
        Test::_tc_RecursiveUnion3,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveStruct3 &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStruct3>::insert_copy (
        _tao_any,
        ::Test::RecursiveStruct3::_tao_any_destructor,
        ::Test::_tc_RecursiveStruct3,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    Test::RecursiveStruct3 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveStruct3>::insert (
      _tao_any,
      ::Test::RecursiveStruct3::_tao_any_destructor,
      ::Test::_tc_RecursiveStruct3,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveStruct3 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveStruct3 *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveStruct3 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveStruct3>::extract (
        _tao_any,
        ::Test::RecursiveStruct3::_tao_any_destructor,
        ::Test::_tc_RecursiveStruct3,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Test::RecursiveStruct3 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStruct3>::insert_copy (
    _tao_any,
    Test::RecursiveStruct3::_tao_any_destructor,
    Test::_tc_RecursiveStruct3,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Test::RecursiveStruct3 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveStruct3>::insert (
    _tao_any,
    Test::RecursiveStruct3::_tao_any_destructor,
    Test::_tc_RecursiveStruct3,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  Test::RecursiveStruct3 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveStruct3 *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Test::RecursiveStruct3 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveStruct3>::extract (
      _tao_any,
      Test::RecursiveStruct3::_tao_any_destructor,
      Test::_tc_RecursiveStruct3,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnionSeqNoDefault &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeqNoDefault>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnionSeqNoDefault::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionSeqNoDefault,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionSeqNoDefault *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeqNoDefault>::insert (
      _tao_any,
      ::Test::RecursiveUnionSeqNoDefault::_tao_any_destructor,
      ::Test::_tc_RecursiveUnionSeqNoDefault,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionSeqNoDefault *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnionSeqNoDefault *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnionSeqNoDefault *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionSeqNoDefault>::extract (
        _tao_any,
        ::Test::RecursiveUnionSeqNoDefault::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionSeqNoDefault,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionSeqNoDefault &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeqNoDefault>::insert_copy (
      _tao_any,
      Test::RecursiveUnionSeqNoDefault::_tao_any_destructor,
      Test::_tc_RecursiveUnionSeqNoDefault,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnionSeqNoDefault *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeqNoDefault>::insert (
      _tao_any,
      Test::RecursiveUnionSeqNoDefault::_tao_any_destructor,
      Test::_tc_RecursiveUnionSeqNoDefault,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnionSeqNoDefault *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnionSeqNoDefault *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionSeqNoDefault *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnionSeqNoDefault>::extract (
        _tao_any,
        Test::RecursiveUnionSeqNoDefault::_tao_any_destructor,
        Test::_tc_RecursiveUnionSeqNoDefault,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveUnionNoDefault &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionNoDefault>::insert_copy (
        _tao_any,
        ::Test::RecursiveUnionNoDefault::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionNoDefault,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionNoDefault *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionNoDefault>::insert (
      _tao_any,
      ::Test::RecursiveUnionNoDefault::_tao_any_destructor,
      ::Test::_tc_RecursiveUnionNoDefault,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveUnionNoDefault *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveUnionNoDefault *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveUnionNoDefault *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveUnionNoDefault>::extract (
        _tao_any,
        ::Test::RecursiveUnionNoDefault::_tao_any_destructor,
        ::Test::_tc_RecursiveUnionNoDefault,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionNoDefault &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionNoDefault>::insert_copy (
      _tao_any,
      Test::RecursiveUnionNoDefault::_tao_any_destructor,
      Test::_tc_RecursiveUnionNoDefault,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveUnionNoDefault *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::RecursiveUnionNoDefault>::insert (
      _tao_any,
      Test::RecursiveUnionNoDefault::_tao_any_destructor,
      Test::_tc_RecursiveUnionNoDefault,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveUnionNoDefault *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::RecursiveUnionNoDefault *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveUnionNoDefault *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveUnionNoDefault>::extract (
        _tao_any,
        Test::RecursiveUnionNoDefault::_tao_any_destructor,
        Test::_tc_RecursiveUnionNoDefault,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Test::VSort _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Test::VSort>::insert (
        _tao_any,
        ::Test::_tc_VSort,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Test::VSort &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Test::VSort>::extract (
          _tao_any,
          ::Test::_tc_VSort,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::VSort _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Test::VSort>::insert (
      _tao_any,
      Test::_tc_VSort,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::VSort &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Test::VSort>::extract (
        _tao_any,
        Test::_tc_VSort,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::VSortRecursiveUnionSeq &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::VSortRecursiveUnionSeq>::insert_copy (
        _tao_any,
        ::Test::VSortRecursiveUnionSeq::_tao_any_destructor,
        ::Test::_tc_VSortRecursiveUnionSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::VSortRecursiveUnionSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::VSortRecursiveUnionSeq>::insert (
      _tao_any,
      ::Test::VSortRecursiveUnionSeq::_tao_any_destructor,
      ::Test::_tc_VSortRecursiveUnionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::VSortRecursiveUnionSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::VSortRecursiveUnionSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::VSortRecursiveUnionSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::VSortRecursiveUnionSeq>::extract (
        _tao_any,
        ::Test::VSortRecursiveUnionSeq::_tao_any_destructor,
        ::Test::_tc_VSortRecursiveUnionSeq,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::VSortRecursiveUnionSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::VSortRecursiveUnionSeq>::insert_copy (
      _tao_any,
      Test::VSortRecursiveUnionSeq::_tao_any_destructor,
      Test::_tc_VSortRecursiveUnionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::VSortRecursiveUnionSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::VSortRecursiveUnionSeq>::insert (
      _tao_any,
      Test::VSortRecursiveUnionSeq::_tao_any_destructor,
      Test::_tc_VSortRecursiveUnionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::VSortRecursiveUnionSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::VSortRecursiveUnionSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::VSortRecursiveUnionSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::VSortRecursiveUnionSeq>::extract (
        _tao_any,
        Test::VSortRecursiveUnionSeq::_tao_any_destructor,
        Test::_tc_VSortRecursiveUnionSeq,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::VSortRecursiveUnion &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::VSortRecursiveUnion>::insert_copy (
        _tao_any,
        ::Test::VSortRecursiveUnion::_tao_any_destructor,
        ::Test::_tc_VSortRecursiveUnion,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::VSortRecursiveUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::VSortRecursiveUnion>::insert (
      _tao_any,
      ::Test::VSortRecursiveUnion::_tao_any_destructor,
      ::Test::_tc_VSortRecursiveUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::VSortRecursiveUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::VSortRecursiveUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::VSortRecursiveUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::VSortRecursiveUnion>::extract (
        _tao_any,
        ::Test::VSortRecursiveUnion::_tao_any_destructor,
        ::Test::_tc_VSortRecursiveUnion,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::VSortRecursiveUnion &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::VSortRecursiveUnion>::insert_copy (
      _tao_any,
      Test::VSortRecursiveUnion::_tao_any_destructor,
      Test::_tc_VSortRecursiveUnion,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::VSortRecursiveUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::VSortRecursiveUnion>::insert (
      _tao_any,
      Test::VSortRecursiveUnion::_tao_any_destructor,
      Test::_tc_VSortRecursiveUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::VSortRecursiveUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::VSortRecursiveUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::VSortRecursiveUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::VSortRecursiveUnion>::extract (
        _tao_any,
        Test::VSortRecursiveUnion::_tao_any_destructor,
        Test::_tc_VSortRecursiveUnion,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::EnumUnion &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::EnumUnion>::insert_copy (
        _tao_any,
        ::Test::EnumUnion::_tao_any_destructor,
        ::Test::_tc_EnumUnion,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::EnumUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::EnumUnion>::insert (
      _tao_any,
      ::Test::EnumUnion::_tao_any_destructor,
      ::Test::_tc_EnumUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::EnumUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::EnumUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::EnumUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::EnumUnion>::extract (
        _tao_any,
        ::Test::EnumUnion::_tao_any_destructor,
        ::Test::_tc_EnumUnion,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::EnumUnion &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::EnumUnion>::insert_copy (
      _tao_any,
      Test::EnumUnion::_tao_any_destructor,
      Test::_tc_EnumUnion,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::EnumUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::EnumUnion>::insert (
      _tao_any,
      Test::EnumUnion::_tao_any_destructor,
      Test::_tc_EnumUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::EnumUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::EnumUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::EnumUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::EnumUnion>::extract (
        _tao_any,
        Test::EnumUnion::_tao_any_destructor,
        Test::_tc_EnumUnion,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::IndirectlyRecursiveValuetypeSeq &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::IndirectlyRecursiveValuetypeSeq>::insert_copy (
        _tao_any,
        ::Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor,
        ::Test::_tc_IndirectlyRecursiveValuetypeSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::IndirectlyRecursiveValuetypeSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::IndirectlyRecursiveValuetypeSeq>::insert (
      _tao_any,
      ::Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor,
      ::Test::_tc_IndirectlyRecursiveValuetypeSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::IndirectlyRecursiveValuetypeSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::IndirectlyRecursiveValuetypeSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::IndirectlyRecursiveValuetypeSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::IndirectlyRecursiveValuetypeSeq>::extract (
        _tao_any,
        ::Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor,
        ::Test::_tc_IndirectlyRecursiveValuetypeSeq,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::IndirectlyRecursiveValuetypeSeq &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::IndirectlyRecursiveValuetypeSeq>::insert_copy (
      _tao_any,
      Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor,
      Test::_tc_IndirectlyRecursiveValuetypeSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::IndirectlyRecursiveValuetypeSeq *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::IndirectlyRecursiveValuetypeSeq>::insert (
      _tao_any,
      Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor,
      Test::_tc_IndirectlyRecursiveValuetypeSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::IndirectlyRecursiveValuetypeSeq *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::IndirectlyRecursiveValuetypeSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::IndirectlyRecursiveValuetypeSeq *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::IndirectlyRecursiveValuetypeSeq>::extract (
        _tao_any,
        Test::IndirectlyRecursiveValuetypeSeq::_tao_any_destructor,
        Test::_tc_IndirectlyRecursiveValuetypeSeq,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Test::IndirectlyRecursiveValuetype>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      IndirectlyRecursiveValuetype *_tao_elem
    )
  {
    #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
      IndirectlyRecursiveValuetype *_tao_copy =
        _tao_elem ?
          IndirectlyRecursiveValuetype::_downcast (_tao_elem->_copy_value ())
          : 0;
      _tao_any <<= &_tao_copy;
    #else
      ::CORBA::add_ref (_tao_elem);
      _tao_any <<= &_tao_elem;
    #endif
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      IndirectlyRecursiveValuetype **_tao_elem
    )
  {
    TAO::Any_Impl_T<IndirectlyRecursiveValuetype>::insert (
        _tao_any,
        IndirectlyRecursiveValuetype::_tao_any_destructor,
        _tc_IndirectlyRecursiveValuetype,
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      IndirectlyRecursiveValuetype *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<IndirectlyRecursiveValuetype>::extract (
          _tao_any,
          IndirectlyRecursiveValuetype::_tao_any_destructor,
          _tc_IndirectlyRecursiveValuetype,
          _tao_elem
        );
  }


}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::IndirectlyRecursiveValuetype *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Test::IndirectlyRecursiveValuetype *_tao_copy =
      _tao_elem ?
        Test::IndirectlyRecursiveValuetype::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::IndirectlyRecursiveValuetype **_tao_elem
  )
{
  TAO::Any_Impl_T<Test::IndirectlyRecursiveValuetype>::insert (
      _tao_any,
      Test::IndirectlyRecursiveValuetype::_tao_any_destructor,
      Test::_tc_IndirectlyRecursiveValuetype,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::IndirectlyRecursiveValuetype *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Test::IndirectlyRecursiveValuetype>::extract (
        _tao_any,
        Test::IndirectlyRecursiveValuetype::_tao_any_destructor,
        Test::_tc_IndirectlyRecursiveValuetype,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Test::DirectlyRecursiveValuetype>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DirectlyRecursiveValuetype *_tao_elem
    )
  {
    #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
      DirectlyRecursiveValuetype *_tao_copy =
        _tao_elem ?
          DirectlyRecursiveValuetype::_downcast (_tao_elem->_copy_value ())
          : 0;
      _tao_any <<= &_tao_copy;
    #else
      ::CORBA::add_ref (_tao_elem);
      _tao_any <<= &_tao_elem;
    #endif
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      DirectlyRecursiveValuetype **_tao_elem
    )
  {
    TAO::Any_Impl_T<DirectlyRecursiveValuetype>::insert (
        _tao_any,
        DirectlyRecursiveValuetype::_tao_any_destructor,
        _tc_DirectlyRecursiveValuetype,
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      DirectlyRecursiveValuetype *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<DirectlyRecursiveValuetype>::extract (
          _tao_any,
          DirectlyRecursiveValuetype::_tao_any_destructor,
          _tc_DirectlyRecursiveValuetype,
          _tao_elem
        );
  }


}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::DirectlyRecursiveValuetype *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Test::DirectlyRecursiveValuetype *_tao_copy =
      _tao_elem ?
        Test::DirectlyRecursiveValuetype::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::DirectlyRecursiveValuetype **_tao_elem
  )
{
  TAO::Any_Impl_T<Test::DirectlyRecursiveValuetype>::insert (
      _tao_any,
      Test::DirectlyRecursiveValuetype::_tao_any_destructor,
      Test::_tc_DirectlyRecursiveValuetype,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::DirectlyRecursiveValuetype *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Test::DirectlyRecursiveValuetype>::extract (
        _tao_any,
        Test::DirectlyRecursiveValuetype::_tao_any_destructor,
        Test::_tc_DirectlyRecursiveValuetype,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Test::PositionEnum _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Test::PositionEnum>::insert (
        _tao_any,
        ::Test::_tc_PositionEnum,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Test::PositionEnum &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Test::PositionEnum>::extract (
          _tao_any,
          ::Test::_tc_PositionEnum,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::PositionEnum _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Test::PositionEnum>::insert (
      _tao_any,
      Test::_tc_PositionEnum,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::PositionEnum &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Test::PositionEnum>::extract (
        _tao_any,
        Test::_tc_PositionEnum,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::Position &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::Position>::insert_copy (
        _tao_any,
        ::Test::Position::_tao_any_destructor,
        ::Test::_tc_Position,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    Test::Position *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::Position>::insert (
      _tao_any,
      ::Test::Position::_tao_any_destructor,
      ::Test::_tc_Position,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::Position *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::Position *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::Position *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::Position>::extract (
        _tao_any,
        ::Test::Position::_tao_any_destructor,
        ::Test::_tc_Position,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Test::Position &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Position>::insert_copy (
    _tao_any,
    Test::Position::_tao_any_destructor,
    Test::_tc_Position,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Test::Position *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Position>::insert (
    _tao_any,
    Test::Position::_tao_any_destructor,
    Test::_tc_Position,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  Test::Position *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::Position *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Test::Position *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::Position>::extract (
      _tao_any,
      Test::Position::_tao_any_destructor,
      Test::_tc_Position,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Test::ValueSort _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Test::ValueSort>::insert (
        _tao_any,
        ::Test::_tc_ValueSort,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Test::ValueSort &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Test::ValueSort>::extract (
          _tao_any,
          ::Test::_tc_ValueSort,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::ValueSort _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Test::ValueSort>::insert (
      _tao_any,
      Test::_tc_ValueSort,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::ValueSort &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Test::ValueSort>::extract (
        _tao_any,
        Test::_tc_ValueSort,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::NonRecursiveUnionWithEnum &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::NonRecursiveUnionWithEnum>::insert_copy (
        _tao_any,
        ::Test::NonRecursiveUnionWithEnum::_tao_any_destructor,
        ::Test::_tc_NonRecursiveUnionWithEnum,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::NonRecursiveUnionWithEnum *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::NonRecursiveUnionWithEnum>::insert (
      _tao_any,
      ::Test::NonRecursiveUnionWithEnum::_tao_any_destructor,
      ::Test::_tc_NonRecursiveUnionWithEnum,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::NonRecursiveUnionWithEnum *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::NonRecursiveUnionWithEnum *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::NonRecursiveUnionWithEnum *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::NonRecursiveUnionWithEnum>::extract (
        _tao_any,
        ::Test::NonRecursiveUnionWithEnum::_tao_any_destructor,
        ::Test::_tc_NonRecursiveUnionWithEnum,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::NonRecursiveUnionWithEnum &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::NonRecursiveUnionWithEnum>::insert_copy (
      _tao_any,
      Test::NonRecursiveUnionWithEnum::_tao_any_destructor,
      Test::_tc_NonRecursiveUnionWithEnum,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::NonRecursiveUnionWithEnum *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::NonRecursiveUnionWithEnum>::insert (
      _tao_any,
      Test::NonRecursiveUnionWithEnum::_tao_any_destructor,
      Test::_tc_NonRecursiveUnionWithEnum,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::NonRecursiveUnionWithEnum *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::NonRecursiveUnionWithEnum *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::NonRecursiveUnionWithEnum *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::NonRecursiveUnionWithEnum>::extract (
        _tao_any,
        Test::NonRecursiveUnionWithEnum::_tao_any_destructor,
        Test::_tc_NonRecursiveUnionWithEnum,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_enum/any_op_cs.cpp:35

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  void operator<<= (
      ::CORBA::Any &_tao_any,
      ::Test::ValueSort2 _tao_elem
    )
  {
    TAO::Any_Basic_Impl_T< ::Test::ValueSort2>::insert (
        _tao_any,
        ::Test::_tc_ValueSort2,
        _tao_elem
      );
  }

  ::CORBA::Boolean operator>>= (
      const ::CORBA::Any &_tao_any,
      ::Test::ValueSort2 &_tao_elem
    )
  {
    return
      TAO::Any_Basic_Impl_T< ::Test::ValueSort2>::extract (
          _tao_any,
          ::Test::_tc_ValueSort2,
          _tao_elem
        );
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::ValueSort2 _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Test::ValueSort2>::insert (
      _tao_any,
      Test::_tc_ValueSort2,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::ValueSort2 &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Test::ValueSort2>::extract (
        _tao_any,
        Test::_tc_ValueSort2,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_structure/any_op_cs.cpp:43



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  /// Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::Symbol2 &_tao_elem)
  {
    TAO::Any_Dual_Impl_T< ::Test::Symbol2>::insert_copy (
        _tao_any,
        ::Test::Symbol2::_tao_any_destructor,
        ::Test::_tc_Symbol2,
        _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any, ::
    Test::Symbol2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::Symbol2>::insert (
      _tao_any,
      ::Test::Symbol2::_tao_any_destructor,
      ::Test::_tc_Symbol2,
      _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::Symbol2 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::Symbol2 *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::Symbol2 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::Symbol2>::extract (
        _tao_any,
        ::Test::Symbol2::_tao_any_destructor,
        ::Test::_tc_Symbol2,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

/// Copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  const Test::Symbol2 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Symbol2>::insert_copy (
    _tao_any,
    Test::Symbol2::_tao_any_destructor,
    Test::_tc_Symbol2,
    _tao_elem);
}

/// Non-copying insertion.
void operator<<= (
  ::CORBA::Any &_tao_any,
  Test::Symbol2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Symbol2>::insert (
    _tao_any,
    Test::Symbol2::_tao_any_destructor,
    Test::_tc_Symbol2,
    _tao_elem);
}

/// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  Test::Symbol2 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::Symbol2 *&> (
      _tao_elem);
}

/// Extraction to const pointer.
::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  const Test::Symbol2 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::Symbol2>::extract (
      _tao_any,
      Test::Symbol2::_tao_any_destructor,
      Test::_tc_Symbol2,
      _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_union/any_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::NonRecursiveUnionWithStringStruct &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::NonRecursiveUnionWithStringStruct>::insert_copy (
        _tao_any,
        ::Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor,
        ::Test::_tc_NonRecursiveUnionWithStringStruct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::NonRecursiveUnionWithStringStruct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T< ::Test::NonRecursiveUnionWithStringStruct>::insert (
      _tao_any,
      ::Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor,
      ::Test::_tc_NonRecursiveUnionWithStringStruct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::NonRecursiveUnionWithStringStruct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const ::Test::NonRecursiveUnionWithStringStruct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::NonRecursiveUnionWithStringStruct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T< ::Test::NonRecursiveUnionWithStringStruct>::extract (
        _tao_any,
        ::Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor,
        ::Test::_tc_NonRecursiveUnionWithStringStruct,
        _tao_elem
      );
}
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::NonRecursiveUnionWithStringStruct &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::NonRecursiveUnionWithStringStruct>::insert_copy (
      _tao_any,
      Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor,
      Test::_tc_NonRecursiveUnionWithStringStruct,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::NonRecursiveUnionWithStringStruct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test::NonRecursiveUnionWithStringStruct>::insert (
      _tao_any,
      Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor,
      Test::_tc_NonRecursiveUnionWithStringStruct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::NonRecursiveUnionWithStringStruct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test::NonRecursiveUnionWithStringStruct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::NonRecursiveUnionWithStringStruct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test::NonRecursiveUnionWithStringStruct>::extract (
        _tao_any,
        Test::NonRecursiveUnionWithStringStruct::_tao_any_destructor,
        Test::_tc_NonRecursiveUnionWithStringStruct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:38
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Test::Hello>::to_object (
      ::CORBA::Object_ptr &_tao_elem) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{


  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Hello_ptr _tao_elem)
  {
    Hello_ptr _tao_objptr =
      Hello::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }

  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Hello_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Hello>::insert (
        _tao_any,
        Hello::_tao_any_destructor,
        _tc_Hello,
        *_tao_elem);
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Hello_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Hello>::extract (
          _tao_any,
          Hello::_tao_any_destructor,
          _tc_Hello,
          _tao_elem);
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Hello_ptr _tao_elem)
{
  Test::Hello_ptr _tao_objptr =
    Test::Hello::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Hello_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Test::Hello>::insert (
      _tao_any,
      Test::Hello::_tao_any_destructor,
      Test::_tc_Hello,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::Hello_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Test::Hello>::extract (
        _tao_any,
        Test::Hello::_tao_any_destructor,
        Test::_tc_Hello,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::Recursive2Seq2 &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::Recursive2Seq2>::insert_copy (
        _tao_any,
        ::Test::Recursive2Seq2::_tao_any_destructor,
        ::Test::_tc_Recursive2Seq2,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::Recursive2Seq2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::Recursive2Seq2>::insert (
      _tao_any,
      ::Test::Recursive2Seq2::_tao_any_destructor,
      ::Test::_tc_Recursive2Seq2,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::Recursive2Seq2 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::Recursive2Seq2 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::Recursive2Seq2 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::Recursive2Seq2>::extract (
        _tao_any,
        ::Test::Recursive2Seq2::_tao_any_destructor,
        ::Test::_tc_Recursive2Seq2,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::Recursive2Seq2 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Recursive2Seq2>::insert_copy (
      _tao_any,
      Test::Recursive2Seq2::_tao_any_destructor,
      Test::_tc_Recursive2Seq2,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Recursive2Seq2 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::Recursive2Seq2>::insert (
      _tao_any,
      Test::Recursive2Seq2::_tao_any_destructor,
      Test::_tc_Recursive2Seq2,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::Recursive2Seq2 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::Recursive2Seq2 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::Recursive2Seq2 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::Recursive2Seq2>::extract (
        _tao_any,
        Test::Recursive2Seq2::_tao_any_destructor,
        Test::_tc_Recursive2Seq2,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Test::Recursive2>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Recursive2 *_tao_elem
    )
  {
    #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
      Recursive2 *_tao_copy =
        _tao_elem ?
          Recursive2::_downcast (_tao_elem->_copy_value ())
          : 0;
      _tao_any <<= &_tao_copy;
    #else
      ::CORBA::add_ref (_tao_elem);
      _tao_any <<= &_tao_elem;
    #endif
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Recursive2 **_tao_elem
    )
  {
    TAO::Any_Impl_T<Recursive2>::insert (
        _tao_any,
        Recursive2::_tao_any_destructor,
        _tc_Recursive2,
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Recursive2 *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<Recursive2>::extract (
          _tao_any,
          Recursive2::_tao_any_destructor,
          _tc_Recursive2,
          _tao_elem
        );
  }


}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Recursive2 *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Test::Recursive2 *_tao_copy =
      _tao_elem ?
        Test::Recursive2::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Recursive2 **_tao_elem
  )
{
  TAO::Any_Impl_T<Test::Recursive2>::insert (
      _tao_any,
      Test::Recursive2::_tao_any_destructor,
      Test::_tc_Recursive2,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::Recursive2 *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Test::Recursive2>::extract (
        _tao_any,
        Test::Recursive2::_tao_any_destructor,
        Test::_tc_Recursive2,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_sequence/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{

  // Copying insertion.
  void operator<<= (
      ::CORBA::Any &_tao_any,
      const ::Test::RecursiveSeq3 &_tao_elem
    )
  {
    TAO::Any_Dual_Impl_T< ::Test::RecursiveSeq3>::insert_copy (
        _tao_any,
        ::Test::RecursiveSeq3::_tao_any_destructor,
        ::Test::_tc_RecursiveSeq3,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    ::Test::RecursiveSeq3 *_tao_elem)
{
  TAO::Any_Dual_Impl_T< ::Test::RecursiveSeq3>::insert (
      _tao_any,
      ::Test::RecursiveSeq3::_tao_any_destructor,
      ::Test::_tc_RecursiveSeq3,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    ::Test::RecursiveSeq3 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const ::Test::RecursiveSeq3 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const ::Test::RecursiveSeq3 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T< ::Test::RecursiveSeq3>::extract (
        _tao_any,
        ::Test::RecursiveSeq3::_tao_any_destructor,
        ::Test::_tc_RecursiveSeq3,
        _tao_elem
      );
}
}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test::RecursiveSeq3 &_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveSeq3>::insert_copy (
      _tao_any,
      Test::RecursiveSeq3::_tao_any_destructor,
      Test::_tc_RecursiveSeq3,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test::RecursiveSeq3 *_tao_elem)
{
  TAO::Any_Dual_Impl_T<Test::RecursiveSeq3>::insert (
      _tao_any,
      Test::RecursiveSeq3::_tao_any_destructor,
      Test::_tc_RecursiveSeq3,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::RecursiveSeq3 *&_tao_elem)
{
  return _tao_any >>= const_cast<
      const Test::RecursiveSeq3 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test::RecursiveSeq3 *&_tao_elem)
{
  return
    TAO::Any_Dual_Impl_T<Test::RecursiveSeq3>::extract (
        _tao_any,
        Test::RecursiveSeq3::_tao_any_destructor,
        Test::_tc_RecursiveSeq3,
        _tao_elem);
}
TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_valuetype/any_op_cs.cpp:45
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Test::Recursive3>::to_value (
      ::CORBA::ValueBase *&_tao_elem
    ) const
  {
    ::CORBA::add_ref (this->value_);
    _tao_elem = this->value_;
    return true;
  }
}


TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace Test
{
  // Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Recursive3 *_tao_elem
    )
  {
    #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
      Recursive3 *_tao_copy =
        _tao_elem ?
          Recursive3::_downcast (_tao_elem->_copy_value ())
          : 0;
      _tao_any <<= &_tao_copy;
    #else
      ::CORBA::add_ref (_tao_elem);
      _tao_any <<= &_tao_elem;
    #endif
  }

  // Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Recursive3 **_tao_elem
    )
  {
    TAO::Any_Impl_T<Recursive3>::insert (
        _tao_any,
        Recursive3::_tao_any_destructor,
        _tc_Recursive3,
        *_tao_elem
      );
  }

  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Recursive3 *&_tao_elem
    )
  {
    return
      TAO::Any_Impl_T<Recursive3>::extract (
          _tao_any,
          Recursive3::_tao_any_destructor,
          _tc_Recursive3,
          _tao_elem
        );
  }


}

#else


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Recursive3 *_tao_elem
  )
{
  #ifdef TAO_VALUETYPE_COPYING_ANY_INSERTION_USES_COPY_VALUE
    Test::Recursive3 *_tao_copy =
      _tao_elem ?
        Test::Recursive3::_downcast (_tao_elem->_copy_value ())
        : 0;
    _tao_any <<= &_tao_copy;
  #else
    ::CORBA::add_ref (_tao_elem);
    _tao_any <<= &_tao_elem;
  #endif
}

// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Test::Recursive3 **_tao_elem
  )
{
  TAO::Any_Impl_T<Test::Recursive3>::insert (
      _tao_any,
      Test::Recursive3::_tao_any_destructor,
      Test::_tc_Recursive3,
      *_tao_elem
    );
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Test::Recursive3 *&_tao_elem
  )
{
  return
    TAO::Any_Impl_T<Test::Recursive3>::extract (
        _tao_any,
        Test::Recursive3::_tao_any_destructor,
        Test::_tc_Recursive3,
        _tao_elem
      );
}


TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Recursive_Type_In_Any_Test_Failed &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Test::Recursive_Type_In_Any_Test_Failed&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:48
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Demarshaling_From_Any_Failed &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Test::Demarshaling_From_Any_Failed&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_RecursiveStructSeq_CPP_
#define _TAO_CDR_OP_Test_RecursiveStructSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveStructSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveStructSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_RecursiveStructSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveStruct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.recursive_structs) &&
    (strm << _tao_aggregate.i) &&
    (strm << _tao_aggregate.recursive_structs_second);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveStruct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.recursive_structs) &&
    (strm >> _tao_aggregate.i) &&
    (strm >> _tao_aggregate.recursive_structs_second);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_NestedRecursiveStructSeq_CPP_
#define _TAO_CDR_OP_Test_NestedRecursiveStructSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::NestedRecursiveStructSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::NestedRecursiveStructSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_NestedRecursiveStructSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::NestedRecursiveStruct::InnerStruct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.recursive_structs);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::NestedRecursiveStruct::InnerStruct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.recursive_structs);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::NestedRecursiveStruct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.ins) &&
    (strm << _tao_aggregate.i);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::NestedRecursiveStruct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.ins) &&
    (strm >> _tao_aggregate.i);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_RecursiveUnionSeq_CPP_
#define _TAO_CDR_OP_Test_RecursiveUnionSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnionSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnionSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_RecursiveUnionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnion &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.recursive_unions ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.a ();
      }
      break;
    case 2:
      {
        result = strm << _tao_union.recursive_unions_second ();
      }
      break;
    default:
      {
        result = strm << _tao_union.i ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnion &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        Test::RecursiveUnionSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.recursive_unions (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.a (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2:
      {
        Test::RecursiveUnionSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.recursive_unions_second (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.i (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_RecursiveUnionSeq2_CPP_
#define _TAO_CDR_OP_Test_RecursiveUnionSeq2_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnionSeq2 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnionSeq2 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_RecursiveUnionSeq2_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnion2::Innerstruct3a &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.recursive_unions);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnion2::Innerstruct3a &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.recursive_unions);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnion2::Innerstruct3b &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.recursive_unions_second);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnion2::Innerstruct3b &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.recursive_unions_second);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnion2 &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.insb ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.a ();
      }
      break;
    case 2:
      {
        result = strm << _tao_union.insa ();
      }
      break;
    default:
      {
        result = strm << _tao_union.i ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnion2 &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        Test::RecursiveUnion2::Innerstruct3a _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.insb (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.a (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2:
      {
        Test::RecursiveUnion2::Innerstruct3b _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.insa (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.i (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_RecursiveStructSeq3_CPP_
#define _TAO_CDR_OP_Test_RecursiveStructSeq3_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveStructSeq3 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveStructSeq3 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_RecursiveStructSeq3_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnion3 &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.a ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.b ();
      }
      break;
    case 2:
      {
        result = strm << _tao_union.c ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnion3 &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.a (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        Test::RecursiveStructSeq3 _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.b (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2:
      {
        Test::RecursiveStructSeq3 _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.c (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveStruct3 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.uni);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveStruct3 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.uni);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_RecursiveUnionSeqNoDefault_CPP_
#define _TAO_CDR_OP_Test_RecursiveUnionSeqNoDefault_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnionSeqNoDefault &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnionSeqNoDefault &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_RecursiveUnionSeqNoDefault_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveUnionNoDefault &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.recursive_unions ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.a ();
      }
      break;
    case 2:
      {
        result = strm << _tao_union.recursive_unions_second ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveUnionNoDefault &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        Test::RecursiveUnionSeqNoDefault _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.recursive_unions (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.a (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2:
      {
        Test::RecursiveUnionSeqNoDefault _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.recursive_unions_second (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Test::VSort _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Test::VSort & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;

  if (_tao_success)
    {
      _tao_enumerator = static_cast<Test::VSort> (_tao_temp);
    }

  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_VSortRecursiveUnionSeq_CPP_
#define _TAO_CDR_OP_Test_VSortRecursiveUnionSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::VSortRecursiveUnionSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::VSortRecursiveUnionSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_VSortRecursiveUnionSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::VSortRecursiveUnion &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case Test::RECURSIVE_TYPE:
      {
        result = strm << _tao_union.recursive_unions ();
      }
      break;
    case Test::LONG_STYPE:
      {
        result = strm << _tao_union.i ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::VSortRecursiveUnion &_tao_union
  )
{
  Test::VSort _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case Test::RECURSIVE_TYPE:
      {
        Test::VSortRecursiveUnionSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.recursive_unions (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Test::LONG_STYPE:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.i (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::EnumUnion &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case Test::BOOL_STYPE:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.a ());
      }
      break;
    case Test::LONG_STYPE:
      {
        result = strm << _tao_union.i ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::EnumUnion &_tao_union
  )
{
  Test::VSort _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case Test::BOOL_STYPE:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.a (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Test::LONG_STYPE:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.i (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_IndirectlyRecursiveValuetypeSeq_CPP_
#define _TAO_CDR_OP_Test_IndirectlyRecursiveValuetypeSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::IndirectlyRecursiveValuetypeSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::IndirectlyRecursiveValuetypeSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_IndirectlyRecursiveValuetypeSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Test::IndirectlyRecursiveValuetype * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Test::IndirectlyRecursiveValuetype * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Test::IndirectlyRecursiveValuetype *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Test::IndirectlyRecursiveValuetype::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Test::IndirectlyRecursiveValuetype *&_tao_valuetype
  )
{
  return Test::IndirectlyRecursiveValuetype::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Test::IndirectlyRecursiveValuetype::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo&ci) const
{
  if (! ci.start_chunk (strm))
    return false;

  CORBA::Boolean const ret =
      (strm << _pd_recursive_valuetypes);
  if ( ! ret)
    return false;

  if (! ci.end_chunk (strm))
    return false;

  return true;
}

::CORBA::Boolean
OBV_Test::IndirectlyRecursiveValuetype::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo&ci)
{
  if (!ci.handle_chunking (strm))
    return false;

  CORBA::Boolean const ret =
      (strm >> _pd_recursive_valuetypes);
  if (!ret)
    return false;

  if (this->require_truncation_)
    return ci.skip_chunks (strm);

  else
    return ci.handle_chunking (strm);


}

void
OBV_Test::IndirectlyRecursiveValuetype::truncation_hook (void)
{
  this->require_truncation_ = true;
}



// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Test::DirectlyRecursiveValuetype * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Test::DirectlyRecursiveValuetype * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Test::DirectlyRecursiveValuetype *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Test::DirectlyRecursiveValuetype::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Test::DirectlyRecursiveValuetype *&_tao_valuetype
  )
{
  return Test::DirectlyRecursiveValuetype::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Test::DirectlyRecursiveValuetype::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo&ci) const
{
  if (! ci.start_chunk (strm))
    return false;

  CORBA::Boolean const ret =
      (strm << _pd_recursive_valuetype.in ()) &&
      (strm << _pd_recursive_valuetype_second.in ());
  if ( ! ret)
    return false;

  if (! ci.end_chunk (strm))
    return false;

  return true;
}

::CORBA::Boolean
OBV_Test::DirectlyRecursiveValuetype::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo&ci)
{
  if (!ci.handle_chunking (strm))
    return false;

  CORBA::Boolean const ret =
      (strm >> _pd_recursive_valuetype.out ()) &&
      (strm >> _pd_recursive_valuetype_second.out ());
  if (!ret)
    return false;

  if (this->require_truncation_)
    return ci.skip_chunks (strm);

  else
    return ci.handle_chunking (strm);


}

void
OBV_Test::DirectlyRecursiveValuetype::truncation_hook (void)
{
  this->require_truncation_ = true;
}



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Test::PositionEnum _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Test::PositionEnum & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;

  if (_tao_success)
    {
      _tao_enumerator = static_cast<Test::PositionEnum> (_tao_temp);
    }

  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Position &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.type);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::Position &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.type);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Test::ValueSort _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Test::ValueSort & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;

  if (_tao_success)
    {
      _tao_enumerator = static_cast<Test::ValueSort> (_tao_temp);
    }

  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::NonRecursiveUnionWithEnum &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case Test::POSITION_TYPE:
      {
        result = strm << _tao_union.position_val ();
      }
      break;
    case Test::OCTET_SEQ_TYPE:
      {
        result = strm << _tao_union.octet_seq_val ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::NonRecursiveUnionWithEnum &_tao_union
  )
{
  Test::ValueSort _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case Test::POSITION_TYPE:
      {
        Test::Position _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.position_val (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Test::OCTET_SEQ_TYPE:
      {
        Test::OctetSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.octet_seq_val (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Test::ValueSort2 _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Test::ValueSort2 & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;

  if (_tao_success)
    {
      _tao_enumerator = static_cast<Test::ValueSort2> (_tao_temp);
    }

  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Symbol2 &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.name.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::Symbol2 &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.name.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:74


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::NonRecursiveUnionWithStringStruct &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case Test::SYMBOL_TYPE2:
      {
        result = strm << _tao_union.symbol_val ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::NonRecursiveUnionWithStringStruct &_tao_union
  )
{
  Test::ValueSort2 _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }

  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case Test::SYMBOL_TYPE2:
      {
        Test::Symbol2 _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.symbol_val (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatibility, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:51

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Hello_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::Hello_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }

  typedef ::Test::Hello RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());

  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_Recursive2Seq2_CPP_
#define _TAO_CDR_OP_Test_Recursive2Seq2_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Recursive2Seq2 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::Recursive2Seq2 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_Recursive2Seq2_CPP_ */

// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Test::Recursive2 * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Test::Recursive2 * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Recursive2::Innerstruct3a &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.recursive_unions);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::Recursive2::Innerstruct3a &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.recursive_unions);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:49

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::Recursive2::Innerstruct3b &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.recursive_second);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::Recursive2::Innerstruct3b &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.recursive_second);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Test::Recursive2 *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Test::Recursive2::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Test::Recursive2 *&_tao_valuetype
  )
{
  return Test::Recursive2::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Test::Recursive2::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo&ci) const
{
  if (! ci.start_chunk (strm))
    return false;

  CORBA::Boolean const ret =
      (strm << _pd_insa) &&
      (strm << _pd_a) &&
      (strm << _pd_insb);
  if ( ! ret)
    return false;

  if (! ci.end_chunk (strm))
    return false;

  return true;
}

::CORBA::Boolean
OBV_Test::Recursive2::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo&ci)
{
  if (!ci.handle_chunking (strm))
    return false;

  CORBA::Boolean const ret =
      (strm >> _pd_insa) &&
      (strm >> _pd_a) &&
      (strm >> _pd_insb);
  if (!ret)
    return false;

  if (this->require_truncation_)
    return ci.skip_chunks (strm);

  else
    return ci.handle_chunking (strm);


}

void
OBV_Test::Recursive2::truncation_hook (void)
{
  this->require_truncation_ = true;
}



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:93
#if !defined _TAO_CDR_OP_Test_RecursiveSeq3_CPP_
#define _TAO_CDR_OP_Test_RecursiveSeq3_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test::RecursiveSeq3 &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test::RecursiveSeq3 &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Test_RecursiveSeq3_CPP_ */

// TAO_IDL - Generated from
// be/be_valuetype.cpp:512

void
CORBA::add_ref (Test::Recursive3 * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Test::Recursive3 * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// be/be_visitor_valuetype/cdr_op_cs.cpp:60


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Test::Recursive3 *_tao_valuetype
  )
{
  return
    ::CORBA::ValueBase::_tao_marshal (
        strm,
        _tao_valuetype,
        reinterpret_cast<ptrdiff_t> (&Test::Recursive3::_downcast)
      );
}

::CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Test::Recursive3 *&_tao_valuetype
  )
{
  return Test::Recursive3::_tao_unmarshal (strm, _tao_valuetype);
}


TAO_END_VERSIONED_NAMESPACE_DECL

// TAO_IDL - Generated from
// be/be_visitor_valuetype/marshal_cs.cpp:33

::CORBA::Boolean
OBV_Test::Recursive3::_tao_marshal_state (TAO_OutputCDR &strm, TAO_ChunkInfo&ci) const
{
  if (! ci.start_chunk (strm))
    return false;

  CORBA::Boolean const ret =
      (strm << _pd_seq1) &&
      (strm << _pd_a) &&
      (strm << _pd_seq2);
  if ( ! ret)
    return false;

  if (! ci.end_chunk (strm))
    return false;

  return true;
}

::CORBA::Boolean
OBV_Test::Recursive3::_tao_unmarshal_state (TAO_InputCDR &strm, TAO_ChunkInfo&ci)
{
  if (!ci.handle_chunking (strm))
    return false;

  CORBA::Boolean const ret =
      (strm >> _pd_seq1) &&
      (strm >> _pd_a) &&
      (strm >> _pd_seq2);
  if (!ret)
    return false;

  if (this->require_truncation_)
    return ci.skip_chunks (strm);

  else
    return ci.handle_chunking (strm);


}

void
OBV_Test::Recursive3::truncation_hook (void)
{
  this->require_truncation_ = true;
}



