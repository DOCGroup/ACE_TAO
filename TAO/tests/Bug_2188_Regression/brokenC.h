// -*- C++ -*-
/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.4.1
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.dre.vanderbilt.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:149

#ifndef _TAO_IDL_BROKENC_UDL9ZL_H_
#define _TAO_IDL_BROKENC_UDL9ZL_H_

#include /**/ "ace/pre.h"


#include /**/ "ace/config-all.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include "tao/ORB.h"
#include "tao/SystemException.h"
#include "tao/Basic_Types.h"
#include "tao/ORB_Constants.h"
#include "tao/Object.h"
#include "tao/String_Manager_T.h"
#include "tao/Objref_VarOut_T.h"
#include "tao/VarOut_T.h"
#include "tao/Array_VarOut_T.h"
#include "tao/Arg_Traits_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/Any_Insert_Policy_T.h"
#include "tao/Basic_Argument_T.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/BD_String_Argument_T.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Fixed_Array_Argument_T.h"
#include "tao/Var_Array_Argument_T.h"
#include /**/ "tao/Version.h"
#include /**/ "tao/Versioned_Namespace.h"

#if TAO_MAJOR_VERSION != 2 || TAO_MINOR_VERSION != 4 || TAO_MICRO_VERSION != 1
#error This file should be regenerated with TAO_IDL
#endif

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO

// TAO_IDL - Generated from
// be/be_visitor_root/root_ch.cpp:157
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<typename T> class Narrow_Utils;
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/enum_ch.cpp:44

enum enum1
{
  One,
  Two,
  Three
};

typedef enum1 &enum1_out;

// TAO_IDL - Generated from
// be/be_visitor_typedef/typedef_ch.cpp:290

typedef enum1 MyEnum;
typedef enum1_out MyEnum_out;

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Char tmp1CharArray[10];
typedef ::CORBA::Char tmp1CharArray_slice;
struct tmp1CharArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      tmp1CharArray,
      tmp1CharArray_slice,
      tmp1CharArray_tag
    >
  tmp1CharArray_var;

typedef
  tmp1CharArray
  tmp1CharArray_out;

typedef
  TAO_Array_Forany_T<
      tmp1CharArray,
      tmp1CharArray_slice,
      tmp1CharArray_tag
    >
  tmp1CharArray_forany;

TAO_EXPORT_MACRO tmp1CharArray_slice *
tmp1CharArray_alloc (void);

TAO_EXPORT_MACRO void
tmp1CharArray_free (
    tmp1CharArray_slice *_tao_slice);

TAO_EXPORT_MACRO tmp1CharArray_slice *
tmp1CharArray_dup (
    const tmp1CharArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
tmp1CharArray_copy (
    tmp1CharArray_slice *_tao_to,
    const tmp1CharArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_typedef/typedef_ch.cpp:179

typedef tmp1CharArray tmp2CharArray;
typedef tmp1CharArray_slice tmp2CharArray_slice;
typedef tmp1CharArray_var tmp2CharArray_var;
typedef tmp1CharArray_out tmp2CharArray_out;
typedef tmp1CharArray_tag tmp2CharArray_tag;
typedef tmp1CharArray_forany tmp2CharArray_forany;

ACE_INLINE
tmp2CharArray_slice *
tmp2CharArray_alloc (void);

ACE_INLINE
tmp2CharArray_slice *
tmp2CharArray_dup (
    const tmp2CharArray_slice *_tao_slice);

ACE_INLINE
void tmp2CharArray_copy (
    tmp2CharArray_slice *_tao_to,
    const tmp2CharArray_slice *_tao_from);

ACE_INLINE
void tmp2CharArray_free (
    tmp2CharArray_slice *_tao_slice);

// TAO_IDL - Generated from
// be/be_visitor_typedef/typedef_ch.cpp:179

typedef tmp2CharArray CharArray;
typedef tmp2CharArray_slice CharArray_slice;
typedef tmp2CharArray_var CharArray_var;
typedef tmp2CharArray_out CharArray_out;
typedef tmp2CharArray_tag CharArray_tag;
typedef tmp2CharArray_forany CharArray_forany;

ACE_INLINE
CharArray_slice *
CharArray_alloc (void);

ACE_INLINE
CharArray_slice *
CharArray_dup (
    const CharArray_slice *_tao_slice);

ACE_INLINE
void CharArray_copy (
    CharArray_slice *_tao_to,
    const CharArray_slice *_tao_from);

ACE_INLINE
void CharArray_free (
    CharArray_slice *_tao_slice);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Octet OctetArray[10];
typedef ::CORBA::Octet OctetArray_slice;
struct OctetArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      OctetArray,
      OctetArray_slice,
      OctetArray_tag
    >
  OctetArray_var;

typedef
  OctetArray
  OctetArray_out;

typedef
  TAO_Array_Forany_T<
      OctetArray,
      OctetArray_slice,
      OctetArray_tag
    >
  OctetArray_forany;

TAO_EXPORT_MACRO OctetArray_slice *
OctetArray_alloc (void);

TAO_EXPORT_MACRO void
OctetArray_free (
    OctetArray_slice *_tao_slice);

TAO_EXPORT_MACRO OctetArray_slice *
OctetArray_dup (
    const OctetArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
OctetArray_copy (
    OctetArray_slice *_tao_to,
    const OctetArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Short ShortArray[10];
typedef ::CORBA::Short ShortArray_slice;
struct ShortArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      ShortArray,
      ShortArray_slice,
      ShortArray_tag
    >
  ShortArray_var;

typedef
  ShortArray
  ShortArray_out;

typedef
  TAO_Array_Forany_T<
      ShortArray,
      ShortArray_slice,
      ShortArray_tag
    >
  ShortArray_forany;

TAO_EXPORT_MACRO ShortArray_slice *
ShortArray_alloc (void);

TAO_EXPORT_MACRO void
ShortArray_free (
    ShortArray_slice *_tao_slice);

TAO_EXPORT_MACRO ShortArray_slice *
ShortArray_dup (
    const ShortArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
ShortArray_copy (
    ShortArray_slice *_tao_to,
    const ShortArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Long LongArray[10];
typedef ::CORBA::Long LongArray_slice;
struct LongArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      LongArray,
      LongArray_slice,
      LongArray_tag
    >
  LongArray_var;

typedef
  LongArray
  LongArray_out;

typedef
  TAO_Array_Forany_T<
      LongArray,
      LongArray_slice,
      LongArray_tag
    >
  LongArray_forany;

TAO_EXPORT_MACRO LongArray_slice *
LongArray_alloc (void);

TAO_EXPORT_MACRO void
LongArray_free (
    LongArray_slice *_tao_slice);

TAO_EXPORT_MACRO LongArray_slice *
LongArray_dup (
    const LongArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
LongArray_copy (
    LongArray_slice *_tao_to,
    const LongArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::LongLong LongLongArray[10];
typedef ::CORBA::LongLong LongLongArray_slice;
struct LongLongArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      LongLongArray,
      LongLongArray_slice,
      LongLongArray_tag
    >
  LongLongArray_var;

typedef
  LongLongArray
  LongLongArray_out;

typedef
  TAO_Array_Forany_T<
      LongLongArray,
      LongLongArray_slice,
      LongLongArray_tag
    >
  LongLongArray_forany;

TAO_EXPORT_MACRO LongLongArray_slice *
LongLongArray_alloc (void);

TAO_EXPORT_MACRO void
LongLongArray_free (
    LongLongArray_slice *_tao_slice);

TAO_EXPORT_MACRO LongLongArray_slice *
LongLongArray_dup (
    const LongLongArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
LongLongArray_copy (
    LongLongArray_slice *_tao_to,
    const LongLongArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::UShort UShortArray[10];
typedef ::CORBA::UShort UShortArray_slice;
struct UShortArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      UShortArray,
      UShortArray_slice,
      UShortArray_tag
    >
  UShortArray_var;

typedef
  UShortArray
  UShortArray_out;

typedef
  TAO_Array_Forany_T<
      UShortArray,
      UShortArray_slice,
      UShortArray_tag
    >
  UShortArray_forany;

TAO_EXPORT_MACRO UShortArray_slice *
UShortArray_alloc (void);

TAO_EXPORT_MACRO void
UShortArray_free (
    UShortArray_slice *_tao_slice);

TAO_EXPORT_MACRO UShortArray_slice *
UShortArray_dup (
    const UShortArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
UShortArray_copy (
    UShortArray_slice *_tao_to,
    const UShortArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::ULong ULongArray[10];
typedef ::CORBA::ULong ULongArray_slice;
struct ULongArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      ULongArray,
      ULongArray_slice,
      ULongArray_tag
    >
  ULongArray_var;

typedef
  ULongArray
  ULongArray_out;

typedef
  TAO_Array_Forany_T<
      ULongArray,
      ULongArray_slice,
      ULongArray_tag
    >
  ULongArray_forany;

TAO_EXPORT_MACRO ULongArray_slice *
ULongArray_alloc (void);

TAO_EXPORT_MACRO void
ULongArray_free (
    ULongArray_slice *_tao_slice);

TAO_EXPORT_MACRO ULongArray_slice *
ULongArray_dup (
    const ULongArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
ULongArray_copy (
    ULongArray_slice *_tao_to,
    const ULongArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::ULongLong ULongLongArray[10];
typedef ::CORBA::ULongLong ULongLongArray_slice;
struct ULongLongArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      ULongLongArray,
      ULongLongArray_slice,
      ULongLongArray_tag
    >
  ULongLongArray_var;

typedef
  ULongLongArray
  ULongLongArray_out;

typedef
  TAO_Array_Forany_T<
      ULongLongArray,
      ULongLongArray_slice,
      ULongLongArray_tag
    >
  ULongLongArray_forany;

TAO_EXPORT_MACRO ULongLongArray_slice *
ULongLongArray_alloc (void);

TAO_EXPORT_MACRO void
ULongLongArray_free (
    ULongLongArray_slice *_tao_slice);

TAO_EXPORT_MACRO ULongLongArray_slice *
ULongLongArray_dup (
    const ULongLongArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
ULongLongArray_copy (
    ULongLongArray_slice *_tao_to,
    const ULongLongArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Float FloatArray[10];
typedef ::CORBA::Float FloatArray_slice;
struct FloatArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      FloatArray,
      FloatArray_slice,
      FloatArray_tag
    >
  FloatArray_var;

typedef
  FloatArray
  FloatArray_out;

typedef
  TAO_Array_Forany_T<
      FloatArray,
      FloatArray_slice,
      FloatArray_tag
    >
  FloatArray_forany;

TAO_EXPORT_MACRO FloatArray_slice *
FloatArray_alloc (void);

TAO_EXPORT_MACRO void
FloatArray_free (
    FloatArray_slice *_tao_slice);

TAO_EXPORT_MACRO FloatArray_slice *
FloatArray_dup (
    const FloatArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
FloatArray_copy (
    FloatArray_slice *_tao_to,
    const FloatArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Double DoubleArray[10];
typedef ::CORBA::Double DoubleArray_slice;
struct DoubleArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      DoubleArray,
      DoubleArray_slice,
      DoubleArray_tag
    >
  DoubleArray_var;

typedef
  DoubleArray
  DoubleArray_out;

typedef
  TAO_Array_Forany_T<
      DoubleArray,
      DoubleArray_slice,
      DoubleArray_tag
    >
  DoubleArray_forany;

TAO_EXPORT_MACRO DoubleArray_slice *
DoubleArray_alloc (void);

TAO_EXPORT_MACRO void
DoubleArray_free (
    DoubleArray_slice *_tao_slice);

TAO_EXPORT_MACRO DoubleArray_slice *
DoubleArray_dup (
    const DoubleArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
DoubleArray_copy (
    DoubleArray_slice *_tao_to,
    const DoubleArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::TAO::String_Manager StringArray[10];
typedef ::TAO::String_Manager StringArray_slice;
struct StringArray_tag {};


typedef
  TAO_VarArray_Var_T<
      StringArray,
      StringArray_slice,
      StringArray_tag
    >
  StringArray_var;

typedef
  TAO_Array_Out_T<
      StringArray,
      StringArray_var,
      StringArray_slice,
      StringArray_tag
    >
  StringArray_out;

typedef
  TAO_Array_Forany_T<
      StringArray,
      StringArray_slice,
      StringArray_tag
    >
  StringArray_forany;

TAO_EXPORT_MACRO StringArray_slice *
StringArray_alloc (void);

TAO_EXPORT_MACRO void
StringArray_free (
    StringArray_slice *_tao_slice);

TAO_EXPORT_MACRO StringArray_slice *
StringArray_dup (
    const StringArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
StringArray_copy (
    StringArray_slice *_tao_to,
    const StringArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Boolean BooleanArray[10];
typedef ::CORBA::Boolean BooleanArray_slice;
struct BooleanArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      BooleanArray,
      BooleanArray_slice,
      BooleanArray_tag
    >
  BooleanArray_var;

typedef
  BooleanArray
  BooleanArray_out;

typedef
  TAO_Array_Forany_T<
      BooleanArray,
      BooleanArray_slice,
      BooleanArray_tag
    >
  BooleanArray_forany;

TAO_EXPORT_MACRO BooleanArray_slice *
BooleanArray_alloc (void);

TAO_EXPORT_MACRO void
BooleanArray_free (
    BooleanArray_slice *_tao_slice);

TAO_EXPORT_MACRO BooleanArray_slice *
BooleanArray_dup (
    const BooleanArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
BooleanArray_copy (
    BooleanArray_slice *_tao_to,
    const BooleanArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef MyEnum MyEnumArray[10];
typedef MyEnum MyEnumArray_slice;
struct MyEnumArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      MyEnumArray,
      MyEnumArray_slice,
      MyEnumArray_tag
    >
  MyEnumArray_var;

typedef
  MyEnumArray
  MyEnumArray_out;

typedef
  TAO_Array_Forany_T<
      MyEnumArray,
      MyEnumArray_slice,
      MyEnumArray_tag
    >
  MyEnumArray_forany;

TAO_EXPORT_MACRO MyEnumArray_slice *
MyEnumArray_alloc (void);

TAO_EXPORT_MACRO void
MyEnumArray_free (
    MyEnumArray_slice *_tao_slice);

TAO_EXPORT_MACRO MyEnumArray_slice *
MyEnumArray_dup (
    const MyEnumArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
MyEnumArray_copy (
    MyEnumArray_slice *_tao_to,
    const MyEnumArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef ::CORBA::Long LongArrayArray[10][10];
typedef ::CORBA::Long LongArrayArray_slice[10];
struct LongArrayArray_tag {};


typedef
  TAO_FixedArray_Var_T<
      LongArrayArray,
      LongArrayArray_slice,
      LongArrayArray_tag
    >
  LongArrayArray_var;

typedef
  LongArrayArray
  LongArrayArray_out;

typedef
  TAO_Array_Forany_T<
      LongArrayArray,
      LongArrayArray_slice,
      LongArrayArray_tag
    >
  LongArrayArray_forany;

TAO_EXPORT_MACRO LongArrayArray_slice *
LongArrayArray_alloc (void);

TAO_EXPORT_MACRO void
LongArrayArray_free (
    LongArrayArray_slice *_tao_slice);

TAO_EXPORT_MACRO LongArrayArray_slice *
LongArrayArray_dup (
    const LongArrayArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
LongArrayArray_copy (
    LongArrayArray_slice *_tao_to,
    const LongArrayArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:35

namespace moola
{

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:370

  typedef ::CORBA::Float CashAmount;
  typedef ::CORBA::Float_out CashAmount_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:404

  typedef char * MyString;
  typedef ::CORBA::String_var MyString_var;
  typedef ::CORBA::String_out MyString_out;

  // TAO_IDL - Generated from
  // be/be_interface.cpp:748

#if !defined (_MOOLA_ACCOUNT__VAR_OUT_CH_)
#define _MOOLA_ACCOUNT__VAR_OUT_CH_

  class Account;
  typedef Account *Account_ptr;

  typedef
    TAO_Objref_Var_T<
        Account
      >
    Account_var;

  typedef
    TAO_Objref_Out_T<
        Account
      >
    Account_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:40

  class  Account
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<Account>;

    // TAO_IDL - Generated from
    // be/be_type.cpp:304

    typedef Account_ptr _ptr_type;
    typedef Account_var _var_type;
    typedef Account_out _out_type;

    // The static operations.
    static Account_ptr _duplicate (Account_ptr obj);

    static void _tao_release (Account_ptr obj);

    static Account_ptr _narrow (::CORBA::Object_ptr obj);
    static Account_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static Account_ptr _nil (void);

    virtual char * name (
      void);

    virtual void name (
      const char * name);

    virtual ::moola::CashAmount balance (
      void);

    virtual void balance (
      ::moola::CashAmount balance);

    virtual void deposit (
      ::moola::CashAmount amount);

    virtual void withdraw (
      ::moola::CashAmount amount);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:137

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

  protected:
    // Concrete interface only.
    Account (void);

    // Concrete non-local interface only.
    Account (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);

    // Non-local interface only.
    Account (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~Account (void);

  private:
    // Private and unimplemented for concrete interfaces.
    Account (const Account &);

    void operator= (const Account &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:64

} // module moola

// TAO_IDL - Generated from
// be/be_type.cpp:258

struct Bucket;

typedef
  ::TAO_Var_Var_T<
      Bucket
    >
  Bucket_var;

typedef
  ::TAO_Out_T<
      Bucket
    >
  Bucket_out;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_ch.cpp:48

struct  Bucket
{

  // TAO_IDL - Generated from
  // be/be_type.cpp:304


  typedef Bucket_var _var_type;
  typedef Bucket_out _out_type;

  ::CORBA::Long a_long;
  ::TAO::String_Manager a_string;
  FloatArray a_floatArray;
  MyEnum a_enum;
};

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef Bucket BucketArray[10];
typedef Bucket BucketArray_slice;
struct BucketArray_tag {};


typedef
  TAO_VarArray_Var_T<
      BucketArray,
      BucketArray_slice,
      BucketArray_tag
    >
  BucketArray_var;

typedef
  TAO_Array_Out_T<
      BucketArray,
      BucketArray_var,
      BucketArray_slice,
      BucketArray_tag
    >
  BucketArray_out;

typedef
  TAO_Array_Forany_T<
      BucketArray,
      BucketArray_slice,
      BucketArray_tag
    >
  BucketArray_forany;

TAO_EXPORT_MACRO BucketArray_slice *
BucketArray_alloc (void);

TAO_EXPORT_MACRO void
BucketArray_free (
    BucketArray_slice *_tao_slice);

TAO_EXPORT_MACRO BucketArray_slice *
BucketArray_dup (
    const BucketArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
BucketArray_copy (
    BucketArray_slice *_tao_to,
    const BucketArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef Bucket BucketArrayArray[10][10];
typedef Bucket BucketArrayArray_slice[10];
struct BucketArrayArray_tag {};


typedef
  TAO_VarArray_Var_T<
      BucketArrayArray,
      BucketArrayArray_slice,
      BucketArrayArray_tag
    >
  BucketArrayArray_var;

typedef
  TAO_Array_Out_T<
      BucketArrayArray,
      BucketArrayArray_var,
      BucketArrayArray_slice,
      BucketArrayArray_tag
    >
  BucketArrayArray_out;

typedef
  TAO_Array_Forany_T<
      BucketArrayArray,
      BucketArrayArray_slice,
      BucketArrayArray_tag
    >
  BucketArrayArray_forany;

TAO_EXPORT_MACRO BucketArrayArray_slice *
BucketArrayArray_alloc (void);

TAO_EXPORT_MACRO void
BucketArrayArray_free (
    BucketArrayArray_slice *_tao_slice);

TAO_EXPORT_MACRO BucketArrayArray_slice *
BucketArrayArray_dup (
    const BucketArrayArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
BucketArrayArray_copy (
    BucketArrayArray_slice *_tao_to,
    const BucketArrayArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_visitor_array/array_ch.cpp:52

typedef moola::Account_var AccountArray[10];
typedef moola::Account_var AccountArray_slice;
struct AccountArray_tag {};


typedef
  TAO_VarArray_Var_T<
      AccountArray,
      AccountArray_slice,
      AccountArray_tag
    >
  AccountArray_var;

typedef
  TAO_Array_Out_T<
      AccountArray,
      AccountArray_var,
      AccountArray_slice,
      AccountArray_tag
    >
  AccountArray_out;

typedef
  TAO_Array_Forany_T<
      AccountArray,
      AccountArray_slice,
      AccountArray_tag
    >
  AccountArray_forany;

TAO_EXPORT_MACRO AccountArray_slice *
AccountArray_alloc (void);

TAO_EXPORT_MACRO void
AccountArray_free (
    AccountArray_slice *_tao_slice);

TAO_EXPORT_MACRO AccountArray_slice *
AccountArray_dup (
    const AccountArray_slice *_tao_slice);

TAO_EXPORT_MACRO void
AccountArray_copy (
    AccountArray_slice *_tao_to,
    const AccountArray_slice *_tao_from);

// TAO_IDL - Generated from
// be/be_type.cpp:258

struct SimpleStruct;

typedef
  ::TAO_Fixed_Var_T<
      SimpleStruct
    >
  SimpleStruct_var;

typedef
  SimpleStruct &
  SimpleStruct_out;

// TAO_IDL - Generated from
// be/be_visitor_structure/structure_ch.cpp:48

struct  SimpleStruct
{

  // TAO_IDL - Generated from
  // be/be_type.cpp:304


  typedef SimpleStruct_var _var_type;
  typedef SimpleStruct_out _out_type;

  ::CORBA::Short simpleShort;
  ::CORBA::Long simpleLong;
};

// TAO_IDL - Generated from
// be/be_interface.cpp:748

#if !defined (_ARRAYTEST__VAR_OUT_CH_)
#define _ARRAYTEST__VAR_OUT_CH_

class ArrayTest;
typedef ArrayTest *ArrayTest_ptr;

typedef
  TAO_Objref_Var_T<
      ArrayTest
    >
  ArrayTest_var;

typedef
  TAO_Objref_Out_T<
      ArrayTest
    >
  ArrayTest_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:40

class  ArrayTest
  : public virtual ::CORBA::Object
{
public:
  friend class TAO::Narrow_Utils<ArrayTest>;

  // TAO_IDL - Generated from
  // be/be_type.cpp:304

  typedef ArrayTest_ptr _ptr_type;
  typedef ArrayTest_var _var_type;
  typedef ArrayTest_out _out_type;

  // The static operations.
  static ArrayTest_ptr _duplicate (ArrayTest_ptr obj);

  static void _tao_release (ArrayTest_ptr obj);

  static ArrayTest_ptr _narrow (::CORBA::Object_ptr obj);
  static ArrayTest_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static ArrayTest_ptr _nil (void);

  virtual ::LongArray_slice * longArrayOp (
    const ::LongArray p1,
    ::LongArray p2,
    ::LongArray_out p3);

  virtual ::StringArray_slice * stringArrayOp (
    const ::StringArray p1,
    ::StringArray p2,
    ::StringArray_out p3);

  virtual ::ShortArray_slice * shortArrayOp (
    const ::ShortArray p1,
    ::ShortArray p2,
    ::ShortArray_out p3);

  virtual ::UShortArray_slice * ushortArrayOp (
    const ::UShortArray p1,
    ::UShortArray p2,
    ::UShortArray_out p3);

  virtual ::CharArray_slice * charArrayOp (
    const ::CharArray p1,
    ::CharArray p2,
    ::CharArray_out p3);

  virtual ::OctetArray_slice * octetArrayOp (
    const ::OctetArray p1,
    ::OctetArray p2,
    ::OctetArray_out p3);

  virtual ::DoubleArray_slice * doubleArrayOp (
    const ::DoubleArray p1,
    ::DoubleArray p2,
    ::DoubleArray_out p3);

  virtual ::LongArray_slice * a_longArray (
    void);

  virtual void a_longArray (
    const ::LongArray a_longArray);

  virtual ::ULongArray_slice * a_ulongArray (
    void);

  virtual void a_ulongArray (
    const ::ULongArray a_ulongArray);

  virtual ::StringArray_slice * a_stringArray (
    void);

  virtual void a_stringArray (
    const ::StringArray a_stringArray);

  virtual ::ShortArray_slice * a_shortArray (
    void);

  virtual void a_shortArray (
    const ::ShortArray a_shortArray);

  virtual ::UShortArray_slice * a_ushortArray (
    void);

  virtual void a_ushortArray (
    const ::UShortArray a_ushortArray);

  virtual ::CORBA::Char a_char (
    void);

  virtual void a_char (
    ::CORBA::Char a_char);

  virtual ::CharArray_slice * a_charArray (
    void);

  virtual void a_charArray (
    const ::CharArray a_charArray);

  virtual ::OctetArray_slice * a_octetArray (
    void);

  virtual void a_octetArray (
    const ::OctetArray a_octetArray);

  virtual ::DoubleArray_slice * a_doubleArray (
    void);

  virtual void a_doubleArray (
    const ::DoubleArray a_doubleArray);

  virtual ::FloatArray_slice * a_floatArray (
    void);

  virtual void a_floatArray (
    const ::FloatArray a_floatArray);

  virtual ::BucketArray_slice * a_bucketArray (
    void);

  virtual void a_bucketArray (
    const ::BucketArray a_bucketArray);

  virtual ::AccountArray_slice * a_accountArray (
    void);

  virtual void a_accountArray (
    const ::AccountArray a_accountArray);

  virtual ::BooleanArray_slice * a_booleanArray (
    void);

  virtual void a_booleanArray (
    const ::BooleanArray a_booleanArray);

  virtual ::LongArrayArray_slice * a_longArrayArray (
    void);

  virtual void a_longArrayArray (
    const ::LongArrayArray a_longArrayArray);

  virtual ::MyEnumArray_slice * a_myEnumArray (
    void);

  virtual void a_myEnumArray (
    const ::MyEnumArray a_myEnumArray);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:137

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Concrete interface only.
  ArrayTest (void);

  // Concrete non-local interface only.
  ArrayTest (
      ::IOP::IOR *ior,
      TAO_ORB_Core *orb_core);

  // Non-local interface only.
  ArrayTest (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);

  virtual ~ArrayTest (void);

private:
  // Private and unimplemented for concrete interfaces.
  ArrayTest (const ArrayTest &);

  void operator= (const ArrayTest &);
};

// TAO_IDL - Generated from
// be/be_interface.cpp:748

#if !defined (_SERVERADMIN__VAR_OUT_CH_)
#define _SERVERADMIN__VAR_OUT_CH_

class ServerAdmin;
typedef ServerAdmin *ServerAdmin_ptr;

typedef
  TAO_Objref_Var_T<
      ServerAdmin
    >
  ServerAdmin_var;

typedef
  TAO_Objref_Out_T<
      ServerAdmin
    >
  ServerAdmin_out;

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ch.cpp:40

class  ServerAdmin
  : public virtual ::CORBA::Object
{
public:
  friend class TAO::Narrow_Utils<ServerAdmin>;

  // TAO_IDL - Generated from
  // be/be_type.cpp:304

  typedef ServerAdmin_ptr _ptr_type;
  typedef ServerAdmin_var _var_type;
  typedef ServerAdmin_out _out_type;

  // The static operations.
  static ServerAdmin_ptr _duplicate (ServerAdmin_ptr obj);

  static void _tao_release (ServerAdmin_ptr obj);

  static ServerAdmin_ptr _narrow (::CORBA::Object_ptr obj);
  static ServerAdmin_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
  static ServerAdmin_ptr _nil (void);

  virtual ::ArrayTest_ptr target (
    void);

  virtual void shutdown (
    void);

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:137

  virtual ::CORBA::Boolean _is_a (const char *type_id);
  virtual const char* _interface_repository_id (void) const;
  virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);

protected:
  // Concrete interface only.
  ServerAdmin (void);

  // Concrete non-local interface only.
  ServerAdmin (
      ::IOP::IOR *ior,
      TAO_ORB_Core *orb_core);

  // Non-local interface only.
  ServerAdmin (
      TAO_Stub *objref,
      ::CORBA::Boolean _tao_collocated = false,
      TAO_Abstract_ServantBase *servant = 0,
      TAO_ORB_Core *orb_core = 0);

  virtual ~ServerAdmin (void);

private:
  // Private and unimplemented for concrete interfaces.
  ServerAdmin (const ServerAdmin &);

  void operator= (const ServerAdmin &);
};

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:66

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:902

  template<>
  class Arg_Traits< ::enum1>
    : public
        Basic_Arg_Traits_T<
            ::enum1,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::tmp1CharArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::tmp1CharArray_var,
            ::tmp1CharArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::OctetArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::OctetArray_var,
            ::OctetArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::ShortArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::ShortArray_var,
            ::ShortArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::LongArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::LongArray_var,
            ::LongArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::LongLongArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::LongLongArray_var,
            ::LongLongArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::UShortArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::UShortArray_var,
            ::UShortArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::ULongArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::ULongArray_var,
            ::ULongArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::ULongLongArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::ULongLongArray_var,
            ::ULongLongArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::FloatArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::FloatArray_var,
            ::FloatArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::DoubleArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::DoubleArray_var,
            ::DoubleArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::StringArray_tag>
    : public
        Var_Array_Arg_Traits_T<
            ::StringArray_out,
            ::StringArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::BooleanArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::BooleanArray_var,
            ::BooleanArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::MyEnumArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::MyEnumArray_var,
            ::MyEnumArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::LongArrayArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::LongArrayArray_var,
            ::LongArrayArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#if !defined (_MYSTRING100__ARG_TRAITS_)
#define _MYSTRING100__ARG_TRAITS_

  struct MyString_100 {};

  template<>
  class Arg_Traits<MyString_100>
    : public
        BD_String_Arg_Traits_T<
            CORBA::String_var,
            100,
            TAO::Any_Insert_Policy_Noop
        >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:145

#if !defined (_MOOLA_ACCOUNT__ARG_TRAITS_)
#define _MOOLA_ACCOUNT__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::moola::Account>
    : public
        Object_Arg_Traits_T<
            ::moola::Account_ptr,
            ::moola::Account_var,
            ::moola::Account_out,
            TAO::Objref_Traits<moola::Account>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:945

  template<>
  class Arg_Traits< ::Bucket>
    : public
        Var_Size_Arg_Traits_T<
            ::Bucket,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::BucketArray_tag>
    : public
        Var_Array_Arg_Traits_T<
            ::BucketArray_out,
            ::BucketArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::BucketArrayArray_tag>
    : public
        Var_Array_Arg_Traits_T<
            ::BucketArrayArray_out,
            ::BucketArrayArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::AccountArray_tag>
    : public
        Var_Array_Arg_Traits_T<
            ::AccountArray_out,
            ::AccountArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:945

  template<>
  class Arg_Traits< ::SimpleStruct>
    : public
        Fixed_Size_Arg_Traits_T<
            ::SimpleStruct,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:145

#if !defined (_ARRAYTEST__ARG_TRAITS_)
#define _ARRAYTEST__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::ArrayTest>
    : public
        Object_Arg_Traits_T<
            ::ArrayTest_ptr,
            ::ArrayTest_var,
            ::ArrayTest_out,
            TAO::Objref_Traits<ArrayTest>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:145

#if !defined (_SERVERADMIN__ARG_TRAITS_)
#define _SERVERADMIN__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::ServerAdmin>
    : public
        Object_Arg_Traits_T<
            ::ServerAdmin_ptr,
            ::ServerAdmin_var,
            ::ServerAdmin_out,
            TAO::Objref_Traits<ServerAdmin>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_traits.cpp:60

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{
  template<>
  struct  Array_Traits<
      tmp1CharArray_forany
    >
  {
    static void free (
        tmp1CharArray_slice * _tao_slice);
    static tmp1CharArray_slice * dup (
        const tmp1CharArray_slice * _tao_slice);
    static void copy (
        tmp1CharArray_slice * _tao_to,
        const tmp1CharArray_slice * _tao_from);
    static tmp1CharArray_slice * alloc (void);
    static void zero (
        tmp1CharArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      OctetArray_forany
    >
  {
    static void free (
        OctetArray_slice * _tao_slice);
    static OctetArray_slice * dup (
        const OctetArray_slice * _tao_slice);
    static void copy (
        OctetArray_slice * _tao_to,
        const OctetArray_slice * _tao_from);
    static OctetArray_slice * alloc (void);
    static void zero (
        OctetArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      ShortArray_forany
    >
  {
    static void free (
        ShortArray_slice * _tao_slice);
    static ShortArray_slice * dup (
        const ShortArray_slice * _tao_slice);
    static void copy (
        ShortArray_slice * _tao_to,
        const ShortArray_slice * _tao_from);
    static ShortArray_slice * alloc (void);
    static void zero (
        ShortArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      LongArray_forany
    >
  {
    static void free (
        LongArray_slice * _tao_slice);
    static LongArray_slice * dup (
        const LongArray_slice * _tao_slice);
    static void copy (
        LongArray_slice * _tao_to,
        const LongArray_slice * _tao_from);
    static LongArray_slice * alloc (void);
    static void zero (
        LongArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      LongLongArray_forany
    >
  {
    static void free (
        LongLongArray_slice * _tao_slice);
    static LongLongArray_slice * dup (
        const LongLongArray_slice * _tao_slice);
    static void copy (
        LongLongArray_slice * _tao_to,
        const LongLongArray_slice * _tao_from);
    static LongLongArray_slice * alloc (void);
    static void zero (
        LongLongArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      UShortArray_forany
    >
  {
    static void free (
        UShortArray_slice * _tao_slice);
    static UShortArray_slice * dup (
        const UShortArray_slice * _tao_slice);
    static void copy (
        UShortArray_slice * _tao_to,
        const UShortArray_slice * _tao_from);
    static UShortArray_slice * alloc (void);
    static void zero (
        UShortArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      ULongArray_forany
    >
  {
    static void free (
        ULongArray_slice * _tao_slice);
    static ULongArray_slice * dup (
        const ULongArray_slice * _tao_slice);
    static void copy (
        ULongArray_slice * _tao_to,
        const ULongArray_slice * _tao_from);
    static ULongArray_slice * alloc (void);
    static void zero (
        ULongArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      ULongLongArray_forany
    >
  {
    static void free (
        ULongLongArray_slice * _tao_slice);
    static ULongLongArray_slice * dup (
        const ULongLongArray_slice * _tao_slice);
    static void copy (
        ULongLongArray_slice * _tao_to,
        const ULongLongArray_slice * _tao_from);
    static ULongLongArray_slice * alloc (void);
    static void zero (
        ULongLongArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      FloatArray_forany
    >
  {
    static void free (
        FloatArray_slice * _tao_slice);
    static FloatArray_slice * dup (
        const FloatArray_slice * _tao_slice);
    static void copy (
        FloatArray_slice * _tao_to,
        const FloatArray_slice * _tao_from);
    static FloatArray_slice * alloc (void);
    static void zero (
        FloatArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      DoubleArray_forany
    >
  {
    static void free (
        DoubleArray_slice * _tao_slice);
    static DoubleArray_slice * dup (
        const DoubleArray_slice * _tao_slice);
    static void copy (
        DoubleArray_slice * _tao_to,
        const DoubleArray_slice * _tao_from);
    static DoubleArray_slice * alloc (void);
    static void zero (
        DoubleArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      StringArray_forany
    >
  {
    static void free (
        StringArray_slice * _tao_slice);
    static StringArray_slice * dup (
        const StringArray_slice * _tao_slice);
    static void copy (
        StringArray_slice * _tao_to,
        const StringArray_slice * _tao_from);
    static StringArray_slice * alloc (void);
    static void zero (
        StringArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      BooleanArray_forany
    >
  {
    static void free (
        BooleanArray_slice * _tao_slice);
    static BooleanArray_slice * dup (
        const BooleanArray_slice * _tao_slice);
    static void copy (
        BooleanArray_slice * _tao_to,
        const BooleanArray_slice * _tao_from);
    static BooleanArray_slice * alloc (void);
    static void zero (
        BooleanArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      MyEnumArray_forany
    >
  {
    static void free (
        MyEnumArray_slice * _tao_slice);
    static MyEnumArray_slice * dup (
        const MyEnumArray_slice * _tao_slice);
    static void copy (
        MyEnumArray_slice * _tao_to,
        const MyEnumArray_slice * _tao_from);
    static MyEnumArray_slice * alloc (void);
    static void zero (
        MyEnumArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      LongArrayArray_forany
    >
  {
    static void free (
        LongArrayArray_slice * _tao_slice);
    static LongArrayArray_slice * dup (
        const LongArrayArray_slice * _tao_slice);
    static void copy (
        LongArrayArray_slice * _tao_to,
        const LongArrayArray_slice * _tao_from);
    static LongArrayArray_slice * alloc (void);
    static void zero (
        LongArrayArray_slice * _tao_slice);
  };

#if !defined (_MOOLA_ACCOUNT__TRAITS_)
#define _MOOLA_ACCOUNT__TRAITS_

  template<>
  struct  Objref_Traits< ::moola::Account>
  {
    static ::moola::Account_ptr duplicate (
        ::moola::Account_ptr p);
    static void release (
        ::moola::Account_ptr p);
    static ::moola::Account_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::moola::Account_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
  template<>
  struct  Array_Traits<
      BucketArray_forany
    >
  {
    static void free (
        BucketArray_slice * _tao_slice);
    static BucketArray_slice * dup (
        const BucketArray_slice * _tao_slice);
    static void copy (
        BucketArray_slice * _tao_to,
        const BucketArray_slice * _tao_from);
    static BucketArray_slice * alloc (void);
    static void zero (
        BucketArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      BucketArrayArray_forany
    >
  {
    static void free (
        BucketArrayArray_slice * _tao_slice);
    static BucketArrayArray_slice * dup (
        const BucketArrayArray_slice * _tao_slice);
    static void copy (
        BucketArrayArray_slice * _tao_to,
        const BucketArrayArray_slice * _tao_from);
    static BucketArrayArray_slice * alloc (void);
    static void zero (
        BucketArrayArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      AccountArray_forany
    >
  {
    static void free (
        AccountArray_slice * _tao_slice);
    static AccountArray_slice * dup (
        const AccountArray_slice * _tao_slice);
    static void copy (
        AccountArray_slice * _tao_to,
        const AccountArray_slice * _tao_from);
    static AccountArray_slice * alloc (void);
    static void zero (
        AccountArray_slice * _tao_slice);
  };

#if !defined (_ARRAYTEST__TRAITS_)
#define _ARRAYTEST__TRAITS_

  template<>
  struct  Objref_Traits< ::ArrayTest>
  {
    static ::ArrayTest_ptr duplicate (
        ::ArrayTest_ptr p);
    static void release (
        ::ArrayTest_ptr p);
    static ::ArrayTest_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::ArrayTest_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_SERVERADMIN__TRAITS_)
#define _SERVERADMIN__TRAITS_

  template<>
  struct  Objref_Traits< ::ServerAdmin>
  {
    static ::ServerAdmin_ptr duplicate (
        ::ServerAdmin_ptr p);
    static void release (
        ::ServerAdmin_ptr p);
    static ::ServerAdmin_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::ServerAdmin_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_ch.cpp:34


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, enum1 _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, enum1 &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::tmp1CharArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::tmp1CharArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::OctetArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::OctetArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::ShortArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::ShortArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::LongArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::LongArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::LongLongArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::LongLongArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::UShortArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::UShortArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::ULongArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::ULongArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::ULongLongArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::ULongLongArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::FloatArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::FloatArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::DoubleArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::DoubleArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::StringArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::StringArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::BooleanArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::BooleanArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::MyEnumArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::MyEnumArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::LongArrayArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::LongArrayArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:41

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const moola::Account_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, moola::Account_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const Bucket &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, Bucket &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::BucketArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::BucketArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::BucketArrayArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::BucketArrayArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:99


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const ::AccountArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ::AccountArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:43


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const SimpleStruct &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, SimpleStruct &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:41

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const ArrayTest_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ArrayTest_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:41

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const ServerAdmin_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, ServerAdmin_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_codegen.cpp:1700
#if defined (__ACE_INLINE__)
#include "brokenC.inl"
#endif /* defined INLINE */

#include /**/ "ace/post.h"

#endif /* ifndef */

