diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Abstract_Timer_Queue.h ACE_wrappers/ace/Abstract_Timer_Queue.h
--- ACE_wrappers_6_2_7/ace/Abstract_Timer_Queue.h	2014-08-01 00:53:54.303511200 +0100
+++ ACE_wrappers/ace/Abstract_Timer_Queue.h	2014-07-29 12:56:10.478650100 +0100
@@ -43,7 +43,7 @@
   /// True if queue is empty, else false.
   virtual bool is_empty (void) const = 0;
 
-  /// Returns the time of the earlier node in the Timer_Queue.  Must
+  /// Returns the earliest due time in the Timer_Queue.  Must
   /// be called on a non-empty queue.
   virtual const ACE_Time_Value &earliest_time (void) const = 0;
 
@@ -62,7 +62,7 @@
    * wrong timer.  Returns -1 on failure (which is guaranteed never to
    * be a valid <timer_id>).
    */
-  virtual long schedule (const TYPE &type,
+  virtual long schedule (TYPE &type,
                          const void *act,
                          const ACE_Time_Value &future_time,
                          const ACE_Time_Value &interval = ACE_Time_Value::zero) = 0;
@@ -140,7 +140,7 @@
    * which typically invokes the <handle_close> hook.  Returns number
    * of timers cancelled.
    */
-  virtual int cancel (const TYPE &type,
+  virtual int cancel (TYPE &type,
                       int dont_call_handle_close = 1) = 0;
 
   /**
@@ -169,12 +169,15 @@
    */
   virtual ACE_Time_Value gettimeofday (void) = 0;
 
-  /**
-   * Allows applications to control how the timer queue gets the time
-   * of day.
-   * @deprecated Use TIME_POLICY support instead. See Timer_Queue_T.h
-   */
-  virtual void gettimeofday (ACE_Time_Value (*gettimeofday)(void)) = 0;
+	/**
+	* Allows applications to control how the timer queue gets the time
+	* of day.
+	* @deprecated Use TIME_POLICY support instead.
+	*             This will only have effect when the TIME_POLICY used
+	*             is ACE_FPointer_Time_Policy. Other standard ACE time
+	*             policies will ignore this.
+	*/
+  virtual void gettimeofday (ACE_Time_Value (*gettimeofday) (void)) = 0;
 
   /// Determine the next event to timeout.  Returns @a max if there are
   /// no pending timers or if all pending timers are longer than max.
@@ -194,12 +197,6 @@
   virtual ACE_Time_Value *calculate_timeout (ACE_Time_Value *max,
                                              ACE_Time_Value *the_timeout) = 0;
 
-  /**
-   * Return the current time, using the right time policy and any
-   * timer skew defined in derived classes.
-   */
-  virtual ACE_Time_Value current_time() = 0;
-
   /// Type of Iterator.
   typedef ACE_Timer_Queue_Iterator_T<TYPE> ITERATOR;
 
@@ -227,4 +224,4 @@
 #endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */
 
 #include /**/ "ace/post.h"
-#endif /* ACE_ABSTRACT_TIMER_QUEUE_H */
+#endif /* ACE_ABSTRACT_TIMER_QUEUE_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Event_Handler_Handle_Timeout_Upcall.cpp ACE_wrappers/ace/Event_Handler_Handle_Timeout_Upcall.cpp
--- ACE_wrappers_6_2_7/ace/Event_Handler_Handle_Timeout_Upcall.cpp	2014-08-01 00:53:55.132661400 +0100
+++ ACE_wrappers/ace/Event_Handler_Handle_Timeout_Upcall.cpp	2014-08-01 11:45:11.427534900 +0100
@@ -11,26 +11,27 @@
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 ACE_Event_Handler_Handle_Timeout_Upcall::
-ACE_Event_Handler_Handle_Timeout_Upcall (void) :
-  requires_reference_counting_ (0)
+ACE_Event_Handler_Handle_Timeout_Upcall (void)
+ : requires_reference_counting_ (0)
 {
+
 }
 
 ACE_Event_Handler_Handle_Timeout_Upcall::
 ~ACE_Event_Handler_Handle_Timeout_Upcall (void)
 {
+
 }
 
 int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-timeout (ACE_Timer_Queue &timer_queue,
-        ACE_Event_Handler *event_handler,
-        const void *act,
-        int recurring_timer,
-        const ACE_Time_Value &cur_time)
+timeout (ACE_Timer_Queue *timer_queue,
+         ACE_Event_Handler *&event_handler,
+         const void *act,
+         int recurring_timer,
+         const ACE_Time_Value &cur_time)
 {
   int requires_reference_counting = 0;
-
   if (!recurring_timer)
     {
       requires_reference_counting =
@@ -39,12 +40,13 @@
     }
 
   // Upcall to the <handler>s handle_timeout method.
-  if (event_handler->handle_timeout (cur_time, act) == -1)
+  int result = event_handler->handle_timeout (cur_time, act);
+  if (result == -1)
     {
       if (event_handler->reactor_timer_interface ())
         event_handler->reactor_timer_interface ()->cancel_timer (event_handler, 0);
       else
-        timer_queue.cancel (event_handler, 0); // 0 means "call handle_close()".
+        result = timer_queue->cancel (event_handler, 0); // 0 means "call handle_close()".
     }
 
   if (!recurring_timer &&
@@ -58,10 +60,10 @@
 
 int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-cancel_type (ACE_Timer_Queue &,
-            ACE_Event_Handler *event_handler,
-            int dont_call,
-            int &requires_reference_counting)
+cancel_type (ACE_Timer_Queue*,
+             ACE_Event_Handler *&event_handler,
+             int dont_call,
+             int &requires_reference_counting)
 {
   requires_reference_counting =
     event_handler->reference_counting_policy ().value () ==
@@ -77,9 +79,9 @@
 
 int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-deletion (ACE_Timer_Queue &timer_queue,
-          ACE_Event_Handler *event_handler,
-          const void *)
+deletion (ACE_Timer_Queue *timer_queue,
+          ACE_Event_Handler *&event_handler,
+          const void*)
 {
   int requires_reference_counting = 0;
 
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Event_Handler_Handle_Timeout_Upcall.h ACE_wrappers/ace/Event_Handler_Handle_Timeout_Upcall.h
--- ACE_wrappers_6_2_7/ace/Event_Handler_Handle_Timeout_Upcall.h	2014-08-01 00:53:55.133123300 +0100
+++ ACE_wrappers/ace/Event_Handler_Handle_Timeout_Upcall.h	2014-08-02 01:05:38.773908500 +0100
@@ -15,7 +15,7 @@
  */
 
 #include "ace/Timer_Queuefwd.h"
-#include "ace/Copy_Disabled.h"
+#include "ace/Timer_Queue_T.h"
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
@@ -30,9 +30,8 @@
  * Queue to call <handle_timeout> on ACE_Event_Handlers.
  */
 class ACE_Export ACE_Event_Handler_Handle_Timeout_Upcall
-  : private ACE_Copy_Disabled
 {
-public:
+ public:
   // = Initialization and termination methods.
   /// Constructor.
   ACE_Event_Handler_Handle_Timeout_Upcall (void);
@@ -41,52 +40,54 @@
   ~ACE_Event_Handler_Handle_Timeout_Upcall (void);
 
   /// This method is called when a timer is registered.
-  int registration (ACE_Timer_Queue &timer_queue,
-                    ACE_Event_Handler *handler,
+  int registration (ACE_Timer_Queue *timer_queue,
+                    ACE_Event_Handler *&handler,
                     const void *arg);
 
   /// This method is called before the timer expires.
-  int preinvoke (ACE_Timer_Queue &timer_queue,
-                 ACE_Event_Handler *handler,
+  int preinvoke (ACE_Timer_Queue *timer_queue,
+                 ACE_Event_Handler *&handler,
                  const void *arg,
                  int recurring_timer,
                  const ACE_Time_Value &cur_time,
                  const void *&upcall_act);
 
   /// This method is called when the timer expires.
-  int timeout (ACE_Timer_Queue &timer_queue,
-               ACE_Event_Handler *handler,
+  int timeout (ACE_Timer_Queue *timer_queue,
+               ACE_Event_Handler *&handler,
                const void *arg,
                int recurring_timer,
                const ACE_Time_Value &cur_time);
 
   /// This method is called after the timer expires.
-  int postinvoke (ACE_Timer_Queue &timer_queue,
-                  ACE_Event_Handler *handler,
+  int postinvoke (ACE_Timer_Queue *timer_queue,
+                  ACE_Event_Handler *&handler,
                   const void *arg,
                   int recurring_timer,
                   const ACE_Time_Value &cur_time,
                   const void *upcall_act);
 
   /// This method is called when a handler is cancelled
-  int cancel_type (ACE_Timer_Queue &timer_queue,
-                   ACE_Event_Handler *handler,
-                   int dont_call,
-                   int &requires_reference_counting);
+  int cancel_type(ACE_Timer_Queue *timer_queue,
+                  ACE_Event_Handler *&handler,
+                  int dont_call,
+                  int &requires_reference_counting);
 
   /// This method is called when a timer is cancelled
-  int cancel_timer (ACE_Timer_Queue &timer_queue,
-                    ACE_Event_Handler *handler,
+  int cancel_timer (ACE_Timer_Queue *timer_queue,
+                    ACE_Event_Handler *&handler,
                     int dont_call,
                     int requires_reference_counting);
 
   /// This method is called when the timer queue is destroyed and
   /// the timer is still contained in it
-  int deletion (ACE_Timer_Queue &timer_queue,
-                ACE_Event_Handler *handler,
+  int deletion (ACE_Timer_Queue *timer_queue,
+                ACE_Event_Handler *&handler,
                 const void *arg);
 
-private:
+ private:
+  ACE_UNIMPLEMENTED_FUNC (ACE_Event_Handler_Handle_Timeout_Upcall (const ACE_Event_Handler_Handle_Timeout_Upcall&));
+  ACE_UNIMPLEMENTED_FUNC (ACE_Event_Handler_Handle_Timeout_Upcall &operator= (const ACE_Event_Handler_Handle_Timeout_Upcall&));
 
   /// Flag indicating that reference counting is required for this
   /// event handler upcall.
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Event_Handler_Handle_Timeout_Upcall.inl ACE_wrappers/ace/Event_Handler_Handle_Timeout_Upcall.inl
--- ACE_wrappers_6_2_7/ace/Event_Handler_Handle_Timeout_Upcall.inl	2014-08-01 00:53:55.133803500 +0100
+++ ACE_wrappers/ace/Event_Handler_Handle_Timeout_Upcall.inl	2014-08-01 11:46:19.992926700 +0100
@@ -6,9 +6,9 @@
 
 ACE_INLINE int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-registration (ACE_Timer_Queue &,
-              ACE_Event_Handler *event_handler,
-              const void *)
+registration (ACE_Timer_Queue*,
+              ACE_Event_Handler *&event_handler,
+              const void*)
 {
   event_handler->add_reference ();
   return 0;
@@ -16,12 +16,12 @@
 
 ACE_INLINE int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-preinvoke (ACE_Timer_Queue &,
-          ACE_Event_Handler *event_handler,
-          const void *,
-          int,
-          const ACE_Time_Value &,
-          const void * & upcall_act)
+preinvoke (ACE_Timer_Queue*,
+           ACE_Event_Handler *&event_handler,
+           const void*,
+           int,
+           const ACE_Time_Value &,
+           const void *&upcall_act)
 {
   bool const requires_reference_counting =
     event_handler->reference_counting_policy ().value () ==
@@ -39,11 +39,11 @@
 
 ACE_INLINE int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-postinvoke (ACE_Timer_Queue & /* timer_queue */,
-            ACE_Event_Handler *event_handler,
-            const void * /* timer_act */,
-            int /* recurring_timer */,
-            const ACE_Time_Value & /* cur_time */,
+postinvoke (ACE_Timer_Queue*,
+            ACE_Event_Handler *&event_handler,
+            const void*,
+            int,
+            const ACE_Time_Value&,
             const void *upcall_act)
 {
   if (upcall_act == &this->requires_reference_counting_)
@@ -56,8 +56,8 @@
 
 ACE_INLINE int
 ACE_Event_Handler_Handle_Timeout_Upcall::
-cancel_timer (ACE_Timer_Queue &,
-              ACE_Event_Handler *event_handler,
+cancel_timer (ACE_Timer_Queue*,
+              ACE_Event_Handler *&event_handler,
               int,
               int requires_reference_counting)
 {
@@ -67,5 +67,4 @@
   return 0;
 }
 
-
 ACE_END_VERSIONED_NAMESPACE_DECL
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Free_List.cpp ACE_wrappers/ace/Free_List.cpp
--- ACE_wrappers_6_2_7/ace/Free_List.cpp	2014-08-01 00:53:54.808365600 +0100
+++ ACE_wrappers/ace/Free_List.cpp	2014-08-01 16:15:21.862705500 +0100
@@ -60,6 +60,8 @@
 {
   ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
 
+  ACE_ASSERT (element != 0);
+
   // Check to see that we not at the high water mark.
   if (this->mode_ == ACE_PURE_FREE_LIST
       || this->size_ < this->hwm_)
@@ -160,4 +162,4 @@
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
-#endif /* ACE_FREE_LIST_CPP */
+#endif /* ACE_FREE_LIST_CPP */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Message_Queue_T.cpp ACE_wrappers/ace/Message_Queue_T.cpp
--- ACE_wrappers_6_2_7/ace/Message_Queue_T.cpp	2014-08-01 00:53:55.234400300 +0100
+++ ACE_wrappers/ace/Message_Queue_T.cpp	2014-07-19 11:13:12.331545000 +0100
@@ -1873,7 +1873,7 @@
 
 template <ACE_SYNCH_DECL, class TIME_POLICY> int
 ACE_Message_Queue<ACE_SYNCH_USE, TIME_POLICY>::enqueue_deadline (ACE_Message_Block *new_item,
-                                                    ACE_Time_Value *timeout)
+                                                                 ACE_Time_Value *timeout)
 {
   ACE_TRACE ("ACE_Message_Queue<ACE_SYNCH_USE, TIME_POLICY>::enqueue_deadline");
   int queue_count = 0;
@@ -1918,7 +1918,7 @@
 
 template <ACE_SYNCH_DECL, class TIME_POLICY> int
 ACE_Message_Queue<ACE_SYNCH_USE, TIME_POLICY>::enqueue_tail (ACE_Message_Block *new_item,
-                                              ACE_Time_Value *timeout)
+                                                             ACE_Time_Value *timeout)
 {
   ACE_TRACE ("ACE_Message_Queue<ACE_SYNCH_USE, TIME_POLICY>::enqueue_tail");
   int queue_count = 0;
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Proactor.cpp ACE_wrappers/ace/Proactor.cpp
--- ACE_wrappers_6_2_7/ace/Proactor.cpp	2014-08-01 00:53:54.740195400 +0100
+++ ACE_wrappers/ace/Proactor.cpp	2014-08-01 11:52:17.953333100 +0100
@@ -75,7 +75,7 @@
   /// recompute its sleep time after changes to the timer queue.
   int signal (void);
 
-protected:
+ protected:
   /// Run by a daemon thread to handle deferred processing. In other
   /// words, this method will do the waiting on the earliest timer and
   /// event.
@@ -92,10 +92,11 @@
 };
 
 ACE_Proactor_Timer_Handler::ACE_Proactor_Timer_Handler (ACE_Proactor &proactor)
-  : ACE_Task <ACE_NULL_SYNCH> (&proactor.thr_mgr_),
-    proactor_ (proactor),
-    shutting_down_ (0)
+ : ACE_Task <ACE_NULL_SYNCH> (&proactor.thr_mgr_),
+   proactor_ (proactor),
+   shutting_down_ (0)
 {
+
 }
 
 ACE_Proactor_Timer_Handler::~ACE_Proactor_Timer_Handler (void)
@@ -114,6 +115,7 @@
 
   // Wait for the Timer Handler thread to exit.
   this->wait ();
+
   return 0;
 }
 
@@ -162,16 +164,16 @@
         {
           switch (errno)
             {
-            case ETIME:
-              // timeout: expire timers
-              this->proactor_.timer_queue ()->expire ();
-              break;
-            default:
-              // Error.
-              ACELIB_ERROR_RETURN ((LM_ERROR,
-                                 ACE_TEXT ("%N:%l:(%P | %t):%p\n"),
-                                 ACE_TEXT ("ACE_Proactor_Timer_Handler::svc:wait failed")),
-                                -1);
+              case ETIME:
+                // timeout: expire timers
+                this->proactor_.timer_queue ()->expire ();
+                break;
+              default:
+                // Error.
+                ACELIB_ERROR_RETURN ((LM_ERROR,
+                                      ACE_TEXT ("%N:%l:(%P | %t):%p\n"),
+                                      ACE_TEXT ("ACE_Proactor_Timer_Handler::svc:wait failed")),
+                                     -1);
             }
         }
     }
@@ -181,53 +183,54 @@
 // *********************************************************************
 
 ACE_Proactor_Handle_Timeout_Upcall::ACE_Proactor_Handle_Timeout_Upcall (void)
-  : proactor_ (0)
+ : proactor_ (0)
 {
+
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::registration (ACE_Proactor_Timer_Queue &,
-                                                  ACE_Handler * handler,
-                                                  const void *)
+ACE_Proactor_Handle_Timeout_Upcall::registration (ACE_Proactor_Timer_Queue*,
+                                                  ACE_Handler *&handler,
+                                                  const void*)
 {
-  handler->proactor(proactor_);
+  handler->proactor (proactor_);
   return 0;
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::preinvoke (ACE_Proactor_Timer_Queue &,
-                                               ACE_Handler *,
-                                               const void *,
+ACE_Proactor_Handle_Timeout_Upcall::preinvoke (ACE_Proactor_Timer_Queue*,
+                                               ACE_Handler*&,
+                                               const void*,
                                                int,
-                                               const ACE_Time_Value &,
-                                               const void *&)
+                                               const ACE_Time_Value&,
+                                               const void*&)
 {
   return 0;
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::postinvoke (ACE_Proactor_Timer_Queue &,
-                                                ACE_Handler *,
-                                                const void *,
+ACE_Proactor_Handle_Timeout_Upcall::postinvoke (ACE_Proactor_Timer_Queue*,
+                                                ACE_Handler*&,
+                                                const void*,
                                                 int,
-                                                const ACE_Time_Value &,
-                                                const void *)
+                                                const ACE_Time_Value&,
+                                                const void*)
 {
   return 0;
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::timeout (ACE_Proactor_Timer_Queue &,
-                                             ACE_Handler *handler,
+ACE_Proactor_Handle_Timeout_Upcall::timeout (ACE_Proactor_Timer_Queue*,
+                                             ACE_Handler *&handler,
                                              const void *act,
                                              int,
                                              const ACE_Time_Value &time)
 {
   if (this->proactor_ == 0)
     ACELIB_ERROR_RETURN ((LM_ERROR,
-                       ACE_TEXT ("(%t) No Proactor set in ACE_Proactor_Handle_Timeout_Upcall,")
-                       ACE_TEXT (" no completion port to post timeout to?!@\n")),
-                      -1);
+                          ACE_TEXT ("(%t) No Proactor set in ACE_Proactor_Handle_Timeout_Upcall,")
+                          ACE_TEXT (" no completion port to post timeout to?!@\n")),
+                         -1);
 
   // Create the Asynch_Timer.
   ACE_Asynch_Result_Impl *asynch_timer =
@@ -240,20 +243,19 @@
 
   if (asynch_timer == 0)
     ACELIB_ERROR_RETURN ((LM_ERROR,
-                       ACE_TEXT ("%N:%l:(%P | %t):%p\n"),
-                       ACE_TEXT ("ACE_Proactor_Handle_Timeout_Upcall::timeout:")
-                       ACE_TEXT ("create_asynch_timer failed")),
-                      -1);
+                          ACE_TEXT ("%N:%l:(%P | %t):%p\n"),
+                          ACE_TEXT ("ACE_Proactor_Handle_Timeout_Upcall::timeout:")
+                          ACE_TEXT ("create_asynch_timer failed")),
+                         -1);
 
   auto_ptr<ACE_Asynch_Result_Impl> safe_asynch_timer (asynch_timer);
 
   // Post a completion.
-  if (-1 == safe_asynch_timer->post_completion
-      (this->proactor_->implementation ()))
+  if (-1 == safe_asynch_timer->post_completion (this->proactor_->implementation ()))
     ACELIB_ERROR_RETURN ((LM_ERROR,
-                       ACE_TEXT ("Failure in dealing with timers: ")
-                       ACE_TEXT ("PostQueuedCompletionStatus failed\n")),
-                      -1);
+                          ACE_TEXT ("Failure in dealing with timers: ")
+                          ACE_TEXT ("PostQueuedCompletionStatus failed\n")),
+                         -1);
 
   // The completion has been posted.  The proactor is now responsible
   // for managing the asynch_timer memory.
@@ -263,18 +265,18 @@
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::cancel_type (ACE_Proactor_Timer_Queue &,
-                                                 ACE_Handler *,
+ACE_Proactor_Handle_Timeout_Upcall::cancel_type (ACE_Proactor_Timer_Queue*,
+                                                 ACE_Handler*&,
                                                  int,
-                                                 int &)
+                                                 int&)
 {
   // Do nothing
   return 0;
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::cancel_timer (ACE_Proactor_Timer_Queue &,
-                                                  ACE_Handler *,
+ACE_Proactor_Handle_Timeout_Upcall::cancel_timer (ACE_Proactor_Timer_Queue*,
+                                                  ACE_Handler*&,
                                                   int,
                                                   int)
 {
@@ -283,9 +285,9 @@
 }
 
 int
-ACE_Proactor_Handle_Timeout_Upcall::deletion (ACE_Proactor_Timer_Queue &,
-                                              ACE_Handler *,
-                                              const void *)
+ACE_Proactor_Handle_Timeout_Upcall::deletion (ACE_Proactor_Timer_Queue*,
+                                              ACE_Handler*&,
+                                              const void*)
 {
   // Do nothing
   return 0;
@@ -301,9 +303,9 @@
     }
   else
     ACELIB_ERROR_RETURN ((LM_ERROR,
-                       ACE_TEXT ("ACE_Proactor_Handle_Timeout_Upcall is only suppose")
-                       ACE_TEXT (" to be used with ONE (and only one) Proactor\n")),
-                      -1);
+                          ACE_TEXT ("ACE_Proactor_Handle_Timeout_Upcall is only suppose")
+                          ACE_TEXT (" to be used with ONE (and only one) Proactor\n")),
+                         -1);
 }
 
 // *********************************************************************
@@ -359,8 +361,8 @@
   // Activate <timer_handler>.
   if (this->timer_handler_->activate () == -1)
     ACELIB_ERROR ((LM_ERROR,
-                ACE_TEXT ("%N:%l:(%P | %t):%p\n"),
-                ACE_TEXT ("Task::activate:could not create thread\n")));
+                   ACE_TEXT ("%N:%l:(%P | %t):%p\n"),
+                   ACE_TEXT ("Task::activate:could not create thread\n")));
 }
 
 ACE_Proactor::~ACE_Proactor (void)
@@ -656,7 +658,7 @@
 }
 
 long
-ACE_Proactor::schedule_timer (ACE_Handler &handler,
+ACE_Proactor::schedule_timer (ACE_Handler *&handler,
                               const void *act,
                               const ACE_Time_Value &time)
 {
@@ -667,7 +669,7 @@
 }
 
 long
-ACE_Proactor::schedule_repeating_timer (ACE_Handler &handler,
+ACE_Proactor::schedule_repeating_timer (ACE_Handler *&handler,
                                         const void *act,
                                         const ACE_Time_Value &interval)
 {
@@ -678,7 +680,7 @@
 }
 
 long
-ACE_Proactor::schedule_timer (ACE_Handler &handler,
+ACE_Proactor::schedule_timer (ACE_Handler *&handler,
                               const void *act,
                               const ACE_Time_Value &time,
                               const ACE_Time_Value &interval)
@@ -686,7 +688,8 @@
   // absolute time.
   ACE_Time_Value absolute_time =
     this->timer_queue_->gettimeofday () + time;
-  long result = this->timer_queue_->schedule (&handler,
+
+  long result = this->timer_queue_->schedule (handler,
                                               act,
                                               absolute_time,
                                               interval);
@@ -713,12 +716,12 @@
 }
 
 int
-ACE_Proactor::cancel_timer (ACE_Handler &handler,
-                                  int dont_call_handle_close)
+ACE_Proactor::cancel_timer (ACE_Handler *&handler,
+                            int dont_call_handle_close)
 {
   // No need to signal timer event here. Even if the cancel timer was
   // the earliest, we will have an extra wakeup.
-  return this->timer_queue_->cancel (&handler,
+  return this->timer_queue_->cancel (handler,
                                      dont_call_handle_close);
 }
 
@@ -792,9 +795,8 @@
     }
 
   // Set the proactor in the timer queue's functor
-  typedef ACE_Timer_Queue_Upcall_Base<ACE_Handler*,ACE_Proactor_Handle_Timeout_Upcall> TQ_Base;
-
-  TQ_Base * tqb = dynamic_cast<TQ_Base*> (this->timer_queue_);
+  typedef ACE_Timer_Queue_Upcall_Base<ACE_Proactor_Handle_Timeout_Upcall> TQ_Base;
+  TQ_Base *tqb = dynamic_cast<TQ_Base*> (this->timer_queue_);
 
   if (tqb != 0)
     {
@@ -979,7 +981,7 @@
    int priority,
    int signal_number)
 {
-  return this->implementation()->create_asynch_read_dgram_result
+  return this->implementation ()->create_asynch_read_dgram_result
     (handler_proxy,
      handle,
      message_block,
@@ -1004,7 +1006,7 @@
    int priority,
    int signal_number)
 {
-  return this->implementation()->create_asynch_write_dgram_result
+  return this->implementation ()->create_asynch_write_dgram_result
     (handler_proxy,
      handle,
      message_block,
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Proactor.h ACE_wrappers/ace/Proactor.h
--- ACE_wrappers_6_2_7/ace/Proactor.h	2014-08-01 00:53:54.742242700 +0100
+++ ACE_wrappers/ace/Proactor.h	2014-08-01 13:11:59.435765000 +0100
@@ -32,10 +32,10 @@
 #  include "ace/Asynch_IO.h"
 #  include "ace/Asynch_IO_Impl.h"
 #  include "ace/Thread_Manager.h"
-#  include "ace/Timer_Queue.h"
-#  include "ace/Timer_List.h"
+#  include "ace/Timer_Queue_T.h"
+//#  include "ace/Timer_List.h"
 #  include "ace/Timer_Heap.h"
-#  include "ace/Timer_Wheel.h"
+//#  include "ace/Timer_Wheel.h"
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
@@ -44,7 +44,7 @@
 class ACE_Proactor_Timer_Handler;
 
 /// Type def for the timer queue.
-typedef ACE_Abstract_Timer_Queue<ACE_Handler *> ACE_Proactor_Timer_Queue;
+typedef ACE_Abstract_Timer_Queue<ACE_Handler*> ACE_Proactor_Timer_Queue;
 
 /**
  * @class ACE_Proactor_Handle_Timeout_Upcall
@@ -55,61 +55,62 @@
  * Queue to call <handle_timeout> on ACE_Handlers.
  */
 class ACE_Export ACE_Proactor_Handle_Timeout_Upcall
+ //: public ACE_Timer_Queue_Functor_Base<ACE_Proactor_Timer_Queue, ACE_Handler*>
 {
   /// The main Proactor class has special permissions.
   friend class ACE_Proactor;
 
-public:
+ public:
   /// Constructor.
   ACE_Proactor_Handle_Timeout_Upcall (void);
 
   /// This method is called when a timer is registered.
-  int registration (ACE_Proactor_Timer_Queue &timer_queue,
-                    ACE_Handler *handler,
+  int registration (ACE_Proactor_Timer_Queue *timer_queue,
+                    ACE_Handler *&handler,
                     const void *arg);
 
   /// This method is called before the timer expires.
-  int preinvoke (ACE_Proactor_Timer_Queue &timer_queue,
-                 ACE_Handler *handler,
+  int preinvoke (ACE_Proactor_Timer_Queue *timer_queue,
+                 ACE_Handler *&handler,
                  const void *arg,
                  int recurring_timer,
                  const ACE_Time_Value &cur_time,
                  const void *&upcall_act);
 
   /// This method is called when the timer expires.
-  int timeout (ACE_Proactor_Timer_Queue &timer_queue,
-               ACE_Handler *handler,
+  int timeout (ACE_Proactor_Timer_Queue *timer_queue,
+               ACE_Handler *&handler,
                const void *arg,
                int recurring_timer,
                const ACE_Time_Value &cur_time);
 
   /// This method is called after the timer expires.
-  int postinvoke (ACE_Proactor_Timer_Queue &timer_queue,
-                  ACE_Handler *handler,
+  int postinvoke (ACE_Proactor_Timer_Queue *timer_queue,
+                  ACE_Handler *&handler,
                   const void *arg,
                   int recurring_timer,
                   const ACE_Time_Value &cur_time,
                   const void *upcall_act);
 
   /// This method is called when a handler is canceled.
-  int cancel_type (ACE_Proactor_Timer_Queue &timer_queue,
-                   ACE_Handler *handler,
+  int cancel_type (ACE_Proactor_Timer_Queue *timer_queue,
+                   ACE_Handler *&handler,
                    int dont_call_handle_close,
                    int &requires_reference_counting);
 
   /// This method is called when a timer is canceled.
-  int cancel_timer (ACE_Proactor_Timer_Queue &timer_queue,
-                    ACE_Handler *handler,
+  int cancel_timer (ACE_Proactor_Timer_Queue *timer_queue,
+                    ACE_Handler *&handler,
                     int dont_call_handle_close,
                     int requires_reference_counting);
 
   /// This method is called when the timer queue is destroyed and the
   /// timer is still contained in it.
-  int deletion (ACE_Proactor_Timer_Queue &timer_queue,
-                ACE_Handler *handler,
+  int deletion (ACE_Proactor_Timer_Queue *timer_queue,
+                ACE_Handler *&handler,
                 const void *arg);
 
-protected:
+ protected:
   /// Set the proactor. This will fail, if one is already set!
   int proactor (ACE_Proactor &proactor);
 
@@ -131,32 +132,22 @@
 {
   // = Here are the private typedefs that the ACE_Proactor uses.
 
-  typedef ACE_Timer_Queue_Iterator_T<ACE_Handler *>
-    TIMER_QUEUE_ITERATOR;
-  typedef ACE_Timer_List_T<ACE_Handler *,
-    ACE_Proactor_Handle_Timeout_Upcall,
-    ACE_SYNCH_RECURSIVE_MUTEX>
-  TIMER_LIST;
-  typedef ACE_Timer_List_Iterator_T<ACE_Handler *,
-    ACE_Proactor_Handle_Timeout_Upcall,
-    ACE_SYNCH_RECURSIVE_MUTEX>
-  TIMER_LIST_ITERATOR;
-  typedef ACE_Timer_Heap_T<ACE_Handler *,
-    ACE_Proactor_Handle_Timeout_Upcall,
-    ACE_SYNCH_RECURSIVE_MUTEX>
-  TIMER_HEAP;
-  typedef ACE_Timer_Heap_Iterator_T<ACE_Handler *,
-    ACE_Proactor_Handle_Timeout_Upcall,
-    ACE_SYNCH_RECURSIVE_MUTEX>
-  TIMER_HEAP_ITERATOR;
-  typedef ACE_Timer_Wheel_T<ACE_Handler *,
-    ACE_Proactor_Handle_Timeout_Upcall,
-    ACE_SYNCH_RECURSIVE_MUTEX>
-  TIMER_WHEEL;
-  typedef ACE_Timer_Wheel_Iterator_T<ACE_Handler *,
-    ACE_Proactor_Handle_Timeout_Upcall,
-    ACE_SYNCH_RECURSIVE_MUTEX>
-  TIMER_WHEEL_ITERATOR;
+ // typedef ACE_Timer_Queue_Iterator_T<ACE_Handler*> TIMER_QUEUE_ITERATOR;
+ // typedef ACE_Timer_List_T<ACE_Handler*,
+  //                         ACE_Proactor_Handle_Timeout_Upcall,
+  //                         ACE_SYNCH_RECURSIVE_MUTEX,
+  //                         ACE_Default_Time_Policy> TIMER_LIST;
+  //typedef TIMER_LIST::LIST_ITERATOR_T TIMER_LIST_ITERATOR;
+  typedef ACE_Timer_Heap_T<ACE_Handler*,
+                           ACE_Proactor_Handle_Timeout_Upcall,
+                           ACE_SYNCH_RECURSIVE_MUTEX,
+                           ACE_Default_Time_Policy> TIMER_HEAP;
+  typedef TIMER_HEAP::HEAP_ITERATOR_T TIMER_HEAP_ITERATOR;
+ // typedef ACE_Timer_Wheel_T<ACE_Handler*,
+  //                          ACE_Proactor_Handle_Timeout_Upcall,
+  //                          ACE_SYNCH_RECURSIVE_MUTEX,
+  //                          ACE_Default_Time_Policy> TIMER_WHEEL;
+  //typedef TIMER_WHEEL::WHEEL_ITERATOR_T TIMER_WHEEL_ITERATOR;
 
   // = Friendship.
 
@@ -164,7 +155,7 @@
   /// the Proactor.
   friend class ACE_Proactor_Timer_Handler;
 
-public:
+ public:
   /**
    * Constructor. If @a implementation is 0, the correct implementation
    * object will be created. @a delete_implementation flag determines
@@ -303,11 +294,11 @@
    * with accidentally deleting the wrong timer.  Returns -1 on
    * failure (which is guaranteed never to be a valid <timer_id>).
    */
-  long schedule_timer (ACE_Handler &handler,
+  long schedule_timer (ACE_Handler *&handler,
                        const void *act,
                        const ACE_Time_Value &time);
 
-  long schedule_repeating_timer (ACE_Handler &handler,
+  long schedule_repeating_timer (ACE_Handler *&handler,
                                  const void *act,
                                  const ACE_Time_Value &interval);
 
@@ -316,14 +307,14 @@
 
   /// This combines the above two methods into one. Mostly for backward
   /// compatibility.
-  long schedule_timer (ACE_Handler &handler,
+  long schedule_timer (ACE_Handler *&handler,
                        const void *act,
                        const ACE_Time_Value &time,
                        const ACE_Time_Value &interval);
 
   /// Cancel all timers associated with this @a handler.  Returns number
   /// of timers cancelled.
-  int cancel_timer (ACE_Handler &handler,
+  int cancel_timer (ACE_Handler *&handler,
                     int dont_call_handle_close = 1);
 
   /**
@@ -562,7 +553,7 @@
                          int priority = 0,
                          int signal_number = ACE_SIGRTMIN);
 
-protected:
+ protected:
 
   /**
    * Post <how_many> completions to the completion port so that all
@@ -616,8 +607,7 @@
   /// Mutex to protect work with lists.
   ACE_SYNCH_MUTEX mutex_;
 
-
-private:
+ private:
   /// Deny access since member-wise won't work...
   ACE_Proactor (const ACE_Proactor &);
   ACE_Proactor &operator= (const ACE_Proactor &);
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Hash.h ACE_wrappers/ace/Timer_Hash.h
--- ACE_wrappers_6_2_7/ace/Timer_Hash.h	2014-08-01 00:53:55.577027000 +0100
+++ ACE_wrappers/ace/Timer_Hash.h	2014-08-01 17:18:30.266973700 +0100
@@ -15,61 +15,57 @@
 #define ACE_TIMER_HASH_H
 #include /**/ "ace/pre.h"
 
-#include "ace/Timer_Hash_T.h"
+#include "ace/Event_Handler.h"
 #include "ace/Event_Handler_Handle_Timeout_Upcall.h"
+#include "ace/Timer_List_T.h"
+#include "ace/Timer_Heap_T.h"
+#include "ace/Timer_Wheel_T.h"
+#include "ace/Timer_Hash_T.h"
+#include "ace/Synch.h"
+#include "ace/Time_Policy.h"
 
 #if !defined (ACE_LACKS_PRAGMA_ONCE)
 # pragma once
 #endif /* ACE_LACKS_PRAGMA_ONCE */
 
-#include "ace/Timer_Heap_T.h"
-#include "ace/Timer_List_T.h"
-
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 // The following typedef are here for ease of use
 
-typedef ACE_Timer_Hash_Upcall <ACE_Event_Handler *,
-                               ACE_Event_Handler_Handle_Timeout_Upcall,
-                               ACE_SYNCH_RECURSIVE_MUTEX>
-        ACE_Hash_Upcall;
-
-typedef ACE_Timer_List_T <ACE_Event_Handler *,
-                          ACE_Hash_Upcall,
-                          ACE_Null_Mutex>
-        ACE_Hash_Timer_List;
-
-typedef ACE_Timer_Heap_T <ACE_Event_Handler *,
-                          ACE_Hash_Upcall,
-                          ACE_Null_Mutex>
-        ACE_Hash_Timer_Heap;
-
-
-typedef ACE_Timer_Hash_T<ACE_Event_Handler *,
-                        ACE_Event_Handler_Handle_Timeout_Upcall,
-                        ACE_SYNCH_RECURSIVE_MUTEX,
-                        ACE_Hash_Timer_List>
-
-        ACE_Timer_Hash;
-
-typedef ACE_Timer_Hash_Iterator_T<ACE_Event_Handler *,
-                                  ACE_Event_Handler_Handle_Timeout_Upcall,
-                                  ACE_SYNCH_RECURSIVE_MUTEX,
-                                  ACE_Hash_Timer_List,
-                                  ACE_Default_Time_Policy>
-        ACE_Timer_Hash_Iterator;
-
-typedef ACE_Timer_Hash_T<ACE_Event_Handler *,
-                        ACE_Event_Handler_Handle_Timeout_Upcall,
-                        ACE_SYNCH_RECURSIVE_MUTEX,
-                        ACE_Hash_Timer_Heap>
-        ACE_Timer_Hash_Heap;
-
-typedef ACE_Timer_Hash_Iterator_T<ACE_Event_Handler *,
-                                  ACE_Event_Handler_Handle_Timeout_Upcall,
-                                  ACE_SYNCH_RECURSIVE_MUTEX,
-                                  ACE_Hash_Timer_Heap>
-        ACE_Timer_Hash_Heap_Iterator;
+typedef ACE_Timer_Hash_Upcall<ACE_Timer_Queue,
+                              ACE_Event_Handler*,
+                              ACE_Event_Handler_Handle_Timeout_Upcall> Timer_Hash_Upcall_t;
+typedef ACE_Timer_List_T <ACE_Event_Handler*,
+                          Timer_Hash_Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          ACE_Default_Time_Policy> ACE_Hash_Timer_List;
+typedef ACE_Timer_Heap_T <ACE_Event_Handler*,
+                          Timer_Hash_Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          ACE_Default_Time_Policy> ACE_Hash_Timer_Heap;
+typedef ACE_Timer_Wheel_T <ACE_Event_Handler*,
+                           Timer_Hash_Upcall_t,
+                           ACE_SYNCH_NULL_MUTEX,
+                           ACE_Default_Time_Policy> ACE_Hash_Timer_Wheel;
+
+typedef ACE_Timer_Hash_T <ACE_Event_Handler*,
+                          ACE_Event_Handler_Handle_Timeout_Upcall,
+                          ACE_SYNCH_RECURSIVE_MUTEX,
+                          ACE_Hash_Timer_List,
+                          ACE_Default_Time_Policy> ACE_Timer_Hash_List;
+typedef ACE_Timer_Hash_List::HASH_ITERATOR_T ACE_Timer_Hash_List_Iterator;
+typedef ACE_Timer_Hash_T <ACE_Event_Handler*,
+                          ACE_Event_Handler_Handle_Timeout_Upcall,
+                          ACE_SYNCH_RECURSIVE_MUTEX,
+                          ACE_Hash_Timer_Heap,
+                          ACE_Default_Time_Policy> ACE_Timer_Hash_Heap;
+typedef ACE_Timer_Hash_Heap::HASH_ITERATOR_T ACE_Timer_Hash_Heap_Iterator;
+typedef ACE_Timer_Hash_T <ACE_Event_Handler*,
+                          ACE_Event_Handler_Handle_Timeout_Upcall,
+                          ACE_SYNCH_RECURSIVE_MUTEX,
+                          ACE_Hash_Timer_Wheel,
+                          ACE_Default_Time_Policy> ACE_Timer_Hash_Wheel;
+typedef ACE_Timer_Hash_Wheel::HASH_ITERATOR_T ACE_Timer_Hash_Wheel_Iterator;
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Hash_T.cpp ACE_wrappers/ace/Timer_Hash_T.cpp
--- ACE_wrappers_6_2_7/ace/Timer_Hash_T.cpp	2014-08-01 00:53:55.194617200 +0100
+++ ACE_wrappers/ace/Timer_Hash_T.cpp	2014-08-01 21:26:51.242556600 +0100
@@ -18,15 +18,13 @@
 template <class TYPE>
 class Hash_Token
 {
-public:
+ public:
   // This constructor is required by ACE_Locked_Free_List::alloc.
-  Hash_Token (void) :
-    act_ (0),
-    pos_ (0),
-    orig_id_ (0),
-    next_ (0)
-  {
-  }
+  Hash_Token (void)
+   : act_ (0)
+   , pos_ (0)
+   , orig_id_ (0)
+   , next_ (0) { }
 
   Hash_Token<TYPE> *get_next (void)
   {
@@ -58,120 +56,156 @@
   Hash_Token<TYPE> *next_;
 };
 
-// Default constructor
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK>
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::ACE_Timer_Hash_Upcall (void)
-  : timer_hash_ (0)
+template <class TQ_TYPE, class TYPE, class FUNCTOR>
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::ACE_Timer_Hash_Upcall ()
+ : timer_hash_ (0)
+ , upcall_functor_ (0)
+ , delete_upcall_functor_ (false)
 {
-  // Nothing
+
 }
 
 // Constructor that specifies a Timer_Hash to call up to
+template <class TQ_TYPE, class TYPE, class FUNCTOR>
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::ACE_Timer_Hash_Upcall (TQ_TYPE *timer_hash,
+                                                                      FUNCTOR* upcall_functor)
+ : timer_hash_ (timer_hash)
+ , upcall_functor_ (upcall_functor)
+ , delete_upcall_functor_ (false)
+{
+
+}
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK>
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::ACE_Timer_Hash_Upcall (
-  ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK> *timer_hash)
-  : timer_hash_ (timer_hash)
+template <class TQ_TYPE, class TYPE, class FUNCTOR> void
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::upcall_functor (FUNCTOR *upcall_functor,
+                                                               const bool& delete_upcall_functor)
 {
-  // Nothing
+  // clean up ?
+  if (delete_upcall_functor_)
+    delete upcall_functor_;
+
+  upcall_functor_ = upcall_functor;
+  delete_upcall_functor_ = (upcall_functor && delete_upcall_functor);
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::registration (
-  TIMER_QUEUE &,
-  ACE_Event_Handler *,
-  const void *)
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::registration (TQ_TYPE*,
+                                                             TYPE& event_handler,
+                                                             const void* upcall_act)
 {
-  // Registration will be handled by the upcall functor of the timer
-  // hash.
-  return 0;
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->registration (this->timer_hash_,
+                                                  event_handler,
+                                                  upcall_act);
+
+  return result;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::preinvoke (TIMER_QUEUE &,
-                                                           ACE_Event_Handler *,
-                                                           const void *,
-                                                           int,
-                                                           const ACE_Time_Value &,
-                                                           const void *&)
-{
-  // This method should never be invoked since we don't invoke
-  // expire() on the buckets.
-  ACE_ASSERT (0);
-  return 0;
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::preinvoke (TQ_TYPE*,
+                                                          TYPE &event_handler,
+                                                          const void *arg,
+                                                          int recurring_timer,
+                                                          const ACE_Time_Value &cur_time,
+                                                          const void *&upcall_act)
+{
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->preinvoke (this->timer_hash_,
+                                               event_handler,
+                                               arg,
+                                               recurring_timer,
+                                               cur_time,
+                                               upcall_act);
+
+  return result;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::postinvoke (
-  TIMER_QUEUE &,
-  ACE_Event_Handler *,
-  const void *,
-  int,
-  const ACE_Time_Value &,
-  const void *)
-{
-  // This method should never be invoked since we don't invoke
-  // expire() on the buckets.
-  ACE_ASSERT (0);
-  return 0;
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::postinvoke (TQ_TYPE*,
+                                                           TYPE &event_handler,
+                                                           const void *arg,
+                                                           int recurring_timer,
+                                                           const ACE_Time_Value& cur_time,
+                                                           const void* upcall_act)
+{
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->postinvoke (this->timer_hash_,
+                                                event_handler,
+                                                arg,
+                                                recurring_timer,
+                                                cur_time,
+                                                upcall_act);
+
+  return result;
 }
 
 // Calls up to timer_hash's upcall functor
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::timeout (
-  TIMER_QUEUE &,
-  ACE_Event_Handler *,
-  const void *,
-  int,
-  const ACE_Time_Value &)
-{
-  // This method should never be invoked since we don't invoke
-  // expire() on the buckets.
-  ACE_ASSERT (0);
-  return 0;
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::timeout (TQ_TYPE*,
+                                                        TYPE &event_handler,
+                                                        const void* arg,
+                                                        int dont_call,
+                                                        const ACE_Time_Value& cur_time)
+{
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->timeout (this->timer_hash_,
+                                             event_handler,
+                                             arg,
+                                             dont_call,
+                                             cur_time);
+
+  return result;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::cancel_type (
-  TIMER_QUEUE &,
-  ACE_Event_Handler *,
-  int,
-  int &)
-{
-  // Cancellation will be handled by the upcall functor of the timer
-  // hash.
-  return 0;
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::cancel_type (TQ_TYPE*,
+                                                            TYPE &event_handler,
+                                                            int dont_call,
+                                                            int& requires_reference_counting)
+{
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->cancel_type (this->timer_hash_,
+                                                 event_handler,
+                                                 dont_call,
+                                                 requires_reference_counting);
+
+  return result;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::cancel_timer (
-  TIMER_QUEUE &,
-  ACE_Event_Handler *,
-  int,
-  int)
-{
-  // Cancellation will be handled by the upcall functor of the timer
-  // hash.
-  return 0;
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::cancel_timer (TQ_TYPE*,
+                                                             TYPE &event_handler,
+                                                             int dont_call,
+                                                             int requires_reference_counting)
+{
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->cancel_timer (this->timer_hash_,
+                                                  event_handler,
+                                                  dont_call,
+                                                  requires_reference_counting);
+
+  return result;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK> int
-ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>::deletion (
-  TIMER_QUEUE &,
-  ACE_Event_Handler *event_handler,
-  const void *arg)
+template <class TQ_TYPE, class TYPE, class FUNCTOR> int
+ACE_Timer_Hash_Upcall<TQ_TYPE, TYPE, FUNCTOR>::deletion (TQ_TYPE*,
+                                                         TYPE &event_handler,
+                                                         const void *arg)
 {
-  // Call up to the upcall functor of the timer hash since the timer
-  // hash does not invoke deletion() on its upcall functor directly.
   Hash_Token<TYPE> *h =
-    reinterpret_cast<Hash_Token<TYPE> *> (const_cast<void *> (arg));
+    reinterpret_cast<Hash_Token<TYPE>*> (const_cast<void*> (arg));
 
-  int result =
-    this->timer_hash_->upcall_functor ().
-    deletion (*this->timer_hash_,
-              event_handler,
-              h->act_);
+  int result = 0;
+  if (upcall_functor_)
+    result = this->upcall_functor_->deletion (this->timer_hash_,
+                                              event_handler,
+                                              h->act_);
 
   return result;
 }
@@ -191,7 +225,6 @@
 }
 
 // Positions the iterator at the first node in the timing hash table
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> void
 ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::first (void)
 {
@@ -214,7 +247,6 @@
 
 // Positions the iterator at the next node in the bucket or goes to the next
 // bucket
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> void
 ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::next (void)
 {
@@ -245,7 +277,6 @@
 }
 
 // Returns true when we are at the end (when bucket_item_ == 0)
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> bool
 ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::isdone (void) const
 {
@@ -253,9 +284,7 @@
 }
 
 // Returns the node at the current position in the sequence
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE> *
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::item (void)
 {
   if (this->isdone ())
@@ -264,8 +293,7 @@
   return this->iter_->item ();
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-ACE_Timer_Queue_Iterator_T<TYPE> &
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> ACE_Timer_Queue_Iterator_T<TYPE> &
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::iter (void)
 {
   this->iterator_->first ();
@@ -273,23 +301,21 @@
 }
 
 // Create an empty queue.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::ACE_Timer_Hash_T (
   size_t table_size,
   FUNCTOR *upcall_functor,
   ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
   TIME_POLICY const & time_policy)
-  : Base_Timer_Queue (upcall_functor, freelist, time_policy),
-    size_ (0),
-    table_size_ (table_size),
-    table_functor_ (this),
-    earliest_position_ (0),
-    iterator_ (0)
+ : inherited (upcall_functor, freelist, time_policy)
+ , size_ (0)
+ , table_size_ (table_size)
+ , table_functor_ (this, upcall_functor)
+ , earliest_position_ (0)
 #if defined (ACE_WIN64)
-  , pointer_base_ (0)
+ , pointer_base_ (0)
 #endif /* ACE_WIN64 */
-  , token_list_ ()
+ , token_list_ ()
 {
   ACE_TRACE ("ACE_Timer_Hash_T::ACE_Timer_Hash_T");
 
@@ -302,29 +328,35 @@
     {
       ACE_NEW (this->table_[i],
                BUCKET (&this->table_functor_,
-                      this->free_list_,
-                      time_policy));
+                       this->free_list_,
+                       time_policy));
+    }
+  if (!upcall_functor)
+    {
+      FUNCTOR* functor = 0;
+      ACE_NEW (functor,
+               FUNCTOR ());
+      this->table_functor_.upcall_functor(functor, true);
     }
 
   ACE_NEW (iterator_,
-           HASH_ITERATOR (*this));
+           HASH_ITERATOR_T (*this));
 }
 
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::ACE_Timer_Hash_T (
   FUNCTOR *upcall_functor,
   ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
   TIME_POLICY const & time_policy)
-  : Base_Timer_Queue (upcall_functor, freelist, time_policy),
-    size_ (0),
-    table_size_ (ACE_DEFAULT_TIMER_HASH_TABLE_SIZE),
-    table_functor_ (this),
-    earliest_position_ (0)
+ : inherited (upcall_functor, freelist, time_policy)
+ , size_ (0)
+ , table_size_ (ACE_DEFAULT_TIMER_HASH_TABLE_SIZE)
+ , table_functor_ (this, upcall_functor)
+ , earliest_position_ (0)
 #if defined (ACE_WIN64)
-  , pointer_base_ (0)
+ , pointer_base_ (0)
 #endif /* ACE_WIN64 */
-  , token_list_ ()
+ , token_list_ ()
 {
   ACE_TRACE ("ACE_Timer_Hash_T::ACE_Timer_Hash_T");
 
@@ -337,21 +369,26 @@
     {
       ACE_NEW (this->table_[i],
                BUCKET (&this->table_functor_,
-                      this->free_list_,
-                      time_policy));
+                       this->free_list_,
+                       time_policy));
+    }
+  if (!upcall_functor)
+    {
+      FUNCTOR* functor = 0;
+      ACE_NEW (functor,
+               FUNCTOR ());
+      this->table_functor_.upcall_functor (functor, true);
     }
 
   ACE_NEW (iterator_,
-           HASH_ITERATOR (*this));
+           HASH_ITERATOR_T (*this));
 }
 
 // Remove all remaining items in the Queue.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::~ACE_Timer_Hash_T (void)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::~ACE_Timer_Hash_T");
-  ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
 
   delete iterator_;
 
@@ -362,7 +399,6 @@
        ++i)
     delete this->table_[i];
 
-
   delete [] this->table_;
 }
 
@@ -370,15 +406,14 @@
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::close (void)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::close");
-  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
   // Remove all remaining items from the queue.
-  while (!this->is_empty())
+  while (! this->is_empty ())
     {
-      ACE_Timer_Node_T<TYPE>* n = this->remove_first();
-      this->upcall_functor ().deletion (*this,
-                                        n->get_type(),
-                                        n->get_act());
+      ACE_Timer_Node_T<TYPE>* n = this->remove_first ();
+      this->upcall_functor ().deletion (this,
+                                        n->get_type (),
+                                        n->get_act ());
       this->free_node (n);
     }
 
@@ -387,22 +422,25 @@
 }
 
 // Checks if queue is empty.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> bool
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::is_empty (void) const
 {
   ACE_TRACE ("ACE_Timer_Hash_T::is_empty");
-  return this->table_[this->earliest_position_]->is_empty ();
+
+  BUCKET* bucket = this->table_[this->earliest_position_];
+  ACE_ASSERT (bucket);
+  return bucket->is_empty ();
 }
 
 // Returns earliest time in a non-empty bucket
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-const ACE_Time_Value &
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> const ACE_Time_Value &
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::earliest_time (void) const
 {
   ACE_TRACE ("ACE_Timer_Hash_T::earliest_time");
-  return this->table_[this->earliest_position_]->earliest_time ();
+
+  BUCKET* bucket = this->table_[this->earliest_position_];
+  ACE_ASSERT (bucket);
+  return bucket->earliest_time ();
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> void
@@ -425,17 +463,15 @@
 
 // Reschedule a periodic timer.  This function must be called with the
 // mutex lock held.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-void
-ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::reschedule (
-  ACE_Timer_Node_T<TYPE> *expired)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> void
+ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::reschedule (ACE_Timer_Node_T<TYPE> *expired)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::reschedule");
 
   Hash_Token<TYPE> *h =
     reinterpret_cast<Hash_Token<TYPE> *> (
       const_cast<void *> (expired->get_act ()));
+  ACE_ASSERT (h);
 
   // Don't use ACE_Utils::truncate_cast<> here.  A straight
   // static_cast<>  will provide more unique results when the number
@@ -455,7 +491,7 @@
   // then here schedule <expired> for deletion. Don't call
   // this->free_node() because that will invalidate <h>
   // and that's what user have as timer_id.
-  Base_Timer_Queue::free_node (expired);
+  inherited::free_node (expired);
 
   if (this->table_[this->earliest_position_]->is_empty ()
       || this->table_[h->pos_]->earliest_time ()
@@ -465,14 +501,12 @@
 
 // Insert a new handler that expires at time future_time; if interval
 // is > 0, the handler will be reinvoked periodically.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-long
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> long
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::schedule_i (
-  const TYPE &type,
-  const void *act,
-  const ACE_Time_Value &future_time,
-  const ACE_Time_Value &interval)
+   TYPE &type
+ , const void *act
+ , const ACE_Time_Value &future_time
+ , const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::schedule_i");
 
@@ -485,6 +519,7 @@
   // Don't create Hash_Token directly. Instead we get one from Free_List
   // and then set it properly.
   Hash_Token<TYPE> *h = this->token_list_.remove ();
+  ACE_ASSERT (h);
   h->set (act, position, 0, type);
 
   h->orig_id_ =
@@ -520,12 +555,10 @@
 }
 
 // Locate and update the inteval on the timer_id
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-int
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> int
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::reset_interval (
-  long timer_id,
-  const ACE_Time_Value & interval)
+   long timer_id
+ , const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::reset_interval");
 
@@ -534,21 +567,17 @@
   if (timer_id == -1)
     return -1;
 
+  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
+
 #if defined (ACE_WIN64)
   unsigned long const timer_offset =
     static_cast<unsigned long> (timer_id);
 
-  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
-
   Hash_Token<TYPE> * const h =
     reinterpret_cast<Hash_Token<TYPE> *> (this->pointer_base_ + timer_offset);
 #else
   Hash_Token<TYPE> * const h =
     reinterpret_cast<Hash_Token<TYPE> *> (timer_id);
-
-  // Grab the lock before accessing the table.  We don't need to do so
-  // before this point since no members are accessed until now.
-  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 #endif /* ACE_WIN64 */
 
   return this->table_[h->pos_]->reset_interval (h->orig_id_,
@@ -557,12 +586,10 @@
 
 // Locate and remove the single <ACE_Event_Handler> with a value of
 // @a timer_id from the correct table timer queue.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-int
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> int
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::cancel (long timer_id,
-                                                           const void **act,
-                                                           int dont_call)
+                                                                        const void **act,
+                                                                        int dont_call)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::cancel");
 
@@ -571,22 +598,21 @@
   if (timer_id == -1)
     return 0;
 
+  // Grab the lock before accessing the table.  We don't need to do so
+  // before this point since no members are accessed until now.
+  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
+
 #if defined (ACE_WIN64)
   unsigned long const timer_offset =
     static_cast<unsigned long> (timer_id);
 
-  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
-
   Hash_Token<TYPE> * const h =
     reinterpret_cast<Hash_Token<TYPE> *> (this->pointer_base_ + timer_offset);
 #else
   Hash_Token<TYPE> * const h =
     reinterpret_cast<Hash_Token<TYPE> *> (timer_id);
-
-  // Grab the lock before accessing the table.  We don't need to do so
-  // before this point since no members are accessed until now.
-  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 #endif /* ACE_WIN64 */
+  ACE_ASSERT (h);
 
   int const result = this->table_[h->pos_]->cancel (h->orig_id_,
                                                     0,
@@ -594,20 +620,22 @@
 
   if (result == 1)
     {
-      // Call the close hooks.
-      int cookie = 0;
+      // *NOTE*: close hooks to be called by the bucket...
+
+      //// Call the close hooks.
+      //int cookie = 0;
 
-      // cancel_type() called once per <type>.
-      this->upcall_functor ().cancel_type (*this,
-                                           h->type_,
-                                           dont_call,
-                                           cookie);
-
-      // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
-                                            h->type_,
-                                            dont_call,
-                                            cookie);
+      //// cancel_type() called once per <type>.
+      //this->upcall_functor ().cancel_type (this,
+      //                                     h->type_,
+      //                                     dont_call,
+      //                                     cookie);
+
+      //// cancel_timer() called once per <timer>.
+      //this->upcall_functor ().cancel_timer (this,
+      //                                      h->type_,
+      //                                      dont_call,
+      //                                      cookie);
 
       if (h->pos_ == this->earliest_position_)
         this->find_new_earliest ();
@@ -627,15 +655,14 @@
 }
 
 // Locate and remove all values of <type> from the timer queue.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
-int
-ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::cancel (const TYPE &type,
-                                                           int dont_call)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> int
+ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::cancel (TYPE &type,
+                                                                        int dont_call)
 {
   ACE_TRACE ("ACE_Timer_Hash_T::cancel");
 
   size_t i; // loop variable.
+  int result = 0;
 
   Hash_Token<TYPE> **timer_ids = 0;
   size_t pos = 0;
@@ -646,33 +673,59 @@
                   Hash_Token<TYPE> *[this->size_],
                   -1);
 
+  int dont_call_handle_close = dont_call;
+  bool has_type = false;
+  int result_temp = 0;
   for (i = 0;
        i < this->table_size_;
        ++i)
-    {
-      ACE_Timer_Queue_Iterator_T<TYPE> & iter =
-        this->table_[i]->iter ();
+  {
+    has_type = false;
 
-      for (iter.first ();
-           !iter.isdone ();
-           iter.next ())
-        if (iter.item ()->get_type () == type)
-          timer_ids[pos++] =
-            reinterpret_cast<Hash_Token<TYPE> *> (
-              const_cast<void *> (iter.item ()->get_act ()));
-    }
+    ACE_Timer_Queue_Iterator_T<TYPE> & iter =
+      this->table_[i]->iter ();
+    for (iter.first ();
+         !iter.isdone ();
+         iter.next ())
+      {
+        ACE_Timer_Node_T<TYPE> * item = iter.item ();
+        ACE_ASSERT (item);
+        if (item->get_type () == type)
+          {
+            has_type = true;
+
+            timer_ids[pos] =
+              reinterpret_cast<Hash_Token<TYPE> *> (
+              const_cast<void *> (item->get_act ()));
+            ACE_ASSERT (timer_ids[pos]);
+
+            pos++;
+          }
+      }
+    if (has_type)
+      {
+        result_temp = this->table_[i]->cancel (type,
+                                               dont_call_handle_close);
+        if (result_temp == -1)
+          result = -1;
+        else
+          result += result_temp;
+        if (dont_call_handle_close == 0)
+          dont_call_handle_close = 1; // call once per type only (iff at all)
+      }
+  }
 
   if (pos > this->size_)
     return -1;
 
   for (i = 0; i < pos; ++i)
     {
-      int const result =
-        this->table_[timer_ids[i]->pos_]->cancel (timer_ids[i]->orig_id_,
-                                                  0,
-                                                  dont_call);
-      ACE_ASSERT (result == 1);
-      ACE_UNUSED_ARG (result);
+      //int const result =
+      //  this->table_[timer_ids[i]->pos_]->cancel (timer_ids[i]->orig_id_,
+      //                                            0,
+      //                                            dont_call);
+      //ACE_ASSERT (result == 1);
+      //ACE_UNUSED_ARG (result);
 
       // We could destruct Hash_Token explicitly but we better
       // schedule it for destruction.
@@ -685,31 +738,37 @@
 
   this->find_new_earliest ();
 
+  // Note: close hooks are to be called by the bucket(s)...
+  // iff there were no timers to cancel, call cancel_type once anyway,
+  // (otherwise it would have been called from the bucket(s), once per bucket
+  // [note that this last bit is inconsistent behaviour, but unavoidable at
+  // this stage])
+
   // Call the close hooks.
   int cookie = 0;
 
   // cancel_type() called once per <type>.
-  this->upcall_functor ().cancel_type (*this,
-                                       type,
-                                       dont_call,
-                                       cookie);
-
-  for (i = 0;
-       i < pos;
-       ++i)
-    {
-      // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
-                                            type,
-                                            dont_call,
-                                            cookie);
-    }
+  if (result <= 0)
+    this->upcall_functor ().cancel_type (this,
+                                         type,
+                                         dont_call,
+                                         cookie);
+
+  //for (i = 0;
+  //     i < pos;
+  //     ++i)
+  //  {
+  //    // cancel_timer() called once per <timer>.
+  //    this->upcall_functor ().cancel_timer (this,
+  //                                          type,
+  //                                          dont_call,
+  //                                          cookie);
+  //  }
 
   return static_cast<int> (pos);
 }
 
 // Removes the earliest node and finds the new earliest position
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::remove_first (void)
 {
@@ -727,12 +786,11 @@
 }
 
 // Finds a new earliest position
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> void
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::find_new_earliest (void)
 {
   for (size_t i = 0; i < this->table_size_; ++i)
-    if (!this->table_[i]->is_empty ())
+    if (! this->table_[i]->is_empty ())
       if (this->table_[this->earliest_position_]->is_empty ()
           || this->earliest_time () == ACE_Time_Value::zero
           || this->table_[i]->earliest_time () <= this->earliest_time ())
@@ -740,7 +798,6 @@
 }
 
 // Returns the earliest node without removing it
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::get_first (void)
 {
@@ -755,24 +812,26 @@
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> void
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::free_node (ACE_Timer_Node_T<TYPE> *node)
 {
-  Base_Timer_Queue::free_node (node);
-
   Hash_Token<TYPE> *h =
     reinterpret_cast<Hash_Token<TYPE> *> (const_cast<void *> (node->get_act ()));
+  ACE_ASSERT (h);
   this->token_list_.add (h);
+
+  inherited::free_node (node);
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> int
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::dispatch_info_i (const ACE_Time_Value &cur_time,
-                                                                    ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
+                                                                                 ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
 {
   int const result =
-    Base_Timer_Queue::dispatch_info_i (cur_time, info);
+    inherited::dispatch_info_i (cur_time, info);
 
   if (result == 1)
     {
       Hash_Token<TYPE> *h =
         reinterpret_cast<Hash_Token<TYPE> *> (const_cast<void *> (info.act_));
+      ACE_ASSERT (h);
 
       info.act_ = h->act_;
     }
@@ -781,15 +840,13 @@
 }
 
 // Dummy version of expire to get rid of warnings in Sun CC 4.2
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> int
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::expire ()
 {
-  return Base_Timer_Queue::expire();
+  return inherited::expire ();
 }
 
 // Specialized expire for Timer Hash
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY> int
 ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>::expire (const ACE_Time_Value &cur_time)
 {
@@ -798,11 +855,14 @@
   int number_of_timers_expired = 0;
 
   ACE_Timer_Node_T<TYPE> *expired = 0;
+  Hash_Token<TYPE> *h = 0;
+  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
+  const void *upcall_act = 0;
 
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
   // Go through the table and expire anything that can be expired
-
+  bool reclaim = true;
   for (size_t i = 0;
        i < this->table_size_;
        ++i)
@@ -810,14 +870,20 @@
       while (!this->table_[i]->is_empty ()
              && this->table_[i]->earliest_time () <= cur_time)
         {
+          reclaim = true;
           expired = this->table_[i]->remove_first ();
-          const void *act = expired->get_act ();
-          bool reclaim = true;
+          ACE_ASSERT (expired);
+          h = 0;
+          upcall_act = 0;
 
-          Hash_Token<TYPE> *h =
-            reinterpret_cast<Hash_Token<TYPE> *> (const_cast<void *> (act));
+          // Get the dispatch info
+          expired->get_dispatch_info (info);
 
-          ACE_ASSERT (h->pos_ == i);
+          h =
+            reinterpret_cast<Hash_Token<TYPE> *> (const_cast<void *> (expired->get_act ()));
+          ACE_ASSERT (h && (h->pos_ == i));
+
+          info.act_ = h->act_;
 
           // Check if this is an interval timer.
           if (expired->get_interval () > ACE_Time_Value::zero)
@@ -836,15 +902,6 @@
               this->free_node (expired);
             }
 
-          ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
-
-          // Get the dispatch info
-          expired->get_dispatch_info (info);
-
-          info.act_ = h->act_;
-
-          const void *upcall_act = 0;
-
           this->preinvoke (info, cur_time, upcall_act);
 
           this->upcall (info, cur_time);
@@ -852,12 +909,10 @@
           this->postinvoke (info, cur_time, upcall_act);
 
           if (reclaim)
-            {
-              --this->size_;
-            }
+            --this->size_;
 
           ++number_of_timers_expired;
-         }
+        }
     }
 
   if (number_of_timers_expired > 0)
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Hash_T.h ACE_wrappers/ace/Timer_Hash_T.h
--- ACE_wrappers_6_2_7/ace/Timer_Hash_T.h	2014-08-01 00:53:55.195475000 +0100
+++ ACE_wrappers/ace/Timer_Hash_T.h	2014-08-01 18:58:21.525410100 +0100
@@ -25,11 +25,11 @@
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 // Forward declaration.
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY = ACE_Default_Time_Policy>
 class ACE_Timer_Hash_T;
 template <typename TYPE>
 class Hash_Token;
-class ACE_Event_Handler;
+//class ACE_Event_Handler;
 
 /**
  * @class ACE_Timer_Hash_Upcall
@@ -39,72 +39,73 @@
  * This class calls up to the Timer Hash's functor from the
  * timer queues in the hash table
  */
-template <class TYPE, class FUNCTOR, class ACE_LOCK>
+template <class TQ_TYPE, class TYPE, class FUNCTOR>
 class ACE_Timer_Hash_Upcall
-  : private ACE_Copy_Disabled
 {
-public:
-  typedef ACE_Timer_Queue_T<ACE_Event_Handler *,
-                            ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK>,
-                            ACE_Null_Mutex>
-          TIMER_QUEUE;
-
-  /// Default constructor (creates an invalid object, but needs to be here
-  /// so timer queues using this functor can be constructed)
-  ACE_Timer_Hash_Upcall (void);
+ public:
+  ACE_Timer_Hash_Upcall ();
 
   /// Constructor that specifies a Timer_Hash to call up to
-  ACE_Timer_Hash_Upcall (ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK> *timer_hash);
+  ACE_Timer_Hash_Upcall (TQ_TYPE *timer_hash,
+                         FUNCTOR *upcall_functor);
+
+  /// Setter to the upcall functor
+  void upcall_functor (FUNCTOR *upcall_functor,
+                       const bool& delete_upcall_functor = false);
 
   /// This method is called when a timer is registered.
-  int registration (TIMER_QUEUE &timer_queue,
-                    ACE_Event_Handler *handler,
+  int registration (TQ_TYPE *timer_queue,
+                    TYPE &handler,
                     const void *arg);
 
   /// This method is called before the timer expires.
-  int preinvoke (TIMER_QUEUE &timer_queue,
-                 ACE_Event_Handler *handler,
+  int preinvoke (TQ_TYPE *timer_queue,
+                 TYPE &handler,
                  const void *arg,
                  int recurring_timer,
                  const ACE_Time_Value &cur_time,
                  const void *&upcall_act);
 
   /// This method is called when the timer expires.
-  int timeout (TIMER_QUEUE &timer_queue,
-               ACE_Event_Handler *handler,
+  int timeout (TQ_TYPE *timer_queue,
+               TYPE &handler,
                const void *arg,
                int recurring_timer,
                const ACE_Time_Value &cur_time);
 
   /// This method is called after the timer expires.
-  int postinvoke (TIMER_QUEUE &timer_queue,
-                  ACE_Event_Handler *handler,
+  int postinvoke (TQ_TYPE *timer_queue,
+                  TYPE &handler,
                   const void *arg,
                   int recurring_timer,
                   const ACE_Time_Value &cur_time,
                   const void *upcall_act);
 
   /// This method is called when a handler is cancelled
-  int cancel_type (TIMER_QUEUE &timer_queue,
-                   ACE_Event_Handler *handler,
+  int cancel_type (TQ_TYPE *timer_queue,
+                   TYPE &handler,
                    int dont_call,
                    int &requires_reference_counting);
 
   /// This method is called when a timer is cancelled
-  int cancel_timer (TIMER_QUEUE &timer_queue,
-                    ACE_Event_Handler *handler,
+  int cancel_timer (TQ_TYPE *timer_queue,
+                    TYPE &handler,
                     int dont_call,
                     int requires_reference_counting);
 
   /// This method is called when the timer queue is destroyed and
   /// the timer is still contained in it
-  int deletion (TIMER_QUEUE &timer_queue,
-                ACE_Event_Handler *handler,
+  int deletion (TQ_TYPE *timer_queue,
+                TYPE &handler,
                 const void *arg);
 
-private:
+ private:
   /// Timer Queue to do the calling up to
-  ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK> *timer_hash_;
+  TQ_TYPE *timer_hash_;
+  /// Upcall functor
+  FUNCTOR *upcall_functor_;
+  /// To delete or not to delete is the question?
+  bool delete_upcall_functor_;
 };
 
 /**
@@ -117,9 +118,10 @@
  * in the order of timeout values.
  */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY = ACE_Default_Time_Policy>
-class ACE_Timer_Hash_Iterator_T : public ACE_Timer_Queue_Iterator_T <TYPE>
+class ACE_Timer_Hash_Iterator_T
+ : public ACE_Timer_Queue_Iterator_T <TYPE>
 {
-public:
+ public:
   /// Constructor.
   typedef ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY> Hash;
   ACE_Timer_Hash_Iterator_T (Hash &);
@@ -138,7 +140,7 @@
   /// Returns the node at the current position in the sequence
   virtual ACE_Timer_Node_T<TYPE> *item (void);
 
-protected:
+ protected:
   /// Pointer to the ACE_Timer_Hash that we are iterating over.
   Hash & timer_hash_;
 
@@ -161,19 +163,17 @@
  * i.e., all events are expired after their deadline.  But two events
  * may expired out of order as defined by their deadlines.
  */
-template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY = ACE_Default_Time_Policy>
-class ACE_Timer_Hash_T : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, class BUCKET, typename TIME_POLICY>
+class ACE_Timer_Hash_T
+ : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
 {
-public:
+ public:
   /// Type of iterator
-  typedef ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>
-          HASH_ITERATOR;
-
+  typedef ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY> HASH_ITERATOR_T;
   /// Iterator is a friend
   friend class ACE_Timer_Hash_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY>;
 
-  /// Type inherited from
-  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Base_Timer_Queue;
+  typedef ACE_Timer_Hash_T<TYPE, FUNCTOR, ACE_LOCK, BUCKET, TIME_POLICY> TQ_T;
 
   // = Initialization and termination methods.
   /**
@@ -185,7 +185,7 @@
   ACE_Timer_Hash_T (size_t table_size,
                     FUNCTOR *upcall_functor = 0,
                     ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist = 0,
-                    TIME_POLICY const & time_policy = TIME_POLICY());
+                    TIME_POLICY const & time_policy = TIME_POLICY ());
 
   /**
    * Default constructor. @a upcall_functor is the instance of the
@@ -196,7 +196,7 @@
    */
   ACE_Timer_Hash_T (FUNCTOR *upcall_functor = 0,
                     ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist = 0,
-                    TIME_POLICY const & time_policy = TIME_POLICY());
+                    TIME_POLICY const & time_policy = TIME_POLICY ());
 
   /// Destructor
   virtual ~ACE_Timer_Hash_T (void);
@@ -225,7 +225,7 @@
    * of this instance of ACE_Timer_Hash_T then user will get a memory
    * leak.
    */
-  virtual int cancel (const TYPE &type,
+  virtual int cancel (TYPE &type,
                       int dont_call_handle_close = 1);
 
   /**
@@ -233,11 +233,11 @@
    * was returned from the <schedule> method).  If act is non-NULL
    * then it will be set to point to the ``magic cookie'' argument
    * passed in when the timer was registered.  This makes it possible
-   * to free up the memory and avoid memory leaks.  If
-   * @a dont_call_handle_close is 0 then the <functor> will be invoked.
-   * Returns 1 if cancellation succeeded and 0 if the @a timer_id wasn't
-   * found.  If any valid timer is not cancelled before destruction of
-   * this instance of ACE_Timer_Hash_T then user will get a memory leak.
+   * to free up the memory and avoid memory leaks.  If <dont_call> is
+   * 0 then the <functor> will be invoked.  Returns 1 if cancellation
+   * succeeded and 0 if the @a timer_id wasn't found.  If any valid
+   * timer is not cancelled before destruction of this instance of
+   * ACE_Timer_Hash_T then user will get a memory leak.
    */
   virtual int cancel (long timer_id,
                       const void **act = 0,
@@ -274,11 +274,12 @@
   /// Reads the earliest node from the queue and returns it.
   virtual ACE_Timer_Node_T<TYPE> *get_first (void);
 
-protected:
+ protected:
   /// Factory method that frees a previously allocated node.
-  virtual void free_node (ACE_Timer_Node_T<TYPE> *);
+  virtual void free_node (ACE_Timer_Node_T<TYPE>*);
 
-private:
+ private:
+  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> inherited;
 
   /**
    * Schedule @a type that will expire at @a future_time,
@@ -291,7 +292,7 @@
    * used to cancel the timer before it expires.  Returns -1 on
    * failure.
    */
-  virtual long schedule_i (const TYPE &type,
+  virtual long schedule_i (TYPE &type,
                            const void *act,
                            const ACE_Time_Value &future_time,
                            const ACE_Time_Value &interval);
@@ -316,13 +317,16 @@
   size_t table_size_;
 
   /// Functor used for the table's timer queues
-  ACE_Timer_Hash_Upcall<TYPE, FUNCTOR, ACE_LOCK> table_functor_;
+  typedef ACE_Abstract_Timer_Queue<TYPE> TQ_BASE_T;
+  typedef ACE_Timer_Hash_Upcall<TQ_BASE_T, TYPE, FUNCTOR> TABLE_FUNCTOR_T;
+  friend class ACE_Timer_Hash_Upcall<TQ_BASE_T, TYPE, FUNCTOR>;
+  TABLE_FUNCTOR_T table_functor_;
 
   /// Index to the position with the earliest entry
   size_t earliest_position_;
 
   /// Iterator used to expire timers.
-  HASH_ITERATOR *iterator_;
+  HASH_ITERATOR_T *iterator_;
 
 #if defined (ACE_WIN64)
   /// Part of a hack... see comments in schedule().
@@ -350,4 +354,4 @@
 #endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */
 
 #include /**/ "ace/post.h"
-#endif /* ACE_TIMER_HASH_T_H */
+#endif /* ACE_TIMER_HASH_T_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Heap.h ACE_wrappers/ace/Timer_Heap.h
--- ACE_wrappers_6_2_7/ace/Timer_Heap.h	2014-08-01 00:53:55.195943900 +0100
+++ ACE_wrappers/ace/Timer_Heap.h	2014-07-15 22:18:52.499728500 +0100
@@ -14,8 +14,11 @@
 #define ACE_TIMER_HEAP_H
 #include /**/ "ace/pre.h"
 
+#include "ace/Event_Handler.h"
 #include "ace/Timer_Heap_T.h"
 #include "ace/Event_Handler_Handle_Timeout_Upcall.h"
+#include "ace/Synch.h"
+#include "ace/Time_Policy.h"
 
 #if !defined (ACE_LACKS_PRAGMA_ONCE)
 # pragma once
@@ -26,23 +29,18 @@
 // The following typedefs are here for ease of use and backward
 // compatibility.
 
-typedef ACE_Timer_Heap_T<ACE_Event_Handler *,
+typedef ACE_Timer_Heap_T<ACE_Event_Handler*,
                          ACE_Event_Handler_Handle_Timeout_Upcall,
-                         ACE_SYNCH_RECURSIVE_MUTEX>
-        ACE_Timer_Heap;
-
-typedef ACE_Timer_Heap_Iterator_T<ACE_Event_Handler *,
-                                  ACE_Event_Handler_Handle_Timeout_Upcall,
-                                  ACE_SYNCH_RECURSIVE_MUTEX>
-        ACE_Timer_Heap_Iterator;
+                         ACE_SYNCH_RECURSIVE_MUTEX,
+                         ACE_Default_Time_Policy> ACE_Timer_Heap;
+typedef ACE_Timer_Heap::HEAP_ITERATOR_T ACE_Timer_Heap_Iterator;
 
-typedef ACE_Timer_Heap_T<ACE_Event_Handler *,
+typedef ACE_Timer_Heap_T<ACE_Event_Handler*,
                          ACE_Event_Handler_Handle_Timeout_Upcall,
                          ACE_SYNCH_RECURSIVE_MUTEX,
-                         ACE_FPointer_Time_Policy>
-        ACE_Timer_Heap_Variable_Time_Source;
+                         ACE_FPointer_Time_Policy> ACE_Timer_Heap_Variable_Time_Source;
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
 #include /**/ "ace/post.h"
-#endif /* ACE_TIMER_HEAP_H */
+#endif /* ACE_TIMER_HEAP_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Heap_T.cpp ACE_wrappers/ace/Timer_Heap_T.cpp
--- ACE_wrappers_6_2_7/ace/Timer_Heap_T.cpp	2014-08-01 00:53:55.196993700 +0100
+++ ACE_wrappers/ace/Timer_Heap_T.cpp	2014-08-01 17:22:07.992213900 +0100
@@ -97,21 +97,19 @@
 // When it's time to wrap, the next ID given out will be 0.
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Heap_T (
-  size_t size,
-  bool preallocated,
-  FUNCTOR *upcall_functor,
-  ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
-  TIME_POLICY const & time_policy)
-  : Base_Time_Policy (upcall_functor,
-      freelist,
-      time_policy),
-    max_size_ (size),
-    cur_size_ (0),
-    cur_limbo_ (0),
-    timer_ids_curr_ (0),
-    timer_ids_min_free_ (0),
-    preallocated_nodes_ (0),
-    preallocated_nodes_freelist_ (0)
+   size_t size
+ , bool preallocated
+ , FUNCTOR *upcall_functor
+ , ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist
+ , TIME_POLICY const & time_policy)
+ : inherited (upcall_functor, freelist, time_policy)
+ , max_size_ (size)
+ , cur_size_ (0)
+ , cur_limbo_ (0)
+ , timer_ids_curr_ (0)
+ , timer_ids_min_free_ (0)
+ , preallocated_nodes_ (0)
+ , preallocated_nodes_freelist_ (0)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::ACE_Timer_Heap_T");
 
@@ -158,7 +156,7 @@
     }
 
   ACE_NEW (iterator_,
-           HEAP_ITERATOR (*this));
+           HEAP_ITERATOR_T (*this));
 }
 
 // Note that timer_ids_curr_ and timer_ids_min_free_ both start at 0.
@@ -167,19 +165,17 @@
 // When it's time to wrap, the next ID given out will be 0.
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Heap_T (
-  FUNCTOR *upcall_functor,
-  ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
-  TIME_POLICY const & time_policy)
-  : Base_Time_Policy (upcall_functor,
-          freelist,
-          time_policy),
-    max_size_ (ACE_DEFAULT_TIMERS),
-    cur_size_ (0),
-    cur_limbo_ (0),
-    timer_ids_curr_ (0),
-    timer_ids_min_free_ (0),
-    preallocated_nodes_ (0),
-    preallocated_nodes_freelist_ (0)
+   FUNCTOR *upcall_functor
+ , ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist
+ , TIME_POLICY const & time_policy)
+ : inherited (upcall_functor, freelist, time_policy)
+ , max_size_ (ACE_DEFAULT_TIMERS)
+ , cur_size_ (0)
+ , cur_limbo_ (0)
+ , timer_ids_curr_ (0)
+ , timer_ids_min_free_ (0)
+ , preallocated_nodes_ (0)
+ , preallocated_nodes_freelist_ (0)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::ACE_Timer_Heap_T");
 
@@ -188,8 +184,8 @@
     this->max_size_ = static_cast<size_t> (ACE_Numeric_Limits<long>::max ());
 
   // Create the heap array.
-    ACE_NEW (this->heap_,
-             ACE_Timer_Node_T<TYPE> *[this->max_size_]);
+  ACE_NEW (this->heap_,
+           ACE_Timer_Node_T<TYPE> *[this->max_size_]);
 
   // Create the parallel array.
   ACE_NEW (this->timer_ids_,
@@ -202,7 +198,7 @@
     this->timer_ids_[i] = -1;
 
   ACE_NEW (iterator_,
-           HEAP_ITERATOR (*this));
+           HEAP_ITERATOR_T (*this));
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
@@ -248,15 +244,14 @@
       TYPE eh = this->heap_[i]->get_type ();
       const void *act = this->heap_[i]->get_act ();
       this->free_node (this->heap_[i]);
-      this->upcall_functor ().deletion (*this, eh, act);
+      this->upcall_functor ().deletion (this, eh, act);
     }
 
   // leave the rest to the destructor
   return 0;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-long
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::pop_freelist (void)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::pop_freelist");
@@ -288,8 +283,7 @@
   return static_cast<long> (this->timer_ids_curr_);
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::push_freelist (long old_id)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::push_freelist");
@@ -313,8 +307,7 @@
   return;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-long
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::timer_id (void)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::timer_id");
@@ -324,9 +317,7 @@
 }
 
 // Checks if queue is empty.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-bool
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> bool
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::is_empty (void) const
 {
   ACE_TRACE ("ACE_Timer_Heap_T::is_empty");
@@ -334,8 +325,7 @@
   return this->cur_size_ == 0;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Queue_Iterator_T<TYPE> &
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Queue_Iterator_T<TYPE> &
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::iter (void)
 {
   this->iterator_->first ();
@@ -343,16 +333,15 @@
 }
 
 // Returns earliest time in a non-empty queue.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> const ACE_Time_Value &
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::earliest_time (void) const
 {
   ACE_TRACE ("ACE_Timer_Heap_T::earliest_time");
+
   return this->heap_[0]->get_timer_value ();
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dump (void) const
 {
 #if defined (ACE_HAS_DUMP)
@@ -389,11 +378,9 @@
 #endif /* ACE_HAS_DUMP */
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::copy (
-  size_t slot,
-  ACE_Timer_Node_T<TYPE> *moved_node)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::copy (size_t slot,
+                                                              ACE_Timer_Node_T<TYPE> *moved_node)
 {
   // Insert <moved_node> into its new location in the heap.
   this->heap_[slot] = moved_node;
@@ -410,8 +397,7 @@
 // this function must call either free_node (to reclaim the timer ID
 // and the timer node memory, as well as decrement the size of the queue)
 // or reschedule (to reinsert the node in the heap at a new time).
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE> *
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::remove (size_t slot)
 {
   ACE_Timer_Node_T<TYPE> *removed_node =
@@ -435,7 +421,7 @@
       // the corresponding slot in the parallel <timer_ids> array.
       this->copy (slot, moved_node);
 
-      // If the <moved_node->time_value_> is great than or equal its
+      // If the <moved_node->time_value_> is greater than or equal its
       // parent it needs be moved down the heap.
       size_t parent = ACE_HEAP_PARENT (slot);
 
@@ -456,10 +442,9 @@
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reheap_down (
-  ACE_Timer_Node_T<TYPE> *moved_node,
-  size_t slot,
-  size_t child)
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reheap_down (ACE_Timer_Node_T<TYPE> *moved_node,
+                                                                     size_t slot,
+                                                                     size_t child)
 {
   // Restore the heap property after a deletion.
 
@@ -489,12 +474,10 @@
   this->copy (slot, moved_node);
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reheap_up (
-  ACE_Timer_Node_T<TYPE> *moved_node,
-  size_t slot,
-  size_t parent)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reheap_up (ACE_Timer_Node_T<TYPE> *moved_node,
+                                                                   size_t slot,
+                                                                   size_t parent)
 {
   // Restore the heap property after an insertion.
 
@@ -519,10 +502,8 @@
               moved_node);
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::insert (
-  ACE_Timer_Node_T<TYPE> *new_node)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::insert (ACE_Timer_Node_T<TYPE> *new_node)
 {
   if (this->cur_size_ + this->cur_limbo_ + 2 >= this->max_size_)
     this->grow_heap ();
@@ -533,8 +514,7 @@
   this->cur_size_++;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::grow_heap (void)
 {
   // All the containers will double in size from max_size_.
@@ -614,11 +594,8 @@
 
 // Reschedule a periodic timer.  This function must be called with the
 // mutex lock held.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reschedule (
-  ACE_Timer_Node_T<TYPE> *expired)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reschedule (ACE_Timer_Node_T<TYPE> *expired)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::reschedule");
 
@@ -632,8 +609,7 @@
   this->insert (expired);
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE> *
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::alloc_node (void)
 {
   ACE_Timer_Node_T<TYPE> *temp = 0;
@@ -661,10 +637,8 @@
   return temp;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-void
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::free_node (
-  ACE_Timer_Node_T<TYPE> *node)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::free_node (ACE_Timer_Node_T<TYPE> *node)
 {
   // Return this timer id to the freelist.
   this->push_freelist (node->get_timer_id ());
@@ -682,13 +656,11 @@
 // Insert a new timer that expires at time future_time; if interval is
 // > 0, the handler will be reinvoked periodically.
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-long
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (
-  const TYPE &type,
-  const void *act,
-  const ACE_Time_Value &future_time,
-  const ACE_Time_Value &interval)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (TYPE &type,
+                                                                    const void *act,
+                                                                    const ACE_Time_Value &future_time,
+                                                                    const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::schedule_i");
 
@@ -719,14 +691,13 @@
 
 // Locate and remove the single timer with a value of @a timer_id from
 // the timer queue.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-int
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (long timer_id,
-                                                   const void **act,
-                                                   int dont_call)
+                                                                const void **act,
+                                                                int dont_call)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::cancel");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
   // Locate the ACE_Timer_Node that corresponds to the timer_id.
@@ -756,13 +727,13 @@
       int cookie = 0;
 
       // cancel_type() called once per <type>.
-      this->upcall_functor ().cancel_type (*this,
+      this->upcall_functor ().cancel_type (this,
                                            temp->get_type (),
                                            dont_call,
                                            cookie);
 
       // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
+      this->upcall_functor ().cancel_timer (this,
                                             temp->get_type (),
                                             dont_call,
                                             cookie);
@@ -775,14 +746,13 @@
     }
 }
 
-// Locate and update the inteval on the timer_id
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-int
+// Locate and update the interval on the timer_id
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reset_interval (long timer_id,
-                                                           const ACE_Time_Value &interval)
+                                                                        const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::reset_interval");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
   // Locate the ACE_Timer_Node that corresponds to the timer_id.
@@ -812,11 +782,9 @@
 }
 
 // Locate and remove all values of @a type from the timer queue.
-
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-int
-ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (const TYPE &type,
-                                                   int dont_call)
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
+ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (TYPE &type,
+                                                                int dont_call)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::cancel");
 
@@ -849,7 +817,7 @@
   int cookie = 0;
 
   // cancel_type() called once per <type>.
-  this->upcall_functor ().cancel_type (*this,
+  this->upcall_functor ().cancel_type (this,
                                        type,
                                        dont_call,
                                        cookie);
@@ -859,7 +827,7 @@
        ++j)
     {
       // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
+      this->upcall_functor ().cancel_timer (this,
                                             type,
                                             dont_call,
                                             cookie);
@@ -870,8 +838,7 @@
 
 // Returns the earliest node or returns 0 if the heap is empty.
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T <TYPE> *
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T <TYPE> *
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::remove_first (void)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::remove_first");
@@ -882,8 +849,7 @@
   return this->remove (0);
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T <TYPE> *
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T <TYPE> *
 ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::get_first (void)
 {
   ACE_TRACE ("ACE_Timer_Heap_T::get_first");
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Heap_T.h ACE_wrappers/ace/Timer_Heap_T.h
--- ACE_wrappers_6_2_7/ace/Timer_Heap_T.h	2014-08-01 00:53:55.197849500 +0100
+++ ACE_wrappers/ace/Timer_Heap_T.h	2014-07-31 00:34:36.399323400 +0100
@@ -20,13 +20,14 @@
 # pragma once
 #endif /* ACE_LACKS_PRAGMA_ONCE */
 
+#include "ace/Time_Policy.h"
 #include "ace/Free_List.h"
 #include "ace/Unbounded_Set.h"
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 // Forward declaration
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
 class ACE_Timer_Heap_T;
 
 /**
@@ -39,9 +40,10 @@
  * in the order of timeout values.
  */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
-class ACE_Timer_Heap_Iterator_T : public ACE_Timer_Queue_Iterator_T<TYPE>
+class ACE_Timer_Heap_Iterator_T
+ : public ACE_Timer_Queue_Iterator_T<TYPE>
 {
-public:
+ public:
   typedef ACE_Timer_Heap_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Heap;
   /// Constructor.
   ACE_Timer_Heap_Iterator_T (Heap &);
@@ -61,7 +63,7 @@
   /// Returns the node at the current position in the sequence
   virtual ACE_Timer_Node_T<TYPE> *item (void);
 
-protected:
+ protected:
   /// Pointer to the ACE_Timer_Heap that we are iterating over.
   Heap & timer_heap_;
 
@@ -83,15 +85,14 @@
  * dynamic memory allocation, which is important for real-time
  * systems.
  */
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
-class ACE_Timer_Heap_T : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
+class ACE_Timer_Heap_T
+ : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
 {
-public:
-  typedef ACE_Timer_Heap_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> HEAP_ITERATOR;
+ public:
+  typedef ACE_Timer_Heap_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> HEAP_ITERATOR_T;
   friend class ACE_Timer_Heap_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>;
 
-  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Base_Time_Policy;
-
   // = Initialization and termination methods.
   /**
    * The Constructor creates a heap with specified number of elements.
@@ -149,7 +150,7 @@
    * is 0 then the <functor> will be invoked.  Returns number of timers
    * cancelled.
    */
-  virtual int cancel (const TYPE &type,
+  virtual int cancel (TYPE &type,
                       int dont_call_handle_close = 1);
 
   /**
@@ -189,8 +190,7 @@
   /// Reads the earliest node from the queue and returns it.
   virtual ACE_Timer_Node_T<TYPE> *get_first (void);
 
-protected:
-
+ protected:
   /**
    * Schedule a timer that may optionally auto-reset.
    * Schedule @a type that will expire at @a future_time,
@@ -207,7 +207,7 @@
    * wrong timer.  Returns -1 on failure (which is guaranteed never to
    * be a valid <timer_id>).
    */
-  virtual long schedule_i (const TYPE &type,
+  virtual long schedule_i (TYPE &type,
                            const void *act,
                            const ACE_Time_Value &future_time,
                            const ACE_Time_Value &interval);
@@ -226,7 +226,9 @@
    */
   virtual void free_node (ACE_Timer_Node_T<TYPE> *);
 
-private:
+ private:
+  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> inherited;
+
   /// Remove and return the @a sloth ACE_Timer_Node and restore the
   /// heap property.
   ACE_Timer_Node_T<TYPE> *remove (size_t slot);
@@ -280,7 +282,7 @@
   size_t cur_limbo_;
 
   /// Iterator used to expire timers.
-  HEAP_ITERATOR *iterator_;
+  HEAP_ITERATOR_T *iterator_;
 
   /**
    * Current contents of the Heap, which is organized as a "heap" of
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_List.h ACE_wrappers/ace/Timer_List.h
--- ACE_wrappers_6_2_7/ace/Timer_List.h	2014-08-01 00:53:55.198482400 +0100
+++ ACE_wrappers/ace/Timer_List.h	2014-07-31 01:39:31.006934400 +0100
@@ -15,8 +15,11 @@
 #define ACE_TIMER_LIST_H
 #include /**/ "ace/pre.h"
 
+#include "ace/Event_Handler.h"
 #include "ace/Timer_List_T.h"
 #include "ace/Event_Handler_Handle_Timeout_Upcall.h"
+#include "ace/Synch.h"
+#include "ace/Time_Policy.h"
 
 #if !defined (ACE_LACKS_PRAGMA_ONCE)
 # pragma once
@@ -26,18 +29,13 @@
 
 // The following typedefs are here for ease of use and backward
 // compatibility.
-typedef ACE_Timer_List_T<ACE_Event_Handler *,
+typedef ACE_Timer_List_T<ACE_Event_Handler*,
                          ACE_Event_Handler_Handle_Timeout_Upcall,
-                         ACE_SYNCH_RECURSIVE_MUTEX>
-        ACE_Timer_List;
-
-typedef ACE_Timer_List_Iterator_T<ACE_Event_Handler *,
-                                  ACE_Event_Handler_Handle_Timeout_Upcall,
-                                  ACE_SYNCH_RECURSIVE_MUTEX,
-                                  ACE_Default_Time_Policy>
-        ACE_Timer_List_Iterator;
+                         ACE_SYNCH_RECURSIVE_MUTEX,
+                         ACE_Default_Time_Policy> ACE_Timer_List;
+typedef ACE_Timer_List::LIST_ITERATOR_T ACE_Timer_List_Iterator;
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
 #include /**/ "ace/post.h"
-#endif /* ACE_TIMER_LIST_H */
+#endif /* ACE_TIMER_LIST_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_List_T.cpp ACE_wrappers/ace/Timer_List_T.cpp
--- ACE_wrappers_6_2_7/ace/Timer_List_T.cpp	2014-08-01 00:53:55.199070600 +0100
+++ ACE_wrappers/ace/Timer_List_T.cpp	2014-08-01 18:39:18.825667000 +0100
@@ -11,44 +11,39 @@
 # pragma once
 #endif /* ACE_LACKS_PRAGMA_ONCE */
 
-
-
 // Default Constructor
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_List_Iterator_T (List& lst)
-  : list_ (lst)
+ : list_ (lst)
 {
-  this->first();
+  this->first ();
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::~ACE_Timer_List_Iterator_T (void)
 {
+
 }
 
 // Positions the iterator at the node right after the dummy node
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::first (void)
 {
-  this->current_node_ = this->list_.get_first();
+  this->current_node_ = this->list_.get_first ();
 }
 
 // Positions the iterator at the next node in the Timer Queue
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::next (void)
 {
   // Make sure that if we are at the end, we don't wrap around
-  if (! this->isdone())
+  if (! this->isdone ())
     this->current_node_ = this->current_node_->get_next ();
   if (this->current_node_  == this->list_.head_)
     this->current_node_ = 0;
 }
 
 // Returns true when we are at <head_>
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> bool
 ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::isdone (void) const
 {
@@ -56,11 +51,10 @@
 }
 
 // Returns the node at <position_> or 0 if we are at the end
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::item (void)
 {
-  if (! this->isdone())
+  if (! this->isdone ())
     return this->current_node_;
   return 0;
 }
@@ -69,7 +63,6 @@
 ///////////////////////////////////////////////////////////////////////////////
 
 // Return our instance of the iterator
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Queue_Iterator_T<TYPE> &
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::iter (void)
 {
@@ -78,53 +71,53 @@
 }
 
 // Create an empty list.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_List_T (FUNCTOR* uf,
-                    FreeList* fl,
-                    TIME_POLICY const & time_policy)
-  : Base_Timer_Queue (uf, fl, time_policy)
-  , head_ (new ACE_Timer_Node_T<TYPE>)
-  , id_counter_ (0)
+                                                                          FreeList* fl,
+                                                                          TIME_POLICY const & time_policy)
+ : inherited (uf, fl, time_policy)
+ , head_ (0)
+ , id_counter_ (0)
 {
   ACE_TRACE ("ACE_Timer_List_T::ACE_Timer_List_T");
 
+  ACE_NEW (head_,
+           ACE_Timer_Node_T<TYPE> ());
+  ACE_ASSERT (head_);
   this->head_->set_next (this->head_);
   this->head_->set_prev (this->head_);
 
-  ACE_NEW (iterator_, Iterator(*this));
+  ACE_NEW (iterator_,
+           LIST_ITERATOR_T (*this));
 }
 
-
 // Checks if list is empty.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> bool
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::is_empty (void) const
 {
   ACE_TRACE ("ACE_Timer_List_T::is_empty");
-  return this->get_first_i() == 0;
-}
 
+  return (this->get_first_i () == 0);
+}
 
 // Returns earliest time in a non-empty list.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> const ACE_Time_Value &
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::earliest_time (void) const
 {
   ACE_TRACE ("ACE_Timer_List_T::earliest_time");
-  ACE_Timer_Node_T<TYPE>* first = this->get_first_i();
+
+  ACE_Timer_Node_T<TYPE>* first = this->get_first_i ();
   if (first != 0)
     return first->get_timer_value ();
   return ACE_Time_Value::zero;
 }
 
-
 // Remove all remaining items in the list.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::~ACE_Timer_List_T (void)
 {
   ACE_TRACE ("ACE_Timer_List_T::~ACE_Timer_List_T");
+
   ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
 
   delete iterator_;
@@ -139,18 +132,17 @@
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::close (void)
 {
   ACE_TRACE ("ACE_Timer_List_T::close");
-  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
   // Remove all remaining items in the list.
-  if (!this->is_empty())
+  if (! this->is_empty ())
     {
-      for (ACE_Timer_Node_T<TYPE>* n = this->get_first();
+      for (ACE_Timer_Node_T<TYPE>* n = this->get_first ();
            n != this->head_;
            )
         {
-          this->upcall_functor ().deletion (*this,
-                                            n->get_type(),
-                                            n->get_act());
+          this->upcall_functor ().deletion (this,
+                                            n->get_type (),
+                                            n->get_act ());
 
           ACE_Timer_Node_T<TYPE> *next =
             n->get_next ();
@@ -174,7 +166,7 @@
 
   int count = 0;
 
-  ACE_Timer_Node_T<TYPE>* n = this->get_first_i();
+  ACE_Timer_Node_T<TYPE>* n = this->get_first_i ();
   if (n != 0) {
     for (; n != this->head_; n = n->get_next()) {
       ++count;
@@ -186,30 +178,28 @@
 #endif /* ACE_HAS_DUMP */
 }
 
-
 // Reschedule a periodic timer.  This function must be called with the
 // lock held.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reschedule (ACE_Timer_Node_T<TYPE>* n)
 {
   ACE_TRACE ("ACE_Timer_List_T::reschedule");
-  this->schedule_i(n, n->get_timer_value());
-}
 
+  ACE_ASSERT (n);
+  this->schedule_i (n, n->get_timer_value ());
+}
 
 // Insert a new handler that expires at time future_time; if interval
 // is > 0, the handler will be reinvoked periodically.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
-ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (const TYPE &type,
-                                                       const void *act,
-                                                       const ACE_Time_Value &future_time,
-                                                       const ACE_Time_Value &interval)
+ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (TYPE &type,
+                                                                    const void *act,
+                                                                    const ACE_Time_Value &future_time,
+                                                                    const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_List_T::schedule_i");
 
-  ACE_Timer_Node_T<TYPE>* n = this->alloc_node();
+  ACE_Timer_Node_T<TYPE>* n = this->alloc_node ();
 
   if (n != 0)
   {
@@ -230,41 +220,43 @@
 /// The shared scheduling functionality between schedule() and reschedule()
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (ACE_Timer_Node_T<TYPE>* n,
-                                                       const ACE_Time_Value& expire)
+                                                                    const ACE_Time_Value& expire)
 {
-  if (this->is_empty()) {
-    n->set_prev(this->head_);
-    n->set_next(this->head_);
-    this->head_->set_prev(n);
-    this->head_->set_next(n);
-    return;
-  }
+  if (this->is_empty ())
+    {
+      n->set_prev (this->head_);
+      n->set_next (this->head_);
+      this->head_->set_prev (n);
+      this->head_->set_next (n);
+      return;
+    }
 
   // We always want to search backwards from the tail of the list, because
   // this minimizes the search in the extreme case when lots of timers are
   // scheduled for exactly the same time, and it also assumes that most of
   // the timers will be scheduled later than existing timers.
-  ACE_Timer_Node_T<TYPE>* p = this->head_->get_prev();
-  while (p != this->head_ && p->get_timer_value() > expire)
-    p = p->get_prev();
+  ACE_Timer_Node_T<TYPE>* p = this->head_->get_prev ();
+  while (p != this->head_ && p->get_timer_value () > expire)
+    p = p->get_prev ();
 
   // insert after
-  n->set_prev(p);
-  n->set_next(p->get_next());
-  p->get_next()->set_prev(n);
-  p->set_next(n);
+  n->set_prev (p);
+  n->set_next (p->get_next ());
+  p->get_next ()->set_prev (n);
+  p->set_next (n);
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_Node_T<TYPE>*
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::find_node (long timer_id) const
 {
-  ACE_Timer_Node_T<TYPE>* n = this->get_first_i();
+  ACE_Timer_Node_T<TYPE>* n = this->get_first_i ();
+
   if (n == 0)
     return 0;
 
-  for (; n != this->head_; n = n->get_next()) {
-    if (n->get_timer_id() == timer_id) {
+  for (; n != this->head_; n = n->get_next ()) {
+    if (n->get_timer_id () == timer_id) {
       return n;
     }
   }
@@ -274,13 +266,15 @@
 // Locate and update the inteval on the timer_id
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reset_interval (long timer_id,
-                                                           const ACE_Time_Value &interval)
+                                                                        const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_List_T::reset_interval");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
-  ACE_Timer_Node_T<TYPE>* n = this->find_node(timer_id);
+
+  ACE_Timer_Node_T<TYPE>* n = this->find_node (timer_id);
   if (n != 0) {
-    n->set_interval(interval); // The interval will take effect the next time this node is expired.
+    n->set_interval (interval); // The interval will take effect the next time this node is expired.
     return 0;
   }
   return -1;
@@ -290,12 +284,15 @@
 // @a timer_id from the timer queue.
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (long timer_id,
-                                                   const void **act,
-                                                   int skip_close)
+                                                                const void **act,
+                                                                int skip_close)
 {
   ACE_TRACE ("ACE_Timer_List_T::cancel");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
-  ACE_Timer_Node_T<TYPE>* n = this->find_node(timer_id);
+
+  ACE_Timer_Node_T<TYPE>* n = this->find_node (timer_id);
+
   if (n != 0)
     {
       if (act != 0)
@@ -305,13 +302,13 @@
       int cookie = 0;
 
       // cancel_type() called once per <type>.
-      this->upcall_functor ().cancel_type (*this,
+      this->upcall_functor ().cancel_type (this,
                                            n->get_type (),
                                            skip_close,
                                            cookie);
 
       // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
+      this->upcall_functor ().cancel_timer (this,
                                             n->get_type (),
                                             skip_close,
                                             cookie);
@@ -326,7 +323,7 @@
 
 // Locate and remove all values of <handler> from the timer queue.
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
-ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (const TYPE &type, int skip_close)
+ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (TYPE &type, int skip_close)
 {
   ACE_TRACE ("ACE_Timer_List_T::cancel");
 
@@ -336,24 +333,24 @@
 
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
-  if (!this->is_empty ())
+  if (! this->is_empty ())
     {
-      for (ACE_Timer_Node_T<TYPE>* n = this->get_first();
+      for (ACE_Timer_Node_T<TYPE>* n = this->get_first ();
            n != this->head_;
            )
         {
-          if (n->get_type() == type) // Note: Typically Type is an ACE_Event_Handler*
+          if (n->get_type () == type) // Note: Typically Type is an ACE_Event_Handler*
             {
               ++num_canceled;
 
               ACE_Timer_Node_T<TYPE>* tmp = n;
-              n = n->get_next();
+              n = n->get_next ();
 
               this->cancel_i (tmp);
             }
           else
             {
-              n = n->get_next();
+              n = n->get_next ();
             }
         }
     }
@@ -361,7 +358,7 @@
   // Call the close hooks.
 
   // cancel_type() called once per <type>.
-  this->upcall_functor ().cancel_type (*this,
+  this->upcall_functor ().cancel_type (this,
                                        type,
                                        skip_close,
                                        cookie);
@@ -371,7 +368,7 @@
        ++i)
     {
       // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
+      this->upcall_functor ().cancel_timer (this,
                                             type,
                                             skip_close,
                                             cookie);
@@ -383,10 +380,10 @@
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::unlink (ACE_Timer_Node_T<TYPE>* n)
 {
-  n->get_prev()->set_next(n->get_next());
-  n->get_next()->set_prev(n->get_prev());
-  n->set_prev(0);
-  n->set_next(0);
+  n->get_prev ()->set_next (n->get_next ());
+  n->get_next ()->set_prev (n->get_prev ());
+  n->set_prev (0);
+  n->set_next (0);
 }
 
 /// Shared subset of the two cancel() methods.
@@ -402,29 +399,31 @@
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::get_first (void)
 {
   ACE_TRACE ("ACE_Timer_List_T::get_first");
-  return this->get_first_i();
+
+  return this->get_first_i ();
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::get_first_i (void) const
 {
   ACE_TRACE ("ACE_Timer_List_T::get_first_i");
-  ACE_Timer_Node_T<TYPE>* first = this->head_->get_next();
+
+  ACE_Timer_Node_T<TYPE>* first = this->head_->get_next ();
   if (first != this->head_) // Note : is_empty() uses get_first()
     return first;
   return 0;
 }
 
-
 // Removes the first node on the list and returns it.
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
 ACE_Timer_List_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::remove_first (void)
 {
   ACE_TRACE ("ACE_Timer_List_T::remove_first");
-  ACE_Timer_Node_T<TYPE>* first = this->get_first();
+
+  ACE_Timer_Node_T<TYPE>* first = this->get_first ();
+
   if (first != 0) {
-    this->unlink(first);
+    this->unlink (first);
     return first;
   }
   return 0;
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_List_T.h ACE_wrappers/ace/Timer_List_T.h
--- ACE_wrappers_6_2_7/ace/Timer_List_T.h	2014-08-01 00:53:55.199624400 +0100
+++ ACE_wrappers/ace/Timer_List_T.h	2014-07-31 01:38:52.599274200 +0100
@@ -21,7 +21,7 @@
 #endif /* ACE_LACKS_PRAGMA_ONCE */
 
 // Forward declaration.
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
 class ACE_Timer_List_T;
 
 /**
@@ -81,19 +81,17 @@
  * ACE_Timer_Heap will perform substantially faster than the
  * ACE_Timer_List.
  */
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
-class ACE_Timer_List_T : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
+class ACE_Timer_List_T 
+ : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
 {
-public:
+ public:
   /// Type of iterator
-  typedef ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Iterator;
-
+  typedef ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> LIST_ITERATOR_T;
   /// Iterator is a friend
   friend class ACE_Timer_List_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>;
 
   typedef ACE_Timer_Node_T<TYPE> Node;
-  /// Type inherited from
-  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Base_Timer_Queue;
   typedef ACE_Free_List<Node> FreeList;
 
   // = Initialization and termination methods.
@@ -103,7 +101,8 @@
    * default FUNCTOR will be created.  @a freelist is the freelist of
    * timer nodes.  If 0, then a default freelist will be created.
    */
-  ACE_Timer_List_T (FUNCTOR* upcall_functor = 0, FreeList* freelist = 0,
+  ACE_Timer_List_T (FUNCTOR* upcall_functor = 0,
+                    FreeList* freelist = 0,
                     TIME_POLICY const & time_policy = TIME_POLICY());
 
   /// Destructor
@@ -127,11 +126,11 @@
                               const ACE_Time_Value& interval);
 
   /**
-   * Cancel all timers associated with @a type.  If @a dont_call_handle_close
-   * is 0 then the @a functor will be invoked.  Returns the number of timers
+   * Cancel all timers associated with @a type.  If dont_call_handle_close is 0
+   * then the @a functor will be invoked.  Returns the number of timers
    * cancelled.
    */
-  virtual int cancel (const TYPE& type,
+  virtual int cancel (TYPE& type,
                       int dont_call_handle_close = 1);
 
   /**
@@ -168,16 +167,15 @@
   /// Reads the earliest node from the queue and returns it.
   virtual ACE_Timer_Node_T<TYPE>* get_first (void);
 
-private:
-
+ private:
   /**
    * Schedule @a type that will expire at @a future_time, which is
    * specified in absolute time.  If it expires then @a act is passed
    * in as the value to the <functor>.  If @a interval is != to
    * ACE_Time_Value::zero then it is used to reschedule the @a type
    * automatically, using relative time to the current <gettimeofday>.
-   * This method returns a timer_id that uniquely identifies the the
-   * @a type entry in an internal list.  This timer_id can be used to
+   * This method returns a <timer_id> that uniquely identifies the the
+   * @a type entry in an internal list.  This <timer_id> can be used to
    * cancel the timer before it expires.  The cancellation ensures
    * that <timer_ids> are unique up to values of greater than 2
    * billion timers.  As long as timers don't stay around longer than
@@ -185,7 +183,7 @@
    * wrong timer.  Returns -1 on failure (which is guaranteed never to
    * be a valid <timer_id>).
    */
-  virtual long schedule_i (const TYPE& type,
+  virtual long schedule_i (TYPE& type,
                            const void* act,
                            const ACE_Time_Value& future_time,
                            const ACE_Time_Value& interval);
@@ -200,13 +198,14 @@
 
   ACE_Timer_Node_T<TYPE>* get_first_i(void) const;
 
-private:
+ private:
+  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> inherited;
 
   /// Pointer to linked list of <ACE_Timer_Handles>.
   ACE_Timer_Node_T<TYPE>* head_;
 
   /// Iterator used to expire timers.
-  Iterator* iterator_;
+  LIST_ITERATOR_T* iterator_;
 
   /**
    * Keeps track of the timer id that uniquely identifies each timer.
@@ -229,4 +228,4 @@
 #endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */
 
 #include /**/ "ace/post.h"
-#endif /* ACE_TIMER_LIST_T_H */
+#endif /* ACE_TIMER_LIST_T_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_Adapters.cpp ACE_wrappers/ace/Timer_Queue_Adapters.cpp
--- ACE_wrappers_6_2_7/ace/Timer_Queue_Adapters.cpp	2014-08-01 00:53:55.201315300 +0100
+++ ACE_wrappers/ace/Timer_Queue_Adapters.cpp	2014-08-01 12:47:22.929355500 +0100
@@ -24,6 +24,16 @@
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
+template <class TYPE> int
+ACE_Timer_Queue_Adapter_Base<TYPE>::cancel (TYPE&,
+                                            int)
+{
+  ACE_ASSERT (false);
+  ACE_NOTREACHED (return -1);
+
+  return -1;
+}
+
 template <class TQ, class TYPE> TQ &
 ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::timer_queue (void)
 {
@@ -32,13 +42,20 @@
 
 template <class TQ, class TYPE> int
 ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::cancel (long timer_id,
-                                           const void **act)
+                                                 const void **act,
+                                                 int dont_call_handle_close)
 {
   // Block designated signals.
   ACE_Sig_Guard sg (&this->mask_);
   ACE_UNUSED_ARG (sg);
 
-  return this->timer_queue_.cancel (timer_id, act);
+  return this->timer_queue_.cancel (timer_id, act, dont_call_handle_close);
+}
+
+template <class TQ, class TYPE> ACE_Time_Value
+ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::gettimeofday (void)
+{
+  return this->timer_queue_.gettimeofday ();
 }
 
 template <class TQ, class TYPE> int
@@ -70,10 +87,10 @@
 }
 
 template <class TQ, class TYPE> long
-ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::schedule (TYPE eh,
-                                             const void *act,
-                                             const ACE_Time_Value &future_time,
-                                             const ACE_Time_Value &interval)
+ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::schedule (TYPE &eh,
+                                                   const void *act,
+                                                   const ACE_Time_Value &future_time,
+                                                   const ACE_Time_Value &interval)
 {
   ACE_UNUSED_ARG (act);
   ACE_UNUSED_ARG (interval);
@@ -87,9 +104,9 @@
 
   if (tid == -1)
     ACELIB_ERROR_RETURN ((LM_ERROR,
-                       ACE_TEXT ("%p\n"),
-                       ACE_TEXT ("schedule_timer")),
-                      -1);
+                          ACE_TEXT ("%p\n"),
+                          ACE_TEXT ("schedule_timer")),
+                         -1);
 
   if (this->schedule_ualarm () == -1)
     return 0;
@@ -101,79 +118,78 @@
 ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::ACE_Async_Timer_Queue_Adapter (ACE_Sig_Set *mask)
   // If <mask> == 0, block *all* signals when the SIGARLM handler is
   // running, else just block those in the mask.
-  : mask_ (mask)
+ : mask_ (mask)
 {
   // The following code is necessary to selectively "block" certain
   // signals when SIGALRM is running.  Also, we always restart system
   // calls that are interrupted by the signals.
 
-  ACE_Sig_Action sa ((ACE_SignalHandler) 0,
+  ACE_Sig_Action sa ((ACE_SignalHandler)0,
                      this->mask_,
                      SA_RESTART);
 
   if (this->sig_handler_.register_handler (SIGALRM, this, &sa) == -1)
     ACELIB_ERROR ((LM_ERROR,
-                ACE_TEXT ("%p\n"),
-                ACE_TEXT ("register_handler")));
+                   ACE_TEXT ("%p\n"),
+                   ACE_TEXT ("register_handler")));
 }
 
 // This is the signal handler function for the asynchronous timer
 // list.  It gets invoked asynchronously when the SIGALRM signal
 // occurs.
-
 template <class TQ, class TYPE> int
 ACE_Async_Timer_Queue_Adapter<TQ, TYPE>::handle_signal (int signum,
-                                                  siginfo_t *,
-                                                  ucontext_t *)
+                                                        siginfo_t*,
+                                                        ucontext_t*)
 {
   switch (signum)
     {
-    case SIGALRM:
-      {
-        // Expire the pending timers.
-
-        // @@ We need to figure out how to implement interval
-        // timers...
-        this->timer_queue_.expire ();
-
-        // Only schedule a new timer if there is one in the list.
-
-        // @@ This code should also become smarter to avoid
-        // unnecessary calls to ualarm().
-        if (this->timer_queue_.is_empty () == 0)
-          return this->schedule_ualarm ();
-        else
-          return 0;
+      case SIGALRM:
+        {
+          // Expire the pending timers.
+
+          // @@ We need to figure out how to implement interval
+          // timers...
+          this->timer_queue_.expire ();
+
+          // Only schedule a new timer if there is one in the list.
+
+          // @@ This code should also become smarter to avoid
+          // unnecessary calls to ualarm().
+          if (this->timer_queue_.is_empty () == 0)
+            return this->schedule_ualarm ();
+          else
+            return 0;
+          /* NOTREACHED */
+        }
+      default:
+        ACELIB_ERROR_RETURN ((LM_ERROR,
+                              ACE_TEXT ("unexpected signal %S\n"),
+                              signum),
+                             -1);
         /* NOTREACHED */
-      }
-    default:
-      ACELIB_ERROR_RETURN ((LM_ERROR,
-                         "unexpected signal %S\n",
-                         signum),
-                        -1);
-      /* NOTREACHED */
     }
 }
 
-template<class TQ, class TYPE>
+template <class TQ, class TYPE>
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::ACE_Thread_Timer_Queue_Adapter (ACE_Thread_Manager *tm,
-                                                                    TQ* timer_queue)
-  : ACE_Task_Base (tm),
-    timer_queue_(timer_queue),
-    delete_timer_queue_(false),
-    condition_ (mutex_),
-    active_ (true), // Assume that we start in active mode.
-    thr_id_ (ACE_OS::NULL_thread)
+                                                                          TQ* timer_queue)
+ : ACE_Task_Base (tm),
+   timer_queue_ (timer_queue),
+   delete_timer_queue_ (false),
+   condition_ (mutex_),
+   active_ (true), // Assume that we start in active mode.
+   thr_id_ (ACE_OS::NULL_thread)
 {
   if (timer_queue_ == 0)
     {
       ACE_NEW (this->timer_queue_,
-               TQ);
+               TQ ());
       this->delete_timer_queue_ = true;
     }
 }
 
-template<class TQ, class TYPE>
+template <class TQ, class TYPE>
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::~ACE_Thread_Timer_Queue_Adapter (void)
 {
   if (this->delete_timer_queue_)
@@ -189,18 +205,17 @@
     }
 }
 
-template<class TQ, class TYPE> ACE_SYNCH_RECURSIVE_MUTEX &
+template <class TQ, class TYPE> ACE_SYNCH_RECURSIVE_MUTEX &
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::mutex (void)
 {
   return this->mutex_;
 }
 
-template<class TQ, class TYPE> long
-ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::schedule
-    (TYPE handler,
-     const void *act,
-     const ACE_Time_Value &future_time,
-     const ACE_Time_Value &interval)
+template <class TQ, class TYPE> long
+ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::schedule (TYPE &handler,
+                                                    const void *act,
+                                                    const ACE_Time_Value &future_time,
+                                                    const ACE_Time_Value &interval)
 {
   ACE_GUARD_RETURN (ACE_SYNCH_RECURSIVE_MUTEX, guard, this->mutex_, -1);
 
@@ -209,18 +224,36 @@
   return result;
 }
 
-template<class TQ, class TYPE> int
+template <class TQ, class TYPE> int
+ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::cancel (TYPE &type,
+                                                  int dont_call_handle_close)
+{
+  ACE_GUARD_RETURN (ACE_SYNCH_RECURSIVE_MUTEX, guard, this->mutex_, -1);
+
+  int result = this->timer_queue_->cancel (type, dont_call_handle_close);
+  condition_.signal ();
+  return result;
+}
+
+template <class TQ, class TYPE> int
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::cancel (long timer_id,
-                                            const void **act)
+                                                  const void **act,
+                                                  int dont_call_handle_close)
 {
   ACE_GUARD_RETURN (ACE_SYNCH_RECURSIVE_MUTEX, guard, this->mutex_, -1);
 
-  int result = this->timer_queue_->cancel (timer_id, act);
+  int result = this->timer_queue_->cancel (timer_id, act, dont_call_handle_close);
   condition_.signal ();
   return result;
 }
 
-template<class TQ, class TYPE> void
+template <class TQ, class TYPE> ACE_Time_Value
+ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::gettimeofday (void)
+{
+  return this->timer_queue_->gettimeofday ();
+}
+
+template <class TQ, class TYPE> void
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::deactivate (void)
 {
   ACE_GUARD (ACE_SYNCH_RECURSIVE_MUTEX, guard, this->mutex_);
@@ -229,7 +262,7 @@
   this->condition_.signal ();
 }
 
-template<class TQ, class TYPE> int
+template <class TQ, class TYPE> int
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::svc (void)
 {
   ACE_GUARD_RETURN (ACE_SYNCH_RECURSIVE_MUTEX, guard, this->mutex_, -1);
@@ -269,31 +302,21 @@
         {
           // Compute the remaining time, being careful not to sleep
           // for "negative" amounts of time.
-          ACE_Time_Value const tv_curr =
-            this->timer_queue_->gettimeofday ();
           ACE_Time_Value const tv_earl =
             this->timer_queue_->earliest_time ();
+          ACE_Time_Value const tv_curr =
+            this->timer_queue_->gettimeofday ();
 
           if (tv_earl > tv_curr)
             {
-              // The earliest time on the Timer_Queue lies in future;
-              // convert the tv to an absolute time.
-              ACE_Time_Value const tv = this->timer_queue_->gettimeofday () + (tv_earl - tv_curr);
-              // ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("waiting until %u.%3.3u secs\n"),
-              // tv.sec(), tv.msec()));
-              this->condition_.wait (&tv);
+              //ACELIB_DEBUG ((LM_DEBUG,
+              //               ACE_TEXT ("waiting until %u.%3.3u secs\n"),
+              //               tv_earl.sec (), tv_earl.msec ()));
+              this->condition_.wait (&tv_earl);
             }
         }
 
-      // Expire timers anyway, at worst this is a no-op. Release the lock
-      // while dispatching; the timer queue has its own lock to protect
-      // itself.
-      {
-        ACE_Reverse_Lock<ACE_SYNCH_RECURSIVE_MUTEX> rel (this->mutex_);
-        ACE_GUARD_RETURN (ACE_Reverse_Lock<ACE_SYNCH_RECURSIVE_MUTEX>,
-                          rmon, rel, -1);
-        this->timer_queue_->expire ();
-      }
+      this->timer_queue_->expire ();
     }
 
    // Thread cancellation point, if ACE supports it.
@@ -304,18 +327,18 @@
   return 0;
 }
 
-template<class TQ, class TYPE> int
+template <class TQ, class TYPE> int
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::activate (long flags,
-                                              int ,
-                                              int ,
-                                              long priority,
-                                              int grp_id,
-                                              ACE_Task_Base *task,
-                                              ACE_hthread_t [],
-                                              void *stack[],
-                                              size_t stack_size[],
-                                              ACE_thread_t thread_ids[],
-                                              const char* thr_name[])
+                                                    int,
+                                                    int,
+                                                    long priority,
+                                                    int grp_id,
+                                                    ACE_Task_Base *task,
+                                                    ACE_hthread_t [],
+                                                    void *stack[],
+                                                    size_t stack_size[],
+                                                    ACE_thread_t thread_ids[],
+                                                    const char *thr_name[])
 {
   // Make sure to set this flag in case we were deactivated earlier.
   this->active_ = true;
@@ -327,16 +350,14 @@
 }
 
 # if defined (ACE_HAS_DEFERRED_TIMER_COMMANDS)
-
 // Enqueues a command object for execution just before waiting on the next
 // timer event. This allows deferred execution of commands that cannot
 // be performed in the timer event handler context, such as registering
 // or cancelling timers on platforms where the timer queue mutex is not
 // recursive.
-
-template<class TQ, class TYPE> int
+template <class TQ, class TYPE> int
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::enqueue_command (ACE_Command_Base *cmd,
-                                                     COMMAND_ENQUEUE_POSITION pos)
+                                                           COMMAND_ENQUEUE_POSITION pos)
 {
   // Serialize access to the command queue.
   ACE_GUARD_RETURN (ACE_SYNCH_MUTEX, guard, this->command_mutex_, -1);
@@ -349,8 +370,7 @@
 
 // Dispatches all command objects enqueued in the most recent event
 // handler context.
-
-template<class TQ, class TYPE> int
+template <class TQ, class TYPE> int
 ACE_Thread_Timer_Queue_Adapter<TQ, TYPE>::dispatch_commands (void)
 {
   // Serialize access to the command queue.
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_Adapters.h ACE_wrappers/ace/Timer_Queue_Adapters.h
--- ACE_wrappers_6_2_7/ace/Timer_Queue_Adapters.h	2014-08-01 00:53:55.202137500 +0100
+++ ACE_wrappers/ace/Timer_Queue_Adapters.h	2014-07-31 15:23:02.502989700 +0100
@@ -34,6 +34,63 @@
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
+/**
+* @class ACE_Timer_Queue_Adapter_Base
+*
+* @brief interface common to the available timer queue adapter strategies
+*
+* @note used mainly for testing purposes
+*
+*/
+template <class TYPE = ACE_Event_Handler*>
+class ACE_Timer_Queue_Adapter_Base
+{
+ public:
+  virtual ~ACE_Timer_Queue_Adapter_Base (void) {};
+
+  /**
+  * Schedule @a type that will expire at @a future_time,
+  * which is specified in absolute time.  If it expires then @a act is
+  * passed in as the value to the <functor>.  If @a interval is != to
+  * ACE_Time_Value::zero then it is used to reschedule the @a type
+  * automatically, using relative time to the current <gettimeofday>.
+  * This method returns a <timer_id> that is a pointer to a token
+  * which stores information about the event. This <timer_id> can be
+  * used to cancel the timer before it expires.  Returns -1 on
+  * failure.
+  */
+  virtual long schedule (TYPE &type,
+                         const void *act,
+                         const ACE_Time_Value &future_time,
+                         const ACE_Time_Value &interval = ACE_Time_Value::zero) = 0;
+
+  /**
+  * Cancel all timer associated with @a type.  If <dont_call> is 0
+  * then the <functor> will be invoked.  Returns number of timers
+  * cancelled.
+  */
+  virtual int cancel (TYPE &type,
+                      int dont_call_handle_close = 1);
+
+  /**
+  * Cancel the single timer that matches the @a timer_id value (which
+  * was returned from the <schedule> method).  If act is non-NULL
+  * then it will be set to point to the ``magic cookie'' argument
+  * passed in when the timer was registered.  This makes it possible
+  * to free up the memory and avoid memory leaks.  If <dont_call> is
+  * 0 then the <functor> will be invoked.  Returns 1 if cancellation
+  * succeeded and 0 if the @a timer_id wasn't found.
+  */
+  virtual int cancel (long timer_id,
+                      const void **act = 0,
+                      int dont_call_handle_close = 1) = 0;
+
+  /**
+  * Retrieve the time of day (according to the TIME POLICY of the timer queue)
+  */
+  virtual ACE_Time_Value gettimeofday (void) = 0;
+};
+
 class ACE_Sig_Set;
 
 /**
@@ -50,9 +107,11 @@
  * @todo This adapter does not automatically reschedule repeating timers.
  */
 template <class TQ, class TYPE = ACE_Event_Handler*>
-class ACE_Async_Timer_Queue_Adapter : public ACE_Event_Handler
+class ACE_Async_Timer_Queue_Adapter
+ : public ACE_Timer_Queue_Adapter_Base<TYPE>,
+   public ACE_Event_Handler
 {
-public:
+ public:
   typedef TQ TIMER_QUEUE;
 
   /// Constructor
@@ -70,14 +129,21 @@
    * calling expire().  Note that interval timers are not implemented
    * yet.
    */
-  long schedule (TYPE type,
-                 const void *act,
-                 const ACE_Time_Value &future_time,
-                 const ACE_Time_Value &interval = ACE_Time_Value::zero);
+  virtual long schedule (TYPE &type,
+                         const void *act,
+                         const ACE_Time_Value &future_time,
+                         const ACE_Time_Value &interval = ACE_Time_Value::zero);
 
   /// Cancel the @a timer_id and pass back the @a act if an address is
   /// passed in.
-  int cancel (long timer_id, const void **act = 0);
+  virtual int cancel (long timer_id,
+                      const void **act = 0,
+                      int dont_call_handle_close = 1);
+
+  /**
+  * Retrieve the time of day (according to the TIME POLICY of the timer queue)
+  */
+  virtual ACE_Time_Value gettimeofday (void);
 
   /// Dispatch all timers with expiry time at or before the current time.
   /// Returns the number of timers expired.
@@ -86,7 +152,7 @@
   /// Return a reference to the underlying timer queue.
   TQ &timer_queue (void);
 
-private:
+ private:
   /// Perform the logic to compute the new ualarm(2) setting.
   virtual int schedule_ualarm (void);
 
@@ -120,9 +186,11 @@
  *
  */
 template <class TQ, class TYPE = ACE_Event_Handler*>
-class ACE_Thread_Timer_Queue_Adapter : public ACE_Task_Base
+class ACE_Thread_Timer_Queue_Adapter
+ : public ACE_Timer_Queue_Adapter_Base<TYPE>,
+   public ACE_Task_Base
 {
-public:
+ public:
   /// Trait for the underlying queue type.
   typedef TQ TIMER_QUEUE;
 
@@ -145,14 +213,29 @@
 
   /// Schedule the timer according to the semantics of the <TQ>; wakes
   /// up the dispatching thread.
-  long schedule (TYPE handler,
-                 const void *act,
-                 const ACE_Time_Value &future_time,
-                 const ACE_Time_Value &interval = ACE_Time_Value::zero);
+  virtual long schedule (TYPE &handler,
+                         const void *act,
+                         const ACE_Time_Value &future_time,
+                         const ACE_Time_Value &interval = ACE_Time_Value::zero);
+
+  /**
+  * Cancel all timer associated with @a type.  If <dont_call> is 0
+  * then the <functor> will be invoked.  Returns number of timers
+  * cancelled.
+  */
+  virtual int cancel (TYPE &type,
+                      int dont_call_handle_close = 1);
 
   /// Cancel the @a timer_id and return the @a act parameter if an
   /// address is passed in. Also wakes up the dispatching thread.
-  int cancel (long timer_id, const void **act = 0);
+  virtual int cancel (long timer_id,
+                      const void **act = 0,
+                      int dont_call_handle_close = 1);
+
+  /**
+  * Retrieve the time of day (according to the TIME POLICY of the timer queue)
+  */
+  virtual ACE_Time_Value gettimeofday (void);
 
   /// Runs the dispatching thread.
   virtual int svc (void);
@@ -203,15 +286,14 @@
 
 # endif /* ACE_HAS_DEFERRED_TIMER_COMMANDS */
 
-private:
-
+ private:
 # if defined (ACE_HAS_DEFERRED_TIMER_COMMANDS)
   /// Dispatches all command objects enqueued in the most
   /// recent event handler context.
   int dispatch_commands (void);
 
   /// Queue of commands for deferred execution.
-  ACE_Unbounded_Queue<ACE_Command_Base *> command_queue_;
+  ACE_Unbounded_Queue<ACE_Command_Base*> command_queue_;
 
   /// The mutual exclusion mechanism for the command queue.
   ACE_SYNCH_MUTEX command_mutex_;
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue.h ACE_wrappers/ace/Timer_Queue.h
--- ACE_wrappers_6_2_7/ace/Timer_Queue.h	2014-08-01 00:53:55.200105800 +0100
+++ ACE_wrappers/ace/Timer_Queue.h	2014-07-15 22:18:53.109053800 +0100
@@ -34,17 +34,13 @@
 
 // The following typedef are here for ease of use and backward
 // compatibility.
-typedef ACE_Timer_Node_Dispatch_Info_T<ACE_Event_Handler *>
-        ACE_Timer_Node_Dispatch_Info;
+typedef ACE_Timer_Node_Dispatch_Info_T<ACE_Event_Handler*> ACE_Timer_Node_Dispatch_Info;
+typedef ACE_Timer_Node_T<ACE_Event_Handler*> ACE_Timer_Node;
 
-typedef ACE_Timer_Node_T<ACE_Event_Handler *>
-        ACE_Timer_Node;
-
-typedef ACE_Timer_Queue_Iterator_T<ACE_Event_Handler *>
-        ACE_Timer_Queue_Iterator;
+typedef ACE_Timer_Queue_Iterator_T<ACE_Event_Handler*> ACE_Timer_Queue_Iterator;
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
 #include /**/ "ace/post.h"
 
-#endif /* ACE_TIMER_QUEUE_H */
+#endif /* ACE_TIMER_QUEUE_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_Iterator.h ACE_wrappers/ace/Timer_Queue_Iterator.h
--- ACE_wrappers_6_2_7/ace/Timer_Queue_Iterator.h	2014-08-01 00:53:55.204026000 +0100
+++ ACE_wrappers/ace/Timer_Queue_Iterator.h	2014-07-15 22:18:53.171556000 +0100
@@ -54,7 +54,7 @@
   typedef ACE_Timer_Node_Dispatch_Info_T <TYPE> DISPATCH_INFO;
 
   /// Singly linked list
-  void set (const TYPE &type,
+  void set (TYPE &type,
             const void *a,
             const ACE_Time_Value &t,
             const ACE_Time_Value &i,
@@ -62,7 +62,7 @@
             long timer_id);
 
   /// Doubly linked list version
-  void set (const TYPE &type,
+  void set (TYPE &type,
             const void *a,
             const ACE_Time_Value &t,
             const ACE_Time_Value &i,
@@ -197,4 +197,4 @@
 #endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */
 
 #include /**/ "ace/post.h"
-#endif /* ACE_TIMER_QUEUE_ITERATOR_H */
+#endif /* ACE_TIMER_QUEUE_ITERATOR_H */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_Iterator.inl ACE_wrappers/ace/Timer_Queue_Iterator.inl
--- ACE_wrappers_6_2_7/ace/Timer_Queue_Iterator.inl	2014-08-01 00:53:55.204660500 +0100
+++ ACE_wrappers/ace/Timer_Queue_Iterator.inl	2014-07-15 22:18:53.202812500 +0100
@@ -5,7 +5,7 @@
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 template <class TYPE> ACE_INLINE void
-ACE_Timer_Node_T<TYPE>::set (const TYPE &type,
+ACE_Timer_Node_T<TYPE>::set (TYPE &type,
                              const void *a,
                              const ACE_Time_Value &t,
                              const ACE_Time_Value &i,
@@ -21,7 +21,7 @@
 }
 
 template <class TYPE> ACE_INLINE void
-ACE_Timer_Node_T<TYPE>::set (const TYPE &type,
+ACE_Timer_Node_T<TYPE>::set (TYPE &type,
                              const void *a,
                              const ACE_Time_Value &t,
                              const ACE_Time_Value &i,
@@ -132,4 +132,4 @@
     this->interval_ > ACE_Time_Value::zero;
 }
 
-ACE_END_VERSIONED_NAMESPACE_DECL
+ACE_END_VERSIONED_NAMESPACE_DECL
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_T.cpp ACE_wrappers/ace/Timer_Queue_T.cpp
--- ACE_wrappers_6_2_7/ace/Timer_Queue_T.cpp	2014-08-01 00:53:55.205260400 +0100
+++ ACE_wrappers/ace/Timer_Queue_T.cpp	2014-08-01 19:59:48.479647600 +0100
@@ -35,41 +35,134 @@
 #  define ACE_TIMER_SKEW 0
 #endif /* ACE_TIMER_SKEW */
 
-template <class TYPE, class FUNCTOR> ACE_INLINE
-ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::ACE_Timer_Queue_Upcall_Base (FUNCTOR * upcall_functor)
-  : ACE_Abstract_Timer_Queue<TYPE>()
-  , ACE_Copy_Disabled()
-  , upcall_functor_(upcall_functor)
-  , delete_upcall_functor_ (upcall_functor == 0)
+template <class TQ_TYPE, class TYPE>
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::ACE_Timer_Queue_Functor_Base ()
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::ACE_Timer_Queue_Functor_Base");
+
+}
+
+template <class TQ_TYPE, class TYPE>
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::~ACE_Timer_Queue_Functor_Base ()
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::~ACE_Timer_Queue_Functor_Base");
+
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::registration (TQ_TYPE*,
+                                                           TYPE&,
+                                                           const void*)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::registration");
+
+  return 0;
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::preinvoke (TQ_TYPE*,
+                                                        TYPE&,
+                                                        const void*,
+                                                        int,
+                                                        const ACE_Time_Value&,
+                                                        const void*&)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::preinvoke");
+
+  return 0;
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::timeout (TQ_TYPE*,
+                                                      TYPE&,
+                                                      const void*,
+                                                      int,
+                                                      const ACE_Time_Value&)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::timeout");
+
+  return 0;
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::postinvoke (TQ_TYPE*,
+                                                         TYPE&,
+                                                         const void*,
+                                                         int,
+                                                         const ACE_Time_Value&,
+                                                         const void*)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::postinvoke");
+
+  return 0;
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::cancel_type (TQ_TYPE*,
+                                                          TYPE&,
+                                                          int,
+                                                          int&)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::cancel_type");
+
+  return 0;
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::cancel_timer (TQ_TYPE*,
+                                                           TYPE&,
+                                                           int,
+                                                           int)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::cancel_timer");
+
+  return 0;
+}
+
+template <class TQ_TYPE, class TYPE> int
+ACE_Timer_Queue_Functor_Base<TQ_TYPE, TYPE>::deletion (TQ_TYPE*,
+                                                       TYPE&,
+                                                       const void*)
+{
+  ACE_TRACE ("ACE_Timer_Queue_Functor_Base::deletion");
+
+  return 0;
+}
+
+template <class FUNCTOR>
+ACE_Timer_Queue_Upcall_Base<FUNCTOR>::ACE_Timer_Queue_Upcall_Base (FUNCTOR *upcall_functor)
+ : upcall_functor_ (upcall_functor)
+ , delete_upcall_functor_ (upcall_functor == 0)
 {
   ACE_TRACE ("ACE_Timer_Queue_Upcall_Base::ACE_Timer_Queue_Upcall_Base");
 
   if (upcall_functor != 0)
-    {
-      return;
-    }
+    return;
 
-  ACE_NEW (upcall_functor_, FUNCTOR);
+  ACE_NEW (upcall_functor_, FUNCTOR ());
 }
 
-template <class TYPE, class FUNCTOR> ACE_INLINE
-ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::~ACE_Timer_Queue_Upcall_Base ()
+template <class FUNCTOR>
+ACE_Timer_Queue_Upcall_Base<FUNCTOR>::~ACE_Timer_Queue_Upcall_Base ()
 {
   ACE_TRACE ("ACE_Timer_Queue_Upcall_Base::~ACE_Timer_Queue_Upcall_Base");
+
   if (this->delete_upcall_functor_)
-    {
-      delete this->upcall_functor_;
-    }
+    delete this->upcall_functor_;
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value
-ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::gettimeofday()
+ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::gettimeofday ()
 {
-  return this->gettimeofday_static();
+  // *TODO*: add timer skew here ?
+  //ACE_Time_Value tv = this->gettimeofday_static ();
+  // tv += this->timer_skew();
+  //return tv;
+  return this->gettimeofday_static ();
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
-ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::gettimeofday (ACE_Time_Value (*gettimeofday)(void))
+ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::gettimeofday (ACE_Time_Value (*gettimeofday) (void))
 {
   this->time_policy_.set_gettimeofday (gettimeofday);
 }
@@ -78,42 +171,40 @@
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::calculate_timeout (ACE_Time_Value *max_wait_time)
 {
   ACE_TRACE ("ACE_Timer_Queue_T::calculate_timeout");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, max_wait_time));
 
   if (this->is_empty ())
-    // Nothing on the Timer_Queue, so use whatever the caller gave us.
-    return max_wait_time;
-  else
     {
-      ACE_Time_Value const cur_time = this->gettimeofday_static ();
+      // Nothing on the Timer_Queue, so use whatever the caller gave us.
+      return max_wait_time;
+    }
 
-      if (this->earliest_time () > cur_time)
-        {
-          // The earliest item on the Timer_Queue is still in the
-          // future.  Therefore, use the smaller of (1) caller's wait
-          // time or (2) the delta time between now and the earliest
-          // time on the Timer_Queue.
+  ACE_Time_Value const cur_time = this->gettimeofday_static ();
+  if (this->earliest_time () > cur_time)
+  {
+    // The earliest item on the Timer_Queue is still in the
+    // future.  Therefore, use the smaller of (1) caller's wait
+    // time or (2) the delta time between now and the earliest
+    // time on the Timer_Queue.
+
+    this->timeout_ = this->earliest_time () - cur_time;
+    if (max_wait_time == 0 || *max_wait_time > timeout_)
+      return &this->timeout_;
+    else
+      return max_wait_time;
+  }
 
-          this->timeout_ = this->earliest_time () - cur_time;
-          if (max_wait_time == 0 || *max_wait_time > timeout_)
-            return &this->timeout_;
-          else
-            return max_wait_time;
-        }
-      else
-        {
-          // The earliest item on the Timer_Queue is now in the past.
-          // Therefore, we've got to "poll" the Reactor, i.e., it must
-          // just check the descriptors and then dispatch timers, etc.
-          this->timeout_ = ACE_Time_Value::zero;
-          return &this->timeout_;
-        }
-    }
+  // The earliest item on the Timer_Queue is now in the past.
+  // Therefore, we've got to "poll" the Reactor, i.e., it must
+  // just check the descriptors and then dispatch timers, etc.
+  this->timeout_ = ACE_Time_Value::zero;
+  return &this->timeout_;
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value *
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::calculate_timeout (ACE_Time_Value *max_wait_time,
-                                                               ACE_Time_Value *the_timeout)
+                                                                            ACE_Time_Value *the_timeout)
 {
   ACE_TRACE ("ACE_Timer_Queue_T::calculate_timeout");
 
@@ -156,14 +247,6 @@
   return the_timeout;
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value
-ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::current_time()
-{
-  ACE_Time_Value tv = this->gettimeofday_static ();
-  tv += this->timer_skew();
-  return tv;
-}
-
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dump (void) const
 {
@@ -178,20 +261,21 @@
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Queue_T (FUNCTOR *upcall_functor,
-                                          ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
-                                          TIME_POLICY const & time_policy)
-  : ACE_Timer_Queue_Upcall_Base<TYPE,FUNCTOR>(upcall_functor),
-    time_policy_ (time_policy),
-    delete_free_list_ (freelist == 0),
-    timer_skew_ (0, ACE_TIMER_SKEW)
+                                                                            ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
+                                                                            TIME_POLICY const & time_policy)
+ : ACE_Timer_Queue_Upcall_Base<FUNCTOR> (upcall_functor)
+ , free_list_ (freelist)
+ , time_policy_ (time_policy)
+ , delete_free_list_ (freelist == 0)
+ , timer_skew_ (0, ACE_TIMER_SKEW)
 {
   ACE_TRACE ("ACE_Timer_Queue_T::ACE_Timer_Queue_T");
 
-  if (!freelist)
+  typedef ACE_Locked_Free_List<ACE_Timer_Node_T<TYPE>,
+                               ACE_SYNCH_NULL_MUTEX> LOCKED_FREELIST_T;
+  if (!free_list_)
     ACE_NEW (free_list_,
-             (ACE_Locked_Free_List<ACE_Timer_Node_T<TYPE>,ACE_Null_Mutex>));
-  else
-    free_list_ = freelist;
+             LOCKED_FREELIST_T ());
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
@@ -223,10 +307,10 @@
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
-ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule (const TYPE &type,
-                                                      const void *act,
-                                                      const ACE_Time_Value &future_time,
-                                                      const ACE_Time_Value &interval)
+ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule (TYPE &type,
+                                                                   const void *act,
+                                                                   const ACE_Time_Value &future_time,
+                                                                   const ACE_Time_Value &interval)
 {
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
@@ -242,7 +326,7 @@
     return result;
 
   // Inform upcall functor of successful registration.
-  this->upcall_functor ().registration (*this,
+  this->upcall_functor ().registration (this,
                                         type,
                                         act);
 
@@ -301,9 +385,8 @@
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
-ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recompute_next_abs_interval_time
-    (ACE_Timer_Node_T<TYPE> *expired,
-     const ACE_Time_Value &cur_time)
+ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recompute_next_abs_interval_time (ACE_Timer_Node_T<TYPE> *expired,
+                                                                                           const ACE_Time_Value &cur_time)
 {
   if ( expired->get_timer_value () <= cur_time )
     {
@@ -361,12 +444,13 @@
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
-ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire_single (
-    ACE_Command_Base & pre_dispatch_command)
+ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire_single (ACE_Command_Base & pre_dispatch_command)
 {
   ACE_TRACE ("ACE_Timer_Queue_T::expire_single");
+
   ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
   ACE_Time_Value cur_time;
+
   {
     // Create a scope for the lock ...
     ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
@@ -406,7 +490,7 @@
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dispatch_info_i (const ACE_Time_Value &cur_time,
-                                                             ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
+                                                                          ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
 {
   ACE_TRACE ("ACE_Timer_Queue_T::dispatch_info_i");
 
@@ -449,9 +533,10 @@
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::return_node (ACE_Timer_Node_T<TYPE> *node)
 {
   ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
+
   this->free_node (node);
 }
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
-#endif /* ACE_TIMER_QUEUE_T_CPP */
+#endif /* ACE_TIMER_QUEUE_T_CPP */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_T.h ACE_wrappers/ace/Timer_Queue_T.h
--- ACE_wrappers_6_2_7/ace/Timer_Queue_T.h	2014-08-01 00:53:55.206154800 +0100
+++ ACE_wrappers/ace/Timer_Queue_T.h	2014-08-01 18:15:05.781342900 +0100
@@ -26,11 +26,78 @@
 #include "ace/Abstract_Timer_Queue.h"
 #include "ace/Timer_Queue_Iterator.h"
 #include "ace/Time_Policy.h"
-#include "ace/Copy_Disabled.h"
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 /**
+* @class ACE_Timer_Queue_Functor_Base
+*
+* @brief Functor for timer queues.
+*
+* This class defines the functor base-class required by a timer
+* queue to call <handle_timeout> on event handlers.
+* Note that the polymorphism isn't currently used for performance
+* reasons (FUNCTORs are implemented as type traits for now, see below)
+*/
+template <class TQ_TYPE, class TYPE>
+class ACE_Timer_Queue_Functor_Base
+{
+ public:
+  // = Initialization and termination methods.
+  /// Constructor.
+  ACE_Timer_Queue_Functor_Base (void);
+
+  /// Destructor.
+  virtual ~ACE_Timer_Queue_Functor_Base (void);
+
+  /// This method is called when a timer is registered.
+  virtual int registration (TQ_TYPE *timer_queue,
+                            TYPE &handler,
+                            const void *arg);
+
+  /// This method is called before the timer expires.
+  virtual int preinvoke (TQ_TYPE *timer_queue,
+                         TYPE &handler,
+                         const void *arg,
+                         int recurring_timer,
+                         const ACE_Time_Value &cur_time,
+                         const void *&upcall_act);
+
+  /// This method is called when the timer expires.
+  virtual int timeout (TQ_TYPE *timer_queue,
+                       TYPE &handler,
+                       const void *arg,
+                       int recurring_timer,
+                       const ACE_Time_Value &cur_time);
+
+  /// This method is called after the timer expires.
+  virtual int postinvoke (TQ_TYPE *timer_queue,
+                          TYPE &handler,
+                          const void *arg,
+                          int recurring_timer,
+                          const ACE_Time_Value &cur_time,
+                          const void *upcall_act);
+
+  /// This method is called when a handler is cancelled
+  virtual int cancel_type (TQ_TYPE *timer_queue,
+                           TYPE &handler,
+                           int dont_call,
+                           int &requires_reference_counting);
+
+  /// This method is called when a timer is cancelled
+  virtual int cancel_timer (TQ_TYPE *timer_queue,
+                            TYPE &handler,
+                            int dont_call,
+                            int requires_reference_counting);
+
+  /// This method is called when the timer queue is destroyed and
+  /// the timer is still contained in it
+  virtual int deletion (TQ_TYPE *timer_queue,
+                        TYPE &handler,
+                        const void *arg);
+};
+
+/**
  * @class ACE_Timer_Queue_Upcall_Base
  *
  * Common base class for all timer queues with the same time source
@@ -38,27 +105,38 @@
  * namely the ACE_Proactor needs to set a backpointer in the upcall
  * functor.
  */
-template<typename TYPE, typename FUNCTOR>
+template <typename FUNCTOR>
 class ACE_Timer_Queue_Upcall_Base
-  : public ACE_Abstract_Timer_Queue<TYPE>
-  , private ACE_Copy_Disabled
 {
-public:
+ public:
+  typedef FUNCTOR UPCALL_FUNCTOR_T;
+
   // Constructor
-  explicit ACE_Timer_Queue_Upcall_Base(FUNCTOR * upcall_functor = 0);
+  explicit ACE_Timer_Queue_Upcall_Base (FUNCTOR *upcall_functor = 0);
 
   /// Destructor
   virtual ~ACE_Timer_Queue_Upcall_Base (void);
 
   /// Accessor to the upcall functor
-  FUNCTOR & upcall_functor (void);
+  FUNCTOR &upcall_functor (void);
+
+  /// Setter to the upcall functor
+  void upcall_functor (FUNCTOR *upcall_functor,
+                       const bool& delete_upcall_functor = false);
+
+  /// Make default upcall functor
+  /// Note: return value needs to be freed !
+  static FUNCTOR *make_functor (void);
+
+ private:
+  ACE_UNIMPLEMENTED_FUNC (ACE_Timer_Queue_Upcall_Base (const ACE_Timer_Queue_Upcall_Base&));
+  ACE_UNIMPLEMENTED_FUNC (ACE_Timer_Queue_Upcall_Base &operator= (const ACE_Timer_Queue_Upcall_Base&));
 
-protected:
   /// Upcall functor
   FUNCTOR *upcall_functor_;
 
   /// To delete or not to delete is the question?
-  bool const delete_upcall_functor_;
+  bool delete_upcall_functor_;
 };
 
 /**
@@ -66,15 +144,15 @@
  *
  * @brief Provides an interface to timers.
  *
- * This is an abstract base class that provides hook for
- * implementing specialized policies such as ACE_Timer_List
- * and ACE_Timer_Heap.
+ * This is an abstract base class that provides functionality common to
+ * more specialized policies such as ACE_Timer_List and ACE_Timer_Heap.
  */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
 class ACE_Timer_Queue_T
-  : public ACE_Timer_Queue_Upcall_Base<TYPE,FUNCTOR>
+ : public ACE_Abstract_Timer_Queue<TYPE>,
+   public ACE_Timer_Queue_Upcall_Base<FUNCTOR>
 {
-public:
+ public:
   // = Initialization and termination methods.
   /**
    * Default constructor. @a upcall_functor is the instance of the
@@ -83,8 +161,8 @@
    * timer nodes.  If 0, then a default freelist will be created.
    */
   ACE_Timer_Queue_T (FUNCTOR *upcall_functor = 0,
-                    ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist = 0,
-                    TIME_POLICY const & time_policy = TIME_POLICY());
+                     ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist = 0,
+                     TIME_POLICY const & time_policy = TIME_POLICY());
 
   /// Destructor - make virtual for proper destruction of inherited
   /// classes.
@@ -94,7 +172,7 @@
    * Implement ACE_Abstract_Timer_Queue<TYPE>::schedule () with the right
    * locking strategy.
    */
-  virtual long schedule (const TYPE &type,
+  virtual long schedule (TYPE &type,
                          const void *act,
                          const ACE_Time_Value &future_time,
                          const ACE_Time_Value &interval = ACE_Time_Value::zero);
@@ -106,7 +184,7 @@
    */
   virtual int expire (const ACE_Time_Value &current_time);
   virtual int expire (void);
-  virtual int expire_single(ACE_Command_Base & pre_dispatch_command);
+  virtual int expire_single (ACE_Command_Base & pre_dispatch_command);
   //@}
 
   /**
@@ -117,12 +195,13 @@
    */
   virtual int dispatch_info (const ACE_Time_Value &current_time,
                              ACE_Timer_Node_Dispatch_Info_T<TYPE> &info);
-  //@{
+
   /**
-   * Implement the gettimeofday() virtual function
-   */
+  * Returns the current time of day.  This method allows different
+  * implementations of the timer queue to use special high resolution
+  * timers.
+  */
   virtual ACE_Time_Value gettimeofday (void);
-  //@}
 
   /**
    * Allows applications to control how the timer queue gets the time
@@ -132,11 +211,9 @@
    *             is ACE_FPointer_Time_Policy. Other standard ACE time
    *             policies will ignore this.
    */
-  virtual void gettimeofday (ACE_Time_Value (*gettimeofday)(void));
+  virtual void gettimeofday (ACE_Time_Value (*gettimeofday) (void));
 
-  /// Implement an inlined, non-abstract version of gettimeofday(),
-  /// through this  member function the internals of the class can
-  /// make calls to  ACE_OS::gettimeofday() with zero overhead.
+  /// Retrieve the current time of day (according to the TIME_POLICY).
   ACE_Time_Value gettimeofday_static();
 
   /// Allows applications to control how the timer queue gets the time
@@ -153,7 +230,6 @@
   virtual ACE_Time_Value *calculate_timeout (ACE_Time_Value *max);
   virtual ACE_Time_Value *calculate_timeout (ACE_Time_Value *max,
                                              ACE_Time_Value *the_timeout);
-  virtual ACE_Time_Value current_time();
   //@}
 
   /// Set the timer skew for the Timer_Queue.
@@ -186,10 +262,9 @@
                    const ACE_Time_Value &cur_time,
                    const void *upcall_act);
 
-protected:
-
+ protected:
   /// Schedule a timer.
-  virtual long schedule_i (const TYPE &type,
+  virtual long schedule_i (TYPE &type,
                            const void *act,
                            const ACE_Time_Value &future_time,
                            const ACE_Time_Value &interval) = 0;
@@ -222,10 +297,9 @@
   TIME_POLICY time_policy_;
 
   /// Flag to delete only if the class created the <free_list_>
-  bool const delete_free_list_;
-
-private:
+  bool delete_free_list_;
 
+ private:
   /// Returned by <calculate_timeout>.
   ACE_Time_Value timeout_;
 
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Queue_T.inl ACE_wrappers/ace/Timer_Queue_T.inl
--- ACE_wrappers_6_2_7/ace/Timer_Queue_T.inl	2014-08-01 00:53:55.206924400 +0100
+++ ACE_wrappers/ace/Timer_Queue_T.inl	2014-07-30 20:34:58.844603300 +0100
@@ -4,12 +4,33 @@
 
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
-template <class TYPE, class FUNCTOR> ACE_INLINE FUNCTOR &
-ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::upcall_functor (void)
+template <class FUNCTOR> ACE_INLINE FUNCTOR &
+ACE_Timer_Queue_Upcall_Base<FUNCTOR>::upcall_functor ()
 {
   return *this->upcall_functor_;
 }
 
+template <class FUNCTOR> ACE_INLINE void
+ACE_Timer_Queue_Upcall_Base<FUNCTOR>::upcall_functor (FUNCTOR *upcall_functor,
+                                                      const bool& delete_upcall_functor)
+{
+  // clean up ?
+  if (delete_upcall_functor_)
+    delete upcall_functor_;
+
+  upcall_functor_ = upcall_functor;
+  delete_upcall_functor_ = (upcall_functor && delete_upcall_functor);
+}
+
+template <class FUNCTOR> ACE_INLINE FUNCTOR *
+ACE_Timer_Queue_Upcall_Base<FUNCTOR>::make_functor()
+{
+  FUNCTOR* functor = 0;
+  ACE_NEW_NORETURN (functor, FUNCTOR ());
+
+  return functor;
+}
+
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_INLINE void
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::timer_skew (const ACE_Time_Value &skew)
 {
@@ -24,9 +45,10 @@
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dispatch_info (const ACE_Time_Value &cur_time,
-                                                           ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
+                                                                        ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
 {
   ACE_TRACE ("ACE_Timer_Queue_T::dispatch_info");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, 0));
 
   return this->dispatch_info_i (cur_time, info);
@@ -34,9 +56,9 @@
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_INLINE void
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::upcall (ACE_Timer_Node_Dispatch_Info_T<TYPE> &info,
-                                                    const ACE_Time_Value &cur_time)
+                                                                 const ACE_Time_Value &cur_time)
 {
-  this->upcall_functor ().timeout (*this,
+  this->upcall_functor ().timeout (this,
                                    info.type_,
                                    info.act_,
                                    info.recurring_timer_,
@@ -45,10 +67,10 @@
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_INLINE void
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::preinvoke (ACE_Timer_Node_Dispatch_Info_T<TYPE> &info,
-                                                       const ACE_Time_Value &cur_time,
-                                                       const void *&upcall_act)
+                                                                    const ACE_Time_Value &cur_time,
+                                                                    const void *&upcall_act)
 {
-  this->upcall_functor ().preinvoke (*this,
+  this->upcall_functor ().preinvoke (this,
                                      info.type_,
                                      info.act_,
                                      info.recurring_timer_,
@@ -58,10 +80,10 @@
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_INLINE void
 ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::postinvoke (ACE_Timer_Node_Dispatch_Info_T<TYPE> &info,
-                                                        const ACE_Time_Value &cur_time,
-                                                        const void *upcall_act)
+                                                                     const ACE_Time_Value &cur_time,
+                                                                     const void *upcall_act)
 {
-  this->upcall_functor ().postinvoke (*this,
+  this->upcall_functor ().postinvoke (this,
                                       info.type_,
                                       info.act_,
                                       info.recurring_timer_,
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Wheel.h ACE_wrappers/ace/Timer_Wheel.h
--- ACE_wrappers_6_2_7/ace/Timer_Wheel.h	2014-08-01 00:53:55.207385900 +0100
+++ ACE_wrappers/ace/Timer_Wheel.h	2014-07-31 01:30:44.751021700 +0100
@@ -16,7 +16,10 @@
 #include /**/ "ace/pre.h"
 
 #include "ace/Timer_Wheel_T.h"
+#include "ace/Event_Handler.h"
 #include "ace/Event_Handler_Handle_Timeout_Upcall.h"
+#include "ace/Synch.h"
+#include "ace/Time_Policy.h"
 
 #if !defined (ACE_LACKS_PRAGMA_ONCE)
 # pragma once
@@ -27,16 +30,11 @@
 // The following typedefs are here for ease of use and backward
 // compatibility.
 
-typedef ACE_Timer_Wheel_T<ACE_Event_Handler *,
-                         ACE_Event_Handler_Handle_Timeout_Upcall,
-                         ACE_SYNCH_RECURSIVE_MUTEX>
-        ACE_Timer_Wheel;
-
-typedef ACE_Timer_Wheel_Iterator_T<ACE_Event_Handler *,
-                                   ACE_Event_Handler_Handle_Timeout_Upcall,
-                                   ACE_SYNCH_RECURSIVE_MUTEX,
-                                   ACE_Default_Time_Policy>
-        ACE_Timer_Wheel_Iterator;
+typedef ACE_Timer_Wheel_T<ACE_Event_Handler*,
+                          ACE_Event_Handler_Handle_Timeout_Upcall,
+                          ACE_SYNCH_RECURSIVE_MUTEX,
+                          ACE_Default_Time_Policy> ACE_Timer_Wheel;
+typedef ACE_Timer_Wheel::WHEEL_ITERATOR_T ACE_Timer_Wheel_Iterator;
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Wheel_T.cpp ACE_wrappers/ace/Timer_Wheel_T.cpp
--- ACE_wrappers_6_2_7/ace/Timer_Wheel_T.cpp	2014-08-01 00:53:55.208551000 +0100
+++ ACE_wrappers/ace/Timer_Wheel_T.cpp	2014-08-01 18:51:29.172123500 +0100
@@ -43,21 +43,21 @@
 * @param freelist       A pointer to a freelist to use instead of the default
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Wheel_T
-(FUNCTOR* upcall_functor
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Wheel_T (
+   FUNCTOR* upcall_functor
  , FreeList* freelist
- , TIME_POLICY const & time_policy
- )
-  : Base_Timer_Queue (upcall_functor, freelist, time_policy)
-, spokes_(0)
-, spoke_count_(0) // calculated in open_i
-, spoke_bits_(0)
-, res_bits_ (0)
-, earliest_spoke_ (0)
-, iterator_(0)
-, timer_count_(0)
+ , TIME_POLICY const & time_policy)
+ : inherited (upcall_functor, freelist, time_policy)
+ , spokes_ (0)
+ , spoke_count_ (0) // calculated in open_i
+ , spoke_bits_ (0)
+ , res_bits_ (0)
+ , earliest_spoke_ (0)
+ , iterator_ (0)
+ , timer_count_ (0)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::ACE_Timer_Wheel_T");
+
   this->open_i (0,
                 ACE_DEFAULT_TIMER_WHEEL_SIZE,
                 ACE_DEFAULT_TIMER_WHEEL_RESOLUTION);
@@ -74,30 +74,33 @@
 * @param freelist       A pointer to a freelist to use instead of the default
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Wheel_T
-  (u_int spoke_count,
-   u_int resolution,
-   size_t prealloc,
-   FUNCTOR* upcall_functor,
-   FreeList* freelist,
-   TIME_POLICY const & time_policy)
-: Base_Timer_Queue (upcall_functor, freelist, time_policy)
-, spokes_ (0)
-, spoke_count_ (0) // calculated in open_i
-, spoke_bits_ (0)
-, res_bits_ (0)
-, earliest_spoke_ (0)
-, iterator_ (0)
-, timer_count_ (0)
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Wheel_T (
+   u_int spoke_count
+ , u_int resolution
+ , size_t prealloc
+ , FUNCTOR* upcall_functor
+ , FreeList* freelist
+ , TIME_POLICY const & time_policy)
+ : inherited (upcall_functor, freelist, time_policy)
+ , spokes_ (0)
+ , spoke_count_ (0) // calculated in open_i
+ , spoke_bits_ (0)
+ , res_bits_ (0)
+ , earliest_spoke_ (0)
+ , iterator_ (0)
+ , timer_count_ (0)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::ACE_Timer_Wheel_T");
-  this->open_i (prealloc, spoke_count, resolution);
+
+  this->open_i (prealloc,
+                spoke_count,
+                resolution);
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::power2bits (int n,
-                                                        int min_bits,
-                                                        int max_bits)
+                                                                     int min_bits,
+                                                                     int max_bits)
 {
   int max = (1 << max_bits) - 1;
   if (n > max)
@@ -131,8 +134,10 @@
 * information.
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::open_i
-  (size_t prealloc, u_int spokes, u_int res)
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::open_i (
+   size_t prealloc
+ , u_int spokes
+ , u_int res)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::open_i");
 
@@ -151,17 +156,26 @@
 
   this->wheel_time_.msec (1 << (this->res_bits_));
 
-  ACE_NEW (this->spokes_, ACE_Timer_Node_T<TYPE>* [this->spoke_count_]);
+  ACE_NEW (this->spokes_,
+           ACE_Timer_Node_T<TYPE>* [this->spoke_count_]);
 
-  // Create the root nodes. These will be treated specially
+  // Create the root nodes. These will be treated differently
+  TYPE eh = 0;
   for (u_int i = 0; i < this->spoke_count_; ++i)
   {
     ACE_Timer_Node_T<TYPE>* root = this->alloc_node ();
-    root->set (0, 0, ACE_Time_Value::zero, ACE_Time_Value::zero, root, root, 0);
+    root->set (eh,
+               0,
+               ACE_Time_Value::zero,
+               ACE_Time_Value::zero,
+               root,
+               root,
+               0);
     this->spokes_[i] = root;
   }
 
-  ACE_NEW (iterator_, Iterator (*this));
+  ACE_NEW (iterator_,
+           WHEEL_ITERATOR_T (*this));
 }
 
 /// Destructor just cleans up its memory
@@ -180,7 +194,7 @@
     this->free_node (root);
   }
 
-  delete[] this->spokes_;
+  delete [] this->spokes_;
 }
 
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
@@ -196,7 +210,7 @@
     for (ACE_Timer_Node_T<TYPE>* n = root->get_next (); n != root;)
     {
       ACE_Timer_Node_T<TYPE>* next = n->get_next ();
-      this->upcall_functor ().deletion (*this,
+      this->upcall_functor ().deletion (this,
                                         n->get_type (),
                                         n->get_act ());
       this->free_node (n);
@@ -209,10 +223,9 @@
 }
 
 /// Searches for a node by timer_id within one spoke.
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE>*
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::find_spoke_node
-  (u_int spoke, long timer_id) const
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE>*
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::find_spoke_node (u_int spoke,
+                                                                          long timer_id) const
 {
   ACE_Timer_Node_T<TYPE>* root = this->spokes_[spoke];
   for (ACE_Timer_Node_T<TYPE>* n = root->get_next ();
@@ -227,8 +240,7 @@
 
 /// Searches all spokes for a node matching the specified timer_id
 /// Uses the spoke encoded in the timer_id as a starting place.
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE>*
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE>*
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::find_node (long timer_id) const
 {
   if (timer_id == -1)
@@ -267,10 +279,10 @@
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::is_empty (void) const
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::is_empty");
+
   return timer_count_ == 0;
 }
 
-
 /**
 * @return First (earliest) node in the wheel_'s earliest_spoke_ list
 */
@@ -278,6 +290,7 @@
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::earliest_time (void) const
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::earliest_time");
+
   ACE_Timer_Node_T<TYPE>* n = this->get_first_i ();
   if (n != 0)
     return n->get_timer_value ();
@@ -288,8 +301,7 @@
 /// timer is due to expire. Hopefully the 64bit int operations avoid
 /// any overflow problems.
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> u_int
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::calculate_spoke
-  (const ACE_Time_Value& t) const
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::calculate_spoke (const ACE_Time_Value& t) const
 {
   return static_cast<u_int> ((t.msec () >> this->res_bits_) & (this->spoke_count_ - 1));
 }
@@ -302,7 +314,6 @@
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::generate_timer_id (u_int spoke)
 {
-
   int cnt_bits = sizeof (long) * 8 - this->spoke_bits_;
   long max_cnt = ((long)1 << cnt_bits) - 1;
   if (spoke == this->spoke_count_)
@@ -311,7 +322,7 @@
   ACE_Timer_Node_T<TYPE>* root = this->spokes_[spoke];
 
   if (root == root->get_next ())
-    root->set_act(0);
+    root->set_act (0);
 
   // We use this field to keep track of the next counter value that
   // may be in use. Of course it may have expired, so we just use
@@ -402,10 +413,10 @@
 *          -1 on failure.
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (const TYPE& type,
-                                                        const void* act,
-                                                        const ACE_Time_Value& future_time,
-                                                        const ACE_Time_Value& interval)
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (TYPE& type,
+                                                                     const void* act,
+                                                                     const ACE_Time_Value& future_time,
+                                                                     const ACE_Time_Value& interval)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::schedule_i");
 
@@ -441,6 +452,7 @@
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reschedule (ACE_Timer_Node_T<TYPE>* n)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::reschedule");
+
   const ACE_Time_Value& expire = n->get_timer_value ();
   u_int spoke = calculate_spoke (expire);
   this->schedule_i (n, spoke, expire);
@@ -448,10 +460,9 @@
 
 /// The shared scheduling functionality between schedule() and reschedule()
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i
-  (ACE_Timer_Node_T<TYPE>* n,
-   u_int spoke,
-   const ACE_Time_Value& expire)
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule_i (ACE_Timer_Node_T<TYPE>* n,
+                                                                     u_int spoke,
+                                                                     const ACE_Time_Value& expire)
 {
   // See if we need to update the earliest time
   if (this->is_empty() || expire < this->earliest_time ())
@@ -497,11 +508,12 @@
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::reset_interval (long timer_id,
-                                                            const ACE_Time_Value &interval
-                                                            )
+                                                                         const ACE_Time_Value &interval)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::reset_interval");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
+
   ACE_Timer_Node_T<TYPE>* n = this->find_node (timer_id);
   if (n != 0)
     {
@@ -512,7 +524,6 @@
   return -1;
 }
 
-
 /**
 * Goes through every list in the wheel and whenever we find one with the
 * correct type value, we remove it and continue.  At the end make sure
@@ -526,7 +537,8 @@
 * @return Number of timers cancelled
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (const TYPE& type, int skip_close)
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (TYPE& type,
+                                                                 int skip_close)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::cancel");
 
@@ -535,7 +547,7 @@
 
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
-  if (!this->is_empty ())
+  if (! this->is_empty ())
     {
       ACE_Timer_Node_T<TYPE>* first = this->get_first ();
       ACE_Time_Value last = first->get_timer_value ();
@@ -571,7 +583,7 @@
   // Call the close hooks.
 
   // cancel_type() called once per <type>.
-  this->upcall_functor ().cancel_type (*this,
+  this->upcall_functor ().cancel_type (this,
                                        type,
                                        skip_close,
                                        cookie);
@@ -581,7 +593,7 @@
        ++i)
     {
       // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
+      this->upcall_functor ().cancel_timer (this,
                                             type,
                                             skip_close,
                                             cookie);
@@ -610,11 +622,13 @@
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::cancel (long timer_id,
-                                                    const void **act,
-                                                    int skip_close)
+                                                                 const void **act,
+                                                                 int skip_close)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::cancel");
+
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
+
   ACE_Timer_Node_T<TYPE>* n = this->find_node (timer_id);
   if (n != 0)
     {
@@ -626,13 +640,13 @@
       int cookie = 0;
 
       // cancel_type() called once per <type>.
-      this->upcall_functor ().cancel_type (*this,
+      this->upcall_functor ().cancel_type (this,
                                            n->get_type (),
                                            skip_close,
                                            cookie);
 
       // cancel_timer() called once per <timer>.
-      this->upcall_functor ().cancel_timer (*this,
+      this->upcall_functor ().cancel_timer (this,
                                             n->get_type (),
                                             skip_close,
                                             cookie);
@@ -664,8 +678,7 @@
 /// The last time is always passed in, even though you can often calculate
 /// it as get_first()->get_timer_value().
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
-ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recalc_earliest
-  (const ACE_Time_Value& last)
+ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recalc_earliest (const ACE_Time_Value& last)
 {
   // This is possible because we use a count for is_empty()
   if (this->is_empty ())
@@ -736,7 +749,6 @@
 #endif /* ACE_HAS_DUMP */
 }
 
-
 /**
 * Removes the earliest node and then find the new <earliest_spoke_>
 *
@@ -746,6 +758,7 @@
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::remove_first (void)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::remove_first");
+
   return remove_first_expired (ACE_Time_Value::max_time);
 }
 
@@ -753,6 +766,7 @@
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::unlink (ACE_Timer_Node_T<TYPE>* n)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::unlink");
+
   --timer_count_;
   n->get_prev ()->set_next (n->get_next ());
   n->get_next ()->set_prev (n->get_prev ());
@@ -778,16 +792,15 @@
 *
 * @return The earliest timer node.
 */
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE>*
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE>*
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::get_first (void)
 {
   ACE_TRACE ("ACE_Timer_Wheel_T::get_first");
+
   return this->get_first_i ();
 }
 
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Node_T<TYPE>*
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE>*
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::get_first_i (void) const
 {
   ACE_Timer_Node_T<TYPE>* root = this->spokes_[this->earliest_spoke_];
@@ -797,12 +810,10 @@
   return 0;
 }
 
-
 /**
 * @return The iterator
 */
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Queue_Iterator_T<TYPE> &
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Queue_Iterator_T<TYPE> &
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::iter (void)
 {
   this->iterator_->first ();
@@ -816,7 +827,7 @@
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
 ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire ()
 {
-  return ACE_Timer_Queue_T<TYPE,FUNCTOR,ACE_LOCK>::expire ();
+  return inherited::expire ();
 }
 
 /**
@@ -837,7 +848,6 @@
   ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
 
   ACE_Timer_Node_T<TYPE>* n = this->remove_first_expired (cur_time);
-
   while (n != 0)
     {
       ++expcount;
@@ -886,22 +896,20 @@
 * @param wheel A reference for a timer queue to iterate over
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
-ACE_Timer_Wheel_Iterator_T<TYPE,FUNCTOR,ACE_LOCK,TIME_POLICY>::ACE_Timer_Wheel_Iterator_T
-(Wheel& wheel)
-: timer_wheel_ (wheel)
+ACE_Timer_Wheel_Iterator_T<TYPE,FUNCTOR,ACE_LOCK,TIME_POLICY>::ACE_Timer_Wheel_Iterator_T (Wheel& wheel)
+ : timer_wheel_ (wheel)
 {
-  this->first();
+  this->first ();
 }
 
-
 /**
 * Destructor, at this level does nothing.
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 ACE_Timer_Wheel_Iterator_T<TYPE,FUNCTOR,ACE_LOCK,TIME_POLICY>::~ACE_Timer_Wheel_Iterator_T (void)
 {
-}
 
+}
 
 /**
 * Positions the iterator at the first position in the timing wheel
@@ -914,17 +922,16 @@
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_Wheel_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::first (void)
 {
-  this->goto_next(0);
+  this->goto_next (0);
 }
 
-
 /**
 * Positions the iterator at the next node.
 */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
 ACE_Timer_Wheel_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::next (void)
 {
-  if (this->isdone())
+  if (this->isdone ())
     return;
 
   ACE_Timer_Node_T<TYPE>* n = this->current_node_->get_next ();
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/ace/Timer_Wheel_T.h ACE_wrappers/ace/Timer_Wheel_T.h
--- ACE_wrappers_6_2_7/ace/Timer_Wheel_T.h	2014-08-01 00:53:55.209280900 +0100
+++ ACE_wrappers/ace/Timer_Wheel_T.h	2014-08-01 18:35:14.642801500 +0100
@@ -24,7 +24,7 @@
 ACE_BEGIN_VERSIONED_NAMESPACE_DECL
 
 // Forward declaration
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
 class ACE_Timer_Wheel_T;
 
 /**
@@ -38,9 +38,9 @@
  */
 template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
 class ACE_Timer_Wheel_Iterator_T
-  : public ACE_Timer_Queue_Iterator_T <TYPE>
+ : public ACE_Timer_Queue_Iterator_T <TYPE>
 {
-public:
+ public:
   typedef ACE_Timer_Wheel_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Wheel;
   typedef ACE_Timer_Node_T<TYPE> Node;
 
@@ -62,7 +62,7 @@
   /// Returns the node at the current position in the sequence
   virtual ACE_Timer_Node_T<TYPE>* item (void);
 
-protected:
+ protected:
   /// Pointer to the ACE_Timer_List that we are iterating over.
   Wheel& timer_wheel_;
 
@@ -71,7 +71,8 @@
 
   /// Pointer to the position in the the <pos_>th list
   ACE_Timer_Node_T<TYPE>* current_node_;
-private:
+
+ private:
   void goto_next(u_int start_spoke);
 };
 
@@ -89,22 +90,21 @@
  * Timer Facilities"
  * (http://dworkin.wustl.edu/~varghese/PAPERS/newbsd.ps.Z)
  */
-template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY = ACE_Default_Time_Policy>
+template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
 class ACE_Timer_Wheel_T
-  : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
+ : public ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>
 {
-public:
+ public:
   /// Type of iterator
-  typedef ACE_Timer_Wheel_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Iterator;
+  typedef ACE_Timer_Wheel_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> WHEEL_ITERATOR_T;
   /// Iterator is a friend
   friend class ACE_Timer_Wheel_Iterator_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>;
   typedef ACE_Timer_Node_T<TYPE> Node;
-  /// Type inherited from
-  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> Base_Timer_Queue;
   typedef ACE_Free_List<Node> FreeList;
 
   /// Default constructor
-  ACE_Timer_Wheel_T (FUNCTOR* upcall_functor = 0, FreeList* freelist = 0,
+  ACE_Timer_Wheel_T (FUNCTOR* upcall_functor = 0,
+                     FreeList* freelist = 0,
                      TIME_POLICY const & time_policy = TIME_POLICY());
 
   /// Constructor with opportunities to set the wheelsize and resolution
@@ -133,7 +133,7 @@
   /// Cancel all timer associated with @a type.  If @a dont_call_handle_close is
   /// 0 then the <functor> will be invoked.  Returns number of timers
   /// cancelled.
-  virtual int cancel (const TYPE& type,
+  virtual int cancel (TYPE& type,
                       int dont_call_handle_close = 1);
 
   // Cancel a timer, storing the magic cookie in act (if nonzero).
@@ -170,30 +170,31 @@
   /// Reads the earliest node from the queue and returns it.
   virtual ACE_Timer_Node_T<TYPE>* get_first (void);
 
-protected:
-
+ protected:
   /// Schedules a timer.
-  virtual long schedule_i (const TYPE& type,
+  virtual long schedule_i (TYPE& type,
                            const void* act,
                            const ACE_Time_Value& future_time,
                            const ACE_Time_Value& interval);
 
-private:
+ private:
+  typedef ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY> inherited;
+
   // The following are documented in the .cpp file.
   ACE_Timer_Node_T<TYPE>* get_first_i (void) const;
   ACE_Timer_Node_T<TYPE>* remove_first_expired (const ACE_Time_Value& now);
   void open_i (size_t prealloc, u_int spokes, u_int res);
   virtual void reschedule (ACE_Timer_Node_T<TYPE> *);
-  ACE_Timer_Node_T<TYPE>* find_spoke_node(u_int spoke, long timer_id) const;
-  ACE_Timer_Node_T<TYPE>* find_node(long timer_id) const;
-  u_int calculate_spoke(const ACE_Time_Value& expire) const;
-  long generate_timer_id(u_int spoke);
+  ACE_Timer_Node_T<TYPE>* find_spoke_node (u_int spoke, long timer_id) const;
+  ACE_Timer_Node_T<TYPE>* find_node (long timer_id) const;
+  u_int calculate_spoke (const ACE_Time_Value& expire) const;
+  long generate_timer_id (u_int spoke);
   void schedule_i (ACE_Timer_Node_T<TYPE>* n, u_int spoke, const ACE_Time_Value& expire);
   void cancel_i (ACE_Timer_Node_T<TYPE>* n);
   void unlink (ACE_Timer_Node_T<TYPE>* n);
-  void recalc_earliest(const ACE_Time_Value& last);
+  void recalc_earliest (const ACE_Time_Value& last);
 
-private:
+ private:
   int power2bits (int n, int min_bits, int max_bits);
 
   /// Timing Wheel.
@@ -209,7 +210,7 @@
   /// Index of the list with the earliest time
   u_int earliest_spoke_;
   /// Iterator used to expire timers.
-  Iterator* iterator_;
+  WHEEL_ITERATOR_T* iterator_;
   /// The total amount of time in one iteration of the wheel. (resolution * spoke_count)
   ACE_Time_Value wheel_time_;
   /// The total number of timers currently scheduled.
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/apps/JAWS3/jaws3/Task_Timer.cpp ACE_wrappers/apps/JAWS3/jaws3/Task_Timer.cpp
--- ACE_wrappers_6_2_7/apps/JAWS3/jaws3/Task_Timer.cpp	2014-08-01 00:53:56.932216900 +0100
+++ ACE_wrappers/apps/JAWS3/jaws3/Task_Timer.cpp	2014-07-31 11:40:54.426273200 +0100
@@ -4,18 +4,17 @@
 #define JAWS_BUILD_DLL
 #endif
 
+#include "ace/OS_Memory.h"
 #include "ace/OS_NS_sys_time.h"
 
 #include "jaws3/Task_Timer.h"
 #include "jaws3/Timer_Helpers.h"
 
-
 JAWS_Task_Timer::JAWS_Task_Timer (void)
 {
   this->timer_queue_.activate ();
 }
 
-
 void
 JAWS_Task_Timer::schedule_timer ( long *timer_id
                                 , const ACE_Time_Value &delta
@@ -23,7 +22,10 @@
                                 , void *act
                                 )
 {
-  JAWS_Timer_EH *eh = new JAWS_Timer_EH (completer, act);
+  ACE_Event_Handler *eh = 0;
+  ACE_NEW_NORETURN (eh, 
+                    JAWS_Timer_EH ( completer
+                                  , act ));
   if (eh == 0
       || (*timer_id =
             this->timer_queue_.schedule ( eh
@@ -37,13 +39,13 @@
                                      );
 
       if (completer)
-        completer->timer_complete (timer_result, act);
+        completer->timer_complete ( timer_result
+                                  , act );
 
       delete eh;
     }
 }
 
-
 void
 JAWS_Task_Timer::schedule_absolute_timer ( long *timer_id
                                          , const ACE_Time_Value &tv
@@ -51,9 +53,14 @@
                                          , void *act
                                          )
 {
-  JAWS_Timer_EH *eh = new JAWS_Timer_EH (completer, act);
+  ACE_Event_Handler *eh = 0;
+  ACE_NEW_NORETURN ( eh
+                   , JAWS_Timer_EH ( completer
+                                   , act ));
   if (eh == 0
-      || (*timer_id = this->timer_queue_.schedule (eh, 0, tv)) == -1)
+      || (*timer_id = this->timer_queue_.schedule ( eh
+                                                  , 0
+                                                  , tv )) == -1)
     {
       JAWS_Event_Result timer_result ( 0
                                      , JAWS_Event_Result::JE_ERROR
@@ -61,13 +68,13 @@
                                      );
 
       if (completer)
-        completer->timer_complete (timer_result, act);
+        completer->timer_complete ( timer_result
+                                  , act );
 
       delete eh;
     }
 }
 
-
 void
 JAWS_Task_Timer::schedule_interval_timer ( long *timer_id
                                          , const ACE_Time_Value &interval
@@ -75,7 +82,10 @@
                                          , void *act
                                          )
 {
-  JAWS_Timer_EH *eh = new JAWS_Timer_EH (completer, act);
+  ACE_Event_Handler *eh = 0;
+  ACE_NEW_NORETURN ( eh
+                   , JAWS_Timer_EH ( completer
+                                   , act ));
   if (eh == 0
       || (*timer_id =
             this->timer_queue_.schedule ( eh
@@ -91,16 +101,15 @@
                                      );
 
       if (completer)
-        completer->timer_complete (timer_result, act);
+        completer->timer_complete ( timer_result
+                                  , act );
 
       delete eh;
     }
 }
 
-
 void
 JAWS_Task_Timer::cancel_timer (long timer_id)
 {
   this->timer_queue_.cancel (timer_id);
 }
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/APG/Timers/Alarm.cpp ACE_wrappers/examples/APG/Timers/Alarm.cpp
--- ACE_wrappers_6_2_7/examples/APG/Timers/Alarm.cpp	2014-08-01 00:53:58.778248900 +0100
+++ ACE_wrappers/examples/APG/Timers/Alarm.cpp	2014-07-15 22:18:53.640400300 +0100
@@ -47,11 +47,11 @@
   ACE_Time_Value initial (2);
   ACE_Time_Value repeat (4);
   initial += ACE_OS::gettimeofday ();
-  timer.schedule (&cb, &arg, initial, repeat);
+	ACE_Event_Handler* eh_base = &cb;
+  timer.schedule (eh_base, &arg, initial, repeat);
 
   while (1)      // Don't let the main thread exit.
     ACE_OS::sleep (2);
   ACE_NOTREACHED (return 0);     // Not reached.
 }
 // Listing 2
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/APG/Timers/Task.cpp ACE_wrappers/examples/APG/Timers/Task.cpp
--- ACE_wrappers_6_2_7/examples/APG/Timers/Task.cpp	2014-08-01 00:53:58.798674400 +0100
+++ ACE_wrappers/examples/APG/Timers/Task.cpp	2014-07-31 11:43:50.562189700 +0100
@@ -22,7 +22,7 @@
     ACE_TRACE ("CB::handle_timeout");
 
     const int *val = static_cast<const int*> (arg);
-    ACE_ASSERT((*val) == id_);
+    ACE_ASSERT ((*val) == id_);
 
     ACE_UNUSED_ARG (val);
 
@@ -56,11 +56,13 @@
   const ACE_Time_Value curr_tv = ACE_OS::gettimeofday ();
   ACE_Time_Value interval = ACE_Time_Value (1, 100000);
 
-  atimer.schedule (&cb1,
+  ACE_Event_Handler* eh_base = &cb1;
+  atimer.schedule (eh_base,
                    &arg1,
                    curr_tv + ACE_Time_Value (3L),
                    interval);
-  atimer.schedule (&cb2,
+  eh_base = &cb2;
+  atimer.schedule (eh_base,
                    &arg2,
                    curr_tv + ACE_Time_Value (4L),
                    interval);
@@ -70,4 +72,3 @@
   return 0;
 }
 // Listing 3
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/APG/Timers/Timers.cpp ACE_wrappers/examples/APG/Timers/Timers.cpp
--- ACE_wrappers_6_2_7/examples/APG/Timers/Timers.cpp	2014-08-01 00:53:58.805511900 +0100
+++ ACE_wrappers/examples/APG/Timers/Timers.cpp	2014-07-31 11:45:31.202983500 +0100
@@ -33,14 +33,16 @@
 
   CB cb[10];
   long args[10];
+  ACE_Event_Handler* eh_base = 0;
   for (long i = 0; i < 10 ; i++)
     {
       ACE_Time_Value const timeout (i);
+      eh_base = &cb[i];
       long timerID =
         Timer::instance ()->schedule
-          (&cb[i],
+          (eh_base,
            &args[i],
-           timer_queue->gettimeofday () + ACE_Time_Value(5),
+           timer_queue->gettimeofday () + ACE_Time_Value (5),
            timeout);
 
       // Set the timerID state variable of the handler.
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/APG/Timers/Upcall.cpp ACE_wrappers/examples/APG/Timers/Upcall.cpp
--- ACE_wrappers_6_2_7/examples/APG/Timers/Upcall.cpp	2014-08-01 00:53:58.815225500 +0100
+++ ACE_wrappers/examples/APG/Timers/Upcall.cpp	2014-08-01 15:21:41.457501600 +0100
@@ -9,11 +9,11 @@
 // The signature of this method changed at ACE 5.4. The 'recurring_timer'
 // parameter was added.
 int
-UpcallHandler::timeout (PTimerQueue &,
-                        PCB *handler,
+UpcallHandler::timeout (PTimerQueue*,
+                        PCB *&handler,
                         const void *arg,
-                        int /* recurring_timer */,
-                        const ACE_Time_Value &)
+                        int,
+                        const ACE_Time_Value&)
 {
   ACE_TRACE ("UpcallHandler::timeout");
 
@@ -24,8 +24,8 @@
 // This method was removed at ACE 5.4. Replaced by cancel_type() and
 // cancel_timer().
 int
-UpcallHandler::cancellation (PTimerQueue &,
-                             PCB *handler)
+UpcallHandler::cancellation (PTimerQueue*,
+                             PCB *&handler)
 {
   ACE_TRACE ("UpcallHandler::cancellation");
 
@@ -39,9 +39,9 @@
 
 // This method is called when the timer is canceled
 int
-UpcallHandler::deletion (PTimerQueue &,
-                         PCB *handler,
-                         const void *)
+UpcallHandler::deletion (PTimerQueue*,
+                         PCB *&handler,
+                         const void*)
 {
   ACE_TRACE ("UpcallHandler::deletion");
 
@@ -57,9 +57,9 @@
 
 // This method is called when a timer is registered.
 int
-UpcallHandler::registration (PTimerQueue &,
-                             PCB *handler,
-                             const void *)
+UpcallHandler::registration (PTimerQueue*,
+                             PCB *&handler,
+                             const void*)
 {
   ACE_TRACE ("UpcallHandler::registration");
 
@@ -73,12 +73,12 @@
 // to the handler is made. ACE uses this to adjust reference counts
 // when needed.
 int
-UpcallHandler::preinvoke (PTimerQueue &,
-                          PCB *handler,
-                          const void *,
+UpcallHandler::preinvoke (PTimerQueue*,
+                          PCB *&handler,
+                          const void*,
                           int,
-                          const ACE_Time_Value &,
-                          const void *&)
+                          const ACE_Time_Value&,
+                          const void*&)
 {
   ACE_TRACE ("UpcallHandler::preinvoke");
 
@@ -92,12 +92,12 @@
 // to the handler returns. ACE uses this to adjust reference counts
 // when needed.
 int
-UpcallHandler::postinvoke (PTimerQueue &,
-                           PCB *handler,
-                           const void *,
+UpcallHandler::postinvoke (PTimerQueue*,
+                           PCB *&handler,
+                           const void*,
                            int,
-                           const ACE_Time_Value &,
-                           const void *)
+                           const ACE_Time_Value&,
+                           const void*)
 {
   ACE_TRACE ("UpcallHandler::postinvoke");
 
@@ -109,10 +109,10 @@
 
 // This method is called when a handler is cancelled
 int
-UpcallHandler::cancel_type (PTimerQueue &,
-                            PCB *handler,
+UpcallHandler::cancel_type (PTimerQueue*,
+                            PCB *&handler,
                             int dont_call,
-                            int &)
+                            int&)
 {
   ACE_TRACE ("UpcallHandler::cancel_type");
 
@@ -126,8 +126,8 @@
 
 // This method is called when a timer is cancelled
 int
-UpcallHandler::cancel_timer (PTimerQueue &,
-                             PCB *handler,
+UpcallHandler::cancel_timer (PTimerQueue*,
+                             PCB *&handler,
                              int dont_call,
                              int)
 {
@@ -169,4 +169,3 @@
   return 0;
 }
 // Listing 3
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/APG/Timers/Upcall.h ACE_wrappers/examples/APG/Timers/Upcall.h
--- ACE_wrappers_6_2_7/examples/APG/Timers/Upcall.h	2014-08-01 00:53:58.816753600 +0100
+++ ACE_wrappers/examples/APG/Timers/Upcall.h	2014-08-01 15:20:40.108082500 +0100
@@ -4,31 +4,34 @@
 #if !defined(UPCALL_H)
 #define UPCALL_H
 
+#include "ace/Global_Macros.h"
 #include "ace/Timer_Queue_T.h"
 #include "ace/Timer_Heap_T.h"
 #include "ace/Synch.h"
+#include "ace/Time_Policy.h"
 
 #include "PCB.h"
 
 // Listing 1 code/ch20
 class UpcallHandler;
 
-typedef ACE_Timer_Queue_T<PCB*, UpcallHandler, ACE_Null_Mutex>
+typedef ACE_Timer_Queue_T<PCB*, UpcallHandler, ACE_Null_Mutex, ACE_Default_Time_Policy>
   PTimerQueue;
 
 // Create a special heap-based timer queue that allows you to
 // control exactly how timer evetns are handled.
-typedef ACE_Timer_Heap_T<PCB*, UpcallHandler, ACE_Null_Mutex>
+typedef ACE_Timer_Heap_T<PCB*, UpcallHandler, ACE_Null_Mutex, ACE_Default_Time_Policy>
   PTimerHeap;
 // Listing 1
 
 class UpcallHandler
+ //: public ACE_Timer_Queue_Functor_Base<PTimerQueue, PCB*>
 {
-public:
+ public:
   // The signature of this method changed at ACE 5.4. The 'recurring_timer'
   // parameter was added.
-  int timeout (PTimerQueue &timer_queue,
-               PCB *handler,
+  int timeout (PTimerQueue *timer_queue,
+               PCB *&handler,
                const void *arg,
                int recurring_timer,
                const ACE_Time_Value &cur_time);
@@ -37,51 +40,55 @@
   // This method was removed at ACE 5.4. Replaced by cancel_type() and
   // cancel_timer().
   // This method is called when the timer is canceled.
-  int cancellation (PTimerQueue &timer_queue,
-                    PCB *handler);
+  int cancellation (PTimerQueue *timer_queue,
+                    PCB &handler);
 #endif
 
   // This method is called when the timer queue is destroyed and
   // the timer is still contained in it.
-  int deletion (PTimerQueue &timer_queue,
-                PCB *handler,
+  int deletion (PTimerQueue *timer_queue,
+                PCB *&handler,
                 const void *arg);
 
   // The following methods don't appear before ACE 5.4, so aren't
   // referenced in APG (it's based on ACE 5.3).
 
   // This method is called when a timer is registered.
-  int registration (PTimerQueue &timer_queue,
-                    PCB *handler,
+  int registration (PTimerQueue *timer_queue,
+                    PCB *&handler,
                     const void *arg);
 
   // This method is called before the timer expires.
-  int preinvoke (PTimerQueue &timer_queue,
-                 PCB *handler,
+  int preinvoke (PTimerQueue *timer_queue,
+                 PCB *&handler,
                  const void *arg,
                  int recurring_timer,
                  const ACE_Time_Value &cur_time,
                  const void *&upcall_act);
 
   // This method is called after the timer expires.
-  int postinvoke (PTimerQueue &timer_queue,
-                  PCB *handler,
+  int postinvoke (PTimerQueue *timer_queue,
+                  PCB *&handler,
                   const void *arg,
                   int recurring_timer,
                   const ACE_Time_Value &cur_time,
                   const void *upcall_act);
 
   // This method is called when a handler is cancelled
-  int cancel_type (PTimerQueue &timer_queue,
-                   PCB *handler,
+  int cancel_type (PTimerQueue *timer_queue,
+                   PCB *&handler,
                    int dont_call,
                    int &requires_reference_counting);
 
   // This method is called when a timer is cancelled
-  int cancel_timer (PTimerQueue &timer_queue,
-                    PCB *handler,
+  int cancel_timer (PTimerQueue *timer_queue,
+                    PCB *&handler,
                     int dont_call,
                     int requires_reference_counting);
+
+ private:
+  ACE_UNIMPLEMENTED_FUNC (UpcallHandler (const UpcallHandler&));
+  ACE_UNIMPLEMENTED_FUNC (UpcallHandler &operator= (const UpcallHandler&));
 };
 
 #endif /*UPCALL_H*/
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/Bounded_Packet_Relay/Thread_Bounded_Packet_Relay.cpp ACE_wrappers/examples/Bounded_Packet_Relay/Thread_Bounded_Packet_Relay.cpp
--- ACE_wrappers_6_2_7/examples/Bounded_Packet_Relay/Thread_Bounded_Packet_Relay.cpp	2014-08-01 00:53:59.000478300 +0100
+++ ACE_wrappers/examples/Bounded_Packet_Relay/Thread_Bounded_Packet_Relay.cpp	2014-07-31 12:01:36.787604000 +0100
@@ -24,32 +24,28 @@
 typedef ACE_Command_Callback<BPR_Handler_Base, BPR_Handler_Base::ACTION> HANDLER_CMD;
 typedef ACE_Command_Callback<Send_Handler, Send_Handler::ACTION> SEND_HANDLER_CMD;
 
-
-
 // Constructor.
-
 Text_Input_Device_Wrapper::Text_Input_Device_Wrapper (ACE_Thread_Manager *input_task_mgr,
                                                       size_t read_length,
                                                       const char* text,
                                                       int logging)
-  : Input_Device_Wrapper_Base (input_task_mgr),
-    read_length_ (read_length),
-    text_ (text),
-    index_ (0),
-    logging_ (logging),
-    packet_count_ (0)
-
+ : Input_Device_Wrapper_Base (input_task_mgr),
+   read_length_ (read_length),
+   text_ (text),
+   index_ (0),
+   logging_ (logging),
+   packet_count_ (0)
 {
+
 }
 
 // Destructor.
-
 Text_Input_Device_Wrapper::~Text_Input_Device_Wrapper (void)
 {
+
 }
 
 // Modifies device settings based on passed pointer to a u_long.
-
 int
 Text_Input_Device_Wrapper::modify_device_settings (void *logging)
 {
@@ -65,14 +61,11 @@
   return 0;
 }
 
-
 // Creates a new message block, carrying data
 // read from the underlying input device.
-
 ACE_Message_Block *
 Text_Input_Device_Wrapper::create_input_message (void)
 {
-
   // Construct a new message block to send.
   ACE_Message_Block *mb = 0;
   ACE_NEW_RETURN (mb,
@@ -112,14 +105,13 @@
 }
 
 // Constructor.
-
 Text_Output_Device_Wrapper::Text_Output_Device_Wrapper (int logging)
   : logging_ (logging)
 {
+
 }
 
 // Consume and possibly print out the passed message.
-
 int
 Text_Output_Device_Wrapper::write_output_message (void *message)
 {
@@ -145,7 +137,6 @@
 }
 
 // Modifies device settings based on passed pointer to a u_long.
-
 int
 Text_Output_Device_Wrapper::modify_device_settings (void *logging)
 {
@@ -162,27 +153,25 @@
 }
 
 // Constructor.
-
 User_Input_Task::User_Input_Task (Bounded_Packet_Relay *relay,
                                   Thread_Timer_Queue *queue,
                                   Thread_Bounded_Packet_Relay_Driver &tbprd)
-  : ACE_Task_Base (ACE_Thread_Manager::instance ()),
-    usecs_ (ACE_ONE_SECOND_IN_USECS),
-    relay_ (relay),
-    queue_ (queue),
-    driver_ (tbprd)
+ : ACE_Task_Base (ACE_Thread_Manager::instance ()),
+   usecs_ (ACE_ONE_SECOND_IN_USECS),
+   relay_ (relay),
+   queue_ (queue),
+   driver_ (tbprd)
 {
+
 }
 
 // Destructor.
-
 User_Input_Task::~User_Input_Task (void)
 {
   this->clear_all_timers ();
 }
 
 // Runs the main event loop.
-
 int
 User_Input_Task::svc (void)
 {
@@ -202,7 +191,6 @@
 }
 
 // Sets the number of packets for the next transmission.
-
 int
 User_Input_Task::set_packet_count (void *argument)
 {
@@ -218,7 +206,6 @@
 
 // Sets the input device packet arrival period (usecs) for the next
 // transmission.
-
 int
 User_Input_Task::set_arrival_period (void *argument)
 {
@@ -234,7 +221,6 @@
 
 // Sets the period between output device sends (usecs) for the next
 // transmission.
-
 int
 User_Input_Task::set_send_period (void *argument)
 {
@@ -249,7 +235,6 @@
 }
 
 // Sets a limit on the transmission duration (usecs).
-
 int
 User_Input_Task::set_duration_limit (void *argument)
 {
@@ -265,7 +250,6 @@
 
 // Sets logging level (0 or 1) for output device for the next
 // transmission.
-
 int
 User_Input_Task::set_logging_level (void *argument)
 {
@@ -280,7 +264,6 @@
 }
 
 // Runs the next transmission (if one is not in progress).
-
 int
 User_Input_Task::run_transmission (void *)
 {
@@ -302,17 +285,17 @@
               ACE_Time_Value send_every (0, driver_.send_period ());
               ACE_Time_Value send_at (send_every + now);
 
-              Send_Handler *send_handler;
-              ACE_NEW_RETURN (send_handler,
+              ACE_Event_Handler* eh = 0;
+              ACE_NEW_RETURN (eh,
                               Send_Handler (driver_.packet_count (),
                                             send_every,
                                             *relay_,
                                             *queue_,
                                             driver_),
                               -1);
-              if (queue_->schedule (send_handler, 0, send_at) < 0)
+              if (queue_->schedule (eh, 0, send_at) < 0)
                 {
-                  delete send_handler;
+                  delete eh;
                   ACE_ERROR_RETURN ((LM_ERROR,
                                      "User_Input_Task::run_transmission: "
                                      "failed to schedule send handler"),
@@ -323,14 +306,11 @@
                   ACE_Time_Value terminate_at (0, driver_.duration_limit ());
                   terminate_at += now;
 
-                  Termination_Handler *termination_handler;
-
-                  termination_handler =
-                    new Termination_Handler (*relay_,
-                                             *queue_,
-                                             driver_);
-
-                  if (! termination_handler)
+                  ACE_NEW_NORETURN (eh,
+                                    Termination_Handler (*relay_,
+                                                         *queue_,
+                                                         driver_));
+                  if (! eh)
                     {
                       this->clear_all_timers ();
                       ACE_ERROR_RETURN ((LM_ERROR,
@@ -339,10 +319,9 @@
                                          "handler"),
                                         -1);
                     }
-                  if (queue_->schedule (termination_handler,
-                                        0, terminate_at) < 0)
+                  if (queue_->schedule (eh, 0, terminate_at) < 0)
                     {
-                      delete termination_handler;
+                      delete eh;
                       this->clear_all_timers ();
                       ACE_ERROR_RETURN ((LM_ERROR,
                                          "User_Input_Task::run_transmission: "
@@ -366,9 +345,8 @@
 }
 
 // Ends the current transmission (if one is in progress).
-
 int
-User_Input_Task::end_transmission (void *)
+User_Input_Task::end_transmission (void*)
 {
   if (relay_)
     {
@@ -397,7 +375,6 @@
 
 // Reports statistics for the previous transmission
 // (if one is not in progress).
-
 int
 User_Input_Task::report_stats (void *)
 {
@@ -429,7 +406,6 @@
 }
 
 // Shut down the task.
-
 int
 User_Input_Task::shutdown (void *)
 {
@@ -449,7 +425,6 @@
 }
 
 // Helper method: clears all timers.
-
 int
 User_Input_Task::clear_all_timers (void)
 {
@@ -463,22 +438,21 @@
 }
 
 // Constructor.
-
 BPR_Handler_Base::BPR_Handler_Base (Bounded_Packet_Relay &relay,
                                     Thread_Timer_Queue &queue)
   : relay_ (relay),
     queue_ (queue)
 {
+
 }
 
 // Destructor.
-
 BPR_Handler_Base::~BPR_Handler_Base (void)
 {
+
 }
 
 // Helper method: clears all timers.
-
 int
 BPR_Handler_Base::clear_all_timers (void *)
 {
@@ -497,27 +471,26 @@
 }
 
 // Constructor.
-
 Send_Handler::Send_Handler (u_long send_count,
                             const ACE_Time_Value &duration,
                             Bounded_Packet_Relay &relay,
                             Thread_Timer_Queue &queue,
                             Thread_Bounded_Packet_Relay_Driver &driver)
-  : BPR_Handler_Base (relay, queue),
-    send_count_ (send_count),
-    duration_ (duration),
-    driver_ (driver)
+ : BPR_Handler_Base (relay, queue)
+ , send_count_ (send_count)
+ , duration_ (duration)
+ , driver_ (driver)
 {
+
 }
 
 // Destructor.
-
 Send_Handler::~Send_Handler (void)
 {
+
 }
 
 // Call back hook.
-
 int
 Send_Handler::handle_timeout (const ACE_Time_Value &,
                               const void *)
@@ -561,7 +534,6 @@
 }
 
 // Cancellation hook.
-
 int
 Send_Handler::cancelled (void)
 {
@@ -570,12 +542,12 @@
 }
 
 // Helper method: re-registers this timer
-
 int
 Send_Handler::reregister (void *)
 {
   // Re-register the handler for a new timeout.
-  if (queue_.schedule (this,
+  ACE_Event_Handler* eh = this;
+  if (queue_.schedule (eh,
                        0,
                        duration_ + ACE_OS::gettimeofday ()) < 0)
     ACE_ERROR_RETURN ((LM_ERROR,
@@ -586,25 +558,23 @@
   return 0;
 }
 
-
 // Constructor.
-
 Termination_Handler::Termination_Handler (Bounded_Packet_Relay &relay,
                                           Thread_Timer_Queue &queue,
                                           Thread_Bounded_Packet_Relay_Driver &driver)
-  : BPR_Handler_Base (relay, queue),
-    driver_ (driver)
+ : BPR_Handler_Base (relay, queue)
+ , driver_ (driver)
 {
+
 }
 
 // Destructor.
-
 Termination_Handler::~Termination_Handler (void)
 {
+
 }
 
 // Call back hook.
-
 int
 Termination_Handler::handle_timeout (const ACE_Time_Value &,
                                      const void *)
@@ -625,7 +595,6 @@
 }
 
 // Cancellation hook
-
 int
 Termination_Handler::cancelled (void)
 {
@@ -634,20 +603,19 @@
 }
 
 // Constructor.
-
 Thread_Bounded_Packet_Relay_Driver::Thread_Bounded_Packet_Relay_Driver (Bounded_Packet_Relay *relay)
-  : input_task_ (relay, &timer_queue_, *this)
+ : input_task_ (relay, &timer_queue_, *this)
 {
+
 }
 
 // Destructor.
-
 Thread_Bounded_Packet_Relay_Driver::~Thread_Bounded_Packet_Relay_Driver (void)
 {
+
 }
 
 // Display the user menu.
-
 int
 Thread_Bounded_Packet_Relay_Driver::display_menu (void)
 {
@@ -691,7 +659,6 @@
 }
 
 // Initialize the driver.
-
 int
 Thread_Bounded_Packet_Relay_Driver::init (void)
 {
@@ -749,11 +716,9 @@
 }
 
 // Run the driver
-
 int
 Thread_Bounded_Packet_Relay_Driver::run (void)
 {
   this->init ();
   return 0;
 }
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/Timer_Queue/Custom_Handler.cpp ACE_wrappers/examples/Timer_Queue/Custom_Handler.cpp
--- ACE_wrappers_6_2_7/examples/Timer_Queue/Custom_Handler.cpp	2014-08-01 00:54:01.006205200 +0100
+++ ACE_wrappers/examples/Timer_Queue/Custom_Handler.cpp	2014-08-01 15:31:26.018083800 +0100
@@ -12,18 +12,19 @@
  */
 //=============================================================================
 
-
 #include "Custom_Handler.h"
 #include "ace/OS_NS_stdio.h"
 
 Custom_Handler::Custom_Handler(const ACE_Time_Value &expiration_time)
-  :  expires_ (expiration_time),
-     id_ (0)
+ : expires_ (expiration_time),
+   id_ (0)
 {
+
 }
 
 Custom_Handler::~Custom_Handler (void)
 {
+
 }
 
 void
@@ -35,7 +36,7 @@
 // This is the method invoked when the Timer expires.
 int
 Custom_Handler::on_timeout (const ACE_Time_Value &current_time,
-                            const void *)
+                            const void*)
 {
   ACE_Time_Value delay = current_time - this->expires_;
 
@@ -55,55 +56,87 @@
   return 0;
 }
 
-int Custom_Handler_Upcall::registration(TTimerQueue& , Custom_Handler* , const void* )
+int
+Custom_Handler_Upcall::registration (TTimerQueue*,
+                                     Custom_Handler*&,
+                                     const void*)
 {
-    ACE_TRACE("registration");
+  ACE_TRACE ("registration");
 
-    return 0;
+  return 0;
 }
 
-int Custom_Handler_Upcall::preinvoke(TTimerQueue& , Custom_Handler* , const void* , int , const ACE_Time_Value& , const void*& )
+int
+Custom_Handler_Upcall::preinvoke (TTimerQueue*,
+                                  Custom_Handler*&,
+                                  const void*,
+                                  int,
+                                  const ACE_Time_Value&,
+                                  const void*&)
 {
-    ACE_TRACE("preinvoke");
+  ACE_TRACE ("preinvoke");
 
-    return 0;
+  return 0;
 }
 
-int Custom_Handler_Upcall::timeout(TTimerQueue& , Custom_Handler* handler, const void* arg, int , const ACE_Time_Value& cur_time)
+int
+Custom_Handler_Upcall::timeout (TTimerQueue*,
+                                Custom_Handler*& handler,
+                                const void *arg,
+                                int,
+                                const ACE_Time_Value &cur_time)
 {
-    ACE_TRACE("timeout");
+  ACE_TRACE ("timeout");
 
-    // Do the actual timer call
-    handler->on_timeout(cur_time, arg);
+  // Do the actual timer call
+  handler->on_timeout (cur_time, arg);
 
-    return 0;
+  return 0;
 }
 
-int Custom_Handler_Upcall::postinvoke(TTimerQueue& , Custom_Handler* , const void* , int , const ACE_Time_Value& , const void* )
+int
+Custom_Handler_Upcall::postinvoke (TTimerQueue*,
+                                   Custom_Handler*&,
+                                   const void*,
+                                   int,
+                                   const ACE_Time_Value&,
+                                   const void*)
 {
-    ACE_TRACE("postinvoke");
+  ACE_TRACE ("postinvoke");
 
-    return 0;
+  return 0;
 }
 
-int Custom_Handler_Upcall::cancel_type(TTimerQueue& , Custom_Handler* , int , int& )
+int
+Custom_Handler_Upcall::cancel_type (TTimerQueue*,
+                                    Custom_Handler*&,
+                                    int,
+                                    int&)
 {
-    ACE_TRACE("cancel_type");
+  ACE_TRACE ("cancel_type");
 
-    return 0;
+  return 0;
 }
 
-int Custom_Handler_Upcall::cancel_timer(TTimerQueue& , Custom_Handler* handler, int , int )
+int
+Custom_Handler_Upcall::cancel_timer (TTimerQueue*,
+                                     Custom_Handler *&handler,
+                                     int,
+                                     int)
 {
-    ACE_TRACE("cancel_timer");
-    delete handler;
-    return 0;
+  ACE_TRACE ("cancel_timer");
+
+  delete handler;
+  return 0;
 }
 
-int Custom_Handler_Upcall::deletion(TTimerQueue& , Custom_Handler* handler, const void* )
+int
+Custom_Handler_Upcall::deletion (TTimerQueue*,
+                                 Custom_Handler *&handler,
+                                 const void*)
 {
-    ACE_TRACE("deletion");
-    delete handler;
-    return 0;
-}
+  ACE_TRACE ("deletion");
 
+  delete handler;
+  return 0;
+}
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/Timer_Queue/Custom_Handler.h ACE_wrappers/examples/Timer_Queue/Custom_Handler.h
--- ACE_wrappers_6_2_7/examples/Timer_Queue/Custom_Handler.h	2014-08-01 00:54:01.006858000 +0100
+++ ACE_wrappers/examples/Timer_Queue/Custom_Handler.h	2014-08-01 20:05:56.344140300 +0100
@@ -14,7 +14,6 @@
  */
 //=============================================================================
 
-
 #ifndef _CUSTOM_HANDLER_H_
 #define _CUSTOM_HANDLER_H_
 
@@ -31,31 +30,28 @@
  */
 class Custom_Handler
 {
-
-    public:
-
-        Custom_Handler (const ACE_Time_Value &expiration_time);
-
-        virtual ~Custom_Handler (void);
-
-        // Set the custom handler's id
-        void set_id (int id);
-
-        // Call back hook.
-        virtual int on_timeout(const ACE_Time_Value &current_time,
-                             const void *arg);
-
-    private:
-
-        // Store the expected time of expiration, it is used to print a nice
-        // message saying how much delay was at the actual expiration time.
-        ACE_Time_Value expires_;
-
-        // Store an "id" for the Handler, which is only use to print better
-        // messages.
-        int id_;
+ public:
+  Custom_Handler (const ACE_Time_Value &expiration_time);
+  virtual ~Custom_Handler (void);
+
+  // Set the custom handler's id
+  void set_id (int id);
+
+  // Call back hook.
+  virtual int on_timeout(const ACE_Time_Value &current_time,
+                         const void *arg);
+
+ private:
+  // Store the expected time of expiration, it is used to print a nice
+  // message saying how much delay was at the actual expiration time.
+  ACE_Time_Value expires_;
+
+  // Store an "id" for the Handler, which is only use to print better
+  // messages.
+  int id_;
 };
 
+typedef ACE_Abstract_Timer_Queue<Custom_Handler*> TTimerQueue;
 
 /// CWorkItemAndParamTupleUpcall
 ///
@@ -63,67 +59,58 @@
 /// IWorkItem interface.
 class ACE_Svc_Export Custom_Handler_Upcall
 {
-    public:
-
-        typedef ACE_Timer_Queue_T<Custom_Handler*,
-                                  Custom_Handler_Upcall,
-                                  ACE_Null_Mutex> TTimerQueue;
-
-        // Default constructor
-        Custom_Handler_Upcall()
-        {
-        }
-
-        // Destructor.
-        ~Custom_Handler_Upcall()
-        {
-        }
-
-        // This method is called when a timer is registered.
-        int registration(TTimerQueue& timer_queue,
-                         Custom_Handler* handler,
-                         const void* arg);
-
-        // This method is called before the timer expires.
-        int preinvoke(TTimerQueue& timer_queue,
-                      Custom_Handler* handler,
-                      const void* arg,
-                      int recurring_timer,
-                      const ACE_Time_Value& cur_time,
-                      const void*& upcall_act);
-
-        // This method is called when the timer expires.
-        int timeout (TTimerQueue& timer_queue,
-                     Custom_Handler* handler,
-                     const void* arg,
-                     int recurring_timer,
-                     const ACE_Time_Value& cur_time);
-
-        // This method is called after the timer expires.
-        int postinvoke(TTimerQueue& timer_queue,
-                       Custom_Handler* handler,
-                       const void* arg,
-                       int recurring_timer,
-                       const ACE_Time_Value& cur_time,
-                       const void* upcall_act);
-
-        // This method is called when a handler is canceled
-        int cancel_type(TTimerQueue& timer_queue,
-                        Custom_Handler* handler,
-                        int dont_call,
-                        int& requires_reference_counting);
-
-        // This method is called when a timer is canceled
-        int cancel_timer(TTimerQueue& timer_queue,
-                         Custom_Handler* handler,
-                         int dont_call,
-                         int requires_reference_counting);
-
-        // This method is called when the timer queue is destroyed and
-        // the timer is still contained in it
-        int deletion(TTimerQueue& timer_queue,
-                     Custom_Handler* handler,
-                     const void* arg);
+ public:
+  // Default constructor
+  Custom_Handler_Upcall () { }
+
+  // Destructor.
+  ~Custom_Handler_Upcall () { }
+
+  // This method is called when a timer is registered.
+  int registration (TTimerQueue *timer_queue,
+                    Custom_Handler *&handler,
+                    const void *arg);
+
+  // This method is called before the timer expires.
+  int preinvoke (TTimerQueue *timer_queue,
+                 Custom_Handler *&handler,
+                 const void *arg,
+                 int recurring_timer,
+                 const ACE_Time_Value &cur_time,
+                 const void *&upcall_act);
+
+  // This method is called when the timer expires.
+  int timeout (TTimerQueue *timer_queue,
+               Custom_Handler *&handler,
+               const void *arg,
+               int recurring_timer,
+               const ACE_Time_Value &cur_time);
+
+  // This method is called after the timer expires.
+  int postinvoke (TTimerQueue *timer_queue,
+                  Custom_Handler *&handler,
+                  const void *arg,
+                  int recurring_timer,
+                  const ACE_Time_Value &cur_time,
+                  const void *upcall_act);
+
+  // This method is called when a handler is canceled
+  int cancel_type (TTimerQueue *timer_queue,
+                   Custom_Handler *&handler,
+                   int dont_call,
+                   int& requires_reference_counting);
+
+  // This method is called when a timer is canceled
+  int cancel_timer (TTimerQueue *timer_queue,
+                    Custom_Handler *&handler,
+                    int dont_call,
+                    int requires_reference_counting);
+
+  // This method is called when the timer queue is destroyed and
+  // the timer is still contained in it
+  int deletion (TTimerQueue *timer_queue,
+                Custom_Handler *&handler,
+                const void *arg);
 };
 
 #endif
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.cpp ACE_wrappers/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.cpp
--- ACE_wrappers_6_2_7/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.cpp	2014-08-01 00:54:01.027517000 +0100
+++ ACE_wrappers/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.cpp	2014-07-31 12:17:56.893046800 +0100
@@ -13,7 +13,6 @@
  */
 //=============================================================================
 
-
 #include "ace/OS_NS_stdio.h"
 #include "ace/OS_NS_sys_time.h"
 #include "ace/Task.h"
@@ -26,17 +25,17 @@
 #include "ace/Thread_Mutex.h"
 
 Custom_Handler_Input_Task::Custom_Handler_Input_Task (Thread_Timer_Queue *queue,
-                        Thread_Timer_Queue_Custom_Handler_Test &timer_queue_driver)
-  : ACE_Task_Base (ACE_Thread_Manager::instance ()),
-    queue_ (queue),
-    usecs_ (ACE_ONE_SECOND_IN_USECS),
-    driver_ (timer_queue_driver)
+                                                      Thread_Timer_Queue_Custom_Handler_Test &timer_queue_driver)
+ : ACE_Task_Base (ACE_Thread_Manager::instance ())
+ , queue_ (queue)
+ , usecs_ (ACE_ONE_SECOND_IN_USECS)
+ , driver_ (timer_queue_driver)
 {
+
 }
 
 // Svc method is called from the thread library to read input from the
 // user.
-
 int
 Custom_Handler_Input_Task::svc (void)
 {
@@ -55,7 +54,6 @@
 
 // schedule a new timer.  This method will be called from inside the
 //  <Timer_Queue_Test_Driver> class.  (see Command pattern)
-
 int
 Custom_Handler_Input_Task::add_timer (void *argument)
 {
@@ -88,7 +86,6 @@
 
 // Cancel a timer.  This method will be called from inside the
 //  <Timer_Queue_Test_Driver> class.  (see Command pattern)
-
 int
 Custom_Handler_Input_Task::cancel_timer (void *argument)
 {
@@ -98,7 +95,6 @@
 // Lists the timers in the queue.  Ignores the argument. This method
 // will be called from inside the <Timer_Queue_Test_Driver> class.
 // (see Command pattern)
-
 int
 Custom_Handler_Input_Task::list_timer (void *)
 {
@@ -110,7 +106,6 @@
 
 // Shutdown the timer queue.  Return -1 indicates to the
 // <Timer_Queue_Test_Driver> class that we are done.
-
 int
 Custom_Handler_Input_Task::shutdown_timer (void *)
 {
@@ -147,14 +142,15 @@
 }
 
 // constructor
-
 Thread_Timer_Queue_Custom_Handler_Test::Thread_Timer_Queue_Custom_Handler_Test (void)
-  : input_task_ (&timer_queue_, *this)
+ : input_task_ (&timer_queue_, *this)
 {
+
 }
 
 Thread_Timer_Queue_Custom_Handler_Test::~Thread_Timer_Queue_Custom_Handler_Test (void)
 {
+
 }
 
 int
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.h ACE_wrappers/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.h
--- ACE_wrappers_6_2_7/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.h	2014-08-01 00:54:01.028477400 +0100
+++ ACE_wrappers/examples/Timer_Queue/Thread_Timer_Queue_Custom_Handler_Test.h	2014-07-31 12:16:08.919917200 +0100
@@ -25,11 +25,11 @@
 # pragma once
 #endif /* ACE_LACKS_PRAGMA_ONCE */
 
-#include "ace/Null_Mutex.h"
 #include "ace/Timer_Heap_T.h"
 #include "ace/Timer_Queue_Adapters.h"
 #include "ace/svc_export.h"
-#include "ace/Condition_Recursive_Thread_Mutex.h"
+#include "ace/Synch.h"
+#include "ace/Time_Policy.h"
 #include "Driver.h"
 #include "Custom_Handler.h"
 
@@ -37,14 +37,11 @@
 // necessary.
 typedef ACE_Timer_Heap_T<Custom_Handler*,
                          Custom_Handler_Upcall,
-                         ACE_Null_Mutex>
-        Timer_Heap;
-typedef ACE_Timer_Heap_Iterator_T<Custom_Handler*,
-                                  Custom_Handler_Upcall,
-                                  ACE_Null_Mutex>
-        Timer_Heap_Iterator;
-typedef ACE_Thread_Timer_Queue_Adapter<Timer_Heap, Custom_Handler*>
-        Thread_Timer_Queue;
+                         ACE_SYNCH_NULL_MUTEX,
+                         ACE_Default_Time_Policy> Timer_Heap;
+typedef Timer_Heap::HEAP_ITERATOR_T Timer_Heap_Iterator;
+typedef ACE_Thread_Timer_Queue_Adapter<Timer_Heap,
+                                       Custom_Handler*> Thread_Timer_Queue;
 
 // Forward declaration.
 class Thread_Timer_Queue_Custom_Handler_Test;
@@ -60,11 +57,11 @@
  */
 class Custom_Handler_Input_Task : public ACE_Task_Base
 {
-public:
-  typedef int (Custom_Handler_Input_Task::*ACTION) (void *);
+ public:
+  typedef int (Custom_Handler_Input_Task::*ACTION) (void*);
 
   Custom_Handler_Input_Task (Thread_Timer_Queue *queue,
-              Thread_Timer_Queue_Custom_Handler_Test &timer_queue_driver);
+                             Thread_Timer_Queue_Custom_Handler_Test &timer_queue_driver);
 
   /// This method runs the event loop in the new thread.
   virtual int svc (void);
@@ -72,21 +69,21 @@
   // = Some helper methods.
 
   /// Add a new timer to expire in <seconds> more.
-  int add_timer (void *);
+  int add_timer (void*);
 
   /// Cancel timer <id>.
-  int cancel_timer (void *);
+  int cancel_timer (void*);
 
   /// List the current scheduled timers.
-  int list_timer (void *);
+  int list_timer (void*);
 
   /// Shutdown task.
-  int shutdown_timer (void *);
+  int shutdown_timer (void*);
 
   /// Dump the state of the timer queue.
   void dump (void);
 
-private:
+ private:
   /// The timer queue implementation.
   Thread_Timer_Queue *queue_;
 
@@ -108,9 +105,10 @@
  * called from the base class to print a menu specific to the
  * thread implementation of the timer queue.
  */
-class ACE_Svc_Export Thread_Timer_Queue_Custom_Handler_Test : public Timer_Queue_Test_Driver <Thread_Timer_Queue, Custom_Handler_Input_Task, Custom_Handler_Input_Task::ACTION>
+class ACE_Svc_Export Thread_Timer_Queue_Custom_Handler_Test
+ : public Timer_Queue_Test_Driver <Thread_Timer_Queue, Custom_Handler_Input_Task, Custom_Handler_Input_Task::ACTION>
 {
-public:
+ public:
   Thread_Timer_Queue_Custom_Handler_Test (void);
   ~Thread_Timer_Queue_Custom_Handler_Test (void);
 
@@ -118,7 +116,7 @@
   virtual int init (void);
   virtual int run_test (void);
 
-private:
+ private:
   /// Subclassed from ACE_Task.
   Custom_Handler_Input_Task input_task_;
 };
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/examples/Timer_Queue/Thread_Timer_Queue_Test.cpp ACE_wrappers/examples/Timer_Queue/Thread_Timer_Queue_Test.cpp
--- ACE_wrappers_6_2_7/examples/Timer_Queue/Thread_Timer_Queue_Test.cpp	2014-08-01 00:54:01.029292100 +0100
+++ ACE_wrappers/examples/Timer_Queue/Thread_Timer_Queue_Test.cpp	2014-07-15 22:18:54.421612700 +0100
@@ -111,7 +111,8 @@
                   Handler (expire_at),
                   -1);
 
-  int id = queue_->schedule (h, 0, expire_at);
+	ACE_Event_Handler* eh_base = h;
+  int id = queue_->schedule (eh_base, 0, expire_at);
 
   if (id == -1)
     ACE_ERROR_RETURN ((LM_ERROR,
@@ -257,4 +258,4 @@
                        "wait on Thread_Manager failed"),
                       -1);
   return 0;
-}
+}
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/protocols/ace/INet/BidirStreamBuffer.cpp ACE_wrappers/protocols/ace/INet/BidirStreamBuffer.cpp
--- ACE_wrappers_6_2_7/protocols/ace/INet/BidirStreamBuffer.cpp	2014-08-01 00:54:02.188818200 +0100
+++ ACE_wrappers/protocols/ace/INet/BidirStreamBuffer.cpp	2014-07-31 12:21:05.880598000 +0100
@@ -13,7 +13,6 @@
 {
   namespace IOS
   {
-
     template <class ACE_CHAR_T, class STREAM_HANDLER, class TR>
     BasicBidirStreamBuffer<ACE_CHAR_T, STREAM_HANDLER, TR>::BasicBidirStreamBuffer (
         STREAM_HANDLER* sh,
@@ -27,10 +26,10 @@
         this->stream_->add_reference ();
 
         char_type* p = 0;
-        ACE_NEW_NORETURN (p, char_type [bufsz]);
+        ACE_NEW_NORETURN (p, char_type [static_cast<unsigned int> (bufsz)]);
         this->read_buffer_.reset (p);
         p = 0;
-        ACE_NEW_NORETURN (p, char_type [bufsz]);
+        ACE_NEW_NORETURN (p, char_type [static_cast<unsigned int> (bufsz)]);
         this->write_buffer_.reset (p);
 
         this->reset_buffers ();
@@ -165,14 +164,20 @@
     int
     BasicBidirStreamBuffer<ACE_CHAR_T, STREAM_HANDLER, TR>::read_from_stream (char_type* buffer, std::streamsize length)
       {
-        return this->stream_ == 0 ? 0 : this->stream_->read_from_stream (buffer, length, sizeof(char_type));
+        return ((this->stream_ == 0) ? 0
+                                     : this->stream_->read_from_stream (buffer,
+                                                                        static_cast<size_t> (length),
+                                                                        sizeof (char_type)));
       }
 
     template <class ACE_CHAR_T, class STREAM_HANDLER, class TR>
     int
     BasicBidirStreamBuffer<ACE_CHAR_T, STREAM_HANDLER, TR>::write_to_stream (const char_type* buffer, std::streamsize length)
       {
-        return this->stream_ == 0 ? 0 : this->stream_->write_to_stream (buffer, length, sizeof(char_type));
+        return ((this->stream_ == 0) ? 0 
+                                     : this->stream_->write_to_stream (buffer,
+                                                                       static_cast<size_t> (length),
+                                                                       sizeof (char_type)));
       }
 
     template <class ACE_CHAR_T, class STREAM_HANDLER, class TR>
@@ -216,4 +221,4 @@
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
-#endif /* ACE_IOS_BIDIR_STREAM_BUFFER_CPP */
+#endif /* ACE_IOS_BIDIR_STREAM_BUFFER_CPP */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/protocols/ace/INet/BufferedStreamBuffer.cpp ACE_wrappers/protocols/ace/INet/BufferedStreamBuffer.cpp
--- ACE_wrappers_6_2_7/protocols/ace/INet/BufferedStreamBuffer.cpp	2014-08-01 00:54:02.190676500 +0100
+++ ACE_wrappers/protocols/ace/INet/BufferedStreamBuffer.cpp	2014-07-31 12:21:51.652766900 +0100
@@ -13,7 +13,6 @@
 {
   namespace IOS
   {
-
     template <class ACE_CHAR_T, class TR>
     BasicBufferedStreamBuffer<ACE_CHAR_T, TR>::BasicBufferedStreamBuffer (
         std::streamsize bufsz,
@@ -23,7 +22,7 @@
         interceptor_ (0)
       {
         char_type* p = 0;
-        ACE_NEW_NORETURN (p, char_type [bufsz]);
+        ACE_NEW_NORETURN (p, char_type [static_cast<unsigned int> (bufsz)]);
         this->buffer_.reset (p);
 
         this->setg (this->buffer_.get () + 4,
@@ -181,4 +180,4 @@
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
-#endif /* ACE_BUFFERED_STREAM_BUFFER_CPP */
+#endif /* ACE_BUFFERED_STREAM_BUFFER_CPP */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/protocols/ace/INet/String_IOStream.cpp ACE_wrappers/protocols/ace/INet/String_IOStream.cpp
--- ACE_wrappers_6_2_7/protocols/ace/INet/String_IOStream.cpp	2014-08-01 00:54:02.308005800 +0100
+++ ACE_wrappers/protocols/ace/INet/String_IOStream.cpp	2014-07-31 12:24:31.487368800 +0100
@@ -13,7 +13,6 @@
 {
   namespace IOS
   {
-
     template <class ACE_CHAR_T, class TR>
     String_StreamBufferBase<ACE_CHAR_T, TR>::String_StreamBufferBase (openmode mode)
       : BasicBufferedStreamBuffer<ACE_CHAR_T, TR> (BUFFER_SIZE, mode),
@@ -51,7 +50,7 @@
           spos = this->rd_ptr_;
         else if (way == std::ios::end)
           spos = this->string_ref_->length ();
-        spos += off;
+        spos += static_cast<unsigned int> (off);
         if (spos < this->string_ref_->length ())
           this->rd_ptr_ = spos;
         else
@@ -102,8 +101,10 @@
               {
                 length = this->string_ref_->length () - this->rd_ptr_;
               }
-            ACE_OS::memmove (buffer, &(*this->string_ref_)[this->rd_ptr_], length * sizeof (char_type));
-            this->rd_ptr_ += length;
+            ACE_OS::memmove (buffer,
+                             &(*this->string_ref_) [this->rd_ptr_],
+                             static_cast<size_t> (length) * sizeof (char_type));
+            this->rd_ptr_ += static_cast<unsigned int>(length);
             n = ACE_Utils::truncate_cast<int> (length);
           }
         return n;
@@ -115,7 +116,7 @@
         int n = 0;
         if (this->string_ref_)
           {
-            this->string_ref_->append (buffer, length);
+            this->string_ref_->append (buffer, static_cast<unsigned int> (length));
             n = ACE_Utils::truncate_cast<int> (length);
           }
         return n;
@@ -226,4 +227,4 @@
 
 ACE_END_VERSIONED_NAMESPACE_DECL
 
-#endif /* ACE_IOS_STRING_IOSTREAM_CPP */
+#endif /* ACE_IOS_STRING_IOSTREAM_CPP */
\ No newline at end of file
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/tests/Proactor_Timer_Test.cpp ACE_wrappers/tests/Proactor_Timer_Test.cpp
--- ACE_wrappers_6_2_7/tests/Proactor_Timer_Test.cpp	2014-08-01 00:54:04.313246300 +0100
+++ ACE_wrappers/tests/Proactor_Timer_Test.cpp	2014-07-31 12:59:51.574436400 +0100
@@ -16,7 +16,6 @@
  */
 //=============================================================================
 
-
 #include "test_config.h"
 #include "ace/Trace.h"
 
@@ -37,7 +36,7 @@
 
 class Time_Handler : public ACE_Handler
 {
-public:
+ public:
   /// Default constructor
   Time_Handler ();
 
@@ -50,7 +49,7 @@
   /// Set our timer id;
   void timer_id (long);
 
-private:
+ private:
   /// Stores the id of this timer.
   long timer_id_;
 };
@@ -65,7 +64,7 @@
  */
 class Repeat_Timer_Handler : public ACE_Handler
 {
-public:
+ public:
   static const int REPEAT_INTERVAL = 2;
 
   // Constructor arg tells how many seconds we intend to do the repeat with.
@@ -79,12 +78,11 @@
   // Handle the timeout.
   virtual void handle_time_out (const ACE_Time_Value &tv, const void *arg);
 
-private:
+ private:
   int repeat_secs_;
   int expirations_;
 };
 
-
 Time_Handler::Time_Handler (void)
   : timer_id_ (-1)
 {
@@ -152,7 +150,8 @@
   if (this->expirations_ == 2)
     {
       ACE_OS::sleep (this->repeat_secs_ + 1);
-      int canceled = this->proactor ()->cancel_timer (*this);
+      ACE_Handler* h = this;
+      int canceled = this->proactor ()->cancel_timer (h);
       if (canceled != 1)
         {
           ACE_ERROR ((LM_ERROR,
@@ -181,12 +180,14 @@
   size_t which[ACE_MAX_TIMERS];
   long secs = 0;
   size_t i = 0;
+  ACE_Handler* h = 0;
   for ( ; i < ACE_MAX_TIMERS; i++, secs++)
     {
       which[i] = i;
+      h = &rt[i];
       t_id[i] =
         ACE_Proactor::instance ()->schedule_timer
-            (rt[i], &which[i], ACE_Time_Value (2 * secs + 1));
+            (h, &which[i], ACE_Time_Value (2 * secs + 1));
       if (t_id[i] == -1)
         ACE_ERROR ((LM_ERROR, ACE_TEXT ("%p\n"), ACE_TEXT ("schedule_timer")));
       rt[i].timer_id (t_id[i]);
@@ -210,12 +211,13 @@
   counter = 0;
   long secs = 0;
   size_t i = 0;
+  ACE_Handler* h = &rt[0];
   for ( ; i < ACE_MAX_TIMERS; i++, secs++)
     {
       which[i] = i;
       t_id[i] =
         ACE_Proactor::instance ()->schedule_timer
-          (rt[0], &which[i], ACE_Time_Value (2 * secs + 1));
+          (h, &which[i], ACE_Time_Value (2 * secs + 1));
       if (t_id[i] == -1)
         ACE_ERROR ((LM_ERROR, ACE_TEXT ("%p\n"), ACE_TEXT ("schedule_timer")));
     }
@@ -239,11 +241,13 @@
   odd = 1;
   size_t i = 0;
   long secs = 0;
+  ACE_Handler* h = 0;
   for ( ; i < ACE_MAX_TIMERS; i++, secs++)
     {
       which[i] = i;
+      h = &rt[i];
       t_id[i] = ACE_Proactor::instance ()->schedule_timer
-        (rt[i], &which[i], ACE_Time_Value (2 * secs + 1));
+        (h, &which[i], ACE_Time_Value (2 * secs + 1));
       if (t_id[i] == -1)
         ACE_ERROR ((LM_ERROR, ACE_TEXT ("%p\n"), ACE_TEXT ("schedule_timer")));
       rt[i].timer_id (t_id[i]);
@@ -264,10 +268,12 @@
 static void
 test_cancel_repeat_timer (void)
 {
-  Repeat_Timer_Handler *handler = new Repeat_Timer_Handler;
+  ACE_Handler *handler = 0;
+  ACE_NEW (handler,
+           Repeat_Timer_Handler ());
   ACE_Time_Value timeout (Repeat_Timer_Handler::REPEAT_INTERVAL);
   long t_id = ACE_Proactor::instance ()->schedule_repeating_timer
-    (*handler, 0, timeout);
+    (handler, 0, timeout);
   if (t_id == -1)
     {
       ACE_ERROR ((LM_ERROR,
@@ -285,11 +291,10 @@
   return;
 }
 
-
 // If any command line arg is given, run the test with high res timer
 // queue. Else run it normally.
 int
-run_main (int argc, ACE_TCHAR *[])
+run_main (int argc, ACE_TCHAR*[])
 {
   ACE_START_TEST (ACE_TEXT ("Proactor_Timer_Test"));
 
@@ -305,25 +310,21 @@
       // high-resolution  timer.  Why does this test require such
       // precision for a 1 second timer is beyond me ...  I think it
       // is a cut&paste error.
-      //
-      // The use of auto_ptr<> is optional, ACE uses dangerous memory
-      // management idioms everywhere, I thought I could demonstrate how
-      // to do it right in at least one test.  Notice the lack of
-      // ACE_NEW_RETURN, that monstrosity has no business in proper C++
-      // code ...
-      typedef ACE_Timer_Heap_T<ACE_Handler*,ACE_Proactor_Handle_Timeout_Upcall,ACE_SYNCH_RECURSIVE_MUTEX,ACE_FPointer_Time_Policy> Timer_Queue;
-
-      auto_ptr<Timer_Queue> tq(new Timer_Queue);
+      typedef ACE_Timer_Heap_T<ACE_Handler*,
+                               ACE_Proactor_Handle_Timeout_Upcall,
+                               ACE_SYNCH_RECURSIVE_MUTEX,
+                               ACE_FPointer_Time_Policy> Timer_Queue;
+      Timer_Queue* tq = 0;
+      ACE_NEW_RETURN (tq,
+                      Timer_Queue (),
+                      -1);
       // ... notice how the policy is in the derived timer queue type.
       // The abstract timer queue does not have a time policy ...
-      tq->set_time_policy(&ACE_High_Res_Timer::gettimeofday_hr);
+      tq->set_time_policy (&ACE_High_Res_Timer::gettimeofday_hr);
       // ... and then the timer queue is replaced.  Strangely, the
       // Proactor does *not* copy the timers, it just deletes the
       // existing timer queue ....
-      r->timer_queue(tq.get());
-      // ... the Proactor has assumed ownership, release the
-      // auto_ptr<> ...
-      tq.release();
+      r->timer_queue (tq);
     }
 
   // Register all different handlers, i.e., one per timer.
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/tests/Recursive_Condition_Bug_Test.cpp ACE_wrappers/tests/Recursive_Condition_Bug_Test.cpp
--- ACE_wrappers_6_2_7/tests/Recursive_Condition_Bug_Test.cpp	2014-08-01 00:54:03.518627800 +0100
+++ ACE_wrappers/tests/Recursive_Condition_Bug_Test.cpp	2014-07-31 12:34:25.418165900 +0100
@@ -17,7 +17,6 @@
  */
 //=============================================================================
 
-
 #include "test_config.h"
 #include "ace/OS_NS_sys_time.h"
 #include "ace/Task_T.h"
@@ -37,7 +36,7 @@
 
 class Test_Task : public ACE_Task<ACE_MT_SYNCH>
 {
-public:
+ public:
   virtual int svc (void)
   {
     while (--max_iterations > 0)
@@ -56,7 +55,8 @@
 
         ACE_Time_Value timeout = ACE_OS::gettimeofday () + ACE_Time_Value (1, 0);
 
-        if (timer_queue_.schedule (reinterpret_cast<ACE_Event_Handler *> (handler),
+        ACE_Event_Handler* eh = (ACE_Event_Handler*)handler;
+        if (timer_queue_.schedule (eh,
                                    this,
                                    timeout) == -1)
           ACE_ERROR_RETURN ((LM_ERROR,
@@ -92,13 +92,13 @@
     return 0;
   }
 
-private:
+ private:
   Thread_Timer_Queue timer_queue_;
 };
 
 class Test_Handler : public ACE_Event_Handler
 {
-public:
+ public:
   virtual int handle_timeout (const ACE_Time_Value &,
                               const void *arg)
   {
@@ -110,18 +110,18 @@
       reinterpret_cast<Test_Task *> (nc_arg);
     ACE_Message_Block *mb = 0;
     ACE_NEW_MALLOC_RETURN (mb,
-                           static_cast<ACE_Message_Block *> (ACE_Allocator::instance()->malloc (sizeof (ACE_Message_Block))),
+                           static_cast<ACE_Message_Block *> (ACE_Allocator::instance ()->malloc (sizeof (ACE_Message_Block))),
                            ACE_Message_Block (sizeof (*this),    // size
                                               ACE_Message_Block::MB_DATA, // type
                                               0,       // cont
-                                              (char *) this,     // data
+                                              (char*)this,     // data
                                               0,
                                               0,
                                               ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                                               ACE_Time_Value::zero,
                                               ACE_Time_Value::max_time,
                                               0,
-                                              ACE_Allocator::instance()),     // data
+                                              ACE_Allocator::instance ()),     // data
                            -1);
 
     test_task->putq (mb);
@@ -151,18 +151,18 @@
 
   ACE_Message_Block *mb = 0;
   ACE_NEW_MALLOC_RETURN (mb,
-                         static_cast<ACE_Message_Block *> (ACE_Allocator::instance()->malloc (sizeof (ACE_Message_Block))),
+                         static_cast<ACE_Message_Block *> (ACE_Allocator::instance ()->malloc (sizeof (ACE_Message_Block))),
                          ACE_Message_Block (sizeof (handler),    // size
                                             ACE_Message_Block::MB_DATA, // type
                                             0,       // cont
-                                            (char *) &handler,
+                                            (char*)&handler,
                                             0,
                                             0,
                                             ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
                                             ACE_Time_Value::zero,
                                             ACE_Time_Value::max_time,
                                             0,
-                                            ACE_Allocator::instance()),     // data
+                                            ACE_Allocator::instance ()),     // data
                           -1);
 
   if (-1 == task.putq (mb))
@@ -182,4 +182,3 @@
   ACE_END_TEST;
   return 0;
 }
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/tests/Recursive_Condition_Test.cpp ACE_wrappers/tests/Recursive_Condition_Test.cpp
--- ACE_wrappers_6_2_7/tests/Recursive_Condition_Test.cpp	2014-08-01 00:54:04.410451200 +0100
+++ ACE_wrappers/tests/Recursive_Condition_Test.cpp	2014-07-15 22:18:54.859183100 +0100
@@ -50,7 +50,8 @@
 
     ACE_DEBUG ((LM_DEBUG,
                 ACE_TEXT ("(%t) scheduling new timer 1 sec from now\n")));
-    if (timer_queue->schedule (this, timer_queue, timeout) == -1)
+		ACE_Event_Handler* eh = this;
+    if (timer_queue->schedule (eh, timer_queue, timeout) == -1)
       ACE_ERROR ((LM_ERROR, ACE_TEXT ("(%t) %p\n"),
                   ACE_TEXT ("schedule failed")));
 
@@ -277,7 +278,8 @@
   ACE_Time_Value timeout =
     ACE_OS::gettimeofday() + ACE_Time_Value (1, 0);
 
-  if (-1 == timer_queue.schedule (&handler, &timer_queue, timeout))
+	ACE_Event_Handler* eh = &handler;
+  if (-1 == timer_queue.schedule (eh, &timer_queue, timeout))
     {
       ACE_ERROR ((LM_ERROR, ACE_TEXT ("(%t) %p\n"), ACE_TEXT ("schedule")));
       ++status;
@@ -301,4 +303,3 @@
   ACE_END_TEST;
   return 0;
 }
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/tests/Thread_Timer_Queue_Adapter_Test.cpp ACE_wrappers/tests/Thread_Timer_Queue_Adapter_Test.cpp
--- ACE_wrappers_6_2_7/tests/Thread_Timer_Queue_Adapter_Test.cpp	2014-08-01 00:54:03.844253900 +0100
+++ ACE_wrappers/tests/Thread_Timer_Queue_Adapter_Test.cpp	2014-07-31 21:26:06.864217200 +0100
@@ -4,6 +4,7 @@
  *  @file    Thread_Timer_Queue_Adapter_Test.cpp
  *
  *  @author Alon Diamant <diamant.alon@gmail.com>
+ *          and Erik Sohns <erik.sohns@web.de>
  *
  * This test verifies the functionality of the ACE_Timer_Queue_Thread_Adapter.
  * It also shows the usage of custom event handlers.
@@ -11,10 +12,45 @@
  */
 //=============================================================================
 
+#include "test_config.h"
+#include "randomize.h"
+#include "ace/Get_Opt.h"
+#include "ace/Message_Block.h"
+#include "ace/OS.h"
+#include "ace/Profile_Timer.h"
+#include "ace/Timer_Heap.h"
+#include "ace/Timer_List.h"
 #include "ace/Timer_Wheel.h"
+#include "ace/Timer_Hash.h"
 #include "ace/Timer_Queue_Adapters.h"
 #include "ace/Truncate.h"
-#include "test_config.h"
+#include "ace/Task.h"
+
+#include <set>
+#include <vector>
+
+// running time
+#define BF_RUNNING_TIME_SEC 5 // seconds
+static ACE_Time_Value bf_running_time(BF_RUNNING_TIME_SEC, 0);
+#define RD_RUNNING_TIME_SEC 20 // seconds
+static ACE_Time_Value rd_running_time(RD_RUNNING_TIME_SEC, 0);
+#define RD_MAXIMUM_INTERVAL_MSEC 50 // milliseconds
+static ACE_Time_Value rd_maximum_interval(0, RD_MAXIMUM_INTERVAL_MSEC * 1000);
+#define HT_RUNNING_TIME_SEC 60 // seconds
+static ACE_Time_Value ht_running_time(HT_RUNNING_TIME_SEC, 0);
+#define HT_MAXIMUM_INTERVAL_MSEC 1 // milliseconds
+static ACE_Time_Value ht_maximum_interval(0, HT_MAXIMUM_INTERVAL_MSEC * 1000);
+
+// Number of parallel threads for the stability tests.
+static int max_threads = 5;
+
+typedef std::vector<long> timer_ids_t;
+typedef timer_ids_t::iterator timer_ids_iterator_t;
+static timer_ids_t timer_ids;
+
+static long timer_act = 1;
+static int call_count = 0;
+static ACE_Thread_Mutex lock;
 
 #if defined (ACE_HAS_THREADS)
 
@@ -24,285 +60,1002 @@
 /// timer queue thread adapter.
 class ICustomEventHandler
 {
-    public:
-
-        /// Default constructor.
-        ///
-        /// @return
-        ICustomEventHandler()
-        {
-        }
+ public:
+  /// Default constructor.
+  ///
+  /// @return
+  ICustomEventHandler () { }
+
+  /// Default destructor.
+  ///
+  /// @return
+  virtual ~ICustomEventHandler () { }
+
+  /// Main functor method.
+  ///
+  /// @return int
+  /// @param p_vParameter
+  virtual int operator () (void* p_vParameter) = 0;
+};
 
-        /// Default destructor.
-        ///
-        /// @return
-        virtual ~ICustomEventHandler()
-        {
-        }
+/// CTestEventHandler
+///
+/// Used to demonstrate the usage of custom event handlers. This is called by the
+/// timer queue thread adapter.
+class CTestEventHandler : public ICustomEventHandler
+{
+ public:
+  /// Default constructor.
+  ///
+  /// @return
+  CTestEventHandler () { }
+
+  /// Default destructor.
+  ///
+  /// @return
+  virtual ~CTestEventHandler () {	}
+
+  /// Main functor method.
+  ///
+  /// @return int
+  /// @param p_vParameter
+  virtual int operator() (void* p_vParameter)
+  {
+    lock.acquire ();
+    long* iParameter = reinterpret_cast<long*> (p_vParameter);
+    call_count += *iParameter;
+    lock.release ();
 
-        /// Main functor method.
-        ///
-        /// @return int
-        /// @param p_vParameter
-        virtual int operator() (void* p_vParameter) = 0;
+    // Success
+    return 0;
+  }
 };
 
+typedef ACE_Abstract_Timer_Queue<ICustomEventHandler*> Timer_Queue_t;
 /// CCustomEventHandlerUpcall
 ///
 /// Implements the Upcall interface used by the ACE_Timer_Queue, specifically for the
 /// ICustomEventHandler interface.
 class CCustomEventHandlerUpcall
+ //: public ACE_Timer_Queue_Functor_Base<Timer_Queue_t, ICustomEventHandler*>
 {
-    public:
-
-        typedef ACE_Timer_Queue_T<ICustomEventHandler*,
-                                  CCustomEventHandlerUpcall,
-                                  ACE_Null_Mutex> TTimerQueue;
-
-        /// Default constructor
-        CCustomEventHandlerUpcall()
-        {
-        }
-
-        /// Destructor.
-        ~CCustomEventHandlerUpcall()
-        {
-        }
-
-        /// This method is called when the timer expires.
-        int timeout (TTimerQueue&,
-                     ICustomEventHandler* p_Handler,
-                     const void* p_vParameter,
-                     int /*recurring_timer*/,
-                     const ACE_Time_Value& /*cur_time*/)
-        {
-            ACE_TRACE("timeout");
-
-            return (*p_Handler)(const_cast<void*> (p_vParameter));
-        }
-
-        /// This method is called when a timer is registered.
-        int registration(TTimerQueue&, ICustomEventHandler*, const void*) { return 0; }
-
-        /// This method is called before the timer expires.
-        int preinvoke(TTimerQueue&, ICustomEventHandler*, const void*,
-            int, const ACE_Time_Value&, const void*&) { return 0; }
-
-        /// This method is called after the timer expires.
-        int postinvoke(TTimerQueue&, ICustomEventHandler*, const void*,
-            int, const ACE_Time_Value&, const void*) { return 0; }
-
-        /// This method is called when a handler is canceled
-        int cancel_type(TTimerQueue&, ICustomEventHandler*, int, int&) { return 0; }
-
-        /// This method is called when a timer is canceled
-        int cancel_timer(TTimerQueue&, ICustomEventHandler* p_Handler, int, int)
-        {
-            ACE_TRACE("cancel_timer");
-            delete p_Handler;
-            return 0;
-        }
-
-        /// This method is called when the timer queue is destroyed and
-        /// the timer is still contained in it
-        int deletion(TTimerQueue&, ICustomEventHandler* p_Handler, const void*)
-        {
-            ACE_TRACE("deletion");
-            delete p_Handler;
-            return 0;
-        }
-};
+ public:
+  /// Default constructor
+  CCustomEventHandlerUpcall () { }
+
+  /// Destructor.
+  ~CCustomEventHandlerUpcall () { }
+
+  /// This method is called when the timer expires.
+  int timeout (Timer_Queue_t*,
+               ICustomEventHandler *&p_Handler,
+               const void* p_vParameter,
+               const int&,
+               const ACE_Time_Value&)
+  {
+    ACE_TRACE ("timeout");
+
+    return (*p_Handler) (const_cast<void*> (p_vParameter));
+  }
+
+  /// This method is called when a timer is registered.
+  int registration (Timer_Queue_t*,
+                    ICustomEventHandler*&,
+                    const void*)
+  {
+    return 0;
+  }
 
-/// ICustomEventHandler
-///
-/// Used to demonstrate the usage of custom event handlers. This is called by the
-/// timer queue thread adapter.
-class CTestEventHandler : public ICustomEventHandler
-{
-    public:
+  /// This method is called before the timer expires.
+  int preinvoke (Timer_Queue_t*,
+                 ICustomEventHandler*&,
+                 const void*,
+                 const int&,
+                 const ACE_Time_Value&,
+                 const void*&)
+  {
+    return 0;
+  }
 
-        /// Default constructor.
-        ///
-        /// @return
-        CTestEventHandler(long* p_iCallCount)
-        : m_p_iCallCount(p_iCallCount)
-        {
-            ACE_DEBUG((LM_DEBUG, ACE_TEXT("%I(%t) Initializing test event handler.\n")));
-        }
+  /// This method is called after the timer expires.
+  int postinvoke (Timer_Queue_t*,
+                  ICustomEventHandler*&,
+                  const void*,
+                  const int&,
+                  const ACE_Time_Value&,
+                  const void*)
+  {
+    return 0;
+  }
 
-        /// Default destructor.
-        ///
-        /// @return
-        virtual ~CTestEventHandler()
-        {
-            ACE_DEBUG((LM_DEBUG, ACE_TEXT("%I(%t) Destroying test event handler.\n")));
-        }
+  /// This method is called when a handler is canceled
+  int cancel_type (Timer_Queue_t*,
+                   ICustomEventHandler*&,
+                   const int&,
+                   int&)
+  {
+    return 0;
+  }
 
-        /// Main functor method.
-        ///
-        /// @return int
-        /// @param p_vParameter
-        virtual int operator() (void* p_vParameter)
-        {
-            long iParameter = ACE_Utils::truncate_cast<long> ((intptr_t)p_vParameter);
+  /// This method is called when a timer is canceled
+  int cancel_timer (Timer_Queue_t*,
+                    ICustomEventHandler*&,
+                    const int&,
+                    const int&)
+  {
+    ACE_TRACE ("cancel_timer");
 
-            ACE_DEBUG((LM_DEBUG,
-                       ACE_TEXT("%I(%t) Incrementing test event handler call count by %d.\n"),
-                       iParameter));
-
-            m_Mutex.acquire();
-            *m_p_iCallCount += iParameter;
-            m_Mutex.release();
+    return 0;
+  }
 
-            // Success
-            return 0;
-        }
+  /// This method is called when the timer queue is destroyed and
+  /// the timer is still contained in it
+  int deletion (Timer_Queue_t*,
+                ICustomEventHandler*& p_Handler,
+                const void*)
+  {
+    ACE_TRACE ("deletion");
 
-    private:
+    delete p_Handler;
+    return 0;
+  }
 
-        long* m_p_iCallCount;
-        ACE_Thread_Mutex m_Mutex;
+ private:
+  ACE_UNIMPLEMENTED_FUNC (CCustomEventHandlerUpcall (const CCustomEventHandlerUpcall&));
+  ACE_UNIMPLEMENTED_FUNC (CCustomEventHandlerUpcall &operator= (const CCustomEventHandlerUpcall&));
 };
 
 // Used for the actual timer queue thread adapter
+typedef CCustomEventHandlerUpcall Upcall_t;
+typedef ACE_Timer_Queue_Adapter_Base<ICustomEventHandler*> TimerQueueAdapterBase_t;
+typedef ACE_Timer_Heap_T <ICustomEventHandler*,
+                          Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          ACE_Default_Time_Policy> TTimerHeap;
+typedef TTimerHeap::HEAP_ITERATOR_T TTimerHeapIterator;
+typedef ACE_Thread_Timer_Queue_Adapter<TTimerHeap,
+                                       ICustomEventHandler*> TTimerHeapThreadAdapter;
+typedef ACE_Timer_List_T <ICustomEventHandler*,
+                          Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          ACE_Default_Time_Policy> TTimerList;
+typedef TTimerList::LIST_ITERATOR_T TTimerListIterator;
+typedef ACE_Thread_Timer_Queue_Adapter<TTimerList,
+                                       ICustomEventHandler*> TTimerListThreadAdapter;
 typedef ACE_Timer_Wheel_T <ICustomEventHandler*,
-                           CCustomEventHandlerUpcall,
-                           ACE_Null_Mutex> TTimerWheel;
-typedef ACE_Timer_Wheel_Iterator_T <ICustomEventHandler*,
-                                    CCustomEventHandlerUpcall,
-                                    ACE_Null_Mutex> TTimerWheelIterator;
+                           Upcall_t,
+                           ACE_SYNCH_NULL_MUTEX,
+                           ACE_Default_Time_Policy> TTimerWheel;
+typedef TTimerWheel::WHEEL_ITERATOR_T TTimerWheelIterator;
 typedef ACE_Thread_Timer_Queue_Adapter<TTimerWheel,
                                        ICustomEventHandler*> TTimerWheelThreadAdapter;
+// hashed timer queues
+typedef ACE_Timer_Hash_Upcall<Timer_Queue_t,
+                              ICustomEventHandler*,
+                              Upcall_t> TTimerHashUpcall;
+typedef ACE_Timer_Heap_T <ICustomEventHandler*,
+                          TTimerHashUpcall,
+                          ACE_SYNCH_NULL_MUTEX,
+                          ACE_Default_Time_Policy> TTimerHeapHash;
+typedef ACE_Timer_Hash_T <ICustomEventHandler*,
+                          Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          TTimerHeapHash,
+                          ACE_Default_Time_Policy> TTimerHashHeap;
+typedef TTimerHashHeap::HASH_ITERATOR_T TTimerHashHeapIterator;
+typedef ACE_Thread_Timer_Queue_Adapter<TTimerHashHeap,
+                                       ICustomEventHandler*> TTimerHashHeapThreadAdapter;
+typedef ACE_Timer_List_T <ICustomEventHandler*,
+                          TTimerHashUpcall,
+                          ACE_SYNCH_NULL_MUTEX,
+                          ACE_Default_Time_Policy> TTimerListHash;
+typedef ACE_Timer_Hash_T <ICustomEventHandler*,
+                          Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          TTimerListHash,
+                          ACE_Default_Time_Policy> TTimerHashList;
+typedef TTimerHashList::HASH_ITERATOR_T TTimerHashListIterator;
+typedef ACE_Thread_Timer_Queue_Adapter<TTimerHashList,
+                                       ICustomEventHandler*> TTimerHashListThreadAdapter;
+typedef ACE_Timer_Wheel_T <ICustomEventHandler*,
+                           TTimerHashUpcall,
+                           ACE_SYNCH_NULL_MUTEX,
+                           ACE_Default_Time_Policy> TTimerWheelHash;
+typedef ACE_Timer_Hash_T <ICustomEventHandler*,
+                          Upcall_t,
+                          ACE_SYNCH_NULL_MUTEX,
+                          TTimerWheelHash,
+                          ACE_Default_Time_Policy> TTimerHashWheel;
+typedef TTimerHashWheel::HASH_ITERATOR_T TTimerHashWheelIterator;
+typedef ACE_Thread_Timer_Queue_Adapter<TTimerHashWheel,
+                                       ICustomEventHandler*> TTimerHashWheelThreadAdapter;
 
-#endif /* ACE_HAS_THREADS */
-
-int
-run_main (int, ACE_TCHAR *[])
+// available strategies
+enum strategy_t
 {
-    ACE_START_TEST (ACE_TEXT ("Thread_Timer_Queue_Adapter_Test"));
-
-#if defined (ACE_HAS_THREADS)
+  QUEUE_HEAP = 0,
+  QUEUE_LIST,
+  QUEUE_WHEEL,
+  //
+  QUEUE_HASH_HEAP,
+  QUEUE_HASH_LIST,
+  QUEUE_HASH_WHEEL,
+  //
+  QUEUE_INVALID
+};
+typedef std::set<strategy_t> strategies_t;
+typedef strategies_t::const_iterator strategiesIterator_t;
+static strategies_t strategies;
+
+// Number of iterations for the performance tests.  Some platforms
+// have a very high ACE_DEFAULT_TIMERS (HP-UX is 400), so limit this
+// to a reasonable run time.
+#if (ACE_DEFAULT_TIMERS > 20)
+static int max_iterations = 20000;
+#else
+static int max_iterations = ACE_DEFAULT_TIMERS * 100;
+#endif
 
-    // Start the thread adapter
-    TTimerWheelThreadAdapter TimerWheelThreadAdapter;
-    TimerWheelThreadAdapter.activate();
+// Amount of time between each timer.
+// (0 schedules all the timers to expire at exactly the same time.)
+// in milliseconds
+static int TIMER_DISTANCE = 20;
 
-    // Single timer
-    {
-        // Create a test event handler
-        long iCallCount = 0;
-        CTestEventHandler* p_TestEventHandler = 0;
-        ACE_NEW_RETURN(p_TestEventHandler, CTestEventHandler(&iCallCount), -1);
+enum scheduler_mode_t
+{
+  MODE_SCHEDULE_ONLY = 0,
+  MODE_SCHEDULE_CANCEL,
+  //
+  MODE_INVALID
+};
 
-        ACE_DEBUG((LM_DEBUG,
-            ACE_TEXT("%I(%t) Scheduling timer...\n")));
+class Event_Scheduler : public ACE_Task<ACE_MT_SYNCH>
+{
+ public:
+  Event_Scheduler (TimerQueueAdapterBase_t* tqa,
+                   ICustomEventHandler* eh,
+                   ACE_Time_Value* p,
+                   timer_ids_t* t,
+                   const ACE_Time_Value& md,
+                   const scheduler_mode_t& m)
+   : tqa_ (tqa)
+   , eh_ (eh)
+   , p_ (p)
+   , t_(t)
+   , md_ (md)
+   , m_ (m)
+   , s_ (0)
+   , c_ (0) { }
+
+  virtual int svc()
+  {
+    ACE_ASSERT (tqa_);
+    ACE_ASSERT (eh_);
+    ACE_ASSERT (p_);
+    ACE_ASSERT (t_);
+
+    long timer_id = -1;
+    int i = 0, j;
+    double coefficient =
+      static_cast<double> (md_.msec ()) / (static_cast<double> (RAND_MAX) + 1.0F);
+    double c = 0.0F;
+    ACE_Time_Value delay = ACE_Time_Value::zero;
+    unsigned int seed = static_cast<unsigned int> (ACE_OS::time (0L));
+    int random_number = 0;
+    bool do_schedule = true;
+    timer_ids_iterator_t iterator;
+    do
+      {
+        // sleep ?
+        delay = ACE_Time_Value::zero;
+        if (md_ != ACE_Time_Value::zero)
+          {
+            random_number = ACE_OS::rand_r (&seed);
+            delay.usec (static_cast<suseconds_t> (coefficient                         *
+                                                  static_cast<double> (random_number) *
+                                                  1000.0F));
+            ACE_OS::sleep (delay);
+          }
+
+        timer_id = -1;
+        switch (m_)
+          {
+            case MODE_SCHEDULE_CANCEL:
+              {
+                do_schedule = true;
+
+                random_number = ACE_OS::rand_r (&seed);
+                c = (1.0F / (static_cast<double> (RAND_MAX) + 1.0F));
+                do_schedule = ((static_cast<double> (random_number) * c) < 0.5F);
+                if (!do_schedule)
+                {
+                  {
+                    ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+                    if (!t_->empty ())
+                    {
+                      c = static_cast<double> (t_->size ()) / ((static_cast<double> (RAND_MAX) + 1.0F));
+                      random_number = ACE_OS::rand_r (&seed);
+                      j = static_cast<int> (random_number * c);
+                      iterator = t_->begin ();
+                      std::advance (iterator, j);
+                      timer_id = *iterator;
+                      ACE_ASSERT ((iterator != t_->end ()) &&
+                                  (timer_id >= 0));
+
+                    }
+                  }
+
+                  if (timer_id != -1)
+                  {
+                    const void* act = 0;
+                    j = tqa_->cancel (timer_id, &act, 0);
+
+                    {
+                      ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+                      if (j > 0)
+                      {
+                        ACE_TEST_ASSERT (act == &timer_act);
+                        c_ += j;
+                      }
+
+                      for (iterator = t_->begin ();
+                           iterator != t_->end ();
+                           iterator++)
+                      {
+                        if (*iterator == timer_id)
+                          break;
+                      }
+                      if (iterator != t_->end ())
+                        t_->erase (iterator);
+                    }
+
+                    break;
+                  }
+                }
+
+                // fall through
+              }
+            case MODE_SCHEDULE_ONLY:
+              {
+                timer_id = tqa_->schedule(eh_,
+                                          &timer_act,
+                                          tqa_->gettimeofday () + p_[i++],
+                                          ACE_Time_Value::zero);
+                ACE_TEST_ASSERT (timer_id >= 0);
+
+                {
+                  ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+                  t_->push_back (timer_id);
+                  s_++;
+                }
+
+                if (i == max_iterations)
+                  i = 0;
+
+                break;
+              }
+            default:
+              {
+                ACE_DEBUG ((LM_ERROR,
+                            ACE_TEXT ("invalid scheduler mode (was : %d), aborting\n"),
+                            m_));
+
+                return -1;
+              }
+          }
+      } while (msg_queue_->is_empty ());
+
+      // clean up
+      if (thr_count () == 1)
+      {
+        int result = msg_queue_->flush ();
+        ACE_ASSERT (result > 0);
+      }
 
-        TimerWheelThreadAdapter.schedule(p_TestEventHandler,
-            (void*) 1,
-            ACE_OS::gettimeofday() + ACE_Time_Value(1, 0));
+    return 0;
+  }
 
-        ACE_OS::sleep(ACE_Time_Value(1, 100 * 1000));
-        ACE_TEST_ASSERT(iCallCount == 1);
+  void set_mode(const scheduler_mode_t& m) { m_ = m; }
+  void set_maximum_delay (const ACE_Time_Value& md) { md_ = md; }
+  unsigned int num_scheduled() const { return s_; }
+  unsigned int num_cancelled() const { return c_; }
+  void reset() { s_ = 0; c_ = 0; }
+
+ private:
+  TimerQueueAdapterBase_t* tqa_;
+  ICustomEventHandler*     eh_;
+  ACE_Time_Value*          p_;
+  timer_ids_t*             t_;
+  ACE_Time_Value           md_;
+  scheduler_mode_t         m_;
+  unsigned int             s_;
+  unsigned int             c_;
+  ACE_Thread_Mutex         l_;
+};
 
-        delete p_TestEventHandler;
+#endif /* ACE_HAS_THREADS */
 
-        ACE_DEBUG((LM_DEBUG, ACE_TEXT("%I(%t) Success in Single timer test.\n")));
-    }
+static void
+test_functionality (TimerQueueAdapterBase_t* tqa)
+{
+  ACE_ASSERT (tqa);
 
-    // Single timer with cancellation
-    {
-        // Create a test event handler
-        long iCallCount = 0;
-        CTestEventHandler* p_TestEventHandler = 0;
-        ACE_NEW_RETURN(p_TestEventHandler, CTestEventHandler(&iCallCount), -1);
+  call_count = 0;
 
-        ACE_DEBUG((LM_DEBUG,
-            ACE_TEXT("%I(%t) Scheduling timer...\n")));
+  // Single timer
+  {
+    // Create a test event handler
+    ICustomEventHandler* p_TestEventHandler = 0;
+    ACE_NEW (p_TestEventHandler,
+             CTestEventHandler ());
+
+    ACE_Time_Value delay (1, 0);
+    tqa->schedule (p_TestEventHandler,
+                   &timer_act,
+                   tqa->gettimeofday () + delay,
+                   ACE_Time_Value::zero);
+    ACE_OS::sleep (delay + ACE_Time_Value (0, 100 * 1000));
+    ACE_TEST_ASSERT (call_count == 1);
+
+    delete p_TestEventHandler;
+
+    ACE_DEBUG ((LM_DEBUG,
+                ACE_TEXT ("%I(%t) Success in Single timer test.\n")));
+  }
+
+  // Single timer with cancellation
+  {
+    call_count = 0;
+
+    // Create a test event handler
+    ICustomEventHandler* p_TestEventHandler = 0;
+    ACE_NEW (p_TestEventHandler,
+             CTestEventHandler ());
+
+    ACE_Time_Value delay (1, 0);
+    long lTimerHandle = tqa->schedule (p_TestEventHandler,
+                                       &timer_act,
+                                       tqa->gettimeofday () + delay,
+                                       ACE_Time_Value::zero);
+    ACE_TEST_ASSERT (lTimerHandle >= 0);
+
+    // Cancel the timer
+    int result = -1;
+    const void* act = 0;
+    result = tqa->cancel (lTimerHandle, &act, 1);
+    ACE_TEST_ASSERT (result == 1);
+    ACE_TEST_ASSERT (act == &timer_act);
+
+    ACE_OS::sleep (delay + ACE_Time_Value(0, 100 * 1000));
+    ACE_TEST_ASSERT (call_count == 0);
+
+    // Test event handler was deleted by the timer.
+
+    ACE_DEBUG ((LM_DEBUG,
+                ACE_TEXT ("%I(%t) Success in Single timer with cancellation test.\n")));
+  }
+
+  // Repeating timer with cancellation
+  {
+  call_count = 0;
+
+  // Create a test event handler
+  ICustomEventHandler* p_TestEventHandler = 0;
+  ACE_NEW (p_TestEventHandler,
+           CTestEventHandler ());
+  ACE_ASSERT (p_TestEventHandler);
+
+  ACE_Time_Value delay (1, 0);
+  ACE_Time_Value interval (1, 0);
+  long lTimerHandle = tqa->schedule (p_TestEventHandler,
+                                     &timer_act,
+                                     tqa->gettimeofday () + delay,
+                                     interval);
+  ACE_TEST_ASSERT (lTimerHandle >= 0);
+
+  ACE_OS::sleep (ACE_Time_Value (3, 500 * 1000));
+  ACE_TEST_ASSERT (call_count == 3);
+
+  // Cancel the repeating timer
+  int result = -1;
+  const void* act = 0;
+  result = tqa->cancel (lTimerHandle, &act, 1);
+  ACE_TEST_ASSERT (result == 1);
+  ACE_TEST_ASSERT (act == &timer_act);
+
+  // Test event handler was deleted by the timer.
+
+  ACE_DEBUG ((LM_DEBUG,
+              ACE_TEXT ("%I(%t) Success in Repeating timer with cancellation test.\n")));
+  }
+
+  // Multiple timers
+  {
+    call_count = 0;
+
+    // Create a test event handler
+    ICustomEventHandler* p_TestEventHandler = 0;
+    ACE_NEW (p_TestEventHandler,
+             CTestEventHandler ());
+    ACE_ASSERT (p_TestEventHandler);
+
+    ACE_Time_Value delay (1, 0);
+    tqa->schedule (p_TestEventHandler,
+                   &timer_act,
+                   tqa->gettimeofday () + delay,
+                   ACE_Time_Value::zero);
+
+    tqa->schedule (p_TestEventHandler,
+                   &timer_act,
+                   tqa->gettimeofday () + delay,
+                   ACE_Time_Value::zero);
+
+    delay.sec (2);
+    tqa->schedule (p_TestEventHandler,
+                   &timer_act,
+                   tqa->gettimeofday () + delay,
+                   ACE_Time_Value::zero);
+
+    ACE_OS::sleep (ACE_Time_Value (2, 500 * 1000));
+    ACE_TEST_ASSERT (call_count == 3);
+
+    delete p_TestEventHandler;
+
+    ACE_DEBUG ((LM_DEBUG,
+                ACE_TEXT ("%I(%t) Success in Multiple timers test.\n")));
+  }
+}
 
-        long lTimerHandle =
-            TimerWheelThreadAdapter.schedule(p_TestEventHandler,
-                (void*) 1,
-                ACE_OS::gettimeofday() + ACE_Time_Value(1, 0));
+static void
+test_stability (TimerQueueAdapterBase_t* tqa)
+{
+  ACE_ASSERT (tqa);
 
-        // Cancel the repeating timer
-        TimerWheelThreadAdapter.cancel(lTimerHandle);
+  ACE_Message_Block* stop = 0;
+  ACE_NEW (stop,
+           ACE_Message_Block ((ACE_Allocator*)0));
+  ACE_ASSERT (stop);
+  stop->msg_type (ACE_Message_Block::MB_STOP);
+
+  ICustomEventHandler* p_TestEventHandler = 0;
+  ACE_NEW (p_TestEventHandler,
+           CTestEventHandler ());
+  ACE_ASSERT (p_TestEventHandler);
+
+  int remaining_timers = 0;
+
+  // Set up a bunch of times TIMER_DISTANCE ms apart.
+  ACE_Time_Value *periods = 0;
+  ACE_NEW_NORETURN (periods,
+                    ACE_Time_Value [max_iterations]);
+  ACE_ASSERT (periods);
+  for (int i = 0; i < max_iterations; i++)
+    periods[i] = ACE_Time_Value (0, i * TIMER_DISTANCE * 1000);
+  randomize (periods,
+             max_iterations,
+             static_cast<unsigned int> (ACE_OS::time (0L)));
+
+  // Test brute-force scheduling behaviour
+  call_count = 0;
+
+  Event_Scheduler scheduler (tqa,
+                             p_TestEventHandler,
+                             periods,
+                             &timer_ids,
+                             ACE_Time_Value::zero,
+                             MODE_SCHEDULE_ONLY);
+
+  ACE_Message_Block* mb = stop->duplicate ();
+  ACE_ASSERT (mb);
+  mb->msg_type (ACE_Message_Block::MB_STOP);
+
+  ACE_Profile_Timer timer;
+  ACE_Profile_Timer::ACE_Elapsed_Time elapsed_time;
+
+  timer.start ();
+
+  int result = scheduler.activate (0L,
+                                   max_threads);
+  ACE_ASSERT (result == 0);
+  ACE_OS::sleep (bf_running_time);
+  result = scheduler.putq (mb);
+  ACE_ASSERT (result == 1);
+  result = scheduler.wait ();
+  ACE_ASSERT (result == 0);
+  timer.stop ();
+
+  remaining_timers = tqa->cancel (p_TestEventHandler, 1);
+  timer_ids.clear();
+
+  timer.elapsed_time (elapsed_time);
+  ACE_DEBUG ((LM_DEBUG,
+              ACE_TEXT ("%I(%t) brute-force scheduling:\t\t%#T (scheduled/dispatched): %d / %d; real/user/system time (secs): %.3f / %.3f / %.3f)\n"),
+              &bf_running_time, scheduler.num_scheduled (), call_count,
+              elapsed_time.real_time, elapsed_time.user_time, elapsed_time.system_time));
+  ACE_TEST_ASSERT (scheduler.num_scheduled () == (remaining_timers + call_count));
+
+  mb = stop->duplicate ();
+  ACE_ASSERT (mb);
+  mb->msg_type (ACE_Message_Block::MB_STOP);
+
+  //// Test random delay scheduling behaviour
+  //call_count = 0;
+
+  //scheduler.reset ();
+  //scheduler.set_maximum_delay(rd_maximum_interval);
+
+  //timer.start ();
+  //result = scheduler.activate (0L,
+  //                             max_threads);
+  //ACE_ASSERT (result == 0);
+  //ACE_OS::sleep (rd_running_time);
+  //result = scheduler.putq (mb);
+  //ACE_ASSERT (result == 1);
+  //result = scheduler.wait ();
+  //ACE_ASSERT (result == 0);
+  //timer.stop();
+
+  //remaining_timers = tqa->cancel (p_TestEventHandler, 1);
+  //timer_ids.clear();
+
+  //timer.elapsed_time (elapsed_time);
+  //ACE_DEBUG ((LM_DEBUG,
+  //            ACE_TEXT ("%I(%t) random delay scheduling:\t%#T (scheduled/dispatched): %d / %d; real/user/system time (secs): %.3f / %.3f / %.3f)\n"),
+  //            &rd_running_time, scheduler.num_scheduled (), call_count,
+  //            elapsed_time.real_time, elapsed_time.user_time, elapsed_time.system_time));
+  //ACE_TEST_ASSERT (scheduler.num_scheduled () == (remaining_timers + call_count));
+
+  //mb = stop->duplicate();
+  //ACE_ASSERT (mb);
+  //mb->msg_type(ACE_Message_Block::MB_STOP);
+
+  // Test high-throughput scheduling/cancellation behaviour
+  call_count = 0;
+
+  scheduler.reset ();
+  scheduler.set_mode (MODE_SCHEDULE_CANCEL);
+  scheduler.set_maximum_delay(ht_maximum_interval);
+
+  timer.start ();
+  result = scheduler.activate (0L,
+                               max_threads);
+  ACE_ASSERT (result == 0);
+  ACE_OS::sleep (ht_running_time);
+  result = scheduler.putq (mb);
+  ACE_ASSERT (result == 1);
+  result = scheduler.wait ();
+  ACE_ASSERT (result == 0);
+  timer.stop ();
+
+  remaining_timers = tqa->cancel (p_TestEventHandler, 1);
+
+  timer.elapsed_time (elapsed_time);
+  ACE_DEBUG((LM_DEBUG,
+             ACE_TEXT ("%I(%t) high throughput scheduling:\t%#T (scheduled/cancelled): %d / %d; real/user/system time (secs): %.3f / %.3f / %.3f\n"),
+             &ht_running_time, scheduler.num_scheduled (), scheduler.num_cancelled (),
+             elapsed_time.real_time, elapsed_time.user_time, elapsed_time.system_time));
+  ACE_TEST_ASSERT ((scheduler.num_scheduled() - scheduler.num_cancelled()) == (remaining_timers + call_count));
+
+  // clean up
+  delete stop;
+  delete p_TestEventHandler;
+  delete [] periods;
+}
 
-        ACE_OS::sleep(ACE_Time_Value(1, 100 * 1000));
+/**
+* @class Timer_Queue_Stack
+*
+* @brief Keeps track of the <Timer_Queue_Thread_Adapter>s that we're going to test.
+*
+* This data structure is organized as a stack to make it easy to implement.
+*/
+class Thread_Adapter_Stack
+{
+ public:
+  // = Initialization method
+  Thread_Adapter_Stack (const strategy_t& strategy,
+                        TimerQueueAdapterBase_t *tqa,
+                        const ACE_TCHAR *name,
+                        Thread_Adapter_Stack *next = 0)
+   : strategy_ (strategy)
+   , tqa_ (tqa)
+   , name_ (name)
+   , next_ (next) { }
+  // "Push" a new <queue> on the stack of <queue>s.
+
+  /// corresponding timer queue strategy
+  strategy_t strategy_;
 
-        ACE_TEST_ASSERT(iCallCount == 0);
+  /// Pointer to the subclass of <TimerQueueAdapterBase_t> that we're testing.
+  TimerQueueAdapterBase_t *tqa_;
 
-        // Test event handler was deleted by the timer.
+  /// Name of the Queue that we're testing.
+  const ACE_TCHAR *name_;
 
-        ACE_DEBUG((LM_DEBUG, ACE_TEXT("%I(%t) Success in Single timer with cancellation test.\n")));
-    }
+  /// Pointer to the next <Thread_Adapter>.
+  Thread_Adapter_Stack *next_;
+};
 
-    // Repeating timer with cancellation
-    {
-        // Create a test event handler
-        long iCallCount = 0;
-        CTestEventHandler* p_TestEventHandler = 0;
-        ACE_NEW_RETURN(p_TestEventHandler, CTestEventHandler(&iCallCount), -1);
-
-        ACE_DEBUG((LM_DEBUG,
-                   ACE_TEXT("%I(%t) Scheduling timer...\n")));
-
-        long lTimerHandle =
-            TimerWheelThreadAdapter.schedule
-                (p_TestEventHandler,
-                 (void*) 1,
-                 ACE_OS::gettimeofday() + ACE_Time_Value(1, 0),
-                 ACE_Time_Value(1, 0));
-
-        ACE_OS::sleep(ACE_Time_Value(3, 500 * 1000));
-        ACE_TEST_ASSERT(iCallCount == 3);
+int
+run_main (int argc, ACE_TCHAR* argv[])
+{
+  ACE_START_TEST (ACE_TEXT ("Thread_Timer_Queue_Adapter_Test"));
 
-        // Cancel the repeating timer
-        TimerWheelThreadAdapter.cancel(lTimerHandle);
+  bool run_stability_tests = false;
 
-        ACE_TEST_ASSERT(iCallCount == 3);
+  ACE_Get_Opt argument_parser (argc,
+                               argv,
+                               ACE_TEXT ("ahi:lst:wx"));
+  int option = 0;
+  while ((option = argument_parser ()) != EOF)
+    {
+      switch (option)
+        {
+          case 'a':
+            {
+              for (int i = 0; i < QUEUE_INVALID; i++)
+                strategies.insert (static_cast<strategy_t> (i));
+
+              break;
+            }
+          case 'h':
+            {
+              strategies.insert (QUEUE_HEAP);
+
+              break;
+            }
+          case 'i':
+            {
+              max_iterations = ACE_OS::atoi (argument_parser.opt_arg ());
+
+              break;
+            }
+          case 'l':
+            {
+              strategies.insert (QUEUE_LIST);
+
+              break;
+            }
+          case 's':
+            {
+              strategies.insert (QUEUE_HASH_HEAP);
+              strategies.insert (QUEUE_HASH_LIST);
+              strategies.insert (QUEUE_HASH_WHEEL);
+
+              break;
+            }
+          case 't':
+            {
+              max_threads = ACE_OS::atoi(argument_parser.opt_arg());
+
+              break;
+            }
+          case 'w':
+            {
+              strategies.insert (QUEUE_WHEEL);
+
+              break;
+            }
+          case 'x':
+            {
+              run_stability_tests = true;
+
+              break;
+            }
+          // long options
+          case 0:
+          // non-options
+          case 1:
+            break;
+          // error handling
+          case '?':
+          case ':':
+            {
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT ("unrecognized option \"%s\", aborting\n"),
+                          ACE_TEXT (argument_parser.last_option ())));
+
+              // fall through
+            }
+          default:
+            {
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT("unrecognized option \"%c\", aborting\n"),
+                          option));
+
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT("\nusage: %s \n\n")
+                          ACE_TEXT("\t[-a] all strategies (defaults to true)\n")
+                          ACE_TEXT("\t[-h] heap strategy (defaults to false)\n")
+                          ACE_TEXT("\t[-i #timers] #iterations (defaults to %d)\n")
+                          ACE_TEXT("\t[-l] list strategy (defaults to false)\n")
+                          ACE_TEXT("\t[-s] hash strategy (defaults to false)\n")
+                          ACE_TEXT("\t[-t #threads] #threads (defaults to %d)\n")
+                          ACE_TEXT("\t[-w] wheel strategy (defaults to false)\n")
+                          ACE_TEXT("\t[-x] run stability tests (defaults to false)\n")
+                          ACE_TEXT("\n"),
+                          argv[0],
+                          max_iterations,
+                          max_threads));
 
-        ACE_DEBUG((LM_DEBUG,
-                   ACE_TEXT("%I(%t) Success in Repeating timer with cancellation test.\n")));
+              return EXIT_FAILURE;
+            }
+        }
+    }
+  // *NOTE*: test all available strategies by default
+  if (strategies.empty ())
+    for (int i = 0; i < QUEUE_INVALID; i++)
+      strategies.insert (static_cast<strategy_t> (i));
+
+  #if defined (ACE_HAS_THREADS)
+
+  TTimerHeapThreadAdapter TimerHeapThreadAdapter;
+  TTimerListThreadAdapter TimerListThreadAdapter;
+  TTimerWheelThreadAdapter TimerWheelThreadAdapter;
+  TTimerHashHeapThreadAdapter TimerHashHeapThreadAdapter;
+  TTimerHashListThreadAdapter TimerHashListThreadAdapter;
+  TTimerHashWheelThreadAdapter TimerHashWheelThreadAdapter;
+
+  Thread_Adapter_Stack *tqa_stack = 0;
+  for (strategiesIterator_t iterator = strategies.begin ();
+       iterator != strategies.end ();
+       iterator++)
+    {
+      switch (*iterator)
+        {
+          case QUEUE_HEAP:
+            // TimerHeapThreadAdapter
+            ACE_NEW_RETURN (tqa_stack,
+                            Thread_Adapter_Stack (*iterator,
+                                                  &TimerHeapThreadAdapter,
+                                                  ACE_TEXT ("TimerHeapThreadAdapter"),
+                                                  tqa_stack),
+                            -1);
+            break;
+          case QUEUE_LIST:
+            // TimerListThreadAdapter
+            ACE_NEW_RETURN (tqa_stack,
+                            Thread_Adapter_Stack (*iterator,
+                                                  &TimerListThreadAdapter,
+                                                  ACE_TEXT ("TimerListThreadAdapter"),
+                                                  tqa_stack),
+                            -1);
+            break;
+          case QUEUE_WHEEL:
+            // TimerWheelThreadAdapter
+            ACE_NEW_RETURN (tqa_stack,
+                            Thread_Adapter_Stack (*iterator,
+                                                  &TimerWheelThreadAdapter,
+                                                  ACE_TEXT ("TimerWheelThreadAdapter"),
+                                                  tqa_stack),
+                            -1);
+            break;
+            //
+          case QUEUE_HASH_HEAP:
+            // TimerHashHeapThreadAdapter
+            ACE_NEW_RETURN (tqa_stack,
+                            Thread_Adapter_Stack (*iterator,
+                                                  &TimerHashHeapThreadAdapter,
+                                                  ACE_TEXT ("TimerHashHeapThreadAdapter"),
+                                                  tqa_stack),
+                            -1);
+            break;
+          case QUEUE_HASH_LIST:
+            // TimerHashListThreadAdapter
+            ACE_NEW_RETURN (tqa_stack,
+                            Thread_Adapter_Stack (*iterator,
+                                                  &TimerHashListThreadAdapter,
+                                                  ACE_TEXT ("TimerHashListThreadAdapter"),
+                                                  tqa_stack),
+                            -1);
+            break;
+          case QUEUE_HASH_WHEEL:
+            // TimerHashWheelThreadAdapter
+            ACE_NEW_RETURN (tqa_stack,
+                            Thread_Adapter_Stack (*iterator,
+                                                  &TimerHashWheelThreadAdapter,
+                                                  ACE_TEXT ("TimerHashWheelThreadAdapter"),
+                                                  tqa_stack),
+                            -1);
+            break;
+          default:
+            {
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT ("invalid queueing strategy (was: %d), continuing\n"),
+                          *iterator));
+              continue;
+            }
+        }
     }
+  ACE_ASSERT (tqa_stack);
 
-    // Multiple timers
+  Thread_Adapter_Stack *tqa_ptr = tqa_stack;
+  while (tqa_ptr)
     {
-        // Create a test event handler
-        long iCallCount = 0;
-        CTestEventHandler* p_TestEventHandler = 0;
-        ACE_NEW_RETURN(p_TestEventHandler, CTestEventHandler(&iCallCount), -1);
-
-        ACE_DEBUG((LM_DEBUG,
-                   ACE_TEXT("%I(%t) Scheduling timer...\n")));
-
-        TimerWheelThreadAdapter.schedule
-                (p_TestEventHandler,
-                 (void*) 1,
-                 ACE_OS::gettimeofday() + ACE_Time_Value(1, 0));
-
-        TimerWheelThreadAdapter.schedule
-                (p_TestEventHandler,
-                 (void*) 1,
-                 ACE_OS::gettimeofday() + ACE_Time_Value(1, 0));
-
-        TimerWheelThreadAdapter.schedule
-                (p_TestEventHandler,
-                 (void*) 1,
-                 ACE_OS::gettimeofday() + ACE_Time_Value(2, 0));
+      ACE_DEBUG ((LM_DEBUG,
+                  ACE_TEXT ("############################# %s #############################\n"),
+                  tqa_ptr->name_));
+
+      switch (tqa_ptr->strategy_)
+        {
+          case QUEUE_HEAP:
+            TimerHeapThreadAdapter.activate (); break;
+          case QUEUE_LIST:
+            TimerListThreadAdapter.activate (); break;
+          case QUEUE_WHEEL:
+            TimerWheelThreadAdapter.activate (); break;
+          //
+          case QUEUE_HASH_HEAP:
+            TimerHashHeapThreadAdapter.activate (); break;
+          case QUEUE_HASH_LIST:
+            TimerHashListThreadAdapter.activate (); break;
+          case QUEUE_HASH_WHEEL:
+            TimerHashWheelThreadAdapter.activate (); break;
+          default:
+            {
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT ("invalid queueing strategy (was: %d), continuing\n"),
+                          tqa_ptr->strategy_));
+              continue;
+            }
+        }
+
+      test_functionality (tqa_ptr->tqa_);
+      if (run_stability_tests)
+        test_stability (tqa_ptr->tqa_);
 
-        ACE_OS::sleep(ACE_Time_Value(3, 0));
-        ACE_TEST_ASSERT(iCallCount == 3);
+      switch (tqa_ptr->strategy_)
+        {
+          case QUEUE_HEAP:
+            TimerHeapThreadAdapter.deactivate ();
+            TimerHeapThreadAdapter.wait ();
+            break;
+          case QUEUE_LIST:
+            TimerListThreadAdapter.deactivate ();
+            TimerListThreadAdapter.wait ();
+            break;
+          case QUEUE_WHEEL:
+            TimerWheelThreadAdapter.deactivate ();
+            TimerWheelThreadAdapter.wait ();
+            break;
+            //
+          case QUEUE_HASH_HEAP:
+            TimerHashHeapThreadAdapter.deactivate ();
+            TimerHashHeapThreadAdapter.wait ();
+            break;
+          case QUEUE_HASH_LIST:
+            TimerHashListThreadAdapter.deactivate ();
+            TimerHashListThreadAdapter.wait ();
+            break;
+          case QUEUE_HASH_WHEEL:
+            TimerHashWheelThreadAdapter.deactivate ();
+            TimerHashWheelThreadAdapter.wait ();
+            break;
+          default:
+          {
+            ACE_DEBUG ((LM_ERROR,
+                        ACE_TEXT ("invalid queueing strategy (was: %d), continuing\n"),
+                        tqa_ptr->strategy_));
+            continue;
+          }
+        }
 
-        delete p_TestEventHandler;
+        ACE_DEBUG ((LM_DEBUG,
+                    ACE_TEXT ("\\END##############################################################\\END\n")));
 
-        ACE_DEBUG((LM_DEBUG, ACE_TEXT("%I(%t) Success in Multiple timers test.\n")));
+      Thread_Adapter_Stack *temp = tqa_ptr;
+      tqa_ptr = tqa_ptr->next_;
+      delete temp;
     }
 
 #else
   ACE_ERROR ((LM_INFO,
               ACE_TEXT ("threads not supported on this platform\n")));
 #endif /* ACE_HAS_THREADS */
-    ACE_END_TEST;
+  ACE_END_TEST;
 
-    return 0;
+  return 0;
 }
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/tests/Timer_Queue_Reference_Counting_Test.cpp ACE_wrappers/tests/Timer_Queue_Reference_Counting_Test.cpp
--- ACE_wrappers_6_2_7/tests/Timer_Queue_Reference_Counting_Test.cpp	2014-08-01 00:54:03.047891300 +0100
+++ ACE_wrappers/tests/Timer_Queue_Reference_Counting_Test.cpp	2014-08-01 15:38:31.205769800 +0100
@@ -13,7 +13,6 @@
  */
 //=============================================================================
 
-
 #include "test_config.h"
 #include "ace/Get_Opt.h"
 #include "ace/Timer_Queue.h"
@@ -26,8 +25,6 @@
 #include "ace/Null_Mutex.h"
 #include "ace/OS_NS_unistd.h"
 
-
-
 static int debug = 0;
 static const char *one_second_timeout = "one second timeout";
 static const char *two_second_timeout = "two second timeout";
@@ -47,8 +44,7 @@
 
 class Reference_Counted_Event_Handler : public ACE_Event_Handler
 {
-public:
-
+ public:
   Reference_Counted_Event_Handler (int expected_number_of_handle_close_calls);
 
   ~Reference_Counted_Event_Handler (void);
@@ -64,8 +60,8 @@
 };
 
 Reference_Counted_Event_Handler::Reference_Counted_Event_Handler (int expected_number_of_handle_close_calls)
-  : expected_number_of_handle_close_calls_ (expected_number_of_handle_close_calls),
-    number_of_handle_close_calls_ (0)
+ : expected_number_of_handle_close_calls_ (expected_number_of_handle_close_calls)
+ , number_of_handle_close_calls_ (0)
 {
   this->reference_counting_policy ().value
     (ACE_Event_Handler::Reference_Counting_Policy::ENABLED);
@@ -85,7 +81,7 @@
 
   if (this->expected_number_of_handle_close_calls_ != -1)
     ACE_TEST_ASSERT (this->number_of_handle_close_calls_ ==
-                this->expected_number_of_handle_close_calls_);
+                     this->expected_number_of_handle_close_calls_);
 }
 
 int
@@ -95,7 +91,7 @@
   if (debug)
     ACE_DEBUG ((LM_DEBUG,
                 "Reference count in Reference_Counted_Event_Handler::handle_timeout() for arg = %C is %d\n",
-                (const char *) arg,
+                (const char*)arg,
                 this->reference_count_.value ()));
 
   return 0;
@@ -147,10 +143,11 @@
   long first_timer_id = -1;
   long second_timer_id = -1;
 
+  ACE_Event_Handler* eh = handler;
   if (repeat_timer)
     {
       first_timer_id =
-        timer_queue.schedule (handler,
+        timer_queue.schedule (eh,
                               one_second_timeout,
                               ACE_Time_Value (1) + timer_queue.gettimeofday (),
                               ACE_Time_Value (1));
@@ -159,7 +156,7 @@
   else
     {
       first_timer_id =
-        timer_queue.schedule (handler,
+        timer_queue.schedule (eh,
                               one_second_timeout,
                               ACE_Time_Value (1) + timer_queue.gettimeofday ());
       ACE_TEST_ASSERT (first_timer_id != -1);
@@ -168,7 +165,7 @@
   if (second_timer)
     {
       second_timer_id =
-        timer_queue.schedule (handler,
+        timer_queue.schedule (eh,
                               two_second_timeout,
                               ACE_Time_Value (2) + timer_queue.gettimeofday (),
                               ACE_Time_Value (2));
@@ -178,7 +175,7 @@
   if (cancel_handler)
     {
       result =
-        timer_queue.cancel (handler,
+        timer_queue.cancel (eh,
                             dont_call_handle_close);
 
       if (second_timer)
@@ -208,7 +205,7 @@
 template <class TIMER_QUEUE>
 class cancellation_test
 {
-public:
+ public:
   cancellation_test (const char *);
 };
 
@@ -264,7 +261,7 @@
 invoke_one_upcall (ACE_Timer_Queue &timer_queue)
 {
   ACE_Noop_Command command;
-  return timer_queue.expire_single(command);
+  return timer_queue.expire_single (command);
 }
 
 void
@@ -279,15 +276,16 @@
 
   ACE_Event_Handler_var safe_handler (handler);
 
+  ACE_Event_Handler* eh = handler;
   long timer_id =
-    timer_queue.schedule (handler,
+    timer_queue.schedule (eh,
                           one_second_timeout,
                           ACE_Time_Value (1) + timer_queue.gettimeofday (),
                           ACE_Time_Value (1));
   ACE_TEST_ASSERT (timer_id != -1);
 
   result =
-    timer_queue.schedule (handler,
+    timer_queue.schedule (eh,
                           two_second_timeout,
                           ACE_Time_Value (2) + timer_queue.gettimeofday ());
   ACE_TEST_ASSERT (result != -1);
@@ -312,8 +310,8 @@
 template<class TIMER_QUEUE>
 class expire_test
 {
-public:
-  expire_test (const char *);
+ public:
+  expire_test (const char*);
 };
 
 template <class TIMER_QUEUE>
@@ -332,8 +330,8 @@
 template<class TIMER_QUEUE>
 class upcall_test
 {
-public:
-  upcall_test (const char *);
+ public:
+  upcall_test (const char*);
 };
 
 template <class TIMER_QUEUE>
@@ -351,8 +349,7 @@
 
 class Simple_Event_Handler : public ACE_Event_Handler
 {
-public:
-
+ public:
   Simple_Event_Handler (void);
 
   ~Simple_Event_Handler (void);
@@ -385,7 +382,7 @@
   if (debug)
     ACE_DEBUG ((LM_DEBUG,
                 "Simple_Event_Handler::handle_timeout() for arg = %C\n",
-                (const char *) arg));
+                (const char*)arg));
   return 0;
 }
 
@@ -410,13 +407,13 @@
   int events = 0;
   int result = 0;
   long timer_id = -1;
+	ACE_Event_Handler* eh = 0;
 
   {
-    Simple_Event_Handler *handler =
-      new Simple_Event_Handler;
-
+    ACE_NEW (eh,
+             Simple_Event_Handler ());
     timer_id =
-      timer_queue.schedule (handler,
+      timer_queue.schedule (eh,
                             one_second_timeout,
                             ACE_Time_Value (1) + timer_queue.gettimeofday (),
                             ACE_Time_Value (1));
@@ -430,11 +427,10 @@
   }
 
   {
-    Simple_Event_Handler *handler =
-      new Simple_Event_Handler;
-
+    ACE_NEW (eh,
+             Simple_Event_Handler ());
     timer_id =
-      timer_queue.schedule (handler,
+      timer_queue.schedule (eh,
                             one_second_timeout,
                             ACE_Time_Value (1) + timer_queue.gettimeofday (),
                             ACE_Time_Value (1));
@@ -482,6 +478,7 @@
 static int hash = 1;
 static int wheel = 1;
 static int hashheap = 1;
+static int hashwheel = 1;
 static int test_cancellation = 1;
 static int test_expire = 1;
 static int test_one_upcall = 1;
@@ -490,7 +487,9 @@
 static int
 parse_args (int argc, ACE_TCHAR *argv[])
 {
-  ACE_Get_Opt get_opt (argc, argv, ACE_TEXT ("a:b:c:d:e:l:m:n:o:z:"));
+  ACE_Get_Opt get_opt (argc,
+                       argv,
+                       ACE_TEXT ("a:b:c:d:e:f:l:m:n:o:z:"));
 
   int cc;
   while ((cc = get_opt ()) != -1)
@@ -512,6 +511,9 @@
         case 'e':
           hashheap = ACE_OS::atoi (get_opt.opt_arg ());
           break;
+        case 'f':
+          hashwheel = ACE_OS::atoi(get_opt.opt_arg());
+          break;
         case 'l':
           test_cancellation = ACE_OS::atoi (get_opt.opt_arg ());
           break;
@@ -535,6 +537,7 @@
                       ACE_TEXT ("\t[-c hash]  (defaults to %d)\n")
                       ACE_TEXT ("\t[-d wheel] (defaults to %d)\n")
                       ACE_TEXT ("\t[-e hashheap] (defaults to %d)\n")
+                      ACE_TEXT ("\t[-f hashwheel] (defaults to %d)\n")
                       ACE_TEXT ("\t[-l test_cancellation] (defaults to %d)\n")
                       ACE_TEXT ("\t[-m test_expire] (defaults to %d)\n")
                       ACE_TEXT ("\t[-n test_one_upcall] (defaults to %d)\n")
@@ -547,6 +550,7 @@
                       hash,
                       wheel,
                       hashheap,
+                      hashwheel,
                       test_cancellation,
                       test_expire,
                       test_one_upcall,
@@ -577,9 +581,10 @@
 
       if (heap)  { cancellation_test<ACE_Timer_Heap>  test ("ACE_Timer_Heap");  ACE_UNUSED_ARG (test); }
       if (list)  { cancellation_test<ACE_Timer_List>  test ("ACE_Timer_List");  ACE_UNUSED_ARG (test); }
-      if (hash)  { cancellation_test<ACE_Timer_Hash>  test ("ACE_Timer_Hash");  ACE_UNUSED_ARG (test); }
+      if (hash)  { cancellation_test<ACE_Timer_Hash_List>  test ("ACE_Timer_Hash_List");  ACE_UNUSED_ARG (test); }
       if (wheel) { cancellation_test<ACE_Timer_Wheel> test ("ACE_Timer_Wheel"); ACE_UNUSED_ARG (test); }
       if (hashheap) { cancellation_test<ACE_Timer_Hash_Heap> test ("ACE_Timer_Hash_Heap"); ACE_UNUSED_ARG (test); }
+      if (hashwheel) { cancellation_test<ACE_Timer_Hash_Wheel> test ("ACE_Timer_Hash_Wheel"); ACE_UNUSED_ARG (test); }
     }
 
   if (test_expire)
@@ -589,9 +594,10 @@
 
       if (heap)  { expire_test<ACE_Timer_Heap>  test ("ACE_Timer_Heap");  ACE_UNUSED_ARG (test); }
       if (list)  { expire_test<ACE_Timer_List>  test ("ACE_Timer_List");  ACE_UNUSED_ARG (test); }
-      if (hash)  { expire_test<ACE_Timer_Hash>  test ("ACE_Timer_Hash");  ACE_UNUSED_ARG (test); }
+      if (hash)  { expire_test<ACE_Timer_Hash_List>  test ("ACE_Timer_Hash_List");  ACE_UNUSED_ARG (test); }
       if (wheel) { expire_test<ACE_Timer_Wheel> test ("ACE_Timer_Wheel"); ACE_UNUSED_ARG (test); }
       if (hashheap) { expire_test<ACE_Timer_Hash_Heap> test ("ACE_Timer_Hash_Heap"); ACE_UNUSED_ARG (test); }
+      if (hashwheel) { expire_test<ACE_Timer_Hash_Wheel> test("ACE_Timer_Hash_Wheel"); ACE_UNUSED_ARG (test); }
     }
 
   if (test_one_upcall)
@@ -601,9 +607,10 @@
 
       if (heap)  { upcall_test<ACE_Timer_Heap>  test ("ACE_Timer_Heap");  ACE_UNUSED_ARG (test); }
       if (list)  { upcall_test<ACE_Timer_List>  test ("ACE_Timer_List");  ACE_UNUSED_ARG (test); }
-      if (hash)  { upcall_test<ACE_Timer_Hash>  test ("ACE_Timer_Hash");  ACE_UNUSED_ARG (test); }
+      if (hash)  { upcall_test<ACE_Timer_Hash_List>  test ("ACE_Timer_Hash_List");  ACE_UNUSED_ARG (test); }
       if (wheel) { upcall_test<ACE_Timer_Wheel> test ("ACE_Timer_Wheel"); ACE_UNUSED_ARG (test); }
       if (hashheap) { upcall_test<ACE_Timer_Hash_Heap> test ("ACE_Timer_Hash_Heap"); ACE_UNUSED_ARG (test); }
+      if (hashwheel) { upcall_test<ACE_Timer_Hash_Wheel> test ("ACE_Timer_Hash_Wheel"); ACE_UNUSED_ARG (test); }
     }
 
   if (test_simple)
@@ -613,13 +620,13 @@
 
       if (heap)  { simple_test<ACE_Timer_Heap>  test ("ACE_Timer_Heap");  ACE_UNUSED_ARG (test); }
       if (list)  { simple_test<ACE_Timer_List>  test ("ACE_Timer_List");  ACE_UNUSED_ARG (test); }
-      if (hash)  { simple_test<ACE_Timer_Hash>  test ("ACE_Timer_Hash");  ACE_UNUSED_ARG (test); }
+      if (hash)  { simple_test<ACE_Timer_Hash_List>  test ("ACE_Timer_Hash_List");  ACE_UNUSED_ARG (test); }
       if (wheel) { simple_test<ACE_Timer_Wheel> test ("ACE_Timer_Wheel"); ACE_UNUSED_ARG (test); }
       if (hashheap) { simple_test<ACE_Timer_Hash_Heap> test ("ACE_Timer_Hash_Heap"); ACE_UNUSED_ARG (test); }
+      if (hashwheel) { simple_test<ACE_Timer_Hash_Wheel> test ("ACE_Timer_Hash_Wheel"); ACE_UNUSED_ARG (test); }
     }
 
   ACE_END_TEST;
 
   return 0;
 }
-
diff '--unified=3' --recursive '--exclude-from=/usr/local/src/diff_patterns' --text ACE_wrappers_6_2_7/tests/Timer_Queue_Test.cpp ACE_wrappers/tests/Timer_Queue_Test.cpp
--- ACE_wrappers_6_2_7/tests/Timer_Queue_Test.cpp	2014-08-01 00:54:04.333302500 +0100
+++ ACE_wrappers/tests/Timer_Queue_Test.cpp	2014-08-01 23:20:47.443936400 +0100
@@ -11,11 +11,13 @@
  *    bunch of timers and then adds them to a timer queue. The
  *    functionality of the timer queue is then tested. No command
  *    line arguments are needed to run the test.
- *
+ *    Note: the test is being extended to include validation of queueing- and
+ *    dispatching stability
  *
  *  @author Douglas C. Schmidt <schmidt@cs.wustl.edu>
  *  @author Prashant Jain <pjain@cs.wustl.edu>
  *  @author and Darrell Brunsch <brunsch@cs.wustl.edu>
+ *  @author and Erik Sohns <erik.sohns@web.de>
  */
 //=============================================================================
 
@@ -34,12 +36,48 @@
 #include "ace/OS_NS_unistd.h"
 #include "ace/Containers_T.h"
 #include "ace/Event_Handler.h"
+#include "ace/Get_Opt.h"
+#include "ace/Task.h"
+#include "ace/Message_Block.h"
+
+#include <vector>
+#include <set>
+
+// available strategies
+enum strategy_t
+{
+  QUEUE_HEAP = 0,
+  QUEUE_LIST,
+  QUEUE_WHEEL,
+  QUEUE_HASH,
+  //
+  QUEUE_INVALID
+};
+typedef std::set<strategy_t> strategies_t;
+static strategies_t strategies;
+
+// running time
+#define BF_RUNNING_TIME_SEC 5 // seconds
+static ACE_Time_Value bf_running_time (BF_RUNNING_TIME_SEC, 0);
+#define RD_RUNNING_TIME_SEC 20 // seconds
+static ACE_Time_Value rd_running_time (RD_RUNNING_TIME_SEC, 0);
+#define RD_MAXIMUM_INTERVAL_MSEC 50 // milliseconds
+static ACE_Time_Value rd_maximum_interval (0, RD_MAXIMUM_INTERVAL_MSEC * 1000);
+#define HT_RUNNING_TIME_SEC 60 // seconds
+static ACE_Time_Value ht_running_time (HT_RUNNING_TIME_SEC, 0);
+#define HT_MAXIMUM_INTERVAL_MSEC 1 // milliseconds
+static ACE_Time_Value ht_maximum_interval (0, HT_MAXIMUM_INTERVAL_MSEC * 1000);
+
+typedef std::vector<long> timer_ids_t;
+typedef timer_ids_t::iterator timer_ids_iterator_t;
+static timer_ids_t timer_ids;
+static int timer_act_global = 42;
 
 // Number of iterations for the performance tests.  Some platforms
 // have a very high ACE_DEFAULT_TIMERS (HP-UX is 400), so limit this
 // to a reasonable run time.
 #if (ACE_DEFAULT_TIMERS > 20)
-static int max_iterations = 2000;
+static int max_iterations = 20000;
 #else
 static int max_iterations = ACE_DEFAULT_TIMERS * 100;
 #endif
@@ -47,27 +85,36 @@
 // Amount of time between each timer.
 // (0 schedules all the timers to expire at exactly the same time.)
 // in milliseconds
-static int TIMER_DISTANCE = 50;
+static int TIMER_DISTANCE = 20;
 
-// Array of timer ids assigned to us that we need to keep track of.
-static long *timer_ids = 0;
+// Number of parallel threads for the stability tests.
+static int max_threads = 5;
 
 class Example_Handler : public ACE_Event_Handler
 {
-public:
-  Example_Handler (void): close_count_ (0) {}
+ public:
+  Example_Handler()
+   : close_count_ (0)
+   , l_ () {}
 
-  virtual int handle_close (ACE_HANDLE, ACE_Reactor_Mask mask)
+  virtual int handle_close (ACE_HANDLE,
+                            ACE_Reactor_Mask mask)
   {
     ACE_TEST_ASSERT (mask == ACE_Event_Handler::TIMER_MASK);
-    this->close_count_++;
+
+    {
+      ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+      this->close_count_++;
+    }
+
     return 0;
   }
 
-  virtual int handle_timeout (const ACE_Time_Value &,
+  virtual int handle_timeout (const ACE_Time_Value&,
                               const void *arg)
   {
-    int *act = (int *) arg;
+    int *act = (int*)arg;
     ACE_TEST_ASSERT (*act == 42 || *act == 007);
     int result = 0;
 
@@ -80,20 +127,23 @@
 
   /// Keeps track of the number of times that <handle_close> is called.
   int close_count_;
-};
 
+ private:
+  ACE_Thread_Mutex l_;
+};
 
-struct Interval_Handler : public ACE_Event_Handler
+class Interval_Handler : public ACE_Event_Handler
 {
-  Interval_Handler (void) : trip_count_ (0) { }
+ public:
+  Interval_Handler () : trip_count_ (0) { }
 
-  virtual int handle_timeout (const ACE_Time_Value & , const void *)
+  virtual int handle_timeout (const ACE_Time_Value& , const void*)
   {
     ++trip_count_;
     return 0;
   }
 
-  unsigned trip_count_; // number of times handle_timeout has been tripped.
+  unsigned int trip_count_; // number of times handle_timeout has been tripped.
 };
 
 static void
@@ -106,36 +156,36 @@
   */
   Interval_Handler ih;
   ACE_Time_Value interval (0, 50 * 1000 /* number of usec in millisecond */);
-  const unsigned NUM_INTERVAL_FIRINGS = 50;
-  ACE_Time_Value loop_stop_time =
-    tq->gettimeofday () + (NUM_INTERVAL_FIRINGS * interval);
-  const unsigned EXPECTED_TRIP_COUNT =
-    NUM_INTERVAL_FIRINGS + 1 /* for the first immediate firing */;
-
-  long id = tq->schedule (&ih, 0 /* no act */, ACE_Time_Value::zero, interval);
+  ACE_Event_Handler* eh = &ih;
+  unsigned int NUM_INTERVAL_FIRINGS = 100;
+  long id = tq->schedule (eh, 0 /* no act */, ACE_Time_Value::zero, interval);
   ACE_TEST_ASSERT (id != -1);
 
+  ACE_Time_Value loop_stop_time = (tq->gettimeofday ()               +
+                                   (NUM_INTERVAL_FIRINGS * interval) +
+                                   ACE_Time_Value (0, 5 * 1000));
   do
     {
       tq->expire ();
     }
   while (tq->gettimeofday () < loop_stop_time);
+  unsigned int EXPECTED_TRIP_COUNT =
+      NUM_INTERVAL_FIRINGS + 1 /* for the first immediate firing */;
+  ACE_TEST_ASSERT (ih.trip_count_ == EXPECTED_TRIP_COUNT);
 
-  ACE_DEBUG((LM_DEBUG,
-             ACE_TEXT("after interval loop, timer fired %d ")
-             ACE_TEXT("times out of %d expected: %s\n"),
-             ih.trip_count_, EXPECTED_TRIP_COUNT,
-             ih.trip_count_ == EXPECTED_TRIP_COUNT
-             ? ACE_TEXT ("success") : ACE_TEXT ("FAIL")
-             ));
+  ACE_DEBUG ((LM_DEBUG,
+              ACE_TEXT ("timer fired %d times (out of %d expected): \t\t\t\t\t\t\t%s\n"),
+              ih.trip_count_, EXPECTED_TRIP_COUNT,
+              (ih.trip_count_ == EXPECTED_TRIP_COUNT) ? ACE_TEXT ("success")
+                                                      : ACE_TEXT ("FAIL")));
 
-  tq->cancel (id);
+  ACE_TEST_ASSERT (tq->cancel (id, 0, 1) == 1);
 }
 
 static void
 test_functionality (ACE_Timer_Queue *tq)
 {
-  Example_Handler eh;
+  Example_Handler handler;
 
   ACE_TEST_ASSERT (tq->is_empty () != 0);
   ACE_TEST_ASSERT (ACE_Time_Value::zero == ACE_Time_Value (0));
@@ -147,12 +197,13 @@
 
   const void *timer_act = 0;
   ACE_NEW (timer_act, int (1));
-  timer_id = tq->schedule (&eh, timer_act, earliest_time);
+  ACE_Event_Handler* eh = &handler;
+  timer_id = tq->schedule (eh, timer_act, earliest_time);
 
   ACE_OS::sleep (ACE_Time_Value (0, 10));
 
   ACE_NEW (timer_act, int (1));
-  timer_id2 = tq->schedule (&eh, timer_act, tq->gettimeofday ());
+  timer_id2 = tq->schedule (eh, timer_act, tq->gettimeofday ());
 
   long result = tq->earliest_time () == earliest_time;
   ACE_TEST_ASSERT (result != 0);
@@ -163,57 +214,57 @@
   delete (int *) timer_act;
 
   ACE_TEST_ASSERT (tq->is_empty () == 1);
-  ACE_TEST_ASSERT (eh.close_count_ == 0);
+  ACE_TEST_ASSERT (handler.close_count_ == 0);
 
   ACE_NEW (timer_act, int (1));
-  timer_id = tq->schedule (&eh,
+  timer_id = tq->schedule (eh,
                            timer_act,
                            tq->gettimeofday ());
   ACE_TEST_ASSERT (timer_id != -1);
   ACE_TEST_ASSERT (tq->is_empty () == 0); //==
 
   ACE_NEW (timer_act, int (42));
-  result = tq->schedule (&eh,
+  result = tq->schedule (eh,
                          timer_act,
                          tq->gettimeofday ());
   ACE_TEST_ASSERT (result != -1);
   ACE_TEST_ASSERT (tq->is_empty () == 0); //==
 
   ACE_NEW (timer_act, int (42));
-  result = tq->schedule (&eh,
+  result = tq->schedule (eh,
                          timer_act,
                          tq->gettimeofday ());
   ACE_TEST_ASSERT (result != -1);
   ACE_TEST_ASSERT (tq->is_empty () == 0); //==
 
   // The following method will trigger a call to <handle_close>.
-  ACE_TEST_ASSERT (eh.close_count_ == 0);
+  ACE_TEST_ASSERT (handler.close_count_ == 0);
   result = tq->cancel (timer_id, &timer_act, 0);
   ACE_TEST_ASSERT (result == 1);
-  delete (int *) timer_act;
+  delete (int*)timer_act;
 
   ACE_TEST_ASSERT (tq->is_empty () == 0);
-  ACE_TEST_ASSERT (eh.close_count_ == 1);
+  ACE_TEST_ASSERT (handler.close_count_ == 1);
 
   result = tq->expire ();
   ACE_TEST_ASSERT (result == 2);
 
   ACE_NEW (timer_act, int (007));
-  result = tq->schedule (&eh,
+  result = tq->schedule (eh,
                          timer_act,
                          tq->gettimeofday ());
   ACE_TEST_ASSERT (result != -1);
 
   const void *timer_act1 = 0;
   ACE_NEW (timer_act1, int (42));
-  result = tq->schedule (&eh,
+  result = tq->schedule (eh,
                          timer_act1,
                          tq->gettimeofday () + ACE_Time_Value (100));
   ACE_TEST_ASSERT (result != -1);
 
   const void *timer_act2 = 0;
   ACE_NEW (timer_act2, int (42));
-  result = tq->schedule (&eh,
+  result = tq->schedule (eh,
                          timer_act2,
                          tq->gettimeofday () + ACE_Time_Value (100));
   ACE_TEST_ASSERT (result != -1);
@@ -224,39 +275,39 @@
   // -1.  Since -1 is returned, all timers that use <eh> will be
   // cancelled (and <handle_close> will only be called on the first
   // timer that is cancelled).
-  ACE_TEST_ASSERT (eh.close_count_ == 1);
+  ACE_TEST_ASSERT (handler.close_count_ == 1);
 
   result = tq->expire ();
   ACE_TEST_ASSERT (result == 1);
-  ACE_TEST_ASSERT (eh.close_count_ == 2);
+  ACE_TEST_ASSERT (handler.close_count_ == 2);
 
   ACE_TEST_ASSERT (tq->is_empty () != 0);
-  delete (int *) timer_act2;
-  delete (int *) timer_act1;
+  delete (int*)timer_act2;
+  delete (int*)timer_act1;
 
   ACE_NEW (timer_act, int (4));
-  timer_id = tq->schedule (&eh,
+  timer_id = tq->schedule (eh,
                            timer_act,
                            tq->gettimeofday ());
   ACE_TEST_ASSERT (timer_id != -1);
 
   ACE_NEW (timer_act, int (4));
-  timer_id2 = tq->schedule (&eh,
+  timer_id2 = tq->schedule (eh,
                             timer_act,
                             tq->gettimeofday ());
   ACE_TEST_ASSERT (timer_id2 != -1);
 
   // The following method will trigger a call to <handle_close>.
-  ACE_TEST_ASSERT (eh.close_count_ == 2);
+  ACE_TEST_ASSERT (handler.close_count_ == 2);
   result = tq->cancel (timer_id, &timer_act);
   ACE_TEST_ASSERT (result != -1);
-  delete (int *) timer_act;
+  delete (int*)timer_act;
 
   result = tq->cancel (timer_id2, &timer_act);
   ACE_TEST_ASSERT (result != -1);
-  delete (int *) timer_act;
+  delete (int*)timer_act;
 
-  ACE_TEST_ASSERT (eh.close_count_ == 2); // Only one call to handle_close() even though two timers
+  ACE_TEST_ASSERT (handler.close_count_ == 2); // Only one call to handle_close() even though two timers
   ACE_TEST_ASSERT (tq->is_empty () != 0);
 
   result = tq->expire ();
@@ -264,160 +315,148 @@
 
   // This tests to make sure that <handle_close> is called when there
   // is only one timer of the type in the queue
-  ACE_TEST_ASSERT (eh.close_count_ == 2);
+  ACE_TEST_ASSERT (handler.close_count_ == 2);
 
   ACE_NEW (timer_act, int (007));
-  result = tq->schedule (&eh,
+  result = tq->schedule (eh,
                          timer_act,
                          tq->gettimeofday ());
   ACE_TEST_ASSERT (result != -1);
 
   result = tq->expire ();
   ACE_TEST_ASSERT (result == 1);
-  ACE_TEST_ASSERT (eh.close_count_ == 3);
+  ACE_TEST_ASSERT (handler.close_count_ == 3);
 
   ACE_NEW (timer_act, int (6));
-  timer_id = tq->schedule (&eh,
+  timer_id = tq->schedule (eh,
                            timer_act,
                            tq->gettimeofday ());
   ACE_TEST_ASSERT (timer_id != -1);
 
   ACE_NEW (timer_act, int (7));
-  timer_id2 = tq->schedule (&eh,
+  timer_id2 = tq->schedule (eh,
                             timer_act,
                             tq->gettimeofday ());
   ACE_TEST_ASSERT (timer_id2 != -1);
 
-  ACE_TEST_ASSERT (eh.close_count_ == 3);
+  ACE_TEST_ASSERT (handler.close_count_ == 3);
 
   result = tq->cancel (timer_id, &timer_act);
   ACE_TEST_ASSERT (result == 1);
-  ACE_TEST_ASSERT (eh.close_count_ == 3);
-  delete (int *) timer_act;
+  ACE_TEST_ASSERT (handler.close_count_ == 3);
+  delete (int*)timer_act;
 
   result = tq->cancel (timer_id2, &timer_act);
   ACE_TEST_ASSERT (result == 1);
-  ACE_TEST_ASSERT (eh.close_count_ == 3);
-  delete (int *) timer_act;
+  ACE_TEST_ASSERT (handler.close_count_ == 3);
+  delete (int*)timer_act;
 
   result = tq->expire ();
   ACE_TEST_ASSERT (result == 0);
-  ACE_TEST_ASSERT (eh.close_count_ == 3);
+  ACE_TEST_ASSERT (handler.close_count_ == 3);
 }
 
 static void
 test_performance (ACE_Timer_Queue *tq,
                   const ACE_TCHAR *test_name)
 {
-  Example_Handler eh;
+  ACE_UNUSED_ARG (test_name);
+
+  Example_Handler handler;
+  ACE_Event_Handler* eh = &handler;
   ACE_Profile_Timer timer;
+  ACE_Profile_Timer::ACE_Elapsed_Time et;
   int i;
   const void *timer_act = 0;
+  long timer_id = 0;
 
-  ACE_TEST_ASSERT (tq->is_empty () != 0);
-  ACE_TEST_ASSERT (ACE_Time_Value::zero == ACE_Time_Value (0));
-
-  // Test the amount of time required to schedule all the timers.
-
-  ACE_Time_Value *times = 0;
-  ACE_NEW (times, ACE_Time_Value[max_iterations]);
+  ACE_ASSERT (tq->is_empty () != 0);
 
   // Set up a bunch of times TIMER_DISTANCE ms apart.
-  for (i = 0; i < max_iterations; ++i)
+  ACE_Time_Value *times = 0;
+  ACE_NEW (times,
+           ACE_Time_Value [max_iterations]);
+  for (i = 0; i < max_iterations; i++)
     {
-      times[i] = (tq->gettimeofday()
-        + ACE_Time_Value(0, i * TIMER_DISTANCE * 1000));
+      times[i] = (tq->gettimeofday ()
+        + ACE_Time_Value (0, i * TIMER_DISTANCE * 1000));
     }
+  ACE_Time_Value last_time = times[max_iterations - 1];
 
-  ACE_Time_Value last_time = times[max_iterations-1];
+  long* timer_ids_local = 0;
+  ACE_NEW (timer_ids_local,
+           long [max_iterations]);
 
-  timer.start ();
+  // Test the amount of time required to schedule all the timers.
+  timer_ids.clear ();
 
-  for (i = 0; i < max_iterations; ++i)
+  timer.start ();
+  for (i = 0; i < max_iterations; i++)
     {
       ACE_NEW (timer_act, int (42));
-      timer_ids[i] = tq->schedule (&eh,
-                                   timer_act,
-                                   times[i]);
-      ACE_TEST_ASSERT (timer_ids[i] != -1);
+      timer_id = tq->schedule (eh,
+                               timer_act,
+                               times[i]);
+      ACE_TEST_ASSERT (timer_id != -1);
+      timer_ids_local[i] = timer_id;
     }
-
-  ACE_TEST_ASSERT (tq->is_empty () == 0);
-
   timer.stop ();
 
-  ACE_Profile_Timer::ACE_Elapsed_Time et;
+  ACE_TEST_ASSERT (tq->is_empty () == 0);
 
   timer.elapsed_time (et);
-
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time to schedule %d timers for %s\n"),
-              max_iterations, test_name));
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("real time = %f secs, user time = %f secs, system time = %f secs\n"),
-              et.real_time, et.user_time, et.system_time));
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time per call = %f usecs\n"),
-              (et.user_time / ACE_timer_t (max_iterations)) * 1000000));
+              ACE_TEXT ("time to schedule %d timers (total/average usecs): \t\t\t\t\t%.3f / %f\n"),
+              max_iterations,// test_name,
+              et.real_time * 1000000.0F,
+              (et.real_time / ACE_timer_t (max_iterations)) * 1000000.0F));
 
   // Test the amount of time required to cancel all the timers.
+  for (i = 0; i < max_iterations; i++)
+    timer_ids.push_back (timer_ids_local[i]);
 
   timer.start ();
-
-  for (i = max_iterations; i-- != 0; )
+  for (timer_ids_iterator_t iterator = timer_ids.begin ();
+       iterator != timer_ids.end ();
+       iterator++)
     {
-      tq->cancel (timer_ids[i], &timer_act);
-      delete (int *) timer_act;
+      tq->cancel (*iterator, &timer_act);
+      delete (int*)timer_act;
     }
-
   timer.stop ();
 
   ACE_TEST_ASSERT (tq->is_empty () != 0);
 
   timer.elapsed_time (et);
-
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time to cancel %d timers for %s\n"),
-              max_iterations, test_name));
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("real time = %f secs, user time = %f secs, system time = %f secs\n"),
-              et.real_time, et.user_time, et.system_time));
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time per call = %f usecs\n"),
-              (et.user_time / ACE_timer_t (max_iterations)) * 1000000));
+              ACE_TEXT ("time to cancel %d timers (total/average usecs): \t\t\t\t\t%.3f / %f\n"),
+              max_iterations,// test_name,
+              et.real_time * 1000000.0F,
+              (et.real_time / ACE_timer_t (max_iterations)) * 1000000.0F));
 
   // Test the amount of time required to schedule and expire all the
   // timers.
 
   timer.start ();
-
-  for (i = 0; i < max_iterations; ++i)
+  for (i = 0; i < max_iterations; i++)
     {
       ACE_NEW (timer_act, int (42));
-      long result = tq->schedule (&eh, timer_act, times[i]);
+      long result = tq->schedule (eh, timer_act, times[i]);
       ACE_TEST_ASSERT (result != -1);
     }
 
-  ACE_TEST_ASSERT (tq->is_empty () == 0);
-
   // Expire all the timers.
-  tq->expire (last_time + ACE_Time_Value(1));
-
+  tq->expire (last_time + ACE_Time_Value (1));
   timer.stop ();
 
   ACE_TEST_ASSERT (tq->is_empty () != 0);
 
   timer.elapsed_time (et);
-
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time to schedule and expire %d timers for %s\n"),
-              max_iterations, test_name));
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("real time = %f secs, user time = %f secs, system time = %f secs\n"),
-              et.real_time, et.user_time, et.system_time));
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time per call = %f usecs\n"),
-              (et.user_time / ACE_timer_t (max_iterations)) * 1000000));
+              ACE_TEXT ("time to schedule and expire %d timers (total/average usecs): \t\t%.3f / %f\n"),
+              max_iterations,// test_name,
+              et.real_time * 1000000.0F,
+              (et.real_time / ACE_timer_t (max_iterations)) * 1000000.0F));
 
   randomize (times,
              max_iterations,
@@ -425,117 +464,443 @@
 
   // Test the amount of time required to randomly cancel all the
   // timers.
+  timer_ids.clear ();
 
-  for (i = 0; i < max_iterations; ++i)
+  for (i = 0; i < max_iterations; i++)
     {
       ACE_NEW (timer_act, int (42));
-      timer_ids[i] = tq->schedule (&eh,
-                                   timer_act,
-                                   times[i]);
-      ACE_TEST_ASSERT (timer_ids[i] != -1);
+      timer_id = tq->schedule (eh,
+                               timer_act,
+                               times[i]);
+      ACE_TEST_ASSERT (timer_id != -1);
+      timer_ids.push_back (timer_id);
     }
 
   ACE_TEST_ASSERT (tq->is_empty () == 0);
 
-  timer.start ();
+  i = 0;
+  for (timer_ids_iterator_t iterator = timer_ids.begin ();
+       iterator != timer_ids.end ();
+       iterator++, i++)
+    timer_ids_local[i] = *iterator;
+  randomize (timer_ids_local,
+             max_iterations,
+             static_cast<unsigned int> (ACE_OS::time(0L)));
+  timer_ids.clear ();
 
-  for (i = max_iterations - 1; i >= 0; i--)
+  timer.start ();
+  for (i = 0; i < max_iterations; i++)
     {
-      tq->cancel (timer_ids[i], &timer_act);
-      delete (int *) timer_act;
+      tq->cancel (timer_ids_local[i], &timer_act);
+      delete (int*)timer_act;
     }
+  timer.stop ();
 
   ACE_TEST_ASSERT (tq->is_empty () != 0);
 
-  timer.stop ();
-
   timer.elapsed_time (et);
-
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time to randomly cancel %d timers for %s\n"),
-              max_iterations,
-              test_name));
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("real time = %f secs, user time = %f secs, system time = %f secs\n"),
-              et.real_time,
-              et.user_time,
-              et.system_time));
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time per call = %f usecs\n"),
-              (et.user_time / ACE_timer_t (max_iterations)) * 1000000));
+              ACE_TEXT ("time to randomly cancel %d timers (total/average usecs): \t\t\t%.3f / %f\n"),
+              max_iterations,// test_name,
+              et.real_time * 1000000.0F,
+              (et.real_time / ACE_timer_t (max_iterations)) * 1000000.0F));
 
   // Test the amount of time required to randomly schedule all the timers.
 
   timer.start ();
-
-  for (i = 0; i < max_iterations; ++i)
+  for (i = 0; i < max_iterations; i++)
     {
       ACE_NEW (timer_act, int (42));
-      timer_ids[i] = tq->schedule (&eh,
-                                   timer_act,
-                                   times[i]);
-      ACE_TEST_ASSERT (timer_ids[i] != -1);
+      timer_id = tq->schedule (eh,
+                               timer_act,
+                               times[i]);
+      ACE_TEST_ASSERT (timer_id != -1);
+      timer_ids_local[i] = timer_id;
     }
-
   timer.stop ();
 
   ACE_TEST_ASSERT (tq->is_empty () == 0);
 
   timer.elapsed_time (et);
-
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time to randomly schedule %d timers for %s\n"),
-              max_iterations, test_name));
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("real time = %f secs, user time = %f secs, system time = %f secs\n"),
-              et.real_time,
-              et.user_time,
-              et.system_time));
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time per call = %f usecs\n"),
-              (et.user_time / ACE_timer_t (max_iterations)) * 1000000));
+              ACE_TEXT ("time to randomly schedule %d timers (total/average usecs): \t\t\t%.3f / %f\n"),
+              max_iterations,// test_name,
+              et.real_time * 1000000.0F,
+              (et.real_time / ACE_timer_t (max_iterations)) * 1000000.0F));
 
   // Test the amount of time required to expire all the timers.
 
   timer.start ();
+  tq->expire (last_time + ACE_Time_Value (1));
+  timer.stop ();
 
-  tq->expire (last_time + ACE_Time_Value(1));
+  ACE_TEST_ASSERT (tq->is_empty () != 0);
 
-  ACE_TEST_ASSERT (tq->is_empty ());
+  timer.elapsed_time (et);
+  ACE_DEBUG ((LM_DEBUG,
+              ACE_TEXT ("time to expire %d randomly scheduled timers (total/average usecs): \t%.3f / %f\n"),
+              max_iterations,// test_name,
+              et.user_time * 1000000.0F,
+              (et.user_time / ACE_timer_t (max_iterations)) * 1000000.0F));
 
-  timer.stop ();
+  // clean up
+  delete [] times;
+  delete [] timer_ids_local;
+}
 
-  timer.elapsed_time (et);
+enum scheduler_mode_t
+{
+  MODE_SCHEDULE_ONLY = 0,
+  MODE_SCHEDULE_CANCEL,
+  //
+  MODE_INVALID
+};
 
+class Event_Scheduler : public ACE_Task<ACE_MT_SYNCH>
+{
+ public:
+  Event_Scheduler (ACE_Timer_Queue *tq,
+                   ACE_Event_Handler *eh,
+                   ACE_Time_Value *p,
+                   timer_ids_t *t,
+                   const ACE_Time_Value &md = ACE_Time_Value::zero,
+                   const scheduler_mode_t &m = MODE_SCHEDULE_ONLY)
+   : tq_ (tq)
+   , eh_ (eh)
+   , p_ (p)
+   , t_ (t)
+   , md_ (md)
+   , m_ (m)
+   , s_ (0)
+   , c_ (0)
+   , l_ () { }
+
+  virtual int svc ()
+  {
+    ACE_ASSERT (tq_);
+    ACE_ASSERT (eh_);
+    ACE_ASSERT (p_);
+    ACE_ASSERT (t_);
+
+    long timer_id = -1;
+    int i = 0, j;
+    double coefficient =
+      static_cast<double> (md_.msec ()) / (static_cast<double> (RAND_MAX) + 1.0F);
+    double c = 0.0F;
+    ACE_Time_Value delay = ACE_Time_Value::zero;
+    unsigned int seed = static_cast<unsigned int> (ACE_OS::time (0L));
+    int random_number = 0;
+    bool do_schedule = true;
+    timer_ids_iterator_t iterator;
+    do
+      {
+        // sleep ?
+        delay = ACE_Time_Value::zero;
+        if (md_ != ACE_Time_Value::zero)
+          {
+            random_number = ACE_OS::rand_r (&seed);
+            delay.usec (static_cast<suseconds_t> (coefficient                         *
+                                                  static_cast<double> (random_number) *
+                                                  1000.0F));
+            ACE_OS::sleep (delay);
+          }
+
+        timer_id = -1;
+        switch (m_)
+          {
+            case MODE_SCHEDULE_CANCEL:
+              {
+                do_schedule = true;
+
+                random_number = ACE_OS::rand_r (&seed);
+                c = (1.0F / (static_cast<double> (RAND_MAX) + 1.0F));
+                do_schedule = ((static_cast<double> (random_number)* c) < 0.5F);
+                if (!do_schedule)
+                {
+                  {
+                    ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+                    if (! t_->empty ())
+                      {
+                        c = static_cast<double> (t_->size ()) / ((static_cast<double> (RAND_MAX) + 1.0F));
+                        random_number = ACE_OS::rand_r (&seed);
+                        j = static_cast<int> (random_number * c);
+                        iterator = t_->begin ();
+                        std::advance (iterator, j);
+                        timer_id = *iterator;
+                        ACE_ASSERT ((iterator != t_->end ()) &&
+                                    (timer_id >= 0));
+
+                      }
+                  }
+
+                  if (timer_id != -1)
+                  {
+                    const void* act = 0;
+                    j = tq_->cancel (timer_id, &act, 0);
+                    ACE_TEST_ASSERT (j >= 0);
+
+                    {
+                      ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+                      if (j > 0)
+                        {
+                          ACE_TEST_ASSERT (act == &timer_act_global);
+                          c_ += j;
+                        }
+
+                      for (iterator = t_->begin ();
+                           iterator != t_->end ();
+                           iterator++)
+                        {
+                          if (*iterator == timer_id)
+                            break;
+                        }
+                      if (iterator != t_->end ())
+                        t_->erase (iterator);
+                    }
+
+                    break;
+                  }
+                }
+
+                // fall through
+              }
+            case MODE_SCHEDULE_ONLY:
+              {
+                timer_id = tq_->schedule (eh_,
+                                          &timer_act_global,
+                                          tq_->gettimeofday () + p_[i++],
+                                          ACE_Time_Value::zero);
+                ACE_TEST_ASSERT (timer_id >= 0);
+
+                {
+                  ACE_Guard<ACE_Thread_Mutex> aGuard (l_);
+
+                  t_->push_back (timer_id);
+                  s_++;
+                }
+
+                if (i == max_iterations)
+                  i = 0;
+
+                break;
+              }
+            default:
+              {
+                ACE_DEBUG ((LM_ERROR,
+                            ACE_TEXT ("invalid scheduler mode (was : %d), aborting\n"),
+                            m_));
+
+                return -1;
+              }
+          }
+      } while (msg_queue_->is_empty ());
+
+    // clean up
+    if (thr_count () == 1)
+      {
+        int result = msg_queue_->flush ();
+        ACE_ASSERT (result > 0);
+      }
+
+    return 0;
+  }
+
+  void set_maximum_delay (const ACE_Time_Value& md) { md_ = md; }
+  unsigned int num_scheduled () const { return s_; }
+  unsigned int num_cancelled () const { return c_; }
+  void reset () { s_ = 0; c_ = 0; }
+
+ private:
+  ACE_Timer_Queue*   tq_;
+  ACE_Event_Handler* eh_;
+  ACE_Time_Value*    p_;
+  timer_ids_t*       t_;
+  ACE_Time_Value     md_;
+  scheduler_mode_t   m_;
+  unsigned int       s_;
+  unsigned int       c_;
+  ACE_Thread_Mutex   l_;
+};
+
+static void
+test_performance_2 (ACE_Timer_Queue* tq,
+                    const ACE_TCHAR *test_name)
+{
+  ACE_UNUSED_ARG (test_name);
+
+  ACE_ASSERT (tq->is_empty () != 0);
+
+  // Test brute-force scheduling behaviour
+
+  ACE_Message_Block* stop = 0;
+  ACE_NEW (stop,
+           ACE_Message_Block((ACE_Allocator*)0));
+  stop->msg_type (ACE_Message_Block::MB_STOP);
+
+  Example_Handler handler;
+  ACE_Event_Handler* eh = &handler;
+  int remaining_timers = 0;
+
+  // Set up a bunch of times TIMER_DISTANCE ms apart.
+  ACE_Time_Value *periods = 0;
+  ACE_NEW (periods,
+           ACE_Time_Value [max_iterations]);
+  for (int i = 0; i < max_iterations; ++i)
+    periods[i] = ACE_Time_Value (0, i * TIMER_DISTANCE * 1000);
+  randomize (periods,
+             max_iterations,
+             static_cast<unsigned int> (ACE_OS::time (0L)));
+
+  ACE_Time_Value maximum_delay = ACE_Time_Value::zero;
+
+  Event_Scheduler scheduler (tq,
+                             &handler,
+                             periods,
+                             &timer_ids,
+                             maximum_delay);
+
+  ACE_Message_Block* mb = stop->duplicate ();
+  ACE_ASSERT (mb);
+  mb->msg_type (ACE_Message_Block::MB_STOP);
+
+  ACE_Profile_Timer timer;
+  ACE_Profile_Timer::ACE_Elapsed_Time elapsed_time;
+
+  timer.start ();
+
+  int result = scheduler.activate ();
+  ACE_ASSERT (result == 0);
+  ACE_OS::sleep (bf_running_time);
+  result = scheduler.putq (mb);
+  ACE_ASSERT (result == 1);
+  result = scheduler.wait ();
+  ACE_ASSERT (result == 0);
+  remaining_timers = tq->cancel (eh, 1);
+
+  timer.stop ();
+  timer.elapsed_time (elapsed_time);
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time to expire %d randomly scheduled timers for %s\n"),
-              max_iterations, test_name));
-  ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("real time = %f secs, user time = %f secs, system time = %f secs\n"),
-              et.real_time, et.user_time, et.system_time));
+              ACE_TEXT ("brute-force scheduling:\t%#T (scheduled): %d; (real/user/system secs): \t%.3f / %.3f / %.3f\n"),
+              &bf_running_time, scheduler.num_scheduled (),
+              elapsed_time.real_time, elapsed_time.user_time, elapsed_time.system_time));
+  ACE_TEST_ASSERT (tq->is_empty ());
+
+  maximum_delay = rd_maximum_interval;
+
+  mb = stop->duplicate ();
+  ACE_ASSERT (mb);
+  mb->msg_type (ACE_Message_Block::MB_STOP);
+
+  timer.start ();
+
+  scheduler.reset ();
+  scheduler.set_maximum_delay (maximum_delay);
+  result = scheduler.activate ();
+  ACE_ASSERT (result == 0);
+  ACE_OS::sleep (rd_running_time);
+  result = scheduler.putq (mb);
+  ACE_ASSERT (result == 1);
+  result = scheduler.wait ();
+  ACE_ASSERT (result == 0);
+  remaining_timers = tq->cancel (eh, 1);
+
+  timer.stop ();
+  timer.elapsed_time (elapsed_time);
   ACE_DEBUG ((LM_DEBUG,
-              ACE_TEXT ("time per call = %f usecs\n"),
-              (et.user_time / ACE_timer_t (max_iterations)) * 1000000));
+              ACE_TEXT ("random delay scheduling:\t%#T (scheduled): %d; (real/user/system secs): \t%.3f / %.3f / %.3f\n"),
+              &rd_running_time, scheduler.num_scheduled (),
+              elapsed_time.real_time, elapsed_time.user_time, elapsed_time.system_time));
+  ACE_ASSERT (tq->is_empty ());
+
+  // clean up
+  delete stop;
+  delete [] periods;
+  timer_ids.clear ();
+}
 
-  delete [] times;
+static void
+test_stability (ACE_Timer_Queue* tq,
+                const ACE_TCHAR *test_name)
+{
+  ACE_UNUSED_ARG (test_name);
+
+  ACE_ASSERT (tq->is_empty ());
+
+  ACE_Message_Block* stop = 0;
+  ACE_NEW (stop,
+           ACE_Message_Block ((ACE_Allocator*)0));
+  stop->msg_type (ACE_Message_Block::MB_STOP);
+
+  Example_Handler handler;
+  ACE_Event_Handler* eh = &handler;
+  ACE_Profile_Timer timer;
+  ACE_Profile_Timer::ACE_Elapsed_Time elapsed_time;
+
+  // Set up a bunch of times TIMER_DISTANCE ms apart.
+  ACE_Time_Value *periods = 0;
+  ACE_NEW (periods,
+           ACE_Time_Value [max_iterations]);
+  for (int i = 0; i < max_iterations; ++i)
+    periods[i] = ACE_Time_Value (0, i * TIMER_DISTANCE * 1000);
+  randomize (periods,
+             max_iterations,
+             static_cast<unsigned int> (ACE_OS::time (0L)));
+
+  Event_Scheduler scheduler (tq,
+                             &handler,
+                             periods,
+                             &timer_ids,
+                             ht_maximum_interval,
+                             MODE_SCHEDULE_CANCEL);
+
+  timer_ids.clear ();
+
+  timer.start ();
+
+  int result = scheduler.activate (0L,
+                                   max_threads);
+  ACE_ASSERT (result == 0);
+  ACE_OS::sleep (ht_running_time);
+  result = scheduler.putq (stop);
+  ACE_ASSERT (result == 1);
+  result = scheduler.wait ();
+  ACE_ASSERT (result == 0);
+  timer.stop ();
+
+  ACE_TEST_ASSERT (handler.close_count_ == scheduler.num_cancelled ());
+
+  int num_remaining = tq->cancel (eh, 0);
+
+  timer.elapsed_time (elapsed_time);
+  ACE_DEBUG ((LM_DEBUG,
+              ACE_TEXT ("high throughput scheduling:\t%#T (scheduled/cancelled): %d / %d; (real/user/system secs): %.3f / %.3f / %.3f\n"),
+              &ht_running_time, scheduler.num_scheduled (), scheduler.num_cancelled (),
+              elapsed_time.real_time, elapsed_time.user_time, elapsed_time.system_time));
+
+  // clean up
+  delete [] periods;
+  timer_ids.clear ();
 }
 
 // This test function was contributed with Bugzilla #2447 to test validity
 // of ACE_Timer_Heap timer IDs around the boundary of having to enlarge
 // the heap.
 static void
-test_unique_timer_heap_ids (void)
+test_unique_timer_heap_ids ()
 {
-  Example_Handler eh;
-  ACE_Timer_Heap timer_heap (44);
-  ACE_Time_Value anytime(1);
+  Example_Handler handler;
+  ACE_Timer_Heap timer_heap (ACE_DEFAULT_TIMERS);
+  ACE_Time_Value anytime (1);
   ACE_Bounded_Set<long> timer_ids (max_iterations);
   long timer_id = -1;
   bool all_unique = true;
 
+  ACE_Event_Handler* eh = &handler;
   for (int i = 0; i < 100; ++i)
     {
-      timer_id = timer_heap.schedule (&eh, 0, anytime);
+      timer_id = timer_heap.schedule (eh, 0, anytime);
       if (timer_id == -1)
         {
           ACE_ERROR ((LM_ERROR,
@@ -588,14 +953,14 @@
  */
 class Timer_Queue_Stack
 {
-public:
+ public:
   // = Initialization method
   Timer_Queue_Stack (ACE_Timer_Queue *queue,
-    const ACE_TCHAR *name,
-    Timer_Queue_Stack *next = 0)
-    : queue_ (queue),
-    name_ (name),
-    next_ (next)
+                     const ACE_TCHAR *name,
+                     Timer_Queue_Stack *next = 0)
+   : queue_ (queue)
+   , name_ (name)
+   , next_ (next)
   {}
   // "Push" a new <queue> on the stack of <queue>s.
 
@@ -614,119 +979,309 @@
 {
   ACE_START_TEST (ACE_TEXT ("Timer_Queue_Test"));
 
-  if (argc > 1)
-    max_iterations = ACE_OS::atoi (argv[1]);
+  bool hash_strategies_only = false;
+  bool run_standard_tests = true;
+  bool run_stability_tests = false;
+
+  ACE_Get_Opt argument_parser (argc,
+                               argv,
+                               ACE_TEXT ("abchi:nst:x"));
+  int option = 0;
+  while ((option = argument_parser ()) != EOF)
+    {
+      switch (option)
+        {
+          // short options
+          case 'a':
+            {
+              strategies.insert (QUEUE_HEAP);
+
+              break;
+            }
+          case 'b':
+            {
+              strategies.insert (QUEUE_LIST);
+
+              break;
+            }
+          case 'c':
+            {
+              strategies.insert (QUEUE_WHEEL);
+
+              break;
+            }
+          case 'h':
+            {
+              strategies.insert (QUEUE_HASH);
+
+              break;
+            }
+          case 'i':
+            {
+              max_iterations = ACE_OS::atoi (argument_parser.opt_arg ());
+
+              break;
+            }
+          case 'n':
+            {
+              run_standard_tests = false;
+
+              break;
+            }
+          case 's':
+            {
+              hash_strategies_only = true;
+
+              break;
+            }
+          case 't':
+            {
+              max_threads = ACE_OS::atoi (argument_parser.opt_arg ());
+
+              break;
+            }
+          case 'x':
+            {
+              run_stability_tests = true;
+
+              break;
+            }
+          // long options
+          case 0:
+          // non-options
+          case 1:
+            break;
+          // error handling
+          case '?':
+          case ':':
+            {
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT ("unrecognized option \"%s\", aborting\n"),
+                          ACE_TEXT (argument_parser.last_option ())));
+
+              // fall through
+            }
+          default:
+            {
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT ("unrecognized option \"%c\", aborting\n"),
+                          option));
+
+              ACE_DEBUG ((LM_ERROR,
+                          ACE_TEXT ("\nusage: %s \n\n")
+                          ACE_TEXT ("\t[-a] heap strategy (defaults to true)\n")
+                          ACE_TEXT ("\t[-b] list strategy (defaults to true)\n")
+                          ACE_TEXT ("\t[-c] wheel strategy (defaults to true)\n")
+                          ACE_TEXT ("\t[-h] hash strategies (defaults to true)\n")
+                          ACE_TEXT ("\t[-i #timers] #iterations (defaults to %d)\n")
+                          ACE_TEXT ("\t[-n] skip standard tests (defaults to false)\n")
+                          ACE_TEXT ("\t[-s] hash strategies only (defaults to false)\n")
+                          ACE_TEXT ("\t[-t #threads] #threads (defaults to %d)\n")
+                          ACE_TEXT ("\t[-x] run stability tests (defaults to false)\n")
+                          ACE_TEXT ("\n"),
+                          argv[0],
+                          max_iterations,
+                          max_threads));
+
+              return EXIT_FAILURE;
+            }
+        }
+    }
+  // *NOTE*: test all available strategies by default
+  if (strategies.empty ())
+    for (int i = 0; i < QUEUE_INVALID; i++)
+      strategies.insert((strategy_t)i);
+
+  if (hash_strategies_only)
+    strategies.insert (QUEUE_HASH);
 
   // = Perform initializations.
 
   Timer_Queue_Stack *tq_stack = 0;
+  ACE_Timer_Queue* tq = 0;
 
   // Add new Timer_Queue implementations here.  Note that these will
   // be executed in "reverse order".
 
-  // Timer_Hash (Heap)
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_Hash_Heap,
-                                     ACE_TEXT ("ACE_Timer_Hash (Heap)"),
-                                     tq_stack),
-                  -1);
-
   // Timer_Hash
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_Hash,
-                                     ACE_TEXT ("ACE_Timer_Hash"),
-                                     tq_stack),
-                  -1);
-
-  // Timer_stack
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_List,
-                                     ACE_TEXT ("ACE_Timer_List"),
-                                     tq_stack),
-                  -1);
-
-  // Timer_Wheel without preallocated memory
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_Wheel,
-                                     ACE_TEXT ("ACE_Timer_Wheel (non-preallocated)"),
-                                     tq_stack),
-                  -1);
-
-  // Timer_Wheel with preallocated memory.
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_Wheel (ACE_DEFAULT_TIMER_WHEEL_SIZE,
-                                                          ACE_DEFAULT_TIMER_WHEEL_RESOLUTION,
-                                                          max_iterations),
-                                     ACE_TEXT ("ACE_Timer_Wheel (preallocated)"),
-                                     tq_stack),
-                  -1);
-  // Timer_Heap without preallocated memory.
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_Heap,
-                                     ACE_TEXT ("ACE_Timer_Heap (non-preallocated)"),
-                                     tq_stack),
-                  -1);
-
-  // Timer_Heap with preallocate memory.
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new ACE_Timer_Heap (max_iterations, 1),
-                                     ACE_TEXT ("ACE_Timer_Heap (preallocated)"),
-                                     tq_stack),
-                  -1);
-
-  // Timer_Heap without preallocated memory, using high-res time.
-  // @deprecated
-  (void) ACE_High_Res_Timer::global_scale_factor ();
-
-  ACE_Timer_Heap *tq_heap =
-    new ACE_Timer_Heap;
-  tq_heap->gettimeofday(&ACE_High_Res_Timer::gettimeofday_hr);
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (tq_heap,
-                                     ACE_TEXT ("ACE_Timer_Heap (high-res timer; deprecated version)"),
-                                     tq_stack),
-                  -1);
-
-  // new (optimized) version
-  typedef ACE_Timer_Heap_T<ACE_Event_Handler *,
-                           ACE_Event_Handler_Handle_Timeout_Upcall,
-                           ACE_SYNCH_RECURSIVE_MUTEX,
-                           ACE_HR_Time_Policy>
-          timer_heap_hr_type;
-  ACE_NEW_RETURN (tq_stack,
-                  Timer_Queue_Stack (new timer_heap_hr_type,
-                                     ACE_TEXT ("ACE_Timer_Heap (high-res timer)"),
-                                     tq_stack),
-                  -1);
-
-
-  // Create the Timer ID array
-  ACE_NEW_RETURN (timer_ids,
-                  long[max_iterations],
-                  -1);
+  if (strategies.find (QUEUE_HASH) != strategies.end ())
+    {
+      if (!hash_strategies_only ||
+          (strategies.find (QUEUE_HEAP) != strategies.end ()))
+        {
+          // Timer_Hash (Heap)
+          ACE_NEW_RETURN (tq,
+                          ACE_Timer_Hash_Heap (),
+                          -1);
+          ACE_NEW_RETURN (tq_stack,
+                          Timer_Queue_Stack (tq,
+                                             ACE_TEXT ("ACE_Timer_Hash (Heap)"),
+                                             tq_stack),
+                          -1);
+        }
 
-  Timer_Queue_Stack *tq_ptr = tq_stack;
+      if (!hash_strategies_only ||
+          (strategies.find (QUEUE_LIST) != strategies.end ()))
+        {
+          // Timer_Hash (List)
+          ACE_NEW_RETURN (tq,
+                          ACE_Timer_Hash_List (),
+                          -1);
+          ACE_NEW_RETURN (tq_stack,
+                          Timer_Queue_Stack (tq,
+                                             ACE_TEXT ("ACE_Timer_Hash (List)"),
+                                             tq_stack),
+                          -1);
+        }
+
+      if (!hash_strategies_only ||
+          (strategies.find (QUEUE_WHEEL) != strategies.end ()))
+        {
+          // Timer_Hash (Wheel)
+          ACE_NEW_RETURN (tq,
+                          ACE_Timer_Hash_Wheel (),
+                          -1);
+          ACE_NEW_RETURN (tq_stack,
+                          Timer_Queue_Stack (tq,
+                                             ACE_TEXT ("ACE_Timer_Hash (Wheel)"),
+                                             tq_stack),
+                          -1);
+        }
 
-  while (tq_ptr != 0)
+      if (hash_strategies_only)
+        strategies.clear ();
+    }
+
+  // Timer_List
+  if (strategies.find (QUEUE_LIST) != strategies.end ())
+    {
+      ACE_NEW_RETURN (tq,
+                      ACE_Timer_List (),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_List"),
+                                         tq_stack),
+                      -1);
+    }
+
+  // Timer_Wheel
+  if (strategies.find (QUEUE_WHEEL) != strategies.end ())
+    {
+      // Timer_Wheel without preallocated memory
+      ACE_NEW_RETURN (tq,
+                      ACE_Timer_Wheel (),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Wheel (non-preallocated)"),
+                                         tq_stack),
+                      -1);
+
+      // Timer_Wheel with preallocated memory.
+      ACE_NEW_RETURN (tq,
+                      ACE_Timer_Wheel (ACE_DEFAULT_TIMER_WHEEL_SIZE,
+                                       ACE_DEFAULT_TIMER_WHEEL_RESOLUTION,
+                                       max_iterations),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Wheel (preallocated)"),
+                                         tq_stack),
+                      -1);
+    }
+
+  // Timer_Heap
+  if (strategies.find (QUEUE_HEAP) != strategies.end ())
+    {
+      // Timer_Heap without preallocated memory.
+      ACE_NEW_RETURN (tq,
+                      ACE_Timer_Heap (),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Heap (non-preallocated)"),
+                                         tq_stack),
+                      -1);
+
+      // Timer_Heap with preallocated memory.
+      ACE_NEW_RETURN (tq,
+                      ACE_Timer_Heap (max_iterations, 1),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Heap (preallocated)"),
+                                         tq_stack),
+                      -1);
+
+      // Timer_Heap without preallocated memory, using high-res time.
+      // @deprecated
+      (void) ACE_High_Res_Timer::global_scale_factor ();
+      ACE_NEW_RETURN (tq,
+                      ACE_Timer_Heap (),
+                      -1);
+      tq->gettimeofday (&ACE_High_Res_Timer::gettimeofday_hr);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Heap (non-preallocated, high-res timer (deprecated version))"),
+                                         tq_stack),
+                      -1);
+
+      // new (optimized) version
+      typedef ACE_Timer_Heap_T<ACE_Event_Handler*,
+                               ACE_Event_Handler_Handle_Timeout_Upcall,
+                               ACE_SYNCH_RECURSIVE_MUTEX,
+                               ACE_HR_Time_Policy> timer_heap_hr_type;
+      ACE_NEW_RETURN (tq,
+                      timer_heap_hr_type (),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Heap (non-preallocated, high-res timer)"),
+                                         tq_stack),
+                      -1);
+      ACE_NEW_RETURN (tq,
+                      timer_heap_hr_type (max_iterations, 1),
+                      -1);
+      ACE_NEW_RETURN (tq_stack,
+                      Timer_Queue_Stack (tq,
+                                         ACE_TEXT ("ACE_Timer_Heap (preallocated, high-res timer)"),
+                                         tq_stack),
+                      -1);
+    }
+
+  Timer_Queue_Stack *tq_ptr = tq_stack;
+  while (tq_ptr)
     {
       ACE_DEBUG ((LM_DEBUG,
-                  ACE_TEXT ("**** starting test of %s\n"),
+                  ACE_TEXT ("############################# %s #############################\n"),
                   tq_ptr->name_));
-      test_interval_timer (tq_ptr->queue_);
-      test_functionality (tq_ptr->queue_);
-      test_performance (tq_ptr->queue_,
+      if (run_standard_tests)
+      {
+        test_interval_timer (tq_ptr->queue_);
+        test_functionality (tq_ptr->queue_);
+        test_performance (tq_ptr->queue_,
+                          tq_ptr->name_);
+        test_performance_2 (tq_ptr->queue_,
+                            tq_ptr->name_);
+      }
+      if (run_stability_tests)
+        test_stability (tq_ptr->queue_,
                         tq_ptr->name_);
+      ACE_DEBUG ((LM_DEBUG,
+                  ACE_TEXT ("\\END##############################################################\\END\n")));
       delete tq_ptr->queue_;
       Timer_Queue_Stack *temp = tq_ptr;
       tq_ptr = tq_ptr->next_;
       delete temp;
     }
-  delete [] timer_ids;
 
-  ACE_DEBUG
-    ((LM_DEBUG,
-      ACE_TEXT ("**** starting unique IDs test for ACE_Timer_Heap\n")));
-  test_unique_timer_heap_ids ();
+  if (strategies.find (QUEUE_HEAP) != strategies.end ())
+    {
+      ACE_DEBUG ((LM_DEBUG,
+                  ACE_TEXT ("**** starting unique IDs test for ACE_Timer_Heap\n")));
+      test_unique_timer_heap_ids ();
+    }
 
   ACE_END_TEST;
   return 0;
