/*
 * Copyright Dept. of Mathematics & Computer Science Univ. Paris-Descartes
 *
 * This software is governed by the CeCILL  license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 */

options {
  	//MULTI=true;
 	NODE_DEFAULT_VOID=false;
    STATIC=false;
    NODE_PREFIX="PDDL_";
    NODE_USES_PARSER=true;
    IGNORE_CASE=true;
}

PARSER_BEGIN(Lexer)

package pddl4j.lexer;

import java.io.InputStream;
import java.io.File;
import java.util.ArrayList;
import java.util.List;

import pddl4j.ErrorManager;
import pddl4j.ErrorManager.Message;

public class Lexer {
	
	private ErrorManager mgr;
	private File file;

	private static final int[] BLOCKS = {REQUIREMENTS, 
		TYPES,
		CONSTANTS,
		PREDICATES,
		FUNCTIONS,
		ACTION,
		DURATIVE_ACTION,
		DERIVED,
		OBJECTS,
		INIT,
		GOAL,
		METRIC,
		EOF};
		
	private boolean isBlock(int token) {
		int i = 0;
		while (i < BLOCKS.length && (BLOCKS[i] != token)) i++;
		return i == BLOCKS.length;
	}
	
	private void error(Throwable e, int line, int column) throws ParseException {
		String message = new String();
		if (e.getClass().equals(TokenMgrError.class)) {
			String[] tmp = e.getMessage().split(" ");
			int l = -1;
			int c = -1;
			int i = 0;
  			for (i = 0 ; i < tmp.length; i++) {
  				if (tmp[i].equals("line") && i+1 < tmp.length) {
  					l = Integer.parseInt(tmp[i+1].substring(0, tmp[i+1].length()-1));
  				}
  				if (tmp[i].equals("column") && i+1 < tmp.length) {
  					c = Integer.parseInt(tmp[i+1].substring(0, tmp[i+1].length()-1));
  				}
  			}
			message = e.getMessage().split(".  ")[1];
			this.mgr.logLexicalError(message, this.file, l, c);
		} else if (e.getClass().equals(ParseException.class)) {
  			ParseException pe = (ParseException) e;
  			message = generateErrorMesssage(pe);
  			this.mgr.logLexicalError(message, this.file, pe.currentToken.beginLine, pe.currentToken.beginColumn);
  		} else if (e instanceof NullPointerException) {
  			// Do nothing
  		} else {
  			e.printStackTrace();
  			throw new ParseException(e.getMessage());
  		}
  		this.skipToNextBlock();
	}	
	
	private void skipToNextBlock() {
		Token t;
		Token t2;
		do {
  			t = getNextToken();  	
  			t2 = getToken(2);	
  			
  		} while (t2 != null && isBlock(t2.kind));
	}
	
	public void setErrorManager(ErrorManager mgr) {
		this.mgr = mgr;
	}
	
	public void setFile(File file) {
		this.file = file;
	}
	
	/**
     * Creates the error message from a specific parse exception.
     * 
     * @param pe the parse exception.
     * @return the error message.
     */
    private String generateErrorMesssage(ParseException pe) {
        StringBuffer expected = new StringBuffer();
        boolean expectedSeq = false;
        int maxSize = 0;
        for (int i = 0; i < pe.expectedTokenSequences.length; i++) {
            if (maxSize < pe.expectedTokenSequences[i].length) {
                maxSize = pe.expectedTokenSequences[i].length;
            }
            for (int j = 0; j < pe.expectedTokenSequences[i].length; j++) {
                expected.append(pe.tokenImage[pe.expectedTokenSequences[i][j]]).append(" ");
                expectedSeq = true;
            }
            if (pe.expectedTokenSequences[i][pe.expectedTokenSequences[i].length - 1] != 0) {
                expected.append("...");
            }
            if (i < pe.expectedTokenSequences.length - 1) {
                expected.append("\n").append("    ");
            }
        }
        String retval = "unexpected token \"" + pe.currentToken.next.image + "\".";
        if (expectedSeq) {
        	if (pe.expectedTokenSequences.length == 1) {
            	retval += "\nWas expecting:" + "\n" + "    ";
        	} else {
            	retval += "\nWas expecting one of:" + "\n" + "    ";
        	}
        	retval += expected.toString();
        }
        return retval;
    }
}
PARSER_END(Lexer)


SKIP : 
{ 
	" "
| 	"\t"
|	"\n" 
| 	"\r"
}
MORE : 
{
	"//" : IN_SINGLE_LINE_COMMENT 
|	";" : IN_SINGLE_LINE_COMMENT 
|	<"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|	"/*" : IN_MULTI_LINE_COMMENT 
}
<IN_SINGLE_LINE_COMMENT>
	SPECIAL_TOKEN : { 
		<SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT 
	}
<IN_FORMAL_COMMENT>
	SPECIAL_TOKEN :	{
		<FORMAL_COMMENT: "*/" > : DEFAULT
	}
<IN_MULTI_LINE_COMMENT>
	SPECIAL_TOKEN : {
		<MULTI_LINE_COMMENT: "*/" > : DEFAULT
	}
<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT> 
	MORE : {
		< ~[] > 
}

TOKEN :
{
  	< LPAREN: "(">
| 	< RPAREN: ")">
}

TOKEN : {
	< DEFINE : "define" >
|	< DOMAIN : "domain" >
|	< REQUIREMENTS : ":requirements" >
|	< TYPES : ":types" >
|	< EITHER : "either" >
|	< CONSTANTS : ":constants" >
|	< PREDICATES : ":predicates" >
|	< FUNCTIONS : ":functions" >
|	< ACTION : ":action" >
|	< PARAMETERS : ":parameters" >
|	< PRECONDITION : ":precondition" >
|	< EFFECT : ":effect" >
|	< PREFERENCE : "preference" >
|	< WHEN : "when" >
|	< PROB : "probabilistic">
|	< DURATIVE_ACTION : ":durative-action" >
|	< DURATION : ":duration" >
|	< CONDITION : ":condition" >
|	< DERIVED : ":derived" >
|	< PROBLEM : "problem" >
|	< P_DOMAIN : ":domain" >
|	< OBJECTS	: ":objects" >
|	< INIT : ":init" >
|	< GOAL: ":goal" >
|	< METRIC : ":metric" >
}

TOKEN : {
	< STRIPS : ":strips" >
|	< TYPING : ":typing" >
|	< NEGATIVE_PRECONDITIONS : ":negative-preconditions" >
|	< DISJUNCTIVE_PRECONDITIONS : ":disjunctive-preconditions" >
|	< EQUALITY : ":equality" >
|	< EXISTENTIAL_PRECONDITIONS : ":existential-preconditions" >
|	< UNIVERSAL_PRECONDITIONS : ":universal-preconditions" >
|	< QUANTIFIED_PRECONDITIONS : ":quantified-preconditions" >
|	< CONDITIONAL_EFFECTS : ":conditional-effects" >
|   < FLUENTS : ":fluents" >
|	< ADL : ":adl" >
|	< DURATIVE_ACTIONS : ":durative-actions" >
|	< DERIVED_PREDICATES : ":derived-predicates" >
|	< TIMED_INITIAL_LITERALS : ":timed-initial-literals" >
|	< PREFERENCES : ":preferences" >
|	< CONSTRAINTS : ":constraints" >
|	< CONTINUS_EFFECTS : ":continus_effects" >
|	< DURATION_INEQUALITIES : ":duration-inequalities" >
}

TOKEN :
{
	< GREATER : ">" >
|	< LESS : "<" >
|	< GEQUAL : ">=" >
|	< LEQUAL : "<=" >
|	< EQUAL : "=" >
}

TOKEN :
{
	< MUL : "*" >
|	< DIV : "/" >
|	< ADD : "+" >
|	< SUB : "-" >
}

TOKEN :
{
	<ASSIGN : "assign" >
|	<SCALE_UP : "scale-up" >
|	<SCALE_DOWN : "scale-down" >
|	<INCREASE : "increase" >
|	<DECREASE : "decrease" >
}

TOKEN :
{
    < OR : "or" >
|   < AND : "and" >
|   < IMPLY : "imply" >
| 	< NOT : "not" >
|	< FORALL : "forall" >
|	< EXISTS : "exists" >
}

TOKEN :
{
	< ALWAYS : "always" >
|	< SOMETIME : "sometime" >
|	< WITHIN : "within" >
|	< AT_MOST_ONCE : "at-most-once" >
|	< SOMETIME_AFTER : "sometime-after" >
|	< SOMETIME_BEFORE : "sometime-before" >
|	< ALWAYS_WITHIN : "always-within" >
|	< HOLD_DURING : "hold-during" >
|	< HOLD_AFTER : "hold-after" >
|	< AT: "at" >
|	< START : "start">
|	< END : "end">
|	< OVER : "over">
|	< ALL : "all">
|	< TOTAL_TIME : "total_time" >	
|	< MAXIMIZE : "maximize" >
|	< MINIMIZE : "minimize" >
|	< IS_VIOLATED : "is-violated" >
}

TOKEN :
{
	< VAR_DURATION : "?duration" >
|	< CONTINOUS_VARIABLE : "#t" >
}

TOKEN :
{
	< NUMBER_TYPE : "number" >
|	< OBJECT_TYPE : "object" >
}


TOKEN :
{
	< SYMBOL : ((<LETTER> (<LETTER> | <DIGIT>)*)) >
|	< NUMBER :  (<DIGIT>)+ ("." (<DIGIT>)*)? >
|	< #DIGIT : ["0"-"9"] >
|	< #LETTER : ["a"-"z","A"-"Z","_","-","#"] > 
}

SimpleNode parse() #ROOT:
{
	Token t= null;
}
{
	try {
		LOOKAHEAD(4) t=domain()
	| 	LOOKAHEAD(4) t=problem()
	} catch (Throwable e) {
		this.mgr.logLexicalError("Lexical error file (" +file.getName() + ") : to many errors", file);
		throw new ParseException(e.getMessage());
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return jjtThis;
	}
	
}

Token domain() #DOMAIN:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DEFINE> <LPAREN> <DOMAIN> domain_name() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		[LOOKAHEAD(2) t=require_def()]
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		[LOOKAHEAD(2) t=type_def()]
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		[LOOKAHEAD(2) t=constants_def()]
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		[LOOKAHEAD(2) t=predicates_def()]
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		[LOOKAHEAD(2) t=functions_def()]
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		[LOOKAHEAD(2) t=constraints()]
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		(t=structure_def())*
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	try {
		<RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}
	
Token require_def() #REQUIRE_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <REQUIREMENTS> (require_key())+ <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	} 
	{
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token require_key() #REQUIRE_KEY: 
{
	Token t = token;
}
{
	try {
		t=<STRIPS>
	| 	t=<TYPING> 
	| 	t=<NEGATIVE_PRECONDITIONS>
	|	t=<DISJUNCTIVE_PRECONDITIONS>
	|	t=<EQUALITY> 
	|	t=<EXISTENTIAL_PRECONDITIONS>
	|	t=<UNIVERSAL_PRECONDITIONS>
	|	t=<QUANTIFIED_PRECONDITIONS>
	|	t=<CONDITIONAL_EFFECTS>
	|	t=<FLUENTS>
	|	t=<ADL>
	|	t=<DURATIVE_ACTIONS>
	|	t=<DERIVED_PREDICATES>
	| 	t=<TIMED_INITIAL_LITERALS>
	|	t=<PREFERENCES>
	|	t=<CONSTRAINTS>
	|	t=<CONTINUS_EFFECTS>
	|	t=<DURATION_INEQUALITIES>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token type_def() #TYPE_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <TYPES> typed_list(LexerTreeConstants.JJTPRIMITIVE_TYPE) <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token typed_list(int type) #TYPED_LIST:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2, {type == LexerTreeConstants.JJTPRIMITIVE_TYPE})
			(t=primitive_type())* (<SUB> type() typed_list(type))?
	|	LOOKAHEAD(2, {type == LexerTreeConstants.JJTCONSTANT})	
			(t=constant())* (<SUB> type() typed_list(type))? 
	|	LOOKAHEAD(2, {type == LexerTreeConstants.JJTVARIABLE})	
			(t=variable())* (<SUB> type() typed_list(type))? 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		if (t != null) {
				jjtThis.setLine(t.beginLine);
				jjtThis.setColumn(t.beginColumn);
				jjtThis.setTypeId(LexerTreeConstants.JJTVARIABLE);
		}
		return t;
	}
}

Token type() #TYPE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <EITHER> (primitive_type())+ <RPAREN>
	|	t=primitive_type()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}	

Token primitive_type() #PRIMITIVE_TYPE:
{
	Token t = token;
}
{
(	t=<OBJECT_TYPE>
|	t=<NUMBER_TYPE>  
| 	t=<SYMBOL>)
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token constants_def() #CONSTANT_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <CONSTANTS> typed_list(LexerTreeConstants.JJTCONSTANT) <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token constant() #CONSTANT:
{
	Token t = token;
}
{
	t=<SYMBOL> 
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token predicates_def() #PREDICATE_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <PREDICATES> (atomic_formula_skeleton())+ <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token atomic_formula_skeleton() #ATOMIC_FORMULA_SKELETON:
{
	Token t = token;
}
{
	t=<LPAREN> predicate() typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> 
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token predicate() #PREDICATE:
{
	Token t = token;
}
{
	(t=<SYMBOL> | t=<AT>) 
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token variable() #VARIABLE:
{
	Token t = token;
}
{
	"?" (t=<SYMBOL> | t=<OBJECT_TYPE> | t=<NUMBER_TYPE>)
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
} 

Token functions_def() #FUNCTION_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FUNCTIONS> function_typed_list(LexerTreeConstants.JJTATOMIC_FUNCTION_SKELETON) <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token atomic_function_skeleton() #ATOMIC_FUNCTION_SKELETON:
{
	Token t = token;
}
{
	t=<LPAREN> functor() typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN>
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token functor() #FUNCTOR:
{
	Token t = token;
}
{
	t=<SYMBOL> 
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token function_typed_list(int type) #FUNCTION_TYPED_LIST:
{
	Token t = token;
}
{
	(t=atomic_function_skeleton())* (<SUB> function_type() function_typed_list(type))? 
	{ 
		if (t != null) {
			jjtThis.setLine(t.beginLine);
			jjtThis.setColumn(t.beginColumn);
		}
		return t;
	}
}

Token function_type() #FUNCTION_TYPE:
{
	Token t = token;
}
{
	t=<NUMBER_TYPE> 
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token con_gd() #CON_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=and_con_gd()
	|	LOOKAHEAD(2) t=forall_con_gd()
	|	LOOKAHEAD(2) t=at_end_con_gd()
	|	LOOKAHEAD(2) t=always_con_gd()
	|	LOOKAHEAD(2) t=sometime_con_gd() 
	|	LOOKAHEAD(2) t=within_con_gd() 
	|	LOOKAHEAD(2) t=at_most_once_con_gd()
	|	LOOKAHEAD(2) t=sometime_after_con_gd()
	|	LOOKAHEAD(2) t=sometime_before_con_gd()
	|	LOOKAHEAD(2) t=always_within_con_gd()
	|	LOOKAHEAD(2) t=hold_during_con_gd()
	|	LOOKAHEAD(2) t=hold_after_con_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_con_gd() #AND_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (con_gd())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token forall_con_gd() #FORALL_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> con_gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_end_con_gd() #AT_END_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <END> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token always_con_gd() #ALWAYS_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ALWAYS> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token sometime_con_gd() #SOMETIME_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SOMETIME> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token within_con_gd() #WITHIN_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <WITHIN> <NUMBER> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_most_once_con_gd() #AT_MOST_ONCE_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT_MOST_ONCE> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token sometime_after_con_gd() #SOMETIME_AFTER_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SOMETIME_AFTER> gd() gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token sometime_before_con_gd() #SOMETIME_BEFORE_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SOMETIME_BEFORE> gd() gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token always_within_con_gd() #ALWAYS_WITHIN_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ALWAYS_WITHIN> <NUMBER> gd() gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token hold_during_con_gd() #HOLD_DURING_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <HOLD_DURING> <NUMBER> <NUMBER> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token hold_after_con_gd() #HOLD_AFTER_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <HOLD_AFTER> <NUMBER> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token gd() #GD: 
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=atomic_formula(LexerTreeConstants.JJTTERM) 		
//	|	LOOKAHEAD(2) t=not_atomic_formula(LexerTreeConstants.JJTTERM) 
	|	LOOKAHEAD(2) t=and_gd()
	|	LOOKAHEAD(2) t=or_gd()
	|	LOOKAHEAD(2) t=not_gd() 
	|	LOOKAHEAD(2) t=imply_gd()
	|	LOOKAHEAD(2) t=exists_gd()
	|	LOOKAHEAD(2) t=forall_gd()
	|	LOOKAHEAD(2) t=f_comp() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_gd() #AND_GD: 
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (gd())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token or_gd() #OR_GD: 
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <OR> (gd())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token not_gd() #NOT_GD: 
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <NOT> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token imply_gd() #IMPLY_GD: 
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <IMPLY> gd() gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token exists_gd() #EXISTS_GD: 
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <EXISTS> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token forall_gd() #FORALL_GD: 
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}
	
Token atomic_formula(int type) #ATOMIC_FORMULA:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> predicate() (		
		LOOKAHEAD({ type == LexerTreeConstants.JJTCONSTANT } ) (constant())* {
				jjtThis.setTypeId(LexerTreeConstants.JJTCONSTANT);
			}
		| LOOKAHEAD({ type == LexerTreeConstants.JJTTERM }) (term())* {		
				jjtThis.setTypeId(LexerTreeConstants.JJTTERM);
			}
		) <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}
		
Token term() #TERM:
{
	Token t = token;
}
{
	try {
		t=constant() 
	|	t=variable() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token literal(int type) #LITERAL:
{
	Token t = token;
}
{
			
	try {
		LOOKAHEAD(2) t=atomic_formula(type)
	| 	LOOKAHEAD(2) t=not_atomic_formula(type)
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token not_atomic_formula(int type) #NOT_ATOMIC_FORMULA:
{
	Token t = token;
}
{		
	try {
		t=<LPAREN> <NOT> atomic_formula(type) <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token f_comp() #F_COMP:
{
	Token t = token;
}
{
	try {
		t=binary_comp() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token binary_comp() #BINARY_COMP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=greater_comp()
	|	LOOKAHEAD(2) t=less_comp()
	|	LOOKAHEAD(2) t=greater_equal_comp()
	|	LOOKAHEAD(2) t=less_equal_comp()
	|	LOOKAHEAD(2) t=equal_comp()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token greater_comp() #GREATER_COMP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <GREATER> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token greater_equal_comp() #GREATER_EQUAL_COMP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <GEQUAL> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token less_equal_comp() #LESS_EQUAL_COMP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <LEQUAL> f_exp() f_exp() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token less_comp() #LESS_COMP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <LESS> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token equal_comp() #EQUAL_COMP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <EQUAL> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token f_exp() #F_EXP:
{
	Token t = token;
}
{
	try {
		t=number() 
	|	LOOKAHEAD(2) t=op()
	|	LOOKAHEAD(2) t=f_head()
	|	LOOKAHEAD(2) t=variable()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token number() #NUMBER:
{
	Token t = token;
}
{
	try {
		t =<NUMBER>

	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 

		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}
	
Token op() #OP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=binary_operation()
	|	LOOKAHEAD(2) t=unary_op()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token binary_operation() #BINARY_OPERATION:
{
	Token t = token;
}
{
	try{
		LOOKAHEAD(2) t=add_op()
	|	LOOKAHEAD(2) t=substract_op()
	|	LOOKAHEAD(2) t=multiply_op()
	|	LOOKAHEAD(2) t=divide_op()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token add_op() #ADD_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ADD> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token substract_op() #SUBSTRACT_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SUB> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token multiply_op() #MULTIPLY_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <MUL> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token divide_op() #DIVIDE_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DIV> f_exp() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token unary_op() #UNARY_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SUB> f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token f_head() #F_HEAD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> functor() (term())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token structure_def() #STRUCTURE_DEF:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=action_def()
	|	LOOKAHEAD(2) t=durative_action_def()
	|	LOOKAHEAD(2) t=derived_def()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token action_def() #ACTION_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ACTION> action_name()
		<PARAMETERS> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN>
		action_def_body()
		<RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token action_name() #ACTION_NAME:
{
	Token t = token;
}
{
	try {
		t=<SYMBOL>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token action_def_body() #ACTION_DEF_BODY:
{
	Token t = token;
}
{
	try {
		t=<PRECONDITION> pre_gd()
		<EFFECT> effect() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);	
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token pre_gd() #PRE_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=empty_or()
	|	LOOKAHEAD(2) t=pref_gd()
	|	LOOKAHEAD(2) t=and_pre_gd()
	|	LOOKAHEAD(2) t=forall_pre_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token empty_or() #EMPTY_OR:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_pre_gd() #AND_PRE_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (pre_gd())* <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}	

Token forall_pre_gd() #FORALL_PRE_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> pre_gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token pref_gd() #PREF_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=named_pref_gd()
	|	t=gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token named_pref_gd() #NAMED_PREF_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <PREFERENCE> [pref_name()] gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token pref_name() #PREF_NAME:
{
	Token t = token;
}
{
	try {
		t=<SYMBOL>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token effect() #EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=and_c_effect()
	|	LOOKAHEAD(2) t=c_effect()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_c_effect() #AND_C_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (c_effect())* <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token prob_effect() #PROB_EFFECT:
{
	Token t = token;
}
{
	try{
		t = <LPAREN> <PROB> (prob_term())* <RPAREN>
	}catch(Throwable e){

		this.error(e, t.beginLine, t.beginColumn);
	}
	{

		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token prob_term() #PROB_TERM:
{
	Token t = token;
}
{
	try{
	  LOOKAHEAD(3)	t = number() c_effect()
	| LOOKAHEAD(3)	t = number() and_c_effect()
	}catch(Throwable e){

		this.error(e, t.beginLine, t.beginColumn);
	}
	{

		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token c_effect() #C_EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=forall_effect()
	|	LOOKAHEAD(2) t=when_con_effect()
	|	LOOKAHEAD(2) t=p_effect()
	|	LOOKAHEAD(2) t=prob_effect()
	} catch (Throwable e) {

		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 

		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token forall_effect() #FORALL_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> effect() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token when_con_effect() #WHEN_CON_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <WHEN> gd() cond_effect() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token cond_effect() #COND_EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=and_c_effect()
	|	LOOKAHEAD(2) t=c_effect()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_p_effect() #AND_P_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (p_effect())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token p_effect() #P_EFFECT:
{
	Token t = token;
}
{
 	try {
 		LOOKAHEAD(2) t=assign_op()
	|	LOOKAHEAD(2) t=literal(LexerTreeConstants.JJTTERM)
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token assign_op() #ASSIGN_OP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=assign()
	|	LOOKAHEAD(2) t=scale_up()
	|	LOOKAHEAD(2) t=scale_down()
	|	LOOKAHEAD(2) t=increase()
	|	LOOKAHEAD(2) t=decrease()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token assign() #ASSIGN:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ASSIGN> f_head() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
	{ return t; }
}

Token scale_up() #SCALE_UP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SCALE_UP> f_head() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}	 
 
Token scale_down() #SCALE_DOWN:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SCALE_DOWN> f_head() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token increase() #INCREASE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <INCREASE> f_head() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token decrease() #DECREASE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DECREASE> f_head() f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token durative_action_def() #DURATION_ACTION_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DURATIVE_ACTION> da_symbol()
		<PARAMETERS> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN>
		da_def_body()
		<RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_symbol() #DA_SYMBOL:
{
	Token t = token;
}
{
	try {
		t=<SYMBOL>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token da_def_body() #DA_DEF_BODY:
{
	Token t = token;
}
{
	try {
		t=<DURATION> duration_constraint()
		<CONDITION> da_gd()
		<EFFECT> da_effect()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token duration_constraint() #DURATION_CONSTRAINT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=empty_or()
	|	LOOKAHEAD(2) t=and_simple_duration_constraint()
	|	LOOKAHEAD(2) t=simple_duration_constraint()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_simple_duration_constraint() #AND_SIMPLE_DURATION_CONSTRAINT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (simple_duration_constraint())+ <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token simple_duration_constraint() #SIMPLE_DURATION_CONSTRAINT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=d_op()
	|	LOOKAHEAD(2) t=at_simple_duration_constraint()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_simple_duration_constraint() #AT_SIMPLE_DURATION_CONSTRAINT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(3) t=at_start_simple_duration_constraint()
	| 	LOOKAHEAD(3) t=at_end_simple_duration_constraint()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_start_simple_duration_constraint() #AT_START_SIMPLE_DURATION_CONSTRAINT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <START> simple_duration_constraint() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_end_simple_duration_constraint() #AT_END_SIMPLE_DURATION_CONSTRAINT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <END> simple_duration_constraint() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token d_op() #D_OP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=equal_d_op()
	|	LOOKAHEAD(2) t=gequal_d_op()
	| 	LOOKAHEAD(2) t=lequal_d_op()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token equal_d_op() #EQUAL_D_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <EQUAL> var_duration() d_value() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token gequal_d_op() #GEQUAL_D_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <GEQUAL> var_duration() d_value() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token lequal_d_op() #LEQUAL_D_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <LEQUAL> var_duration() d_value() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token var_duration() #VAR_DURATION:
{
	Token t = token;
}
{
	try {
		t=<VAR_DURATION>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token d_value() #D_VALUE:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=number() 
	| 	LOOKAHEAD(2) t=f_exp()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_gd() #DA_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=pref_timed_gd() 
	|	LOOKAHEAD(2) t=and_da_gd()
	|	LOOKAHEAD(2) t=forall_da_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token forall_da_gd() #FORALL_DA_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> da_gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_da_gd() #AND_DA_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (da_gd())* <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token pref_timed_gd() #PREF_TIMED_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=timed_gd()
	|	LOOKAHEAD(2) t=named_pref_timed_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token named_pref_timed_gd() #NAMED_PREF_TIMED_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <PREFERENCE> [pref_name()] timed_gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token timed_gd() #TIMED_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=at_timed_gd()
	|	LOOKAHEAD(2) t=over_timed_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token over_timed_gd() #OVER_TIMED_GD:
{
	Token t = token;
}
{
	try {
		t=over_all_timed_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token over_all_timed_gd() #OVER_ALL_TIMED_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <OVER> <ALL> gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_timed_gd() #AT_TIMED_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(3) t=at_start_timed_gd()
	|	LOOKAHEAD(2) t=at_end_timed_gd()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_start_timed_gd() #AT_START_TIMED_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <START> gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_end_timed_gd() #AT_END_TIMED_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <END> gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token interval() #INTERVAL:
{
	Token t = token;
}
{
	try {
		t=<ALL>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_effect() #DA_EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=timed_effect()
	|	LOOKAHEAD(2) t=and_da_effect() 
	|	LOOKAHEAD(2) t=forall_da_effect()
	|	LOOKAHEAD(2) t=when_da_effect()
	|	LOOKAHEAD(2) t=da_assign_op() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_assign_op() #DA_ASSIGN_OP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=da_assign()
	|	LOOKAHEAD(2) t=da_scale_up()
	|	LOOKAHEAD(2) t=da_scale_down()
	|	LOOKAHEAD(2) t=da_increase()
	|	LOOKAHEAD(2) t=da_decrease()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_assign() #DA_ASSIGN:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ASSIGN> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_scale_up() #DA_SCALE_UP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SCALE_UP> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}	 
 
Token da_scale_down() #DA_SCALE_DOWN:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SCALE_DOWN> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
	
}

Token da_increase() #DA_INCREASE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <INCREASE> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_decrease() #DA_DECREASE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DECREASE> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token when_da_effect() #WHEN_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <WHEN> da_gd() timed_effect() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token forall_da_effect() #FORALL_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> da_effect() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_da_effect() #AND_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (da_effect())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token timed_effect() #TIMED_EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=at_da_effect()
	|	LOOKAHEAD(2) t=at_f_assign_da_effect()
	|	LOOKAHEAD(2) t=assign_op_t() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_f_assign_da_effect() #AT_F_ASSIGN_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(3) t=at_start_f_assign_da_effect()
	|	LOOKAHEAD(3) t=at_end_f_assign_da_effect()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_start_f_assign_da_effect() #AT_START_F_ASSIGN_DA_EFFECT:
{
	Token t = token;
}
{
	try { 
		t=<LPAREN> <AT> <START> f_assign_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token at_end_f_assign_da_effect() #AT_END_F_ASSIGN_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <END> f_assign_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_da_effect() #AT_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(4) t=at_start_da_effect()
	|	LOOKAHEAD(4) t=at_end_da_effect()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token at_start_da_effect() #AT_START_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <START> literal(LexerTreeConstants.JJTTERM) <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token at_end_da_effect() #AT_END_DA_EFFECT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> <END> literal(LexerTreeConstants.JJTTERM)  <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token assign_op_t() #ASSIGN_OP_T:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=increase_assign_op_t()
	|	LOOKAHEAD(2) t=decrease_assign_op_t() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token increase_assign_op_t() #INCREASE_ASSIGN_OP_T:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <INCREASE> f_head() f_exp_t() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token decrease_assign_op_t() #DECREASE_ASSIGN_OP_T:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DECREASE> f_head() f_exp_t() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token f_exp_t() #F_EXP_T:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=<LPAREN> <MUL> continous_variable() f_exp() <RPAREN>
	| 	LOOKAHEAD(2) t=<LPAREN> <MUL> f_exp() continous_variable() <RPAREN>
	| 	LOOKAHEAD(2) t=continous_variable() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token continous_variable() #CONTINOUS_VARIABLE:
{
	Token t = token;
}
{
	try {
		t=<CONTINOUS_VARIABLE> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
	
}

Token f_assign_da() #F_ASSIGN_DA:
{
	Token t = token;
}
{	
	try {
		LOOKAHEAD(2) t=da_assign() 
	|	LOOKAHEAD(2) t=da_scale_up() 
	|	LOOKAHEAD(2) t=da_scale_down() 
	|	LOOKAHEAD(2) t=da_increase()
	|	LOOKAHEAD(2) t=da_decrease()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token f_exp_da() #F_EXP_DA:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(3) t=f_exp()
	|	LOOKAHEAD(3) t=da_binary_op()
	|	LOOKAHEAD(3) t=da_unary_op()
	|	LOOKAHEAD(3) t=var_duration()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token da_binary_op() #DA_BINARY_OP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=da_add_op() 
	|	LOOKAHEAD(2) t=da_substract_op()
	|	LOOKAHEAD(2) t=da_multiply_op()
	|	LOOKAHEAD(2) t=da_divide_op()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_add_op() #DA_ADD_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ADD> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_substract_op() #DA_SUBSTRACT_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SUB> f_head() f_exp_da() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_multiply_op() #DA_MULTIPLY_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <MUL> f_head() f_exp_da() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_divide_op() #DA_DIVIDE_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DIV> f_head() f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token da_unary_op() #DA_UNARY_OP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SUB> f_exp_da() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token derived_def() #DERIVED_DEF:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DERIVED> atomic_formula(LexerTreeConstants.JJTVARIABLE) gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token problem() #PROBLEM:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <DEFINE> <LPAREN> <PROBLEM> problem_name() <RPAREN> 
		<LPAREN> <P_DOMAIN> domain_name() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	[LOOKAHEAD(2) require_def()]
	[LOOKAHEAD(2) object_declaration()]
	init()
	goal()
	[LOOKAHEAD(2) constraints()]
	[LOOKAHEAD(2) metric_spec()]
	// [length-spec()] not implemented
	<RPAREN> { 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token problem_name() #PROBLEM_NAME:
{
	Token t = token;
}
{
	try {
		t=<SYMBOL>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token domain_name() #DOMAIN_NAME:
{
	Token t = token;
}
{
	try {
		t=<SYMBOL>  
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		jjtThis.setImage(t.image);
		return t;
	}
}

Token object_declaration() #OBJECT_DECLARATION:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <OBJECTS> typed_list(LexerTreeConstants.JJTCONSTANT) <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token init() #INIT:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <INIT> (init_el())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token init_el() #INIT_EL:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=literal(LexerTreeConstants.JJTCONSTANT)
	|	LOOKAHEAD(2) t=equal_init_el() 
	|	LOOKAHEAD(3) t=timed_literal()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token equal_init_el() #EQUAL_INIT_EL:
{
	Token t = token;
}
{	
	try {
		t=<LPAREN> <EQUALITY> f_head() number() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token timed_literal() #TIMED_LITERAL:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AT> number() literal(LexerTreeConstants.JJTCONSTANT) <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token goal() #GOAL:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <GOAL> pre_gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token constraints() #CONSTRAINTS:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <CONSTRAINTS> pref_con_gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token pref_con_gd() #PREF_CON_GD:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=and_pref_con_gd()
	|	LOOKAHEAD(2) t=forall_pref_con_gd()
	| 	LOOKAHEAD(2) t=named_pref_con_gd()
	|	LOOKAHEAD(2) t=con_gd() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token and_pref_con_gd() #AND_PREF_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <AND> (pref_con_gd())* <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token named_pref_con_gd() #NAMED_PREF_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <PREFERENCE> [pref_name()] con_gd() <RPAREN> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token forall_pref_con_gd() #FORALL_PREF_CON_GD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <FORALL> <LPAREN> typed_list(LexerTreeConstants.JJTVARIABLE) <RPAREN> pref_con_gd() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token metric_spec() #METRIC_SPEC:
{
	Token t = token;
}
{	
	try {
		LOOKAHEAD(3) t=maximize()
	| 	LOOKAHEAD(3) t=minimize() 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token maximize() #MAXIMIZE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <METRIC> <MAXIMIZE> metric_f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token minimize() #MINIMIZE:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <METRIC> <MINIMIZE> metric_f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token metric_f_exp() #METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=unary_op_metric_f_exp()
	|	LOOKAHEAD(2) t=binary_op_metric_f_exp()
	|	LOOKAHEAD(2) t=multi_op_metric_f_exp()
	|	LOOKAHEAD(2) t=number()
	|	LOOKAHEAD(2) t=constant_f_head()
	|	LOOKAHEAD(2) t=total_time()
	|	LOOKAHEAD(2) t=violated_pref_exp()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token violated_pref_exp() #VIOLATED_PREF_EXP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <IS_VIOLATED> pref_name() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token constant_f_head() #CONSTANT_F_HEAD:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> functor() (constant())* <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token total_time() #TOTAL_TIME:
{
	Token t = token;
}
{
	try {
		t=<TOTAL_TIME> 
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}


Token binary_op_metric_f_exp() #BINARY_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=add_op_metric_f_exp()
	|	LOOKAHEAD(2) t=substract_op_metric_f_exp()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token add_op_metric_f_exp() #ADD_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ADD> metric_f_exp() metric_f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token substract_op_metric_f_exp() #SUBSTRACT_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try{
		t=<LPAREN> <SUB> metric_f_exp() metric_f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token multi_op_metric_f_exp() #MULTI_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		LOOKAHEAD(2) t=multiply_narity_op_metric_f_exp()
	|	LOOKAHEAD(2) t=add_narity_op_metric_f_exp()
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token multiply_narity_op_metric_f_exp() #MULTIPLY_NARITY_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <MUL> metric_f_exp() (metric_f_exp())+ <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token add_narity_op_metric_f_exp() #ADD_NARITY_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <ADD> metric_f_exp() (metric_f_exp())+ <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}

Token unary_op_metric_f_exp() #UNARY_OP_METRIC_F_EXP:
{
	Token t = token;
}
{
	try {
		t=<LPAREN> <SUB> metric_f_exp() <RPAREN>
	} catch (Throwable e) {
		this.error(e, t.beginLine, t.beginColumn);;
	}
	{ 
		jjtThis.setLine(t.beginLine);
		jjtThis.setColumn(t.beginColumn);
		return t;
	}
}



