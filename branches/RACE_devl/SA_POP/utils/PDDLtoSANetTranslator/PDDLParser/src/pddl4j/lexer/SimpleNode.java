/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package pddl4j.lexer;

import java.util.Iterator;
import java.util.LinkedList;

public class SimpleNode implements Node, Iterable<SimpleNode> {
    protected Node parent;

    protected Node[] children;

    protected int id;

    protected Lexer parser;

    protected Token token;

    protected int line;

    protected int column;

    protected String image;

    protected int typeId;
    
    

    public SimpleNode(int id) {
        this.id = id;
        this.line = -1;
        this.column = -1;
        this.image = "";
        this.typeId = -1;
    }

    public SimpleNode(Lexer p, int id) {
        this(id);
        parser = p;
    }

    public void jjtOpen() {
    }

    public void jjtClose() {
    }

    public void jjtSetParent(Node n) {
        parent = n;
    }

    public Node jjtGetParent() {
        return parent;
    }

    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    public Node jjtGetChild(int i) {
        return children[i];
    }

    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }

    /*
     * You can override these two methods in subclasses of SimpleNode to customize the way the node appears when the
     * tree is dumped. If your output uses more than one line you should override toString(String), otherwise overriding
     * toString() is probably all you need to do.
     */

    public String toString() {
        StringBuffer str = new StringBuffer();
        str.append("[");
        str.append(this.getLabel());
        
        if (!this.image.equals("")) {
            str.append(", image=\"" + this.image + "\"");
        }
        str.append(", line=" + this.line);
        str.append(", column=" + this.column);
        if (this.typeId != -1) {
            str.append(", type=" + LexerTreeConstants.jjtNodeName[this.typeId]);
        }
        str.append("]");
        return str.toString();
        
    }

    public String toString(String prefix) {
        return prefix + toString();
    }

    public int getDepth() {
        int depth = 0;
        SimpleNode pred = (SimpleNode) this.parent;
        while (pred != null) {
            depth++;
            pred = (SimpleNode) pred.parent;
        }
        return depth;
    }
    /*
     * Override this method if you want to customize how the node dumps out its children.
     */

    public void dump(String prefix) {
        System.out.println(toString(prefix));
        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    public void setToken(Token token) {
        this.token = token;
    }

    public final String getLabel() {
        return LexerTreeConstants.jjtNodeName[id];
    }

    public final void setLine(int line) {
        this.line = line;
    }

    public final int getLine() {
        return this.line;
    }

    public final void setColumn(int column) {
        this.column = column;
    }

    public final int getColumn() {
        return this.column;
    }

    public void setTypeId(int typeId) {
        this.typeId = typeId;
    }

    public int getTypeId() {
        return this.typeId;
    }

    /**
     * @return Returns the image.
     */
    public final String getImage() {
        return image;
    }

    public int getId() {
        return this.id;
    }
    
    /**
     * @param image The image to set.
     */
    public final void setImage(String image) {
        this.image = image.toLowerCase();
    }
    
    private class TreeIterator implements Iterator<SimpleNode> {
        
        private LinkedList<SimpleNode> nodes;
        
        public TreeIterator() {
            this.nodes = new LinkedList<SimpleNode>();
            this.nodes.add(SimpleNode.this);
        }
        public boolean hasNext() {
            return !this.nodes.isEmpty();
        }

        public SimpleNode next() {
            SimpleNode node = null;
            if (this.hasNext()) { 
                node = nodes.poll();
                for (int i = 0; i < node.jjtGetNumChildren(); i++) {
                    nodes.add(i, (SimpleNode) node.jjtGetChild(i));
                }
            }
            return node;
        }

        public void remove() {
            return;
        }
        
    }

    public Iterator<SimpleNode> iterator() {
       return new TreeIterator();
    }
    
}
