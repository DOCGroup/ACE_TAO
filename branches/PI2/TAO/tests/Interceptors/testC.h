/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_TESTC_H_
#define _TAO_IDL_TESTC_H_

#include "tao/corba.h"

#if defined (ACE_HAS_MINIMUM_IOSTREAMH_INCLUSION)
#include "ace/streams.h"
#endif /* ACE_HAS_MINIMUM_IOSTREAMH_INCLUSION */

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO 

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO 
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

TAO_NAMESPACE  Test_Interceptors
{

#if !defined (_TEST_INTERCEPTORS_SILLY_CH_)
#define _TEST_INTERCEPTORS_SILLY_CH_

  class  Silly : public CORBA::UserException
  {
  public:


  Silly (void); // default ctor
  Silly (const Silly &); // copy ctor
  ~Silly (void);
  static void _tao_any_destructor (void*);
  Silly &operator= (const Silly &);


  virtual void _raise (void);

  virtual void _tao_encode (
      TAO_OutputCDR &,
      CORBA::Environment &) const;
  virtual void _tao_decode (
      TAO_InputCDR &,
      CORBA::Environment &);

  static Silly *_narrow (CORBA::Exception *);


  // = TAO extension
  static CORBA::Exception *_alloc (void);

}; // exception Test_Interceptors::Silly

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Silly;


#endif /* end #if !defined */


#if !defined (_TEST_INTERCEPTORS_VISUAL___PTR_CH_)
#define _TEST_INTERCEPTORS_VISUAL___PTR_CH_

class Visual;
typedef Visual *Visual_ptr;

#endif /* end #if !defined */


#if !defined (_TEST_INTERCEPTORS_VISUAL___VAR_CH_)
#define _TEST_INTERCEPTORS_VISUAL___VAR_CH_

class  Visual_var : public TAO_Base_var
{
public:
  Visual_var (void); // default constructor
  Visual_var (Visual_ptr);
  Visual_var (const Visual_var &); // copy constructor
  ~Visual_var (void); // destructor
  
  Visual_var &operator= (Visual_ptr);
  Visual_var &operator= (const Visual_var &);
  Visual_ptr operator-> (void) const;
  
  operator const Visual_ptr &() const;
  operator Visual_ptr &();
  // in, inout, out, _retn 
  Visual_ptr in (void) const;
  Visual_ptr &inout (void);
  Visual_ptr &out (void);
  Visual_ptr _retn (void);
  Visual_ptr ptr (void) const;

private:
  Visual_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  Visual_var (const TAO_Base_var &rhs);
  Visual_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_TEST_INTERCEPTORS_VISUAL___OUT_CH_)
#define _TEST_INTERCEPTORS_VISUAL___OUT_CH_

class  Visual_out
{
public:
  Visual_out (Visual_ptr &);
  Visual_out (Visual_var &);
  Visual_out (const Visual_out &);
  Visual_out &operator= (const Visual_out &);
  Visual_out &operator= (const Visual_var &);
  Visual_out &operator= (Visual_ptr);
  operator Visual_ptr &();
  Visual_ptr &ptr (void);
  Visual_ptr operator-> (void);
  
private:
  Visual_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_TEST_INTERCEPTORS_VISUAL_CH_)
#define _TEST_INTERCEPTORS_VISUAL_CH_

class  Visual : public virtual CORBA_Object
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef Visual_ptr _ptr_type;
  typedef Visual_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static Visual_ptr _duplicate (Visual_ptr obj);
  static Visual_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static Visual_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  static Visual_ptr _nil (void)
    {
      return (Visual_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual void normal (
      CORBA::Long arg,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void nothing (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void user (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException,
      Test_Interceptors::Silly
    ));

  virtual void system (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void shutdown (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id, 
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);
  
  virtual const char* _interface_repository_id (void) const;

protected:
  Visual (void);
  Visual (TAO_Stub *objref, 
      TAO_ServantBase *_tao_servant = 0, 
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~Visual (void);
private:
  Visual (const Visual &);
  void operator= (const Visual &);
};

class  TAO_Test_Interceptors_Visual_Default_Proxy_Factory
{
public:
  
  TAO_Test_Interceptors_Visual_Default_Proxy_Factory (int register_proxy_factory = 1);
  
  virtual ~TAO_Test_Interceptors_Visual_Default_Proxy_Factory (void);
  
  virtual Visual_ptr create_proxy (
      Visual_ptr proxy,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
};

class  TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter
{
public:
  
  friend class ACE_Singleton<TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>;
  
  int register_proxy_factory (
      TAO_Test_Interceptors_Visual_Default_Proxy_Factory *df,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  
  int unregister_proxy_factory (
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );
  
  Visual_ptr create_proxy (
      Visual_ptr proxy,
      CORBA::Environment &ACE_TRY_ENV = 
        TAO_default_environment ()
    );

protected:
  TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter (void);
  ~TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter (void);
  TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter &operator= (
      const TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter &
    );
  TAO_Test_Interceptors_Visual_Default_Proxy_Factory *proxy_factory_;
  int delete_proxy_factory_;
  ACE_SYNCH_RECURSIVE_MUTEX lock_;
  
};

typedef ACE_Singleton<TAO_Test_Interceptors_Visual_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX> TAO_Test_Interceptors_Visual_PROXY_FACTORY_ADAPTER;

class  TAO_Test_Interceptors_Visual_Smart_Proxy_Base
  : public virtual ACE_NESTED_CLASS (Test_Interceptors, Visual),
    public virtual TAO_Smart_Proxy_Base
{
public:
  TAO_Test_Interceptors_Visual_Smart_Proxy_Base (void);
  ~TAO_Test_Interceptors_Visual_Smart_Proxy_Base (void);
  virtual TAO_Stub *_stubobj (void) const;
virtual void normal (
    CORBA::Long arg,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ));

virtual void nothing (
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ));

virtual void user (
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    Test_Interceptors::Silly
  ));

virtual void system (
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ));

virtual void shutdown (
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ));

protected:
  ::Test_Interceptors::Visual_ptr get_proxy (void);
  ::Test_Interceptors::Visual_var proxy_;
};


#endif /* end #if !defined */

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Visual;


}
TAO_NAMESPACE_CLOSE // module Test_Interceptors

 void operator<<= (CORBA::Any &, const Test_Interceptors::Silly &); // copying version
 void operator<<= (CORBA::Any &, Test_Interceptors::Silly*); // noncopying version
 CORBA::Boolean operator>>= (const CORBA::Any &, Test_Interceptors::Silly *&); // deprecated
 CORBA::Boolean operator>>= (const CORBA::Any &, const Test_Interceptors::Silly *&);
extern  Test_Interceptors::Visual_ptr (*_TAO_collocation_Test_Interceptors_Visual_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface Test_Interceptors::Visual
 void operator<<= (CORBA::Any &, Test_Interceptors::Visual_ptr);
 CORBA::Boolean operator>>= (const CORBA::Any &, Test_Interceptors::Visual *&);

#ifndef __ACE_INLINE__

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Test_Interceptors::Silly &);
 CORBA::Boolean operator>> (TAO_InputCDR &, Test_Interceptors::Silly &);

# if !defined (ACE_LACKS_IOSTREAM_TOTALLY)

 ostream& operator<< (ostream &, const Test_Interceptors::Silly &);

# endif /* ACE_LACKS_IOSTREAM_TOTALLY */
 CORBA::Boolean operator<< (TAO_OutputCDR &, const Test_Interceptors::Visual_ptr );
 CORBA::Boolean operator>> (TAO_InputCDR &, Test_Interceptors::Visual_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "testC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* ifndef */
