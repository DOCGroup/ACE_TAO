/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "testS.h"

#if !defined (__ACE_INLINE__)
#include "testS.i"
#endif /* !defined INLINE */

class TAO_Test_Interceptors_Visual_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:05:03 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /project/acetmp/kirthika/BUILD/cc5/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Test_Interceptors_Visual_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Test_Interceptors_Visual_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14,  0, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14,  5,  0,  0,
     14, 14, 14,  0, 14, 14, 14, 14, 14, 14,
     14, 14,  0,  0,  0, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14,
#else
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14,  0, 14,  0, 14, 14,
     14, 14, 14,  0, 14, 14, 14, 14,  5,  0,
      0, 14, 14, 14,  0,  0,  0,  0, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Test_Interceptors_Visual_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 13,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"user", 	&POA_Test_Interceptors::Visual::user_skel},
      {"_is_a",  &POA_Test_Interceptors::Visual::_is_a_skel},
      {"system", 	&POA_Test_Interceptors::Visual::system_skel},
      {"nothing", 	&POA_Test_Interceptors::Visual::nothing_skel},
      {"shutdown", 	&POA_Test_Interceptors::Visual::shutdown_skel},
      {"",0},{"",0},
      {"normal", 	&POA_Test_Interceptors::Visual::normal_skel},
      {"",0},
      {"_non_existent",  &POA_Test_Interceptors::Visual::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:05:03 */
static TAO_Test_Interceptors_Visual_Perfect_Hash_OpTable tao_Test_Interceptors_Visual_optable;

Test_Interceptors::Visual_ptr _TAO_collocation_POA_Test_Interceptors_Visual_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      Test_Interceptors::Visual_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_Test_Interceptors::_tao_thru_poa_collocated_Visual (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_Test_Interceptors_Visual_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_Test_Interceptors_Visual_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_Test_Interceptors_Visual_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_Test_Interceptors_Visual_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_Test_Interceptors_Visual_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_Test_Interceptors_Visual_Stub_Factory_Initializer));

// skeleton constructor
POA_Test_Interceptors::Visual::Visual (void)
{
  this->optable_ = &tao_Test_Interceptors_Visual_optable;
}

// copy ctor
POA_Test_Interceptors::Visual::Visual (const Visual& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_Test_Interceptors::Visual::~Visual (void)
{
}

void POA_Test_Interceptors::Visual::normal_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *)_tao_object_reference;

  CORBA::Long arg;
  if (!(
    (_tao_in >> arg)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "normal",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->normal (
        arg,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "normal",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "normal",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_Test_Interceptors::Visual::nothing_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *)_tao_object_reference;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "nothing",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->nothing (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "nothing",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "nothing",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_Test_Interceptors::Visual::user_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *)_tao_object_reference;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "user",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->user (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "user",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "user",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_Test_Interceptors::Visual::system_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *)_tao_object_reference;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "system",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->system (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "system",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "system",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_Test_Interceptors::Visual::shutdown_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *)_tao_object_reference;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          0,
          _tao_objref.in (),
          "shutdown",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#else
      ACE_UNUSED_ARG (_tao_server_request);
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->shutdown (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          0,
          _tao_objref.in (),
          "shutdown",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          0,
          _tao_objref.in (),
          "shutdown",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  if (_tao_server_request.response_expected ()
      && !_tao_server_request.sync_with_server ())
    {
      _tao_server_request.init_reply (ACE_TRY_ENV);
      ACE_CHECK;
    }
}

void POA_Test_Interceptors::Visual::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Test_Interceptors::Visual::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_Test_Interceptors::Visual *_tao_impl = (POA_Test_Interceptors::Visual *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Test_Interceptors::Visual::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Test_Interceptors/Visual:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Test_Interceptors::Visual::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:Test_Interceptors/Visual:1.0") == 0)
    return ACE_static_cast (POA_Test_Interceptors::Visual_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Test_Interceptors::Visual::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_Test_Interceptors::Visual::_interface_repository_id (void) const
{
  return "IDL:Test_Interceptors/Visual:1.0";
}

Test_Interceptors::Visual*
POA_Test_Interceptors::Visual::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::Test_Interceptors::Visual_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_Test_Interceptors::_tao_thru_poa_collocated_Visual (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::Test_Interceptors::Visual::_unchecked_narrow (obj.in ());
    }
}

POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::_tao_thru_poa_collocated_Visual (
  TAO_Stub *stub
)
  :  CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


void POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::normal  (
    CORBA::Long arg,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "normal",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->normal (
      arg,
      ACE_TRY_ENV
    );
  return;
}

void POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::nothing  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "nothing",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->nothing (
      ACE_TRY_ENV
    );
  return;
}

void POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::user  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    Test_Interceptors::Silly
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "user",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->user (
      ACE_TRY_ENV
    );
  return;
}

void POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::system  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "system",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->system (
      ACE_TRY_ENV
    );
  return;
}

void POA_Test_Interceptors::_tao_thru_poa_collocated_Visual::shutdown  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "shutdown",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_Test_Interceptors::Visual_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Test_Interceptors/Visual:1.0"
        )
    )->shutdown (
      ACE_TRY_ENV
    );
  return;
}



