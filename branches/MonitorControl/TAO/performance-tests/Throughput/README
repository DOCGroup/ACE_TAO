/**

@page Throughput Performance Test README File

	This test tries to estimate the maximum throughput (int bytes
per second) that the ORB can achieve.  The test sends octet sequences
of increasing sizes to a remote consumer, and measures both the time
it takes to receive the data as well as the time required to send it.
A single twoway operation is used to ensure that the data is properly
flushed.

	Please do not extend this test to deal with other data types,
configurations, etc.  If you need to just create a new test.  In the
past we had multi-purpose tests like that, they were hard to maintain,
and the results were hard to interpret.  Furthermore, the test is
purposely simple so its output can be parsed via nightly scripts and
plotted in a graph.   More importantly, the throughput for raw data
and the marshaling time are completely different things and should be
measured with different tools.

	To run the test use the run_test.pl script:

$ ./run_test.pl

	The script returns 0 if the test was successful, and prints
out the performance numbers.

Since monitors have been added to ACE and TAO (April 2008), the
performance numbers may be affected by whether these monitors
are enabled or disabled. All monitors are disabled by default.
To enable all ACE + TAO monitors, add

#define ACE_ENABLE_MONITORS

to $ACE_ROOT/ace/config.h. If this line is present, TAO monitors
may be disabled by finding

// Comment out to enable only ACE monitors...
#if defined (ACE_ENABLE_MONITORS)
#  define TAO_ENABLE_MONITORS
#endif /* ACE_ENABLE_MONITORS */

in $TAO_ROOT/tao/orbconf.h and commenting out the middle line.

Note that ACE and TAO monitors are event-driven, and thus are
updated whenever the size of what they are monitoring changes.
TAO monitors may also be queried remotely, through the interface
defined in $TAO_ROOT/tao/Monitor/Monitor.idl. In this test
directory, there is a second perl script, called
run_test_with_monitor_queries.pl, that starts the client
and server and passes octet sequences of increasing lengths
identically to run_test.pl. However, in this scenario, we
want to query the monitor of the client's marshaling buffer
size, so the client is passed a command line option that
causes it to expose the object reference corresponding to
the interface Monitor::MC found in Monitor.idl for remote
queries. The script also starts a separate process that makes
the queries. If monitors are disabled, these queries will
simply return 0 for both the size and the timestamp.

*/
