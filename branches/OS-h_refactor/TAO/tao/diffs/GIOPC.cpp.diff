--- orig/GIOPC.cpp	Thu Jan 10 11:45:43 2002
+++ GIOPC.cpp	Thu Jan 10 11:37:59 2002
@@ -1,83 +1,45 @@
-// -*- C++ -*-
-//
-// $Id$
+/* -*- C++ -*- $Id$ */
 
-// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
-// TAO and the TAO IDL Compiler have been developed by:
-//       Center for Distributed Object Computing
-//       Washington University
-//       St. Louis, MO
-//       USA
-//       http://www.cs.wustl.edu/~schmidt/doc-center.html
-// and
-//       Distributed Object Computing Laboratory
-//       University of California at Irvine
-//       Irvine, CA
-//       USA
-//       http://doc.ece.uci.edu/
+// ================================================================
+//
+// = LIBRARY
+//   TAO
 //
-// Information about TAO is available at:
-//     http://www.cs.wustl.edu/~schmidt/TAO.html
+// = FILENAME
+//   GIOPC.h
+//
+// = DESCRIPTION
+//   Generated from GIOP1_2.pidl, that contains a part of the new data
+//   type definitions for GIOP1.2 module.
+//   The code was generated by the IDL compiler and then hand-crafted
+//   to reduce the includes interdependencies.
+//   hand crafted by Balachandran Natarajan <bala@cs.wustl.edu>
+// ================================================================
 
-#include "GIOPC.h"
 
-#include "tao/Stub.h"
-#include "tao/Invocation.h"
-#include "tao/PortableInterceptor.h"
-
-#if TAO_HAS_INTERCEPTORS == 1
-#include "tao/RequestInfo_Util.h"
-#include "tao/ClientRequestInfo.h"
-#include "tao/ClientInterceptorAdapter.h"
-#endif  /* TAO_HAS_INTERCEPTORS == 1 */
-
-#if defined (__BORLANDC__)
-#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
-#endif /* __BORLANDC__ */
+#include "tao/GIOPC.h"
+#include "tao/Environment.h"
+#include "tao/Any.h"
+#include "tao/Typecode.h"
 
 #if !defined (__ACE_INLINE__)
 #include "GIOPC.i"
 #endif /* !defined INLINE */
 
+
 static const CORBA::Long _oc_GIOP_AddressingDisposition[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  43,
-  ACE_NTOHL (0x49444c3a), 
-  ACE_NTOHL (0x6f6d672e), 
-  ACE_NTOHL (0x6f72672f), 
-  ACE_NTOHL (0x47494f50), 
-  ACE_NTOHL (0x2f416464), 
-  ACE_NTOHL (0x72657373), 
-  ACE_NTOHL (0x696e6744), 
-  ACE_NTOHL (0x6973706f), 
-  ACE_NTOHL (0x73697469), 
-  ACE_NTOHL (0x6f6e3a31), 
-  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/AddressingDisposition:1.0
-  22,
-  ACE_NTOHL (0x41646472), 
-  ACE_NTOHL (0x65737369), 
-  ACE_NTOHL (0x6e674469), 
-  ACE_NTOHL (0x73706f73), 
-  ACE_NTOHL (0x6974696f), 
-  ACE_NTOHL (0x6e000000),  // name = AddressingDisposition
+  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x47494f50), ACE_NTOHL (0x2f416464), ACE_NTOHL (0x72657373), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x6973706f), ACE_NTOHL (0x73697469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/AddressingDisposition:1.0
+  22, ACE_NTOHL (0x41646472), ACE_NTOHL (0x65737369), ACE_NTOHL (0x6e674469), ACE_NTOHL (0x73706f73), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e000000),  // name = AddressingDisposition
   CORBA::tk_short,
 
 };
-
-static CORBA::TypeCode _tc_TAO_tc_GIOP_AddressingDisposition (
-    CORBA::tk_alias,
-    sizeof (_oc_GIOP_AddressingDisposition),
-    (char *) &_oc_GIOP_AddressingDisposition,
-    0,
-    sizeof (GIOP::AddressingDisposition)
-  );
-
+static CORBA::TypeCode _tc_TAO_tc_GIOP_AddressingDisposition (CORBA::tk_alias, sizeof (_oc_GIOP_AddressingDisposition), (char *) &_oc_GIOP_AddressingDisposition, 0, sizeof (GIOP::AddressingDisposition));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (GIOP)
-TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AddressingDisposition, &_tc_TAO_tc_GIOP_AddressingDisposition)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AddressingDisposition, &_tc_TAO_tc_GIOP_AddressingDisposition)
 TAO_NAMESPACE_END
-
 TAO_NAMESPACE_TYPE (const CORBA::Short)
 TAO_NAMESPACE_BEGIN (GIOP)
 TAO_NAMESPACE_DEFINE (const CORBA::Short, KeyAddr, 0)
@@ -90,155 +52,45 @@
 TAO_NAMESPACE_BEGIN (GIOP)
 TAO_NAMESPACE_DEFINE (const CORBA::Short, ReferenceAddr, 2)
 TAO_NAMESPACE_END
-static const CORBA::Long _oc_GIOP_Version[] =
-{
-  TAO_ENCAP_BYTE_ORDER, // byte order
-  29,
-  ACE_NTOHL (0x49444c3a), 
-  ACE_NTOHL (0x6f6d672e), 
-  ACE_NTOHL (0x6f72672f), 
-  ACE_NTOHL (0x47494f50), 
-  ACE_NTOHL (0x2f566572), 
-  ACE_NTOHL (0x73696f6e), 
-  ACE_NTOHL (0x3a312e30), 
-  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
-  8,
-  ACE_NTOHL (0x56657273), 
-  ACE_NTOHL (0x696f6e00),  // name = Version
-  2, // member count
-  6,
-  ACE_NTOHL (0x6d616a6f), 
-  ACE_NTOHL (0x72000000),  // name = major
-  CORBA::tk_octet,
-
-  6,
-  ACE_NTOHL (0x6d696e6f), 
-  ACE_NTOHL (0x72000000),  // name = minor
-  CORBA::tk_octet,
-
-};
-
-static CORBA::TypeCode _tc_TAO_tc_GIOP_Version (
-    CORBA::tk_struct,
-    sizeof (_oc_GIOP_Version),
-    (char *) &_oc_GIOP_Version,
-    0,
-    sizeof (GIOP::Version)
-  );
-
-TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
-TAO_NAMESPACE_BEGIN (GIOP)
-TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Version, &_tc_TAO_tc_GIOP_Version)
-TAO_NAMESPACE_END
-
-void GIOP::Version::_tao_any_destructor (void *_tao_void_pointer)
-{
-  Version *tmp = ACE_static_cast (Version*, _tao_void_pointer);
-  delete tmp;
-}
-
 static const CORBA::Long _oc_GIOP_IORAddressingInfo[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  39,
-  ACE_NTOHL (0x49444c3a), 
-  ACE_NTOHL (0x6f6d672e), 
-  ACE_NTOHL (0x6f72672f), 
-  ACE_NTOHL (0x47494f50), 
-  ACE_NTOHL (0x2f494f52), 
-  ACE_NTOHL (0x41646472), 
-  ACE_NTOHL (0x65737369), 
-  ACE_NTOHL (0x6e67496e), 
-  ACE_NTOHL (0x666f3a31), 
-  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/IORAddressingInfo:1.0
-  18,
-  ACE_NTOHL (0x494f5241), 
-  ACE_NTOHL (0x64647265), 
-  ACE_NTOHL (0x7373696e), 
-  ACE_NTOHL (0x67496e66), 
-  ACE_NTOHL (0x6f000000),  // name = IORAddressingInfo
+  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x47494f50), ACE_NTOHL (0x2f494f52), ACE_NTOHL (0x41646472), ACE_NTOHL (0x65737369), ACE_NTOHL (0x6e67496e), ACE_NTOHL (0x666f3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/IORAddressingInfo:1.0
+  18, ACE_NTOHL (0x494f5241), ACE_NTOHL (0x64647265), ACE_NTOHL (0x7373696e), ACE_NTOHL (0x67496e66), ACE_NTOHL (0x6f000000),  // name = IORAddressingInfo
   2, // member count
-  23,
-  ACE_NTOHL (0x73656c65), 
-  ACE_NTOHL (0x63746564), 
-  ACE_NTOHL (0x5f70726f), 
-  ACE_NTOHL (0x66696c65), 
-  ACE_NTOHL (0x5f696e64), 
-  ACE_NTOHL (0x65780000),  // name = selected_profile_index
+  23, ACE_NTOHL (0x73656c65), ACE_NTOHL (0x63746564), ACE_NTOHL (0x5f70726f), ACE_NTOHL (0x66696c65), ACE_NTOHL (0x5f696e64), ACE_NTOHL (0x65780000),  // name = selected_profile_index
   CORBA::tk_ulong,
 
-  4,
-  ACE_NTOHL (0x696f7200),  // name = ior
+  4, ACE_NTOHL (0x696f7200),  // name = ior
   CORBA::tk_struct, // typecode kind
   288, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    24,
-    ACE_NTOHL (0x49444c3a), 
-    ACE_NTOHL (0x6f6d672e), 
-    ACE_NTOHL (0x6f72672f), 
-    ACE_NTOHL (0x494f502f), 
-    ACE_NTOHL (0x494f523a), 
-    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IOP/IOR:1.0
-    4,
-    ACE_NTOHL (0x494f5200),  // name = IOR
+    24, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x494f523a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IOP/IOR:1.0
+    4, ACE_NTOHL (0x494f5200),  // name = IOR
     2, // member count
-    8,
-    ACE_NTOHL (0x74797065), 
-    ACE_NTOHL (0x5f696400),  // name = type_id
-    CORBA::tk_string, 
+    8, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f696400),  // name = type_id
+    CORBA::tk_string,
     0U, // string length
-    9,
-    ACE_NTOHL (0x70726f66), 
-    ACE_NTOHL (0x696c6573), 
-    ACE_NTOHL (0x0),  // name = profiles
+    9, ACE_NTOHL (0x70726f66), ACE_NTOHL (0x696c6573), ACE_NTOHL (0x0),  // name = profiles
     CORBA::tk_sequence, // typecode kind
     200, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
       CORBA::tk_struct, // typecode kind
       184, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
-        34,
-        ACE_NTOHL (0x49444c3a), 
-        ACE_NTOHL (0x6f6d672e), 
-        ACE_NTOHL (0x6f72672f), 
-        ACE_NTOHL (0x494f502f), 
-        ACE_NTOHL (0x54616767), 
-        ACE_NTOHL (0x65645072), 
-        ACE_NTOHL (0x6f66696c), 
-        ACE_NTOHL (0x653a312e), 
-        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/TaggedProfile:1.0
-        14,
-        ACE_NTOHL (0x54616767), 
-        ACE_NTOHL (0x65645072), 
-        ACE_NTOHL (0x6f66696c), 
-        ACE_NTOHL (0x65000000),  // name = TaggedProfile
+        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x54616767), ACE_NTOHL (0x65645072), ACE_NTOHL (0x6f66696c), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/TaggedProfile:1.0
+        14, ACE_NTOHL (0x54616767), ACE_NTOHL (0x65645072), ACE_NTOHL (0x6f66696c), ACE_NTOHL (0x65000000),  // name = TaggedProfile
         2, // member count
-        4,
-        ACE_NTOHL (0x74616700),  // name = tag
+        4, ACE_NTOHL (0x74616700),  // name = tag
         CORBA::tk_alias, // typecode kind for typedefs
         60, // encapsulation length
           TAO_ENCAP_BYTE_ORDER, // byte order
-          30,
-          ACE_NTOHL (0x49444c3a), 
-          ACE_NTOHL (0x6f6d672e), 
-          ACE_NTOHL (0x6f72672f), 
-          ACE_NTOHL (0x494f502f), 
-          ACE_NTOHL (0x50726f66), 
-          ACE_NTOHL (0x696c6549), 
-          ACE_NTOHL (0x643a312e), 
-          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/ProfileId:1.0
-          10,
-          ACE_NTOHL (0x50726f66), 
-          ACE_NTOHL (0x696c6549), 
-          ACE_NTOHL (0x64000000),  // name = ProfileId
+          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x50726f66), ACE_NTOHL (0x696c6549), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/ProfileId:1.0
+          10, ACE_NTOHL (0x50726f66), ACE_NTOHL (0x696c6549), ACE_NTOHL (0x64000000),  // name = ProfileId
           CORBA::tk_ulong,
 
 
-        13,
-        ACE_NTOHL (0x70726f66), 
-        ACE_NTOHL (0x696c655f), 
-        ACE_NTOHL (0x64617461), 
-        ACE_NTOHL (0x0),  // name = profile_data
+        13, ACE_NTOHL (0x70726f66), ACE_NTOHL (0x696c655f), ACE_NTOHL (0x64617461), ACE_NTOHL (0x0),  // name = profile_data
         CORBA::tk_sequence, // typecode kind
         12, // encapsulation length
           TAO_ENCAP_BYTE_ORDER, // byte order
@@ -251,74 +103,12 @@
 
 
 };
-
-static CORBA::TypeCode _tc_TAO_tc_GIOP_IORAddressingInfo (
-    CORBA::tk_struct,
-    sizeof (_oc_GIOP_IORAddressingInfo),
-    (char *) &_oc_GIOP_IORAddressingInfo,
-    0,
-    sizeof (GIOP::IORAddressingInfo)
-  );
-
+static CORBA::TypeCode _tc_TAO_tc_GIOP_IORAddressingInfo (CORBA::tk_struct, sizeof (_oc_GIOP_IORAddressingInfo), (char *) &_oc_GIOP_IORAddressingInfo, 0, sizeof (GIOP::IORAddressingInfo));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (GIOP)
-TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_IORAddressingInfo, &_tc_TAO_tc_GIOP_IORAddressingInfo)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IORAddressingInfo, &_tc_TAO_tc_GIOP_IORAddressingInfo)
 TAO_NAMESPACE_END
 
-void GIOP::IORAddressingInfo::_tao_any_destructor (void *_tao_void_pointer)
-{
-  IORAddressingInfo *tmp = ACE_static_cast (IORAddressingInfo*, _tao_void_pointer);
-  delete tmp;
-}
-
-
-#if !defined (_GIOP_TARGETADDRESS__TAO_SEQ_OCTET_CS_)
-#define _GIOP_TARGETADDRESS__TAO_SEQ_OCTET_CS_
-
-// *************************************************************
-// GIOP::TargetAddress::_tao_seq_Octet
-// *************************************************************
-
-GIOP::TargetAddress::_tao_seq_Octet::_tao_seq_Octet (void)
-{}
-GIOP::TargetAddress::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max) // uses max size
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-TAO_Unbounded_Sequence<CORBA::Octet>
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-TAO_Unbounded_Sequence<CORBA::Octet>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max)
-{}
-GIOP::TargetAddress::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-TAO_Unbounded_Sequence<CORBA::Octet>
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-TAO_Unbounded_Sequence<CORBA::Octet>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (max, length, buffer, release)
-{}
-GIOP::TargetAddress::_tao_seq_Octet::_tao_seq_Octet (const _tao_seq_Octet &seq) // copy ctor
-  : 
-#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
-TAO_Unbounded_Sequence<CORBA::Octet>
-#else /* TAO_USE_SEQUENCE_TEMPLATES */
-TAO_Unbounded_Sequence<CORBA::Octet>
-#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
- (seq)
-{}
-GIOP::TargetAddress::_tao_seq_Octet::~_tao_seq_Octet (void) // dtor
-{}
-void GIOP::TargetAddress::_tao_seq_Octet::_tao_any_destructor (void *_tao_void_pointer)
-{
-  _tao_seq_Octet *tmp = ACE_static_cast (_tao_seq_Octet*, _tao_void_pointer);
-  delete tmp;
-}
-
-
-#endif /* end #if !defined */
-
 // *************************************************************
 // Operations for union GIOP::TargetAddress
 // *************************************************************
@@ -328,58 +118,36 @@
 {
   ACE_OS::memset (&this->disc_, 0, sizeof (this->disc_));
   ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
-  this->disc_ = 0;
 }
 
 // copy constructor
-GIOP::TargetAddress::TargetAddress (const ::GIOP::TargetAddress &u)
+GIOP::TargetAddress::TargetAddress (const GIOP::TargetAddress &u)
 {
   this->disc_ = u.disc_;
   switch (this->disc_)
   {
     case 0:
     {
-      if (u.u_.object_key_ == 0)
-        {
-          this->u_.object_key_ = 0;
-        }
-      else
-        {
-          ACE_NEW (
-              this->u_.object_key_,
-              GIOP::TargetAddress::_tao_seq_Octet (*u.u_.object_key_)
-            );
-        }
+      ACE_NEW (
+          this->u_.object_key_,
+          TAO_ObjectKey (*u.u_.object_key_)
+        );
     }
     break;
     case 1:
     {
-      if (u.u_.profile_ == 0)
-        {
-          this->u_.profile_ = 0;
-        }
-      else
-        {
-          ACE_NEW (
-              this->u_.profile_,
-              IOP::TaggedProfile (*u.u_.profile_)
-            );
-        }
+      ACE_NEW (
+          this->u_.profile_,
+          IOP::TaggedProfile (*u.u_.profile_)
+        );
     }
     break;
     case 2:
     {
-      if (u.u_.ior_ == 0)
-        {
-          this->u_.ior_ = 0;
-        }
-      else
-        {
-          ACE_NEW (
-              this->u_.ior_,
-              GIOP::IORAddressingInfo (*u.u_.ior_)
-            );
-        }
+      ACE_NEW (
+          this->u_.ior_,
+          GIOP::IORAddressingInfo (*u.u_.ior_)
+        );
     }
     break;
     default:
@@ -387,86 +155,45 @@
   }
 }
 
-// destructor
-GIOP::TargetAddress::~TargetAddress (void)
-{
-  // finalize
-  this->_reset (this->disc_, 1);
-}
-
-void GIOP::TargetAddress::_tao_any_destructor (void *_tao_void_pointer)
-{
-  TargetAddress *tmp = ACE_static_cast (TargetAddress*, _tao_void_pointer);
-  delete tmp;
-}
-
 // assignment operator
 GIOP::TargetAddress &
-GIOP::TargetAddress::operator= (const ::GIOP::TargetAddress &u)
+GIOP::TargetAddress::operator= (const GIOP::TargetAddress &u)
 {
-  if (&u == this)
-    {
-      return *this;
-    }
-  
   this->_reset (u.disc_, 0);
   this->disc_ = u.disc_;
-  
   switch (this->disc_)
   {
     case 0:
     {
-      if (u.u_.object_key_ == 0)
-        {
-          this->u_.object_key_ = 0;
-        }
-      else
-        {
-          ACE_NEW_RETURN (
-              this->u_.object_key_,
-              GIOP::TargetAddress::_tao_seq_Octet (*u.u_.object_key_),
-              *this
-            );
-        }
+      ACE_NEW_RETURN (
+          this->u_.object_key_,
+          TAO_ObjectKey (*u.u_.object_key_),
+          *this
+        );
     }
     break;
     case 1:
     {
-      if (u.u_.profile_ == 0)
-        {
-          this->u_.profile_ = 0;
-        }
-      else
-        {
-          ACE_NEW_RETURN (
-              this->u_.profile_,
-              IOP::TaggedProfile (*u.u_.profile_),
-              *this
-            );
-        }
+      ACE_NEW_RETURN (
+          this->u_.profile_,
+          IOP::TaggedProfile (*u.u_.profile_),
+          *this
+        );
     }
     break;
     case 2:
     {
-      if (u.u_.ior_ == 0)
-        {
-          this->u_.ior_ = 0;
-        }
-      else
-        {
-          ACE_NEW_RETURN (
-              this->u_.ior_,
-              GIOP::IORAddressingInfo (*u.u_.ior_),
-              *this
-            );
-        }
+      ACE_NEW_RETURN (
+          this->u_.ior_,
+          GIOP::IORAddressingInfo (*u.u_.ior_),
+          *this
+        );
     }
     break;
     default:
     break;
   }
-  
-  return *this;
+return *this;
 }
 
 // reset method to reset old values of a union
@@ -494,30 +221,14 @@
 static const CORBA::Long _oc_GIOP_TargetAddress[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  35,
-  ACE_NTOHL (0x49444c3a), 
-  ACE_NTOHL (0x6f6d672e), 
-  ACE_NTOHL (0x6f72672f), 
-  ACE_NTOHL (0x47494f50), 
-  ACE_NTOHL (0x2f546172), 
-  ACE_NTOHL (0x67657441), 
-  ACE_NTOHL (0x64647265), 
-  ACE_NTOHL (0x73733a31), 
-  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/TargetAddress:1.0
-  14,
-  ACE_NTOHL (0x54617267), 
-  ACE_NTOHL (0x65744164), 
-  ACE_NTOHL (0x64726573), 
-  ACE_NTOHL (0x73000000),  // name = TargetAddress
+  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x47494f50), ACE_NTOHL (0x2f546172), ACE_NTOHL (0x67657441), ACE_NTOHL (0x64647265), ACE_NTOHL (0x73733a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/TargetAddress:1.0
+  14, ACE_NTOHL (0x54617267), ACE_NTOHL (0x65744164), ACE_NTOHL (0x64726573), ACE_NTOHL (0x73000000),  // name = TargetAddress
   CORBA::tk_short,
 
   -1, // default used index
   3, // member count
   ACE_IDL_NSTOHL (0x0000), // union case label (evaluated value)
-  11,
-  ACE_NTOHL (0x6f626a65), 
-  ACE_NTOHL (0x63745f6b), 
-  ACE_NTOHL (0x65790000),  // name = object_key
+  11, ACE_NTOHL (0x6f626a65), ACE_NTOHL (0x63745f6b), ACE_NTOHL (0x65790000),  // name = object_key
   CORBA::tk_sequence, // typecode kind
   12, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -526,54 +237,23 @@
     0U,
 
   ACE_IDL_NSTOHL (0x0001), // union case label (evaluated value)
-  8,
-  ACE_NTOHL (0x70726f66), 
-  ACE_NTOHL (0x696c6500),  // name = profile
+  8, ACE_NTOHL (0x70726f66), ACE_NTOHL (0x696c6500),  // name = profile
   CORBA::tk_struct, // typecode kind
   184, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    34,
-    ACE_NTOHL (0x49444c3a), 
-    ACE_NTOHL (0x6f6d672e), 
-    ACE_NTOHL (0x6f72672f), 
-    ACE_NTOHL (0x494f502f), 
-    ACE_NTOHL (0x54616767), 
-    ACE_NTOHL (0x65645072), 
-    ACE_NTOHL (0x6f66696c), 
-    ACE_NTOHL (0x653a312e), 
-    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/TaggedProfile:1.0
-    14,
-    ACE_NTOHL (0x54616767), 
-    ACE_NTOHL (0x65645072), 
-    ACE_NTOHL (0x6f66696c), 
-    ACE_NTOHL (0x65000000),  // name = TaggedProfile
+    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x54616767), ACE_NTOHL (0x65645072), ACE_NTOHL (0x6f66696c), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/TaggedProfile:1.0
+    14, ACE_NTOHL (0x54616767), ACE_NTOHL (0x65645072), ACE_NTOHL (0x6f66696c), ACE_NTOHL (0x65000000),  // name = TaggedProfile
     2, // member count
-    4,
-    ACE_NTOHL (0x74616700),  // name = tag
+    4, ACE_NTOHL (0x74616700),  // name = tag
     CORBA::tk_alias, // typecode kind for typedefs
     60, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
-      30,
-      ACE_NTOHL (0x49444c3a), 
-      ACE_NTOHL (0x6f6d672e), 
-      ACE_NTOHL (0x6f72672f), 
-      ACE_NTOHL (0x494f502f), 
-      ACE_NTOHL (0x50726f66), 
-      ACE_NTOHL (0x696c6549), 
-      ACE_NTOHL (0x643a312e), 
-      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/ProfileId:1.0
-      10,
-      ACE_NTOHL (0x50726f66), 
-      ACE_NTOHL (0x696c6549), 
-      ACE_NTOHL (0x64000000),  // name = ProfileId
+      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x50726f66), ACE_NTOHL (0x696c6549), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/ProfileId:1.0
+      10, ACE_NTOHL (0x50726f66), ACE_NTOHL (0x696c6549), ACE_NTOHL (0x64000000),  // name = ProfileId
       CORBA::tk_ulong,
 
 
-    13,
-    ACE_NTOHL (0x70726f66), 
-    ACE_NTOHL (0x696c655f), 
-    ACE_NTOHL (0x64617461), 
-    ACE_NTOHL (0x0),  // name = profile_data
+    13, ACE_NTOHL (0x70726f66), ACE_NTOHL (0x696c655f), ACE_NTOHL (0x64617461), ACE_NTOHL (0x0),  // name = profile_data
     CORBA::tk_sequence, // typecode kind
     12, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
@@ -583,110 +263,46 @@
 
 
   ACE_IDL_NSTOHL (0x0002), // union case label (evaluated value)
-  4,
-  ACE_NTOHL (0x696f7200),  // name = ior
+  4, ACE_NTOHL (0x696f7200),  // name = ior
   CORBA::tk_struct, // typecode kind
   412, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
-    39,
-    ACE_NTOHL (0x49444c3a), 
-    ACE_NTOHL (0x6f6d672e), 
-    ACE_NTOHL (0x6f72672f), 
-    ACE_NTOHL (0x47494f50), 
-    ACE_NTOHL (0x2f494f52), 
-    ACE_NTOHL (0x41646472), 
-    ACE_NTOHL (0x65737369), 
-    ACE_NTOHL (0x6e67496e), 
-    ACE_NTOHL (0x666f3a31), 
-    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/IORAddressingInfo:1.0
-    18,
-    ACE_NTOHL (0x494f5241), 
-    ACE_NTOHL (0x64647265), 
-    ACE_NTOHL (0x7373696e), 
-    ACE_NTOHL (0x67496e66), 
-    ACE_NTOHL (0x6f000000),  // name = IORAddressingInfo
+    39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x47494f50), ACE_NTOHL (0x2f494f52), ACE_NTOHL (0x41646472), ACE_NTOHL (0x65737369), ACE_NTOHL (0x6e67496e), ACE_NTOHL (0x666f3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/GIOP/IORAddressingInfo:1.0
+    18, ACE_NTOHL (0x494f5241), ACE_NTOHL (0x64647265), ACE_NTOHL (0x7373696e), ACE_NTOHL (0x67496e66), ACE_NTOHL (0x6f000000),  // name = IORAddressingInfo
     2, // member count
-    23,
-    ACE_NTOHL (0x73656c65), 
-    ACE_NTOHL (0x63746564), 
-    ACE_NTOHL (0x5f70726f), 
-    ACE_NTOHL (0x66696c65), 
-    ACE_NTOHL (0x5f696e64), 
-    ACE_NTOHL (0x65780000),  // name = selected_profile_index
+    23, ACE_NTOHL (0x73656c65), ACE_NTOHL (0x63746564), ACE_NTOHL (0x5f70726f), ACE_NTOHL (0x66696c65), ACE_NTOHL (0x5f696e64), ACE_NTOHL (0x65780000),  // name = selected_profile_index
     CORBA::tk_ulong,
 
-    4,
-    ACE_NTOHL (0x696f7200),  // name = ior
+    4, ACE_NTOHL (0x696f7200),  // name = ior
     CORBA::tk_struct, // typecode kind
     288, // encapsulation length
       TAO_ENCAP_BYTE_ORDER, // byte order
-      24,
-      ACE_NTOHL (0x49444c3a), 
-      ACE_NTOHL (0x6f6d672e), 
-      ACE_NTOHL (0x6f72672f), 
-      ACE_NTOHL (0x494f502f), 
-      ACE_NTOHL (0x494f523a), 
-      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IOP/IOR:1.0
-      4,
-      ACE_NTOHL (0x494f5200),  // name = IOR
+      24, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x494f523a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IOP/IOR:1.0
+      4, ACE_NTOHL (0x494f5200),  // name = IOR
       2, // member count
-      8,
-      ACE_NTOHL (0x74797065), 
-      ACE_NTOHL (0x5f696400),  // name = type_id
-      CORBA::tk_string, 
+      8, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f696400),  // name = type_id
+      CORBA::tk_string,
       0U, // string length
-      9,
-      ACE_NTOHL (0x70726f66), 
-      ACE_NTOHL (0x696c6573), 
-      ACE_NTOHL (0x0),  // name = profiles
+      9, ACE_NTOHL (0x70726f66), ACE_NTOHL (0x696c6573), ACE_NTOHL (0x0),  // name = profiles
       CORBA::tk_sequence, // typecode kind
       200, // encapsulation length
         TAO_ENCAP_BYTE_ORDER, // byte order
         CORBA::tk_struct, // typecode kind
         184, // encapsulation length
           TAO_ENCAP_BYTE_ORDER, // byte order
-          34,
-          ACE_NTOHL (0x49444c3a), 
-          ACE_NTOHL (0x6f6d672e), 
-          ACE_NTOHL (0x6f72672f), 
-          ACE_NTOHL (0x494f502f), 
-          ACE_NTOHL (0x54616767), 
-          ACE_NTOHL (0x65645072), 
-          ACE_NTOHL (0x6f66696c), 
-          ACE_NTOHL (0x653a312e), 
-          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/TaggedProfile:1.0
-          14,
-          ACE_NTOHL (0x54616767), 
-          ACE_NTOHL (0x65645072), 
-          ACE_NTOHL (0x6f66696c), 
-          ACE_NTOHL (0x65000000),  // name = TaggedProfile
+          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x54616767), ACE_NTOHL (0x65645072), ACE_NTOHL (0x6f66696c), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/TaggedProfile:1.0
+          14, ACE_NTOHL (0x54616767), ACE_NTOHL (0x65645072), ACE_NTOHL (0x6f66696c), ACE_NTOHL (0x65000000),  // name = TaggedProfile
           2, // member count
-          4,
-          ACE_NTOHL (0x74616700),  // name = tag
+          4, ACE_NTOHL (0x74616700),  // name = tag
           CORBA::tk_alias, // typecode kind for typedefs
           60, // encapsulation length
             TAO_ENCAP_BYTE_ORDER, // byte order
-            30,
-            ACE_NTOHL (0x49444c3a), 
-            ACE_NTOHL (0x6f6d672e), 
-            ACE_NTOHL (0x6f72672f), 
-            ACE_NTOHL (0x494f502f), 
-            ACE_NTOHL (0x50726f66), 
-            ACE_NTOHL (0x696c6549), 
-            ACE_NTOHL (0x643a312e), 
-            ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/ProfileId:1.0
-            10,
-            ACE_NTOHL (0x50726f66), 
-            ACE_NTOHL (0x696c6549), 
-            ACE_NTOHL (0x64000000),  // name = ProfileId
+            30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x494f502f), ACE_NTOHL (0x50726f66), ACE_NTOHL (0x696c6549), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IOP/ProfileId:1.0
+            10, ACE_NTOHL (0x50726f66), ACE_NTOHL (0x696c6549), ACE_NTOHL (0x64000000),  // name = ProfileId
             CORBA::tk_ulong,
 
 
-          13,
-          ACE_NTOHL (0x70726f66), 
-          ACE_NTOHL (0x696c655f), 
-          ACE_NTOHL (0x64617461), 
-          ACE_NTOHL (0x0),  // name = profile_data
+          13, ACE_NTOHL (0x70726f66), ACE_NTOHL (0x696c655f), ACE_NTOHL (0x64617461), ACE_NTOHL (0x0),  // name = profile_data
           CORBA::tk_sequence, // typecode kind
           12, // encapsulation length
             TAO_ENCAP_BYTE_ORDER, // byte order
@@ -700,101 +316,59 @@
 
 
 };
+static CORBA::TypeCode _tc_TAO_tc_GIOP_TargetAddress (CORBA::tk_union, sizeof (_oc_GIOP_TargetAddress), (char *) &_oc_GIOP_TargetAddress, 0, sizeof (GIOP::TargetAddress));
+TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
+TAO_NAMESPACE_BEGIN (GIOP)
+TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TargetAddress, &_tc_TAO_tc_GIOP_TargetAddress)
+TAO_NAMESPACE_END
+
+static const CORBA::Long _oc_GIOP_Version[] =
+{
+  TAO_ENCAP_BYTE_ORDER, // byte order
+  29,
+  ACE_NTOHL (0x49444c3a),
+  ACE_NTOHL (0x6f6d672e),
+  ACE_NTOHL (0x6f72672f),
+  ACE_NTOHL (0x47494f50),
+  ACE_NTOHL (0x2f566572),
+  ACE_NTOHL (0x73696f6e),
+  ACE_NTOHL (0x3a312e30),
+  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/GIOP/Version:1.0
+  8,
+  ACE_NTOHL (0x56657273),
+  ACE_NTOHL (0x696f6e00),  // name = Version
+  2, // member count
+  6,
+  ACE_NTOHL (0x6d616a6f),
+  ACE_NTOHL (0x72000000),  // name = major
+  CORBA::tk_octet,
+
+  6,
+  ACE_NTOHL (0x6d696e6f),
+  ACE_NTOHL (0x72000000),  // name = minor
+  CORBA::tk_octet,
+
+};
 
-static CORBA::TypeCode _tc_TAO_tc_GIOP_TargetAddress (
-    CORBA::tk_union,
-    sizeof (_oc_GIOP_TargetAddress),
-    (char *) &_oc_GIOP_TargetAddress,
+static CORBA::TypeCode _tc_TAO_tc_GIOP_Version (
+    CORBA::tk_struct,
+    sizeof (_oc_GIOP_Version),
+    (char *) &_oc_GIOP_Version,
     0,
-    sizeof (GIOP::TargetAddress)
+    sizeof (GIOP::Version)
   );
 
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (GIOP)
-TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_TargetAddress, &_tc_TAO_tc_GIOP_TargetAddress)
+TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Version, &_tc_TAO_tc_GIOP_Version)
 TAO_NAMESPACE_END
 
-void operator<<= (CORBA::Any &_tao_any, const GIOP::Version &_tao_elem) // copying
-{
-  TAO_OutputCDR stream;
-  stream << _tao_elem;
-  _tao_any._tao_replace (
-      GIOP::_tc_Version,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin ()
-    );
-}
-
-void operator<<= (CORBA::Any &_tao_any, GIOP::Version *_tao_elem) // non copying
-{
-  TAO_OutputCDR stream;
-  stream << *_tao_elem;
-  _tao_any._tao_replace (
-      GIOP::_tc_Version,
-      TAO_ENCAP_BYTE_ORDER,
-      stream.begin (),
-      1,
-      _tao_elem,
-      GIOP::Version::_tao_any_destructor
-    );
-}
-
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, GIOP::Version *&_tao_elem)
-{
-  return _tao_any >>= ACE_const_cast(const GIOP::Version*&,_tao_elem);
-}
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const GIOP::Version *&_tao_elem)
+void
+GIOP::IORAddressingInfo::_tao_any_destructor (void *x)
 {
-  _tao_elem = 0;
-  ACE_TRY_NEW_ENV
-  {
-    CORBA::TypeCode_var type = _tao_any.type ();
-    
-    CORBA::Boolean result = type->equivalent (GIOP::_tc_Version TAO_ENV_ARG_PARAMETER);
-    ACE_TRY_CHECK;
-    
-    if (!result)
-      return 0; // not equivalent
-    
-    if (_tao_any.any_owns_data ())
-    {
-      _tao_elem = ACE_static_cast(
-          const GIOP::Version*,
-          _tao_any.value ()
-        );
-      return 1;
-    }
-    else
-    {
-      GIOP::Version *tmp;
-      ACE_NEW_RETURN (tmp, GIOP::Version, 0);
-      TAO_InputCDR stream (
-          _tao_any._tao_get_cdr (),
-          _tao_any._tao_byte_order ()
-        );
-      if (stream >> *tmp)
-      {
-        ((CORBA::Any *)&_tao_any)->_tao_replace (
-            GIOP::_tc_Version,
-            1,
-            ACE_static_cast (void *, tmp),
-            GIOP::Version::_tao_any_destructor
-          );
-        _tao_elem = tmp;
-        return 1;
-      }
-      else
-      {
-        delete tmp;
-      }
-    }
-  }
-  ACE_CATCHANY
-  {
-  }
-  ACE_ENDTRY;
-  return 0;
+  GIOP::IORAddressingInfo *tmp = ACE_static_cast (GIOP::IORAddressingInfo*,x);
+  delete tmp;
 }
 
 void operator<<= (CORBA::Any &_tao_any, const GIOP::IORAddressingInfo &_tao_elem) // copying
@@ -824,62 +398,70 @@
 
 CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, GIOP::IORAddressingInfo *&_tao_elem)
 {
-  return _tao_any >>= ACE_const_cast(const GIOP::IORAddressingInfo*&,_tao_elem);
-}
-
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const GIOP::IORAddressingInfo *&_tao_elem)
-{
-  _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    
-    CORBA::Boolean result = type->equivalent (GIOP::_tc_IORAddressingInfo TAO_ENV_ARG_PARAMETER);
+    CORBA::Boolean result =
+      type->equivalent (GIOP::_tc_IORAddressingInfo TAO_ENV_ARG_PARAMETER);
     ACE_TRY_CHECK;
-    
+
     if (!result)
-      return 0; // not equivalent
-    
+      {
+        _tao_elem = 0;
+        return 0;
+      }
+
     if (_tao_any.any_owns_data ())
     {
-      _tao_elem = ACE_static_cast(
-          const GIOP::IORAddressingInfo*,
-          _tao_any.value ()
-        );
+      _tao_elem = (GIOP::IORAddressingInfo *)_tao_any.value ();
       return 1;
     }
     else
     {
-      GIOP::IORAddressingInfo *tmp;
-      ACE_NEW_RETURN (tmp, GIOP::IORAddressingInfo, 0);
+      ACE_NEW_RETURN (_tao_elem, GIOP::IORAddressingInfo, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
         );
-      if (stream >> *tmp)
+      if (stream >> *_tao_elem)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
             GIOP::_tc_IORAddressingInfo,
             1,
-            ACE_static_cast (void *, tmp),
+            ACE_reinterpret_cast (void *, _tao_elem),
             GIOP::IORAddressingInfo::_tao_any_destructor
           );
-        _tao_elem = tmp;
         return 1;
       }
       else
       {
-        delete tmp;
+        delete _tao_elem;
+        _tao_elem = 0;
       }
     }
   }
   ACE_CATCHANY
   {
+    delete _tao_elem;
+    _tao_elem = 0;
+    return 0;
   }
   ACE_ENDTRY;
   return 0;
 }
 
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const GIOP::IORAddressingInfo *&_tao_elem)
+{
+  return _tao_any >>= ACE_const_cast(GIOP::IORAddressingInfo*&,_tao_elem);
+}
+
+void
+GIOP::TargetAddress::_tao_any_destructor (void *x)
+{
+  GIOP::TargetAddress *tmp = ACE_static_cast (GIOP::TargetAddress*,x);
+  delete tmp;
+}
+
 void operator<<= (
     CORBA::Any &_tao_any,
     const GIOP::TargetAddress &_tao_elem
@@ -887,13 +469,13 @@
 {
   TAO_OutputCDR stream;
   if (stream << _tao_elem)
-  {
-    _tao_any._tao_replace (
-        GIOP::_tc_TargetAddress,
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin ()
-      );
-  }
+    {
+      _tao_any._tao_replace (
+          GIOP::_tc_TargetAddress,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin ()
+        );
+    }
 }
 
 void operator<<= (
@@ -903,16 +485,16 @@
 {
   TAO_OutputCDR stream;
   if (stream << *_tao_elem)
-  {
-    _tao_any._tao_replace (
-        GIOP::_tc_TargetAddress,
-        TAO_ENCAP_BYTE_ORDER,
-        stream.begin (),
-        1,
-        _tao_elem,
-        GIOP::TargetAddress::_tao_any_destructor
-      );
-  }
+    {
+      _tao_any._tao_replace (
+          GIOP::_tc_TargetAddress,
+          TAO_ENCAP_BYTE_ORDER,
+          stream.begin (),
+          1,
+          _tao_elem,
+          GIOP::IORAddressingInfo::_tao_any_destructor
+        );
+    }
 }
 
 CORBA::Boolean operator>>= (
@@ -920,145 +502,62 @@
     GIOP::TargetAddress *&_tao_elem
   )
 {
-  return _tao_any >>= ACE_const_cast(
-      const GIOP::TargetAddress*&,
-      _tao_elem
-    );
-}
-
-CORBA::Boolean operator>>= (
-    const CORBA::Any &_tao_any,
-    const GIOP::TargetAddress *&_tao_elem
-  )
-{
-  _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    
-    CORBA::Boolean result = type->equivalent (GIOP::_tc_TargetAddress TAO_ENV_ARG_PARAMETER);
+    CORBA::Boolean result =
+      type->equivalent (GIOP::_tc_TargetAddress TAO_ENV_ARG_PARAMETER);
     ACE_TRY_CHECK;
-    
+
     if (!result)
-      return 0; // not equivalent
-    
+      {
+        _tao_elem = 0;
+        return 0;
+      }
+
     if (_tao_any.any_owns_data ())
     {
-      _tao_elem = ACE_static_cast(
-          const GIOP::TargetAddress*,
-          _tao_any.value ()
-        );
+      _tao_elem = (GIOP::TargetAddress *)_tao_any.value ();
       return 1;
     }
     else
     {
-      GIOP::TargetAddress *tmp;
-      ACE_NEW_RETURN (tmp, GIOP::TargetAddress, 0);
+      ACE_NEW_RETURN (_tao_elem, GIOP::TargetAddress, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
         );
-      
-      if (stream >> *tmp)
+
+      if (stream >> *_tao_elem)
       {
         ((CORBA::Any *)&_tao_any)->_tao_replace (
             GIOP::_tc_TargetAddress,
             1,
-            ACE_static_cast (void *, tmp),
-            GIOP::TargetAddress::_tao_any_destructor
+            ACE_reinterpret_cast (void *, _tao_elem),
+            GIOP::IORAddressingInfo::_tao_any_destructor
           );
-        _tao_elem = tmp;
         return 1;
       }
       else
       {
-        delete  tmp;
+        delete  _tao_elem;
+        _tao_elem = 0;
       }
     }
   }
   ACE_CATCHANY
   {
+    delete _tao_elem;
+    _tao_elem = 0;
   }
   ACE_ENDTRY;
   return 0;
 }
 
-
-#if !defined _TAO_CDR_OP_GIOP_TargetAddress__tao_seq_Octet_CPP_
-#define _TAO_CDR_OP_GIOP_TargetAddress__tao_seq_Octet_CPP_
-
-CORBA::Boolean operator<< (
-    TAO_OutputCDR &strm,
-    const GIOP::TargetAddress::_tao_seq_Octet &_tao_sequence
-  )
-{
-  if (strm << _tao_sequence.length ())
-  {
-    // encode all elements
-    
-#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
-    {
-      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
-        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (GIOP::TargetAddress::_tao_seq_Octet *)&_tao_sequence);
-      if (oseq->mb ())
-        return strm.write_octet_array_mb (oseq->mb ());
-      else
-        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-    }
-    
-#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
-    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-  
-#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
-  }
-  return 0; // error
-}
-
-CORBA::Boolean operator>> (
-    TAO_InputCDR &strm,
-    GIOP::TargetAddress::_tao_seq_Octet &_tao_sequence
+CORBA::Boolean operator>>= (
+    const CORBA::Any &_tao_any,
+    const GIOP::TargetAddress *&_tao_elem
   )
 {
-  CORBA::ULong _tao_seq_len;
-  if (strm >> _tao_seq_len)
-  {
-    // set the length of the sequence
-    _tao_sequence.length (_tao_seq_len);
-    // If length is 0 we return true.
-    if (0 >= _tao_seq_len) 
-      return 1;
-    // Add a check to the length of the sequence
-    // to make sure it does not exceed the length
-    // of the stream. (See bug 58.)
-    if (_tao_seq_len > strm.length())
-      return 0;
-    // retrieve all the elements
-    
-#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
-    if (ACE_BIT_DISABLED (strm.start ()->flags (),
-    ACE_Message_Block::DONT_DELETE))
-    {
-      TAO_ORB_Core* orb_core = strm.orb_core ();
-      if (orb_core != 0 &&
-      strm.orb_core ()->resource_factory ()->
-      input_cdr_allocator_type_locked () == 1)
-      {
-        TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
-          ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
-        oseq->replace (_tao_seq_len, strm.start ());
-        oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
-        strm.skip_bytes (_tao_seq_len);
-        return 1;
-      }
-    }
-    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
-#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
-    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
-  
-#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
-  }
-  return 0; // error
+  return _tao_any >>= ACE_const_cast (GIOP::TargetAddress*&,_tao_elem);
 }
-
-#endif /* _TAO_CDR_OP_GIOP_TargetAddress__tao_seq_Octet_CPP_ */
-
