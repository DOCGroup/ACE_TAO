/* -*- C++ -*- */
// $Id$


// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/orbconf.h"

#if (TAO_HAS_CORBA_MESSAGING == 1)

#include "tao/MessagingS.h"
#include "tao/POA_CORBA.h"
#include "tao/Operation_Table.h"
#include "tao/Server_Request.h"
#include "tao/Stub.h"
#include "tao/ORB_Core.h"
#include "tao/Object_Adapter.h"

#if !defined (__ACE_INLINE__)
#include "tao/MessagingS.i"
#endif /* !defined INLINE */

ACE_RCSID(tao, MessagingS, "$Id$")

  POA_Messaging::RebindPolicy::RebindPolicy (void)
{
}

POA_Messaging::RebindPolicy::RebindPolicy (const RebindPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RebindPolicy::~RebindPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RebindPolicy::_is_a (
                                                   const char* value,
                                                   CORBA::Environment &ACE_TRY_ENV
                                                   )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RebindPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RebindPolicy::_downcast (
                                              const char* logical_type_id
                                              )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RebindPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RebindPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RebindPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RebindPolicy:1.0";
}

POA_Messaging::_tao_collocated_RebindPolicy::_tao_collocated_RebindPolicy (
                                                                           POA_Messaging::RebindPolicy_ptr  servant,
                                                                           TAO_Stub *stub
                                                                           )
  : ACE_NESTED_CLASS (Messaging,RebindPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RebindPolicy_ptr POA_Messaging::_tao_collocated_RebindPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RebindPolicy::_is_a (
                                                                   const char* logical_type_id,
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

Messaging::RebindMode POA_Messaging::_tao_collocated_RebindPolicy::rebind_mode  (
                                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                                 )
{
  return this->servant_->rebind_mode (
                                      ACE_TRY_ENV
                                      );
}


Messaging::RebindPolicy*
POA_Messaging::RebindPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RebindPolicy *retval =
    Messaging::RebindPolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_RebindPolicy (this,
                                                               stub),
                  Messaging::RebindPolicy::_nil ());

  return retval;
}

void
POA_Messaging::RebindPolicy::_dispatch (
                                        CORBA::ServerRequest &_tao_request,
                                        void *_tao_context,
                                        CORBA::Environment &ACE_TRY_ENV
                                        )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::SyncScopePolicy::SyncScopePolicy (void)
{
}

POA_Messaging::SyncScopePolicy::SyncScopePolicy (const SyncScopePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::SyncScopePolicy::~SyncScopePolicy (void)
{
}

CORBA::Boolean POA_Messaging::SyncScopePolicy::_is_a (
                                                      const char* value,
                                                      CORBA::Environment &ACE_TRY_ENV
                                                      )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/SyncScopePolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::SyncScopePolicy::_downcast (
                                                 const char* logical_type_id
                                                 )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/SyncScopePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::SyncScopePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::SyncScopePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/SyncScopePolicy:1.0";
}

POA_Messaging::_tao_collocated_SyncScopePolicy::_tao_collocated_SyncScopePolicy (
                                                                                 POA_Messaging::SyncScopePolicy_ptr  servant,
                                                                                 TAO_Stub *stub
                                                                                 )
  : ACE_NESTED_CLASS (Messaging,SyncScopePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::SyncScopePolicy_ptr POA_Messaging::_tao_collocated_SyncScopePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_SyncScopePolicy::_is_a (
                                                                      const char* logical_type_id,
                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                      )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

Messaging::SyncScope POA_Messaging::_tao_collocated_SyncScopePolicy::synchronization  (CORBA::Environment &ACE_TRY_ENV)
{
  return this->servant_->synchronization (ACE_TRY_ENV);
}

Messaging::SyncScope POA_Messaging::_tao_collocated_SyncScopePolicy::synchronization  (void)
{
  return this->servant_->synchronization ();
}


Messaging::SyncScopePolicy*
POA_Messaging::SyncScopePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::SyncScopePolicy *retval =
    Messaging::SyncScopePolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_SyncScopePolicy (this,
                                                                  stub),
                  Messaging::SyncScopePolicy::_nil ());

  return retval;
}

void
POA_Messaging::SyncScopePolicy::_dispatch (
                                           CORBA::ServerRequest &_tao_request,
                                           void *_tao_context,
                                           CORBA::Environment &ACE_TRY_ENV
                                           )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::RequestPriorityPolicy::RequestPriorityPolicy (void)
{
}

POA_Messaging::RequestPriorityPolicy::RequestPriorityPolicy (const RequestPriorityPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RequestPriorityPolicy::~RequestPriorityPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RequestPriorityPolicy::_is_a (
                                                            const char* value,
                                                            CORBA::Environment &ACE_TRY_ENV
                                                            )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestPriorityPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RequestPriorityPolicy::_downcast (
                                                       const char* logical_type_id
                                                       )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RequestPriorityPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RequestPriorityPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RequestPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestPriorityPolicy:1.0";
}

POA_Messaging::_tao_collocated_RequestPriorityPolicy::_tao_collocated_RequestPriorityPolicy (
                                                                                             POA_Messaging::RequestPriorityPolicy_ptr  servant,
                                                                                             TAO_Stub *stub
                                                                                             )
  : ACE_NESTED_CLASS (Messaging,RequestPriorityPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RequestPriorityPolicy_ptr POA_Messaging::_tao_collocated_RequestPriorityPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RequestPriorityPolicy::_is_a (
                                                                            const char* logical_type_id,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

Messaging::PriorityRange POA_Messaging::_tao_collocated_RequestPriorityPolicy::priority_range  (
                                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                                )
{
  return this->servant_->priority_range (
                                         ACE_TRY_ENV
                                         );
}


Messaging::RequestPriorityPolicy*
POA_Messaging::RequestPriorityPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RequestPriorityPolicy *retval =
    Messaging::RequestPriorityPolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_RequestPriorityPolicy (this,
                                                                        stub),
                  Messaging::RequestPriorityPolicy::_nil ());

  return retval;
}

void
POA_Messaging::RequestPriorityPolicy::_dispatch (
                                                 CORBA::ServerRequest &_tao_request,
                                                 void *_tao_context,
                                                 CORBA::Environment &ACE_TRY_ENV
                                                 )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::ReplyPriorityPolicy::ReplyPriorityPolicy (void)
{
}

POA_Messaging::ReplyPriorityPolicy::ReplyPriorityPolicy (const ReplyPriorityPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyPriorityPolicy::~ReplyPriorityPolicy (void)
{
}

CORBA::Boolean POA_Messaging::ReplyPriorityPolicy::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyPriorityPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::ReplyPriorityPolicy::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyPriorityPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyPriorityPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::ReplyPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyPriorityPolicy:1.0";
}

POA_Messaging::_tao_collocated_ReplyPriorityPolicy::_tao_collocated_ReplyPriorityPolicy (
                                                                                         POA_Messaging::ReplyPriorityPolicy_ptr  servant,
                                                                                         TAO_Stub *stub
                                                                                         )
  : ACE_NESTED_CLASS (Messaging,ReplyPriorityPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyPriorityPolicy_ptr POA_Messaging::_tao_collocated_ReplyPriorityPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyPriorityPolicy::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

Messaging::PriorityRange POA_Messaging::_tao_collocated_ReplyPriorityPolicy::priority_range  (
                                                                                              CORBA::Environment &ACE_TRY_ENV
                                                                                              )
{
  return this->servant_->priority_range (
                                         ACE_TRY_ENV
                                         );
}


Messaging::ReplyPriorityPolicy*
POA_Messaging::ReplyPriorityPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::ReplyPriorityPolicy *retval =
    Messaging::ReplyPriorityPolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_ReplyPriorityPolicy (this,
                                                                      stub),
                  Messaging::ReplyPriorityPolicy::_nil ());

  return retval;
}

void
POA_Messaging::ReplyPriorityPolicy::_dispatch (
                                               CORBA::ServerRequest &_tao_request,
                                               void *_tao_context,
                                               CORBA::Environment &ACE_TRY_ENV
                                               )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::RequestStartTimePolicy::RequestStartTimePolicy (void)
{
}

POA_Messaging::RequestStartTimePolicy::RequestStartTimePolicy (const RequestStartTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RequestStartTimePolicy::~RequestStartTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::RequestStartTimePolicy::_is_a (
                                                             const char* value,
                                                             CORBA::Environment &ACE_TRY_ENV
                                                             )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestStartTimePolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RequestStartTimePolicy::_downcast (
                                                        const char* logical_type_id
                                                        )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RequestStartTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RequestStartTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RequestStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestStartTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_RequestStartTimePolicy::_tao_collocated_RequestStartTimePolicy (
                                                                                               POA_Messaging::RequestStartTimePolicy_ptr  servant,
                                                                                               TAO_Stub *stub
                                                                                               )
  : ACE_NESTED_CLASS (Messaging,RequestStartTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RequestStartTimePolicy_ptr POA_Messaging::_tao_collocated_RequestStartTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RequestStartTimePolicy::_is_a (
                                                                             const char* logical_type_id,
                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                             )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_RequestStartTimePolicy::start_time  (
                                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                                   )
{
  return this->servant_->start_time (
                                     ACE_TRY_ENV
                                     );
}


Messaging::RequestStartTimePolicy*
POA_Messaging::RequestStartTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RequestStartTimePolicy *retval =
    Messaging::RequestStartTimePolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_RequestStartTimePolicy (this,
                                                                         stub),
                  Messaging::RequestStartTimePolicy::_nil ());

  return retval;
}

void
POA_Messaging::RequestStartTimePolicy::_dispatch (
                                                  CORBA::ServerRequest &_tao_request,
                                                  void *_tao_context,
                                                  CORBA::Environment &ACE_TRY_ENV
                                                  )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::RequestEndTimePolicy::RequestEndTimePolicy (void)
{
}

POA_Messaging::RequestEndTimePolicy::RequestEndTimePolicy (const RequestEndTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RequestEndTimePolicy::~RequestEndTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::RequestEndTimePolicy::_is_a (
                                                           const char* value,
                                                           CORBA::Environment &ACE_TRY_ENV
                                                           )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestEndTimePolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RequestEndTimePolicy::_downcast (
                                                      const char* logical_type_id
                                                      )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RequestEndTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RequestEndTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RequestEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestEndTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_RequestEndTimePolicy::_tao_collocated_RequestEndTimePolicy (
                                                                                           POA_Messaging::RequestEndTimePolicy_ptr  servant,
                                                                                           TAO_Stub *stub
                                                                                           )
  : ACE_NESTED_CLASS (Messaging,RequestEndTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RequestEndTimePolicy_ptr POA_Messaging::_tao_collocated_RequestEndTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RequestEndTimePolicy::_is_a (
                                                                           const char* logical_type_id,
                                                                           CORBA::Environment &ACE_TRY_ENV
                                                                           )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_RequestEndTimePolicy::end_time  (
                                                                               CORBA::Environment &ACE_TRY_ENV
                                                                               )
{
  return this->servant_->end_time (
                                   ACE_TRY_ENV
                                   );
}


Messaging::RequestEndTimePolicy*
POA_Messaging::RequestEndTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RequestEndTimePolicy *retval =
    Messaging::RequestEndTimePolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_RequestEndTimePolicy (this,
                                                                       stub),
                  Messaging::RequestEndTimePolicy::_nil ());

  return retval;
}

void
POA_Messaging::RequestEndTimePolicy::_dispatch (
                                                CORBA::ServerRequest &_tao_request,
                                                void *_tao_context,
                                                CORBA::Environment &ACE_TRY_ENV
                                                )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::ReplyStartTimePolicy::ReplyStartTimePolicy (void)
{
}

POA_Messaging::ReplyStartTimePolicy::ReplyStartTimePolicy (const ReplyStartTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyStartTimePolicy::~ReplyStartTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::ReplyStartTimePolicy::_is_a (
                                                           const char* value,
                                                           CORBA::Environment &ACE_TRY_ENV
                                                           )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyStartTimePolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::ReplyStartTimePolicy::_downcast (
                                                      const char* logical_type_id
                                                      )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyStartTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyStartTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::ReplyStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyStartTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_ReplyStartTimePolicy::_tao_collocated_ReplyStartTimePolicy (
                                                                                           POA_Messaging::ReplyStartTimePolicy_ptr  servant,
                                                                                           TAO_Stub *stub
                                                                                           )
  : ACE_NESTED_CLASS (Messaging,ReplyStartTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyStartTimePolicy_ptr POA_Messaging::_tao_collocated_ReplyStartTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyStartTimePolicy::_is_a (
                                                                           const char* logical_type_id,
                                                                           CORBA::Environment &ACE_TRY_ENV
                                                                           )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_ReplyStartTimePolicy::start_time  (
                                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                                 )
{
  return this->servant_->start_time (
                                     ACE_TRY_ENV
                                     );
}


Messaging::ReplyStartTimePolicy*
POA_Messaging::ReplyStartTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::ReplyStartTimePolicy *retval =
    Messaging::ReplyStartTimePolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_ReplyStartTimePolicy (this,
                                                                       stub),
                  Messaging::ReplyStartTimePolicy::_nil ());

  return retval;
}

void
POA_Messaging::ReplyStartTimePolicy::_dispatch (
                                                CORBA::ServerRequest &_tao_request,
                                                void *_tao_context,
                                                CORBA::Environment &ACE_TRY_ENV
                                                )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::ReplyEndTimePolicy::ReplyEndTimePolicy (void)
{
}

POA_Messaging::ReplyEndTimePolicy::ReplyEndTimePolicy (const ReplyEndTimePolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::ReplyEndTimePolicy::~ReplyEndTimePolicy (void)
{
}

CORBA::Boolean POA_Messaging::ReplyEndTimePolicy::_is_a (
                                                         const char* value,
                                                         CORBA::Environment &ACE_TRY_ENV
                                                         )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyEndTimePolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::ReplyEndTimePolicy::_downcast (
                                                    const char* logical_type_id
                                                    )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyEndTimePolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyEndTimePolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::ReplyEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyEndTimePolicy:1.0";
}

POA_Messaging::_tao_collocated_ReplyEndTimePolicy::_tao_collocated_ReplyEndTimePolicy (
                                                                                       POA_Messaging::ReplyEndTimePolicy_ptr  servant,
                                                                                       TAO_Stub *stub
                                                                                       )
  : ACE_NESTED_CLASS (Messaging,ReplyEndTimePolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::ReplyEndTimePolicy_ptr POA_Messaging::_tao_collocated_ReplyEndTimePolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_ReplyEndTimePolicy::_is_a (
                                                                         const char* logical_type_id,
                                                                         CORBA::Environment &ACE_TRY_ENV
                                                                         )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

TimeBase::UtcT POA_Messaging::_tao_collocated_ReplyEndTimePolicy::end_time  (
                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                             )
{
  return this->servant_->end_time (
                                   ACE_TRY_ENV
                                   );
}


Messaging::ReplyEndTimePolicy*
POA_Messaging::ReplyEndTimePolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::ReplyEndTimePolicy *retval =
    Messaging::ReplyEndTimePolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_Messaging::_tao_collocated_ReplyEndTimePolicy (this,
                                                                     stub),
                  Messaging::ReplyEndTimePolicy::_nil ());

  return retval;
}

void
POA_Messaging::ReplyEndTimePolicy::_dispatch (
                                              CORBA::ServerRequest &_tao_request,
                                              void *_tao_context,
                                              CORBA::Environment &ACE_TRY_ENV
                                              )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::RelativeRequestTimeoutPolicy::RelativeRequestTimeoutPolicy (void)
{
}

POA_Messaging::RelativeRequestTimeoutPolicy::RelativeRequestTimeoutPolicy (const RelativeRequestTimeoutPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RelativeRequestTimeoutPolicy::~RelativeRequestTimeoutPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RelativeRequestTimeoutPolicy::_is_a (
                                                                   const char* value,
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RelativeRequestTimeoutPolicy::_downcast (
                                                              const char* logical_type_id
                                                              )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RelativeRequestTimeoutPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RelativeRequestTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0";
}

POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::_tao_collocated_RelativeRequestTimeoutPolicy (
                                                                                                           POA_Messaging::RelativeRequestTimeoutPolicy_ptr  servant,
                                                                                                           TAO_Stub *stub
                                                                                                           )
  : ACE_NESTED_CLASS (Messaging,RelativeRequestTimeoutPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RelativeRequestTimeoutPolicy_ptr POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::_is_a (
                                                                                   const char* logical_type_id,
                                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                                   )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

TimeBase::TimeT POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::relative_expiry  (CORBA::Environment &ACE_TRY_ENV)
{
  return this->servant_->relative_expiry (ACE_TRY_ENV);
}

TimeBase::TimeT POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy::relative_expiry  (void)
{
  return this->servant_->relative_expiry ();
}


Messaging::RelativeRequestTimeoutPolicy*
POA_Messaging::RelativeRequestTimeoutPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RelativeRequestTimeoutPolicy *retval =
    Messaging::RelativeRequestTimeoutPolicy::_nil ();

  ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy (this,
                                                                               stub),
                  Messaging::RelativeRequestTimeoutPolicy::_nil ()
                  );

  return retval;
}

void
POA_Messaging::RelativeRequestTimeoutPolicy::_dispatch (
                                                        CORBA::ServerRequest &_tao_request,
                                                        void *_tao_context,
                                                        CORBA::Environment &ACE_TRY_ENV
                                                        )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::RelativeRoundtripTimeoutPolicy::RelativeRoundtripTimeoutPolicy (void)
{
}

POA_Messaging::RelativeRoundtripTimeoutPolicy::RelativeRoundtripTimeoutPolicy (const RelativeRoundtripTimeoutPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RelativeRoundtripTimeoutPolicy::~RelativeRoundtripTimeoutPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RelativeRoundtripTimeoutPolicy::_is_a (
                                                                     const char* value,
                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                     )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RelativeRoundtripTimeoutPolicy::_downcast (
                                                                const char* logical_type_id
                                                                )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RelativeRoundtripTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0";
}

POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::_tao_collocated_RelativeRoundtripTimeoutPolicy (
                                                                                                               POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr  servant,
                                                                                                               TAO_Stub *stub
                                                                                                               )
  : ACE_NESTED_CLASS (Messaging,RelativeRoundtripTimeoutPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::_is_a (
                                                                                     const char* logical_type_id,
                                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                                     )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

TimeBase::TimeT POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::relative_expiry  (CORBA::Environment &ACE_TRY_ENV)
{
  return this->servant_->relative_expiry (ACE_TRY_ENV);
}

TimeBase::TimeT POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy::relative_expiry  (void)
{
  return this->servant_->relative_expiry ();
}


Messaging::RelativeRoundtripTimeoutPolicy*
POA_Messaging::RelativeRoundtripTimeoutPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RelativeRoundtripTimeoutPolicy *retval =
    Messaging::RelativeRoundtripTimeoutPolicy::_nil ();

  ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy (this,
                                                                                 stub),
                  Messaging::RelativeRoundtripTimeoutPolicy::_nil ()
                  );

  return retval;
}

void
POA_Messaging::RelativeRoundtripTimeoutPolicy::_dispatch (
                                                          CORBA::ServerRequest &_tao_request,
                                                          void *_tao_context,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::RoutingPolicy::RoutingPolicy (void)
{
}

POA_Messaging::RoutingPolicy::RoutingPolicy (const RoutingPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::RoutingPolicy::~RoutingPolicy (void)
{
}

CORBA::Boolean POA_Messaging::RoutingPolicy::_is_a (
                                                    const char* value,
                                                    CORBA::Environment &ACE_TRY_ENV
                                                    )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RoutingPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::RoutingPolicy::_downcast (
                                               const char* logical_type_id
                                               )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/RoutingPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::RoutingPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::RoutingPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RoutingPolicy:1.0";
}

POA_Messaging::_tao_collocated_RoutingPolicy::_tao_collocated_RoutingPolicy (
                                                                             POA_Messaging::RoutingPolicy_ptr  servant,
                                                                             TAO_Stub *stub
                                                                             )
  : ACE_NESTED_CLASS (Messaging,RoutingPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::RoutingPolicy_ptr POA_Messaging::_tao_collocated_RoutingPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_RoutingPolicy::_is_a (
                                                                    const char* logical_type_id,
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

Messaging::RoutingTypeRange POA_Messaging::_tao_collocated_RoutingPolicy::routing_range  (
                                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                                          )
{
  return this->servant_->routing_range (
                                        ACE_TRY_ENV
                                        );
}


Messaging::RoutingPolicy*
POA_Messaging::RoutingPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::RoutingPolicy *retval =
    Messaging::RoutingPolicy::_nil ();

  ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_collocated_RoutingPolicy (this,
                                                                stub),
                  Messaging::RoutingPolicy::_nil ()
                  );

  return retval;
}

void
POA_Messaging::RoutingPolicy::_dispatch (
                                         CORBA::ServerRequest &_tao_request,
                                         void *_tao_context,
                                         CORBA::Environment &ACE_TRY_ENV
                                         )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::MaxHopsPolicy::MaxHopsPolicy (void)
{
}

POA_Messaging::MaxHopsPolicy::MaxHopsPolicy (const MaxHopsPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::MaxHopsPolicy::~MaxHopsPolicy (void)
{
}

CORBA::Boolean POA_Messaging::MaxHopsPolicy::_is_a (
                                                    const char* value,
                                                    CORBA::Environment &ACE_TRY_ENV
                                                    )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/MaxHopsPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::MaxHopsPolicy::_downcast (
                                               const char* logical_type_id
                                               )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/MaxHopsPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::MaxHopsPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::MaxHopsPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/MaxHopsPolicy:1.0";
}

POA_Messaging::_tao_collocated_MaxHopsPolicy::_tao_collocated_MaxHopsPolicy (
                                                                             POA_Messaging::MaxHopsPolicy_ptr  servant,
                                                                             TAO_Stub *stub
                                                                             )
  : ACE_NESTED_CLASS (Messaging,MaxHopsPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::MaxHopsPolicy_ptr POA_Messaging::_tao_collocated_MaxHopsPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_MaxHopsPolicy::_is_a (
                                                                    const char* logical_type_id,
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::UShort POA_Messaging::_tao_collocated_MaxHopsPolicy::max_hops  (
                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                       )
{
  return this->servant_->max_hops (
                                   ACE_TRY_ENV
                                   );
}


Messaging::MaxHopsPolicy*
POA_Messaging::MaxHopsPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::MaxHopsPolicy *retval =
    Messaging::MaxHopsPolicy::_nil ();

  ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_collocated_MaxHopsPolicy (this,
                                                                stub),
                  Messaging::MaxHopsPolicy::_nil ()
                  );

  return retval;
}

void
POA_Messaging::MaxHopsPolicy::_dispatch (
                                         CORBA::ServerRequest &_tao_request,
                                         void *_tao_context,
                                         CORBA::Environment &ACE_TRY_ENV
                                         )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

POA_Messaging::QueueOrderPolicy::QueueOrderPolicy (void)
{
}

POA_Messaging::QueueOrderPolicy::QueueOrderPolicy (const QueueOrderPolicy& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Policy) (rhs),
      TAO_ServantBase (rhs)
{}

POA_Messaging::QueueOrderPolicy::~QueueOrderPolicy (void)
{
}

CORBA::Boolean POA_Messaging::QueueOrderPolicy::_is_a (
                                                       const char* value,
                                                       CORBA::Environment &ACE_TRY_ENV
                                                       )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/QueueOrderPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_Messaging::QueueOrderPolicy::_downcast (
                                                  const char* logical_type_id
                                                  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/QueueOrderPolicy:1.0") == 0)
    return ACE_static_cast (POA_Messaging::QueueOrderPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_Messaging::QueueOrderPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/QueueOrderPolicy:1.0";
}

POA_Messaging::_tao_collocated_QueueOrderPolicy::_tao_collocated_QueueOrderPolicy (
                                                                                   POA_Messaging::QueueOrderPolicy_ptr  servant,
                                                                                   TAO_Stub *stub
                                                                                   )
  : ACE_NESTED_CLASS (Messaging,QueueOrderPolicy) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::QueueOrderPolicy_ptr POA_Messaging::_tao_collocated_QueueOrderPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_QueueOrderPolicy::_is_a (
                                                                       const char* logical_type_id,
                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                       )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

Messaging::Ordering POA_Messaging::_tao_collocated_QueueOrderPolicy::allowed_orders  (
                                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                                      )
{
  return this->servant_->allowed_orders (
                                         ACE_TRY_ENV
                                         );
}


Messaging::QueueOrderPolicy*
POA_Messaging::QueueOrderPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::QueueOrderPolicy *retval =
    Messaging::QueueOrderPolicy::_nil ();

  ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_collocated_QueueOrderPolicy (this,
                                                                   stub),
                  Messaging::QueueOrderPolicy::_nil ()
                  );

  return retval;
}

void
POA_Messaging::QueueOrderPolicy::_dispatch (
                                            CORBA::ServerRequest &_tao_request,
                                            void *_tao_context,
                                            CORBA::Environment &ACE_TRY_ENV
                                            )
{
  TAO_Locality_Constrained_ServantBase::_dispatch (_tao_request,
                                                   _tao_context,
                                                   ACE_TRY_ENV);
}

// ****************************************************************

#if (TAO_HAS_AMI_CALLBACK == 1)


class TAO_Messaging_ReplyHandler_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 20:19:57 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Messaging_ReplyHandler_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Messaging_ReplyHandler_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14,  0, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14,
#else
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14,  0, 14,  0, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14,  0, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Messaging_ReplyHandler_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 2,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 13,
      HASH_VALUE_RANGE = 9,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Messaging::ReplyHandler::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_Messaging::ReplyHandler::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 20:19:57 */
static TAO_Messaging_ReplyHandler_Perfect_Hash_OpTable tao_Messaging_ReplyHandler_optable;

Messaging::ReplyHandler_ptr _TAO_collocation_POA_Messaging_ReplyHandler_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      Messaging::ReplyHandler_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_Messaging::_tao_thru_poa_collocated_ReplyHandler (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      if (obj->_servant () != 0)
        {
          POA_Messaging::ReplyHandler *servant = ACE_reinterpret_cast (POA_Messaging::ReplyHandler*, obj->_servant ()->_downcast ("IDL:Messaging/ReplyHandler:1.0"));
          if (servant != 0)
            {
              Messaging::ReplyHandler *retval = 0;
              ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_direct_collocated_ReplyHandler (servant, stub),
                  0
                );
              return retval;
            }
        }
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_Messaging_ReplyHandler_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_Messaging_ReplyHandler_Stub_Factory_function_pointer =
    _TAO_collocation_POA_Messaging_ReplyHandler_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_Messaging_ReplyHandler_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_Messaging_ReplyHandler_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_Messaging_ReplyHandler_Stub_Factory_Initializer));

// skeleton constructor
POA_Messaging::ReplyHandler::ReplyHandler (void)
{
  this->optable_ = &tao_Messaging_ReplyHandler_optable;
}

// copy ctor
POA_Messaging::ReplyHandler::ReplyHandler (const ReplyHandler& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_Messaging::ReplyHandler::~ReplyHandler (void)
{
}

void POA_Messaging::ReplyHandler::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Messaging::ReplyHandler *_tao_impl = (POA_Messaging::ReplyHandler *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Messaging::ReplyHandler::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_Messaging::ReplyHandler *_tao_impl = (POA_Messaging::ReplyHandler *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Messaging::ReplyHandler::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyHandler:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Messaging::ReplyHandler::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/ReplyHandler:1.0") == 0)
    return ACE_static_cast (POA_Messaging::ReplyHandler_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::ReplyHandler::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_Messaging::ReplyHandler::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyHandler:1.0";
}

Messaging::ReplyHandler*
POA_Messaging::ReplyHandler::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          Messaging::ReplyHandler_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_Messaging::_tao_thru_poa_collocated_ReplyHandler (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        {
          Messaging::ReplyHandler_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_Messaging::_tao_direct_collocated_ReplyHandler (this, stub),
              0
            );
          return retval;
        }
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return Messaging::ReplyHandler::_unchecked_narrow (obj.in ());
    }
}

POA_Messaging::_tao_thru_poa_collocated_ReplyHandler::_tao_thru_poa_collocated_ReplyHandler (
  TAO_Stub *stub
)
  : ACE_NESTED_CLASS (Messaging,ReplyHandler) (),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_Messaging::_tao_thru_poa_collocated_ReplyHandler::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_Messaging::ReplyHandler_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Messaging/ReplyHandler:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_Messaging::_tao_thru_poa_collocated_ReplyHandler::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_Messaging::ReplyHandler_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Messaging/ReplyHandler:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


POA_Messaging::_tao_direct_collocated_ReplyHandler::_tao_direct_collocated_ReplyHandler (
    POA_Messaging::ReplyHandler_ptr  servant,
    TAO_Stub *stub
  )
  : ACE_NESTED_CLASS (Messaging,ReplyHandler) (),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

CORBA::Boolean POA_Messaging::_tao_direct_collocated_ReplyHandler::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  return this->servant_->_is_a (logical_type_id, ACE_TRY_ENV);
}


POA_Messaging::ReplyHandler_ptr POA_Messaging::_tao_direct_collocated_ReplyHandler::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_direct_collocated_ReplyHandler::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  return this->servant_->_non_existent (ACE_TRY_ENV);
}

#endif /* TAO_HAS_AMI_CALLBACK == 1 */

// ****************************************************************

#if (TAO_HAS_AMI_POLLER == 1)

class TAO_Messaging_Poller_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 12:37:20 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: /project/macarena/coryan/head/ACE_wrappers/bin/gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Messaging_Poller_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Messaging_Poller_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
  {
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
    30, 30, 30, 30, 30,  0, 30,  0, 30, 10,
    30,  5, 30, 30, 30,  0, 30, 30, 30, 30,
    30, 30, 30, 30,  0, 30,  0, 30, 30, 30,
    30,  0, 30, 30, 30, 30, 30, 30,
  };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Messaging_Poller_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
  {
    TOTAL_KEYWORDS = 11,
    MIN_WORD_LENGTH = 5,
    MAX_WORD_LENGTH = 23,
    MIN_HASH_VALUE = 5,
    MAX_HASH_VALUE = 29,
    HASH_VALUE_RANGE = 25,
    DUPLICATES = 2
  };

  static const class TAO_operation_db_entry  wordlist[] =
  {
    {"",0}, {"",0}, {"",0}, {"",0}, {"",0},
    {"_is_a",  &POA_Messaging::Poller::_is_a_skel},
    {"is_ready",      &POA_Messaging::Poller::is_ready_skel},
    {"_get_target",   &POA_Messaging::Poller::_get_target_skel},
    {"_non_existent",  &POA_Messaging::Poller::_non_existent_skel},
    {"_get_op_name",  &POA_Messaging::Poller::_get_op_name_skel},
    {"_get_is_from_poller",   &POA_Messaging::Poller::_get_is_from_poller_skel},
    {"_get_operation_target",         &POA_Messaging::Poller::_get_operation_target_skel},
    {"_get_associated_handler",       &POA_Messaging::Poller::_get_associated_handler_skel},
    {"_set_associated_handler",       &POA_Messaging::Poller::_set_associated_handler_skel},
    {"_get_operation_name",   &POA_Messaging::Poller::_get_operation_name_skel},
    {"create_pollable_set",   &POA_Messaging::Poller::create_pollable_set_skel},
  };

  static const signed char lookup[] =
  {
    -1,  -1,  -1,  -1,  -1,   5,  -1,  -1,   6,  -1,  -1,   7,  -1,   8,
    -1, -12,  -2,   9,  -1,  10,  -1,  11,  -1, -37,  14,  -1,  -1,  -1,
    -1,  15,
  };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              u_int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 12:37:20 */
TAO_Messaging_Poller_Perfect_Hash_OpTable tao_Messaging_Poller_optable;
// skeleton constructor
POA_Messaging::Poller::Poller (void)
{
  this->optable_ = &tao_Messaging_Poller_optable;
}

// copy ctor
POA_Messaging::Poller::Poller (const Poller& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Pollable) (rhs),
      TAO_ServantBase (rhs)
{}
// skeleton destructor
POA_Messaging::Poller::~Poller (void)
{
}
void POA_Messaging::Poller::_get_operation_target_skel (
                                                        CORBA::ServerRequest &_tao_server_request,
                                                        void *_tao_object_reference,
                                                        void * /* context */,
                                                        CORBA::Environment &ACE_TRY_ENV
                                                        )
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::Object_var _tao_retval;
  _tao_retval = _tao_impl->operation_target (
                                             ACE_TRY_ENV
                                             );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
        (_tao_out << _tao_retval.in ())
        ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Messaging::Poller::_get_operation_name_skel (
                                                      CORBA::ServerRequest &_tao_server_request,
                                                      void *_tao_object_reference,
                                                      void * /* context */,
                                                      CORBA::Environment &ACE_TRY_ENV
                                                      )
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::String_var _tao_retval;
  _tao_retval = _tao_impl->operation_name (
                                           ACE_TRY_ENV
                                           );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
        (_tao_out << _tao_retval.in ())
        ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Messaging::Poller::_get_associated_handler_skel (
                                                          CORBA::ServerRequest &_tao_server_request,
                                                          void *_tao_object_reference,
                                                          void * /* context */,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  Messaging::ReplyHandler_var _tao_retval;
  _tao_retval = _tao_impl->associated_handler (
                                               ACE_TRY_ENV
                                               );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
        (_tao_out << _tao_retval.in ())
        ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Messaging::Poller::_set_associated_handler_skel (
                                                          CORBA::ServerRequest &_tao_server_request,
                                                          void *_tao_object_reference,
                                                          void * /* context */,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  Messaging::ReplyHandler_var associated_handler;
  if (!(
        (_tao_in >> associated_handler.out ())
        ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->associated_handler (
                                 associated_handler.in (),
                                 ACE_TRY_ENV
                                 );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
}

void POA_Messaging::Poller::_get_is_from_poller_skel (
                                                      CORBA::ServerRequest &_tao_server_request,
                                                      void *_tao_object_reference,
                                                      void * /* context */,
                                                      CORBA::Environment &ACE_TRY_ENV
                                                      )
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  _tao_retval = _tao_impl->is_from_poller (
                                           ACE_TRY_ENV
                                           );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
        (_tao_out << CORBA::Any::from_boolean (_tao_retval))
        ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Messaging::Poller::_get_target_skel (
                                              CORBA::ServerRequest &_tao_server_request,
                                              void *_tao_object_reference,
                                              void * /* context */,
                                              CORBA::Environment &ACE_TRY_ENV
                                              )
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::Object_var _tao_retval;
  _tao_retval = _tao_impl->target (
                                   ACE_TRY_ENV
                                   );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
        (_tao_out << _tao_retval.in ())
        ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Messaging::Poller::_get_op_name_skel (
                                               CORBA::ServerRequest &_tao_server_request,
                                               void *_tao_object_reference,
                                               void * /* context */,
                                               CORBA::Environment &ACE_TRY_ENV
                                               )
{
  POA_Messaging::Poller *_tao_impl = (POA_Messaging::Poller *)_tao_object_reference;
  CORBA::String_var _tao_retval;
  _tao_retval = _tao_impl->op_name (
                                    ACE_TRY_ENV
                                    );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
        (_tao_out << _tao_retval.in ())
        ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Messaging::Poller::_is_a_skel (
                                        CORBA::ServerRequest &_tao_server_request,
                                        void * _tao_object_reference,
                                        void * /*context*/,
                                        CORBA::Environment &ACE_TRY_ENV
                                        )
{
  static const TAO_Param_Data_Skel Messaging_Poller_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel Messaging_Poller_is_a_calldata =
  {"_is_a", 1, 2, Messaging_Poller_is_a_paramdata};
  POA_Messaging::Poller_ptr  _tao_impl = (POA_Messaging::Poller_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
                                 ACE_TRY_ENV,
                                 &Messaging_Poller_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value.inout ()
                                 );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
                               ACE_TRY_ENV,
                               &Messaging_Poller_is_a_calldata,
                               &_tao_retval,
                               &_tao_value.inout ()
                               );
}

CORBA::Boolean POA_Messaging::Poller::_is_a (
                                             const char* value,
                                             CORBA::Environment &ACE_TRY_ENV
                                             )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/Poller:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Pollable:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void POA_Messaging::Poller::_non_existent_skel (
                                                CORBA::ServerRequest &_tao_server_request,
                                                void * /* _tao_object_reference */ ,
                                                void * /*context*/,
                                                CORBA::Environment &ACE_TRY_ENV
                                                )
{
  static const TAO_Param_Data_Skel Messaging_Poller_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel Messaging_Poller_non_existent_calldata =
  {"_non_existent", 1, 1, Messaging_Poller_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
                               ACE_TRY_ENV,
                               &Messaging_Poller_non_existent_calldata,
                               &_tao_retval
                               );
}

void* POA_Messaging::Poller::_downcast (
                                        const char* logical_type_id
                                        )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:Messaging/Poller:1.0") == 0)
    return ACE_static_cast (POA_Messaging::Poller_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Pollable:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Pollable_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Messaging::Poller::_dispatch (CORBA::ServerRequest &req, void * context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
      ACE_THROW (CORBA_BAD_OPERATION ());
    }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_Messaging::Poller::_interface_repository_id (void) const
{
  return "IDL:Messaging/Poller:1.0";
}

POA_Messaging::_tao_collocated_Poller::_tao_collocated_Poller (
                                                               POA_Messaging::Poller_ptr  servant,
                                                               TAO_Stub *stub
                                                               )
  : ACE_NESTED_CLASS (Messaging,Poller) (),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Pollable) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_Messaging::Poller_ptr POA_Messaging::_tao_collocated_Poller::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_Messaging::_tao_collocated_Poller::_is_a (
                                                             const char* logical_type_id,
                                                             CORBA::Environment &ACE_TRY_ENV
                                                             )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Object_ptr POA_Messaging::_tao_collocated_Poller::operation_target  (
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  return this->servant_->operation_target (
                                           ACE_TRY_ENV
                                           );
}

char * POA_Messaging::_tao_collocated_Poller::operation_name  (
                                                               CORBA::Environment &ACE_TRY_ENV
                                                               )
{
  return this->servant_->operation_name (
                                         ACE_TRY_ENV
                                         );
}

Messaging::ReplyHandler_ptr POA_Messaging::_tao_collocated_Poller::associated_handler  (
                                                                                        CORBA::Environment &ACE_TRY_ENV
                                                                                        )
{
  return this->servant_->associated_handler (
                                             ACE_TRY_ENV
                                             );
}

void POA_Messaging::_tao_collocated_Poller::associated_handler  (
                                                                 Messaging::ReplyHandler_ptr associated_handler,
                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                 )
{
  this->servant_->associated_handler (
                                      associated_handler,
                                      ACE_TRY_ENV
                                      );
}

CORBA::Boolean POA_Messaging::_tao_collocated_Poller::is_from_poller  (
                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                       )
{
  return this->servant_->is_from_poller (
                                         ACE_TRY_ENV
                                         );
}

CORBA::Object_ptr POA_Messaging::_tao_collocated_Poller::target  (
                                                                  CORBA::Environment &ACE_TRY_ENV
                                                                  )
{
  return this->servant_->target (
                                 ACE_TRY_ENV
                                 );
}

char * POA_Messaging::_tao_collocated_Poller::op_name  (
                                                        CORBA::Environment &ACE_TRY_ENV
                                                        )
{
  return this->servant_->op_name (
                                  ACE_TRY_ENV
                                  );
}


Messaging::Poller*
POA_Messaging::Poller::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Messaging::Poller *retval =
    Messaging::Poller::_nil ();

  ACE_NEW_RETURN (
                  retval,
                  POA_Messaging::_tao_collocated_Poller (this,
                                                         stub),
                  Messaging::Poller::_nil ()
                  );

  return retval;
}
#endif /* TAO_HAS_AMI_POLLER == 1 */

#endif /* TAO_HAS_CORBA_MESSAGING == 1 */
