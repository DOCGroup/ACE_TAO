/* -*- C++ -*- */
//$Id$



// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_INTERFACEC_H_
#define _TAO_IDL_INTERFACEC_H_

#include "tao/corbafwd.h"
#include "tao/Object.h"

#include "tao/Any.h"
#include "tao/Sequence_T.h"
#include "tao/varout.h"

#if (TAO_HAS_INTERFACE_REPOSITORY == 1)
#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO
#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO
#endif /* TAO_EXPORT_NESTED_CLASSES */
#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

  class TAO_Export CORBA_IRObject_var
  {
  public:
    CORBA_IRObject_var (void); // default constructor
    CORBA_IRObject_var (CORBA_IRObject_ptr);
    CORBA_IRObject_var (const CORBA_IRObject_var &); // copy constructor
    ~CORBA_IRObject_var (void); // destructor

    CORBA_IRObject_var &operator= (CORBA_IRObject_ptr);
    CORBA_IRObject_var &operator= (const CORBA_IRObject_var &);
    CORBA_IRObject_ptr operator-> (void) const;

    operator const CORBA_IRObject_ptr &() const;
    operator CORBA_IRObject_ptr &();
    // in, inout, out, _retn
    CORBA_IRObject_ptr in (void) const;
    CORBA_IRObject_ptr &inout (void);
    CORBA_IRObject_ptr &out (void);
    CORBA_IRObject_ptr _retn (void);
    CORBA_IRObject_ptr ptr (void) const;

  private:
    CORBA_IRObject_ptr ptr_;
  };


//#endif /* end #if !defined */


#if !defined (_CORBA_IROBJECT___OUT_CH_)
#define _CORBA_IROBJECT___OUT_CH_

  class TAO_Export CORBA_IRObject_out
  {
  public:
    CORBA_IRObject_out (CORBA_IRObject_ptr &);
    CORBA_IRObject_out (CORBA_IRObject_var &);
    CORBA_IRObject_out (const CORBA_IRObject_out &);
    CORBA_IRObject_out &operator= (const CORBA_IRObject_out &);
    CORBA_IRObject_out &operator= (const CORBA_IRObject_var &);
    CORBA_IRObject_out &operator= (CORBA_IRObject_ptr);
    operator CORBA_IRObject_ptr &();
    CORBA_IRObject_ptr &ptr (void);
    CORBA_IRObject_ptr operator-> (void);

  private:
    CORBA_IRObject_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_IROBJECT_CH_)
#define _CORBA_IROBJECT_CH_

class TAO_Export CORBA_IRObject : public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_IRObject_ptr _ptr_type;
    typedef CORBA_IRObject_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_IRObject_ptr _duplicate (CORBA_IRObject_ptr obj);
    static CORBA_IRObject_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_IRObject_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_IRObject_ptr _nil (void)
      {
        return (CORBA::IRObject_ptr)0;
      }

    virtual CORBA::DefinitionKind def_kind (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void destroy (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_IRObject (void);
    CORBA_IRObject (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_IRObject (void);
  private:
    CORBA_IRObject (const CORBA_IRObject &);
    void operator= (const CORBA_IRObject &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED___VAR_CH_)
#define _CORBA_CONTAINED___VAR_CH_

  class TAO_Export CORBA_Contained_var
  {
  public:
    CORBA_Contained_var (void); // default constructor
    CORBA_Contained_var (CORBA_Contained_ptr);
    CORBA_Contained_var (const CORBA_Contained_var &); // copy constructor
    ~CORBA_Contained_var (void); // destructor

    CORBA_Contained_var &operator= (CORBA_Contained_ptr);
    CORBA_Contained_var &operator= (const CORBA_Contained_var &);
    CORBA_Contained_ptr operator-> (void) const;

    operator const CORBA_Contained_ptr &() const;
    operator CORBA_Contained_ptr &();
    // in, inout, out, _retn
    CORBA_Contained_ptr in (void) const;
    CORBA_Contained_ptr &inout (void);
    CORBA_Contained_ptr &out (void);
    CORBA_Contained_ptr _retn (void);
    CORBA_Contained_ptr ptr (void) const;

  private:
    CORBA_Contained_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED___OUT_CH_)
#define _CORBA_CONTAINED___OUT_CH_

  class TAO_Export CORBA_Contained_out
  {
  public:
    CORBA_Contained_out (CORBA_Contained_ptr &);
    CORBA_Contained_out (CORBA_Contained_var &);
    CORBA_Contained_out (const CORBA_Contained_out &);
    CORBA_Contained_out &operator= (const CORBA_Contained_out &);
    CORBA_Contained_out &operator= (const CORBA_Contained_var &);
    CORBA_Contained_out &operator= (CORBA_Contained_ptr);
    operator CORBA_Contained_ptr &();
    CORBA_Contained_ptr &ptr (void);
    CORBA_Contained_ptr operator-> (void);

  private:
    CORBA_Contained_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_REPOSITORY___VAR_CH_)
#define _CORBA_REPOSITORY___VAR_CH_

  class TAO_Export CORBA_Repository_var
  {
  public:
    CORBA_Repository_var (void); // default constructor
    CORBA_Repository_var (CORBA_Repository_ptr);
    CORBA_Repository_var (const CORBA_Repository_var &); // copy constructor
    ~CORBA_Repository_var (void); // destructor

    CORBA_Repository_var &operator= (CORBA_Repository_ptr);
    CORBA_Repository_var &operator= (const CORBA_Repository_var &);
    CORBA_Repository_ptr operator-> (void) const;

    operator const CORBA_Repository_ptr &() const;
    operator CORBA_Repository_ptr &();
    // in, inout, out, _retn
    CORBA_Repository_ptr in (void) const;
    CORBA_Repository_ptr &inout (void);
    CORBA_Repository_ptr &out (void);
    CORBA_Repository_ptr _retn (void);
    CORBA_Repository_ptr ptr (void) const;

  private:
    CORBA_Repository_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY___OUT_CH_)
#define _CORBA_REPOSITORY___OUT_CH_

  class TAO_Export CORBA_Repository_out
  {
  public:
    CORBA_Repository_out (CORBA_Repository_ptr &);
    CORBA_Repository_out (CORBA_Repository_var &);
    CORBA_Repository_out (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_var &);
    CORBA_Repository_out &operator= (CORBA_Repository_ptr);
    operator CORBA_Repository_ptr &();
    CORBA_Repository_ptr &ptr (void);
    CORBA_Repository_ptr operator-> (void);

  private:
    CORBA_Repository_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER___VAR_CH_)
#define _CORBA_CONTAINER___VAR_CH_

  class TAO_Export CORBA_Container_var
  {
  public:
    CORBA_Container_var (void); // default constructor
    CORBA_Container_var (CORBA_Container_ptr);
    CORBA_Container_var (const CORBA_Container_var &); // copy constructor
    ~CORBA_Container_var (void); // destructor

    CORBA_Container_var &operator= (CORBA_Container_ptr);
    CORBA_Container_var &operator= (const CORBA_Container_var &);
    CORBA_Container_ptr operator-> (void) const;

    operator const CORBA_Container_ptr &() const;
    operator CORBA_Container_ptr &();
    // in, inout, out, _retn
    CORBA_Container_ptr in (void) const;
    CORBA_Container_ptr &inout (void);
    CORBA_Container_ptr &out (void);
    CORBA_Container_ptr _retn (void);
    CORBA_Container_ptr ptr (void) const;

  private:
    CORBA_Container_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER___OUT_CH_)
#define _CORBA_CONTAINER___OUT_CH_

  class TAO_Export CORBA_Container_out
  {
  public:
    CORBA_Container_out (CORBA_Container_ptr &);
    CORBA_Container_out (CORBA_Container_var &);
    CORBA_Container_out (const CORBA_Container_out &);
    CORBA_Container_out &operator= (const CORBA_Container_out &);
    CORBA_Container_out &operator= (const CORBA_Container_var &);
    CORBA_Container_out &operator= (CORBA_Container_ptr);
    operator CORBA_Container_ptr &();
    CORBA_Container_ptr &ptr (void);
    CORBA_Container_ptr operator-> (void);

  private:
    CORBA_Container_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINED___VAR_CH_)
#define _CORBA_CONTAINED___VAR_CH_

  class TAO_Export CORBA_Contained_var
  {
  public:
    CORBA_Contained_var (void); // default constructor
    CORBA_Contained_var (CORBA_Contained_ptr);
    CORBA_Contained_var (const CORBA_Contained_var &); // copy constructor
    ~CORBA_Contained_var (void); // destructor

    CORBA_Contained_var &operator= (CORBA_Contained_ptr);
    CORBA_Contained_var &operator= (const CORBA_Contained_var &);
    CORBA_Contained_ptr operator-> (void) const;

    operator const CORBA_Contained_ptr &() const;
    operator CORBA_Contained_ptr &();
    // in, inout, out, _retn
    CORBA_Contained_ptr in (void) const;
    CORBA_Contained_ptr &inout (void);
    CORBA_Contained_ptr &out (void);
    CORBA_Contained_ptr _retn (void);
    CORBA_Contained_ptr ptr (void) const;

  private:
    CORBA_Contained_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED___OUT_CH_)
#define _CORBA_CONTAINED___OUT_CH_

  class TAO_Export CORBA_Contained_out
  {
  public:
    CORBA_Contained_out (CORBA_Contained_ptr &);
    CORBA_Contained_out (CORBA_Contained_var &);
    CORBA_Contained_out (const CORBA_Contained_out &);
    CORBA_Contained_out &operator= (const CORBA_Contained_out &);
    CORBA_Contained_out &operator= (const CORBA_Contained_var &);
    CORBA_Contained_out &operator= (CORBA_Contained_ptr);
    operator CORBA_Contained_ptr &();
    CORBA_Contained_ptr &ptr (void);
    CORBA_Contained_ptr operator-> (void);

  private:
    CORBA_Contained_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED_CH_)
#define _CORBA_CONTAINED_CH_

class TAO_Export CORBA_Contained: public virtual CORBA_IRObject
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_Contained_ptr _ptr_type;
    typedef CORBA_Contained_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_Contained_ptr _duplicate (CORBA_Contained_ptr obj);
    static CORBA_Contained_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_Contained_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_Contained_ptr _nil (void)
      {
        return (CORBA::Contained_ptr)0;
      }

    virtual char * id (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void id (
        const char * id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * name (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void name (
        const char * name,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * version (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void version (
        const char * version,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Container_ptr defined_in (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * absolute_name (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Repository_ptr containing_repository (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    struct  Description
    {
      CORBA::DefinitionKind kind;
      CORBA::Any value;
    };

    class Description_var
    {
    public:
      Description_var (void); // default constructor
      Description_var (Description *);
      Description_var (const Description_var &); // copy constructor
      ~Description_var (void); // destructor

      Description_var &operator= (Description *);
      Description_var &operator= (const Description_var &);
      Description *operator-> (void);
      const Description *operator-> (void) const;

      operator const Description &() const;
      operator Description &();
      operator Description &() const;
      // in, inout, out, _retn
      const Description &in (void) const;
      Description &inout (void);
      Description *&out (void);
      Description *_retn (void);
      Description *ptr (void) const;

    private:
      Description *ptr_;
    };

    class  Description_out
    {
    public:
      Description_out (Description *&);
      Description_out (Description_var &);
      Description_out (const Description_out &);
      Description_out &operator= (const Description_out &);
      Description_out &operator= (Description *);
      operator Description *&();
      Description *&ptr (void);
      Description *operator-> (void);

    private:
      Description *&ptr_;
      // assignment from T_var not allowed
      void operator= (const Description_var &);
    };

    static CORBA::TypeCode_ptr _tc_Description;

    virtual Description * describe (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void move (
        CORBA_Container_ptr new_container,
        const char * new_name,
        const char * new_version,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_Contained (void);
    CORBA_Contained (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_Contained (void);
  private:
    CORBA_Contained (const CORBA_Contained &);
    void operator= (const CORBA_Contained &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_MODULEDEF___VAR_CH_)
#define _CORBA_MODULEDEF___VAR_CH_

  class TAO_Export CORBA_ModuleDef_var
  {
  public:
    CORBA_ModuleDef_var (void); // default constructor
    CORBA_ModuleDef_var (CORBA_ModuleDef_ptr);
    CORBA_ModuleDef_var (const CORBA_ModuleDef_var &); // copy constructor
    ~CORBA_ModuleDef_var (void); // destructor

    CORBA_ModuleDef_var &operator= (CORBA_ModuleDef_ptr);
    CORBA_ModuleDef_var &operator= (const CORBA_ModuleDef_var &);
    CORBA_ModuleDef_ptr operator-> (void) const;

    operator const CORBA_ModuleDef_ptr &() const;
    operator CORBA_ModuleDef_ptr &();
    // in, inout, out, _retn
    CORBA_ModuleDef_ptr in (void) const;
    CORBA_ModuleDef_ptr &inout (void);
    CORBA_ModuleDef_ptr &out (void);
    CORBA_ModuleDef_ptr _retn (void);
    CORBA_ModuleDef_ptr ptr (void) const;

  private:
    CORBA_ModuleDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF___OUT_CH_)
#define _CORBA_MODULEDEF___OUT_CH_

  class TAO_Export CORBA_ModuleDef_out
  {
  public:
    CORBA_ModuleDef_out (CORBA_ModuleDef_ptr &);
    CORBA_ModuleDef_out (CORBA_ModuleDef_var &);
    CORBA_ModuleDef_out (const CORBA_ModuleDef_out &);
    CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_out &);
    CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_var &);
    CORBA_ModuleDef_out &operator= (CORBA_ModuleDef_ptr);
    operator CORBA_ModuleDef_ptr &();
    CORBA_ModuleDef_ptr &ptr (void);
    CORBA_ModuleDef_ptr operator-> (void);

  private:
    CORBA_ModuleDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_CONSTANTDEF___VAR_CH_)
#define _CORBA_CONSTANTDEF___VAR_CH_

  class TAO_Export CORBA_ConstantDef_var
  {
  public:
    CORBA_ConstantDef_var (void); // default constructor
    CORBA_ConstantDef_var (CORBA_ConstantDef_ptr);
    CORBA_ConstantDef_var (const CORBA_ConstantDef_var &); // copy constructor
    ~CORBA_ConstantDef_var (void); // destructor

    CORBA_ConstantDef_var &operator= (CORBA_ConstantDef_ptr);
    CORBA_ConstantDef_var &operator= (const CORBA_ConstantDef_var &);
    CORBA_ConstantDef_ptr operator-> (void) const;

    operator const CORBA_ConstantDef_ptr &() const;
    operator CORBA_ConstantDef_ptr &();
    // in, inout, out, _retn
    CORBA_ConstantDef_ptr in (void) const;
    CORBA_ConstantDef_ptr &inout (void);
    CORBA_ConstantDef_ptr &out (void);
    CORBA_ConstantDef_ptr _retn (void);
    CORBA_ConstantDef_ptr ptr (void) const;

  private:
    CORBA_ConstantDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF___OUT_CH_)
#define _CORBA_CONSTANTDEF___OUT_CH_

  class TAO_Export CORBA_ConstantDef_out
  {
  public:
    CORBA_ConstantDef_out (CORBA_ConstantDef_ptr &);
    CORBA_ConstantDef_out (CORBA_ConstantDef_var &);
    CORBA_ConstantDef_out (const CORBA_ConstantDef_out &);
    CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_out &);
    CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_var &);
    CORBA_ConstantDef_out &operator= (CORBA_ConstantDef_ptr);
    operator CORBA_ConstantDef_ptr &();
    CORBA_ConstantDef_ptr &ptr (void);
    CORBA_ConstantDef_ptr operator-> (void);

  private:
    CORBA_ConstantDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_IDLTYPE___VAR_CH_)
#define _CORBA_IDLTYPE___VAR_CH_

  class TAO_Export CORBA_IDLType_var
  {
  public:
    CORBA_IDLType_var (void); // default constructor
    CORBA_IDLType_var (CORBA_IDLType_ptr);
    CORBA_IDLType_var (const CORBA_IDLType_var &); // copy constructor
    ~CORBA_IDLType_var (void); // destructor

    CORBA_IDLType_var &operator= (CORBA_IDLType_ptr);
    CORBA_IDLType_var &operator= (const CORBA_IDLType_var &);
    CORBA_IDLType_ptr operator-> (void) const;

    operator const CORBA_IDLType_ptr &() const;
    operator CORBA_IDLType_ptr &();
    // in, inout, out, _retn
    CORBA_IDLType_ptr in (void) const;
    CORBA_IDLType_ptr &inout (void);
    CORBA_IDLType_ptr &out (void);
    CORBA_IDLType_ptr _retn (void);
    CORBA_IDLType_ptr ptr (void) const;

  private:
    CORBA_IDLType_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_IDLTYPE___OUT_CH_)
#define _CORBA_IDLTYPE___OUT_CH_

  class TAO_Export CORBA_IDLType_out
  {
  public:
    CORBA_IDLType_out (CORBA_IDLType_ptr &);
    CORBA_IDLType_out (CORBA_IDLType_var &);
    CORBA_IDLType_out (const CORBA_IDLType_out &);
    CORBA_IDLType_out &operator= (const CORBA_IDLType_out &);
    CORBA_IDLType_out &operator= (const CORBA_IDLType_var &);
    CORBA_IDLType_out &operator= (CORBA_IDLType_ptr);
    operator CORBA_IDLType_ptr &();
    CORBA_IDLType_ptr &ptr (void);
    CORBA_IDLType_ptr operator-> (void);

  private:
    CORBA_IDLType_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_STRUCTDEF___VAR_CH_)
#define _CORBA_STRUCTDEF___VAR_CH_

  class TAO_Export CORBA_StructDef_var
  {
  public:
    CORBA_StructDef_var (void); // default constructor
    CORBA_StructDef_var (CORBA_StructDef_ptr);
    CORBA_StructDef_var (const CORBA_StructDef_var &); // copy constructor
    ~CORBA_StructDef_var (void); // destructor

    CORBA_StructDef_var &operator= (CORBA_StructDef_ptr);
    CORBA_StructDef_var &operator= (const CORBA_StructDef_var &);
    CORBA_StructDef_ptr operator-> (void) const;

    operator const CORBA_StructDef_ptr &() const;
    operator CORBA_StructDef_ptr &();
    // in, inout, out, _retn
    CORBA_StructDef_ptr in (void) const;
    CORBA_StructDef_ptr &inout (void);
    CORBA_StructDef_ptr &out (void);
    CORBA_StructDef_ptr _retn (void);
    CORBA_StructDef_ptr ptr (void) const;

  private:
    CORBA_StructDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF___OUT_CH_)
#define _CORBA_STRUCTDEF___OUT_CH_

  class TAO_Export CORBA_StructDef_out
  {
  public:
    CORBA_StructDef_out (CORBA_StructDef_ptr &);
    CORBA_StructDef_out (CORBA_StructDef_var &);
    CORBA_StructDef_out (const CORBA_StructDef_out &);
    CORBA_StructDef_out &operator= (const CORBA_StructDef_out &);
    CORBA_StructDef_out &operator= (const CORBA_StructDef_var &);
    CORBA_StructDef_out &operator= (CORBA_StructDef_ptr);
    operator CORBA_StructDef_ptr &();
    CORBA_StructDef_ptr &ptr (void);
    CORBA_StructDef_ptr operator-> (void);

  private:
    CORBA_StructDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_UNIONDEF___VAR_CH_)
#define _CORBA_UNIONDEF___VAR_CH_

  class TAO_Export CORBA_UnionDef_var
  {
  public:
    CORBA_UnionDef_var (void); // default constructor
    CORBA_UnionDef_var (CORBA_UnionDef_ptr);
    CORBA_UnionDef_var (const CORBA_UnionDef_var &); // copy constructor
    ~CORBA_UnionDef_var (void); // destructor

    CORBA_UnionDef_var &operator= (CORBA_UnionDef_ptr);
    CORBA_UnionDef_var &operator= (const CORBA_UnionDef_var &);
    CORBA_UnionDef_ptr operator-> (void) const;

    operator const CORBA_UnionDef_ptr &() const;
    operator CORBA_UnionDef_ptr &();
    // in, inout, out, _retn
    CORBA_UnionDef_ptr in (void) const;
    CORBA_UnionDef_ptr &inout (void);
    CORBA_UnionDef_ptr &out (void);
    CORBA_UnionDef_ptr _retn (void);
    CORBA_UnionDef_ptr ptr (void) const;

  private:
    CORBA_UnionDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___OUT_CH_)
#define _CORBA_UNIONDEF___OUT_CH_

  class TAO_Export CORBA_UnionDef_out
  {
  public:
    CORBA_UnionDef_out (CORBA_UnionDef_ptr &);
    CORBA_UnionDef_out (CORBA_UnionDef_var &);
    CORBA_UnionDef_out (const CORBA_UnionDef_out &);
    CORBA_UnionDef_out &operator= (const CORBA_UnionDef_out &);
    CORBA_UnionDef_out &operator= (const CORBA_UnionDef_var &);
    CORBA_UnionDef_out &operator= (CORBA_UnionDef_ptr);
    operator CORBA_UnionDef_ptr &();
    CORBA_UnionDef_ptr &ptr (void);
    CORBA_UnionDef_ptr operator-> (void);

  private:
    CORBA_UnionDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_ENUMDEF___VAR_CH_)
#define _CORBA_ENUMDEF___VAR_CH_

  class TAO_Export CORBA_EnumDef_var
  {
  public:
    CORBA_EnumDef_var (void); // default constructor
    CORBA_EnumDef_var (CORBA_EnumDef_ptr);
    CORBA_EnumDef_var (const CORBA_EnumDef_var &); // copy constructor
    ~CORBA_EnumDef_var (void); // destructor

    CORBA_EnumDef_var &operator= (CORBA_EnumDef_ptr);
    CORBA_EnumDef_var &operator= (const CORBA_EnumDef_var &);
    CORBA_EnumDef_ptr operator-> (void) const;

    operator const CORBA_EnumDef_ptr &() const;
    operator CORBA_EnumDef_ptr &();
    // in, inout, out, _retn
    CORBA_EnumDef_ptr in (void) const;
    CORBA_EnumDef_ptr &inout (void);
    CORBA_EnumDef_ptr &out (void);
    CORBA_EnumDef_ptr _retn (void);
    CORBA_EnumDef_ptr ptr (void) const;

  private:
    CORBA_EnumDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF___OUT_CH_)
#define _CORBA_ENUMDEF___OUT_CH_

  class TAO_Export CORBA_EnumDef_out
  {
  public:
    CORBA_EnumDef_out (CORBA_EnumDef_ptr &);
    CORBA_EnumDef_out (CORBA_EnumDef_var &);
    CORBA_EnumDef_out (const CORBA_EnumDef_out &);
    CORBA_EnumDef_out &operator= (const CORBA_EnumDef_out &);
    CORBA_EnumDef_out &operator= (const CORBA_EnumDef_var &);
    CORBA_EnumDef_out &operator= (CORBA_EnumDef_ptr);
    operator CORBA_EnumDef_ptr &();
    CORBA_EnumDef_ptr &ptr (void);
    CORBA_EnumDef_ptr operator-> (void);

  private:
    CORBA_EnumDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_ALIASDEF___VAR_CH_)
#define _CORBA_ALIASDEF___VAR_CH_

  class TAO_Export CORBA_AliasDef_var
  {
  public:
    CORBA_AliasDef_var (void); // default constructor
    CORBA_AliasDef_var (CORBA_AliasDef_ptr);
    CORBA_AliasDef_var (const CORBA_AliasDef_var &); // copy constructor
    ~CORBA_AliasDef_var (void); // destructor

    CORBA_AliasDef_var &operator= (CORBA_AliasDef_ptr);
    CORBA_AliasDef_var &operator= (const CORBA_AliasDef_var &);
    CORBA_AliasDef_ptr operator-> (void) const;

    operator const CORBA_AliasDef_ptr &() const;
    operator CORBA_AliasDef_ptr &();
    // in, inout, out, _retn
    CORBA_AliasDef_ptr in (void) const;
    CORBA_AliasDef_ptr &inout (void);
    CORBA_AliasDef_ptr &out (void);
    CORBA_AliasDef_ptr _retn (void);
    CORBA_AliasDef_ptr ptr (void) const;

  private:
    CORBA_AliasDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF___OUT_CH_)
#define _CORBA_ALIASDEF___OUT_CH_

  class TAO_Export CORBA_AliasDef_out
  {
  public:
    CORBA_AliasDef_out (CORBA_AliasDef_ptr &);
    CORBA_AliasDef_out (CORBA_AliasDef_var &);
    CORBA_AliasDef_out (const CORBA_AliasDef_out &);
    CORBA_AliasDef_out &operator= (const CORBA_AliasDef_out &);
    CORBA_AliasDef_out &operator= (const CORBA_AliasDef_var &);
    CORBA_AliasDef_out &operator= (CORBA_AliasDef_ptr);
    operator CORBA_AliasDef_ptr &();
    CORBA_AliasDef_ptr &ptr (void);
    CORBA_AliasDef_ptr operator-> (void);

  private:
    CORBA_AliasDef_ptr &ptr_;
  };


#endif /* end #if !defined */

//#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___VAR_CH_)
#define _CORBA_INTERFACEDEF___VAR_CH_

  class TAO_Export CORBA_InterfaceDef_var
  {
  public:
    CORBA_InterfaceDef_var (void); // default constructor
    CORBA_InterfaceDef_var (CORBA_InterfaceDef_ptr);
    CORBA_InterfaceDef_var (const CORBA_InterfaceDef_var &); // copy constructor
    ~CORBA_InterfaceDef_var (void); // destructor

    CORBA_InterfaceDef_var &operator= (CORBA_InterfaceDef_ptr);
    CORBA_InterfaceDef_var &operator= (const CORBA_InterfaceDef_var &);
    CORBA_InterfaceDef_ptr operator-> (void) const;

    operator const CORBA_InterfaceDef_ptr &() const;
    operator CORBA_InterfaceDef_ptr &();
    // in, inout, out, _retn
    CORBA_InterfaceDef_ptr in (void) const;
    CORBA_InterfaceDef_ptr &inout (void);
    CORBA_InterfaceDef_ptr &out (void);
    CORBA_InterfaceDef_ptr _retn (void);
    CORBA_InterfaceDef_ptr ptr (void) const;

  private:
    CORBA_InterfaceDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___OUT_CH_)
#define _CORBA_INTERFACEDEF___OUT_CH_

  class TAO_Export CORBA_InterfaceDef_out
  {
  public:
    CORBA_InterfaceDef_out (CORBA_InterfaceDef_ptr &);
    CORBA_InterfaceDef_out (CORBA_InterfaceDef_var &);
    CORBA_InterfaceDef_out (const CORBA_InterfaceDef_out &);
    CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_out &);
    CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_var &);
    CORBA_InterfaceDef_out &operator= (CORBA_InterfaceDef_ptr);
    operator CORBA_InterfaceDef_ptr &();
    CORBA_InterfaceDef_ptr &ptr (void);
    CORBA_InterfaceDef_ptr operator-> (void);

  private:
    CORBA_InterfaceDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_EXCEPTIONDEF___VAR_CH_)
#define _CORBA_EXCEPTIONDEF___VAR_CH_

  class TAO_Export CORBA_ExceptionDef_var
  {
  public:
    CORBA_ExceptionDef_var (void); // default constructor
    CORBA_ExceptionDef_var (CORBA_ExceptionDef_ptr);
    CORBA_ExceptionDef_var (const CORBA_ExceptionDef_var &); // copy constructor
    ~CORBA_ExceptionDef_var (void); // destructor

    CORBA_ExceptionDef_var &operator= (CORBA_ExceptionDef_ptr);
    CORBA_ExceptionDef_var &operator= (const CORBA_ExceptionDef_var &);
    CORBA_ExceptionDef_ptr operator-> (void) const;

    operator const CORBA_ExceptionDef_ptr &() const;
    operator CORBA_ExceptionDef_ptr &();
    // in, inout, out, _retn
    CORBA_ExceptionDef_ptr in (void) const;
    CORBA_ExceptionDef_ptr &inout (void);
    CORBA_ExceptionDef_ptr &out (void);
    CORBA_ExceptionDef_ptr _retn (void);
    CORBA_ExceptionDef_ptr ptr (void) const;

  private:
    CORBA_ExceptionDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF___OUT_CH_)
#define _CORBA_EXCEPTIONDEF___OUT_CH_

  class TAO_Export CORBA_ExceptionDef_out
  {
  public:
    CORBA_ExceptionDef_out (CORBA_ExceptionDef_ptr &);
    CORBA_ExceptionDef_out (CORBA_ExceptionDef_var &);
    CORBA_ExceptionDef_out (const CORBA_ExceptionDef_out &);
    CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_out &);
    CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_var &);
    CORBA_ExceptionDef_out &operator= (CORBA_ExceptionDef_ptr);
    operator CORBA_ExceptionDef_ptr &();
    CORBA_ExceptionDef_ptr &ptr (void);
    CORBA_ExceptionDef_ptr operator-> (void);

  private:
    CORBA_ExceptionDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF___VAR_CH_)
#define _CORBA_NATIVEDEF___VAR_CH_

  class TAO_Export CORBA_NativeDef_var
  {
  public:
    CORBA_NativeDef_var (void); // default constructor
    CORBA_NativeDef_var (CORBA_NativeDef_ptr);
    CORBA_NativeDef_var (const CORBA_NativeDef_var &); // copy constructor
    ~CORBA_NativeDef_var (void); // destructor

    CORBA_NativeDef_var &operator= (CORBA_NativeDef_ptr);
    CORBA_NativeDef_var &operator= (const CORBA_NativeDef_var &);
    CORBA_NativeDef_ptr operator-> (void) const;

    operator const CORBA_NativeDef_ptr &() const;
    operator CORBA_NativeDef_ptr &();
    // in, inout, out, _retn
    CORBA_NativeDef_ptr in (void) const;
    CORBA_NativeDef_ptr &inout (void);
    CORBA_NativeDef_ptr &out (void);
    CORBA_NativeDef_ptr _retn (void);
    CORBA_NativeDef_ptr ptr (void) const;

  private:
    CORBA_NativeDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF___OUT_CH_)
#define _CORBA_NATIVEDEF___OUT_CH_

  class TAO_Export CORBA_NativeDef_out
  {
  public:
    CORBA_NativeDef_out (CORBA_NativeDef_ptr &);
    CORBA_NativeDef_out (CORBA_NativeDef_var &);
    CORBA_NativeDef_out (const CORBA_NativeDef_out &);
    CORBA_NativeDef_out &operator= (const CORBA_NativeDef_out &);
    CORBA_NativeDef_out &operator= (const CORBA_NativeDef_var &);
    CORBA_NativeDef_out &operator= (CORBA_NativeDef_ptr);
    operator CORBA_NativeDef_ptr &();
    CORBA_NativeDef_ptr &ptr (void);
    CORBA_NativeDef_ptr operator-> (void);

  private:
    CORBA_NativeDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CH_

    class _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_InterfaceDef* *value,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &rhs);
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &rhs);
      TAO_Object_Manager<CORBA::InterfaceDef,CORBA::InterfaceDef_var> operator[] (CORBA::ULong index) const;
      static CORBA_InterfaceDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_InterfaceDef **buffer);
      // The Base_Sequence functions, please see tao/Sequence.h
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_InterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_InterfaceDef* *get_buffer (void) const;
      virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
      virtual void _downcast (
          void* target,
          CORBA_Object *src,
          CORBA_Environment &ACE_TRY_ENV =
            TAO_default_environment ()
        );
      virtual CORBA_Object* _upcast (void *src) const;

    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_INTERFACEDEFSEQ_CH_)
#define _CORBA_INTERFACEDEFSEQ_CH_

  // *************************************************************
  // InterfaceDefSeq
  // *************************************************************

  class TAO_Export CORBA_InterfaceDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_InterfaceDefSeq (void); // default ctor
    CORBA_InterfaceDefSeq (CORBA::ULong max); // uses max size
    CORBA_InterfaceDefSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_InterfaceDef_ptr *buffer,
      CORBA::Boolean release=0
    );
    CORBA_InterfaceDefSeq (const CORBA_InterfaceDefSeq &); // copy ctor
    ~CORBA_InterfaceDefSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_INTERFACEDEFSEQ___VAR_CH_

// *************************************************************
  // class CORBA::InterfaceDefSeq_var
  // *************************************************************

  class TAO_Export CORBA_InterfaceDefSeq_var
  {
  public:
    CORBA_InterfaceDefSeq_var (void); // default constructor
    CORBA_InterfaceDefSeq_var (CORBA_InterfaceDefSeq *);
    CORBA_InterfaceDefSeq_var (const CORBA_InterfaceDefSeq_var &); // copy constructor
    ~CORBA_InterfaceDefSeq_var (void); // destructor

    CORBA_InterfaceDefSeq_var &operator= (CORBA_InterfaceDefSeq *);
    CORBA_InterfaceDefSeq_var &operator= (const CORBA_InterfaceDefSeq_var &);
    CORBA_InterfaceDefSeq *operator-> (void);
    const CORBA_InterfaceDefSeq *operator-> (void) const;

    operator const CORBA_InterfaceDefSeq &() const;
    operator CORBA_InterfaceDefSeq &();
    operator CORBA_InterfaceDefSeq &() const;
    TAO_Object_Manager<CORBA_InterfaceDef,CORBA_InterfaceDef_var> operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_InterfaceDefSeq &in (void) const;
    CORBA_InterfaceDefSeq &inout (void);
    CORBA_InterfaceDefSeq *&out (void);
    CORBA_InterfaceDefSeq *_retn (void);
    CORBA_InterfaceDefSeq *ptr (void) const;

  private:
    CORBA_InterfaceDefSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_INTERFACEDEFSEQ___OUT_CH_

  class TAO_Export CORBA_InterfaceDefSeq_out
  {
  public:
    CORBA_InterfaceDefSeq_out (CORBA_InterfaceDefSeq *&);
    CORBA_InterfaceDefSeq_out (CORBA_InterfaceDefSeq_var &);
    CORBA_InterfaceDefSeq_out (const CORBA_InterfaceDefSeq_out &);
    CORBA_InterfaceDefSeq_out &operator= (const CORBA_InterfaceDefSeq_out &);
    CORBA_InterfaceDefSeq_out &operator= (CORBA_InterfaceDefSeq *);
    operator CORBA_InterfaceDefSeq *&();
    CORBA_InterfaceDefSeq *&ptr (void);
    CORBA_InterfaceDefSeq *operator-> (void);
    TAO_Object_Manager<CORBA_InterfaceDef,CORBA_InterfaceDef_var> operator[] (CORBA::ULong index);

  private:
    CORBA_InterfaceDefSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_InterfaceDefSeq_var &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_VALUEDEF___VAR_CH_)
#define _CORBA_VALUEDEF___VAR_CH_

  class TAO_Export CORBA_ValueDef_var
  {
  public:
    CORBA_ValueDef_var (void); // default constructor
    CORBA_ValueDef_var (CORBA_ValueDef_ptr);
    CORBA_ValueDef_var (const CORBA_ValueDef_var &); // copy constructor
    ~CORBA_ValueDef_var (void); // destructor

    CORBA_ValueDef_var &operator= (CORBA_ValueDef_ptr);
    CORBA_ValueDef_var &operator= (const CORBA_ValueDef_var &);
    CORBA_ValueDef_ptr operator-> (void) const;

    operator const CORBA_ValueDef_ptr &() const;
    operator CORBA_ValueDef_ptr &();
    // in, inout, out, _retn
    CORBA_ValueDef_ptr in (void) const;
    CORBA_ValueDef_ptr &inout (void);
    CORBA_ValueDef_ptr &out (void);
    CORBA_ValueDef_ptr _retn (void);
    CORBA_ValueDef_ptr ptr (void) const;

  private:
    CORBA_ValueDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___OUT_CH_)
#define _CORBA_VALUEDEF___OUT_CH_

  class TAO_Export CORBA_ValueDef_out
  {
  public:
    CORBA_ValueDef_out (CORBA_ValueDef_ptr &);
    CORBA_ValueDef_out (CORBA_ValueDef_var &);
    CORBA_ValueDef_out (const CORBA_ValueDef_out &);
    CORBA_ValueDef_out &operator= (const CORBA_ValueDef_out &);
    CORBA_ValueDef_out &operator= (const CORBA_ValueDef_var &);
    CORBA_ValueDef_out &operator= (CORBA_ValueDef_ptr);
    operator CORBA_ValueDef_ptr &();
    CORBA_ValueDef_ptr &ptr (void);
    CORBA_ValueDef_ptr operator-> (void);

  private:
    CORBA_ValueDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CH_

    class _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_ValueDef* *value,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq &rhs);
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq &rhs);
      TAO_Object_Manager<CORBA::ValueDef,CORBA::ValueDef_var> operator[] (CORBA::ULong index) const;
      static CORBA_ValueDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_ValueDef **buffer);
      // The Base_Sequence functions, please see tao/Sequence.h
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_ValueDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_ValueDef* *get_buffer (void) const;
      virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
      virtual void _downcast (
          void* target,
          CORBA_Object *src,
          CORBA_Environment &ACE_TRY_ENV =
            TAO_default_environment ()
        );
      virtual CORBA_Object* _upcast (void *src) const;

    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_VALUEDEFSEQ_CH_)
#define _CORBA_VALUEDEFSEQ_CH_

  // *************************************************************
  // ValueDefSeq
  // *************************************************************

  class TAO_Export CORBA_ValueDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_ValueDef,CORBA_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ValueDefSeq (void); // default ctor
    CORBA_ValueDefSeq (CORBA::ULong max); // uses max size
    CORBA_ValueDefSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ValueDef_ptr *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ValueDefSeq (const CORBA_ValueDefSeq &); // copy ctor
    ~CORBA_ValueDefSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEFSEQ___VAR_CH_)
#define _CORBA_VALUEDEFSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ValueDefSeq_var
  // *************************************************************

  class TAO_Export CORBA_ValueDefSeq_var
  {
  public:
    CORBA_ValueDefSeq_var (void); // default constructor
    CORBA_ValueDefSeq_var (CORBA_ValueDefSeq *);
    CORBA_ValueDefSeq_var (const CORBA_ValueDefSeq_var &); // copy constructor
    ~CORBA_ValueDefSeq_var (void); // destructor

    CORBA_ValueDefSeq_var &operator= (CORBA_ValueDefSeq *);
    CORBA_ValueDefSeq_var &operator= (const CORBA_ValueDefSeq_var &);
    CORBA_ValueDefSeq *operator-> (void);
    const CORBA_ValueDefSeq *operator-> (void) const;

    operator const CORBA_ValueDefSeq &() const;
    operator CORBA_ValueDefSeq &();
    operator CORBA_ValueDefSeq &() const;
    TAO_Object_Manager<CORBA_ValueDef,CORBA_ValueDef_var> operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ValueDefSeq &in (void) const;
    CORBA_ValueDefSeq &inout (void);
    CORBA_ValueDefSeq *&out (void);
    CORBA_ValueDefSeq *_retn (void);
    CORBA_ValueDefSeq *ptr (void) const;

  private:
    CORBA_ValueDefSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEFSEQ___OUT_CH_)
#define _CORBA_VALUEDEFSEQ___OUT_CH_

  class TAO_Export CORBA_ValueDefSeq_out
  {
  public:
    CORBA_ValueDefSeq_out (CORBA_ValueDefSeq *&);
    CORBA_ValueDefSeq_out (CORBA_ValueDefSeq_var &);
    CORBA_ValueDefSeq_out (const CORBA_ValueDefSeq_out &);
    CORBA_ValueDefSeq_out &operator= (const CORBA_ValueDefSeq_out &);
    CORBA_ValueDefSeq_out &operator= (CORBA_ValueDefSeq *);
    operator CORBA_ValueDefSeq *&();
    CORBA_ValueDefSeq *&ptr (void);
    CORBA_ValueDefSeq *operator-> (void);
    TAO_Object_Manager<CORBA_ValueDef,CORBA_ValueDef_var> operator[] (CORBA::ULong index);

  private:
    CORBA_ValueDefSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ValueDefSeq_var &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_VALUEBOXDEF___VAR_CH_)
#define _CORBA_VALUEBOXDEF___VAR_CH_

  class TAO_Export CORBA_ValueBoxDef_var
  {
  public:
    CORBA_ValueBoxDef_var (void); // default constructor
    CORBA_ValueBoxDef_var (CORBA_ValueBoxDef_ptr);
    CORBA_ValueBoxDef_var (const CORBA_ValueBoxDef_var &); // copy constructor
    ~CORBA_ValueBoxDef_var (void); // destructor

    CORBA_ValueBoxDef_var &operator= (CORBA_ValueBoxDef_ptr);
    CORBA_ValueBoxDef_var &operator= (const CORBA_ValueBoxDef_var &);
    CORBA_ValueBoxDef_ptr operator-> (void) const;

    operator const CORBA_ValueBoxDef_ptr &() const;
    operator CORBA_ValueBoxDef_ptr &();
    // in, inout, out, _retn
    CORBA_ValueBoxDef_ptr in (void) const;
    CORBA_ValueBoxDef_ptr &inout (void);
    CORBA_ValueBoxDef_ptr &out (void);
    CORBA_ValueBoxDef_ptr _retn (void);
    CORBA_ValueBoxDef_ptr ptr (void) const;

  private:
    CORBA_ValueBoxDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___OUT_CH_)
#define _CORBA_VALUEBOXDEF___OUT_CH_

  class TAO_Export CORBA_ValueBoxDef_out
  {
  public:
    CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_ptr &);
    CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_var &);
    CORBA_ValueBoxDef_out (const CORBA_ValueBoxDef_out &);
    CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_out &);
    CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_var &);
    CORBA_ValueBoxDef_out &operator= (CORBA_ValueBoxDef_ptr);
    operator CORBA_ValueBoxDef_ptr &();
    CORBA_ValueBoxDef_ptr &ptr (void);
    CORBA_ValueBoxDef_ptr operator-> (void);

  private:
    CORBA_ValueBoxDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CH_

    class _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_Contained* *value,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq(const _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq &rhs);
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq &rhs);
      TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var> operator[] (CORBA::ULong index) const;
      static CORBA_Contained **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_Contained **buffer);
      // The Base_Sequence functions, please see tao/Sequence.h
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_Contained* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_Contained* *get_buffer (void) const;
      virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
      virtual void _downcast (
          void* target,
          CORBA_Object *src,
          CORBA_Environment &ACE_TRY_ENV =
            TAO_default_environment ()
        );
      virtual CORBA_Object* _upcast (void *src) const;

    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_CONTAINEDSEQ_CH_)
#define _CORBA_CONTAINEDSEQ_CH_

  // *************************************************************
  // ContainedSeq
  // *************************************************************

  class TAO_Export CORBA_ContainedSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_Contained,CORBA_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ContainedSeq (void); // default ctor
    CORBA_ContainedSeq (CORBA::ULong max); // uses max size
    CORBA_ContainedSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_Contained_ptr *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ContainedSeq (const CORBA_ContainedSeq &); // copy ctor
    ~CORBA_ContainedSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINEDSEQ___VAR_CH_)
#define _CORBA_CONTAINEDSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ContainedSeq_var
  // *************************************************************

  class TAO_Export CORBA_ContainedSeq_var
  {
  public:
    CORBA_ContainedSeq_var (void); // default constructor
    CORBA_ContainedSeq_var (CORBA_ContainedSeq *);
    CORBA_ContainedSeq_var (const CORBA_ContainedSeq_var &); // copy constructor
    ~CORBA_ContainedSeq_var (void); // destructor

    CORBA_ContainedSeq_var &operator= (CORBA_ContainedSeq *);
    CORBA_ContainedSeq_var &operator= (const CORBA_ContainedSeq_var &);
    CORBA_ContainedSeq *operator-> (void);
    const CORBA_ContainedSeq *operator-> (void) const;

    operator const CORBA_ContainedSeq &() const;
    operator CORBA_ContainedSeq &();
    operator CORBA_ContainedSeq &() const;
    TAO_Object_Manager<CORBA_Contained,CORBA_Contained_var> operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ContainedSeq &in (void) const;
    CORBA_ContainedSeq &inout (void);
    CORBA_ContainedSeq *&out (void);
    CORBA_ContainedSeq *_retn (void);
    CORBA_ContainedSeq *ptr (void) const;

  private:
    CORBA_ContainedSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINEDSEQ___OUT_CH_)
#define _CORBA_CONTAINEDSEQ___OUT_CH_

  class  CORBA_ContainedSeq_out
  {
  public:
    CORBA_ContainedSeq_out (CORBA_ContainedSeq *&);
    CORBA_ContainedSeq_out (CORBA_ContainedSeq_var &);
    CORBA_ContainedSeq_out (const CORBA_ContainedSeq_out &);
    CORBA_ContainedSeq_out &operator= (const CORBA_ContainedSeq_out &);
    CORBA_ContainedSeq_out &operator= (CORBA_ContainedSeq *);
    operator CORBA_ContainedSeq *&();
    CORBA_ContainedSeq *&ptr (void);
    CORBA_ContainedSeq *operator-> (void);
    TAO_Object_Manager<CORBA_Contained,CORBA_Contained_var> operator[] (CORBA::ULong index);

  private:
    CORBA_ContainedSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ContainedSeq_var &);
  };


#endif /* end #if !defined */

  struct  CORBA_StructMember
  {
    TAO_String_Manager name;
    CORBA::TypeCode_var type;
    TAO_Object_Field_T<CORBA_IDLType,CORBA_IDLType_var> type_def;
  };

  class TAO_Export CORBA_StructMember_var
  {
  public:
    CORBA_StructMember_var (void); // default constructor
    CORBA_StructMember_var (CORBA_StructMember *);
    CORBA_StructMember_var (const CORBA_StructMember_var &); // copy constructor
    ~CORBA_StructMember_var (void); // destructor

    CORBA_StructMember_var &operator= (CORBA_StructMember *);
    CORBA_StructMember_var &operator= (const CORBA_StructMember_var &);
    CORBA_StructMember *operator-> (void);
    const CORBA_StructMember *operator-> (void) const;

    operator const CORBA_StructMember &() const;
    operator CORBA_StructMember &();
    operator CORBA_StructMember &() const;
    // in, inout, out, _retn
    const CORBA_StructMember &in (void) const;
    CORBA_StructMember &inout (void);
    CORBA_StructMember *&out (void);
    CORBA_StructMember *_retn (void);
    CORBA_StructMember *ptr (void) const;

  private:
    CORBA_StructMember *ptr_;
  };

  class TAO_Export CORBA_StructMember_out
  {
  public:
    CORBA_StructMember_out (CORBA_StructMember *&);
    CORBA_StructMember_out (CORBA_StructMember_var &);
    CORBA_StructMember_out (const CORBA_StructMember_out &);
    CORBA_StructMember_out &operator= (const CORBA_StructMember_out &);
    CORBA_StructMember_out &operator= (CORBA_StructMember *);
    operator CORBA_StructMember *&();
    CORBA_StructMember *&ptr (void);
    CORBA_StructMember *operator-> (void);

  private:
    CORBA_StructMember *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_StructMember_var &);
  };

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_StructMemberSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_StructMember *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (const _TAO_Unbounded_Sequence_CORBA_StructMemberSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_StructMemberSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void); // Dtor.
      // = Accessors.
      CORBA_StructMember &operator[] (CORBA::ULong i);
      const CORBA_StructMember &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_StructMember *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_StructMember *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_StructMember *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_StructMember *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_StructMember *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_STRUCTMEMBERSEQ_CH_)
#define _CORBA_STRUCTMEMBERSEQ_CH_

  // *************************************************************
  // StructMemberSeq
  // *************************************************************

  class TAO_Export CORBA_StructMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_StructMemberSeq (void); // default ctor
    CORBA_StructMemberSeq (CORBA::ULong max); // uses max size
    CORBA_StructMemberSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_StructMember *buffer,
      CORBA::Boolean release=0
    );
    CORBA_StructMemberSeq (const CORBA_StructMemberSeq &); // copy ctor
    ~CORBA_StructMemberSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTMEMBERSEQ___VAR_CH_)
#define _CORBA_STRUCTMEMBERSEQ___VAR_CH_

// *************************************************************
  // class CORBA::StructMemberSeq_var
  // *************************************************************

  class TAO_Export CORBA_StructMemberSeq_var
  {
  public:
    CORBA_StructMemberSeq_var (void); // default constructor
    CORBA_StructMemberSeq_var (CORBA_StructMemberSeq *);
    CORBA_StructMemberSeq_var (const CORBA_StructMemberSeq_var &); // copy constructor
    ~CORBA_StructMemberSeq_var (void); // destructor

    CORBA_StructMemberSeq_var &operator= (CORBA_StructMemberSeq *);
    CORBA_StructMemberSeq_var &operator= (const CORBA_StructMemberSeq_var &);
    CORBA_StructMemberSeq *operator-> (void);
    const CORBA_StructMemberSeq *operator-> (void) const;

    operator const CORBA_StructMemberSeq &() const;
    operator CORBA_StructMemberSeq &();
    operator CORBA_StructMemberSeq &() const;
    CORBA_StructMember &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_StructMemberSeq &in (void) const;
    CORBA_StructMemberSeq &inout (void);
    CORBA_StructMemberSeq *&out (void);
    CORBA_StructMemberSeq *_retn (void);
    CORBA_StructMemberSeq *ptr (void) const;

  private:
    CORBA_StructMemberSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTMEMBERSEQ___OUT_CH_)
#define _CORBA_STRUCTMEMBERSEQ___OUT_CH_

  class TAO_Export CORBA_StructMemberSeq_out
  {
  public:
    CORBA_StructMemberSeq_out (CORBA_StructMemberSeq *&);
    CORBA_StructMemberSeq_out (CORBA_StructMemberSeq_var &);
    CORBA_StructMemberSeq_out (const CORBA_StructMemberSeq_out &);
    CORBA_StructMemberSeq_out &operator= (const CORBA_StructMemberSeq_out &);
    CORBA_StructMemberSeq_out &operator= (CORBA_StructMemberSeq *);
    operator CORBA_StructMemberSeq *&();
    CORBA_StructMemberSeq *&ptr (void);
    CORBA_StructMemberSeq *operator-> (void);
    CORBA_StructMember &operator[] (CORBA::ULong index);

  private:
    CORBA_StructMemberSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_StructMemberSeq_var &);
  };


#endif /* end #if !defined */

  struct  CORBA_Initializer
  {
    CORBA_StructMemberSeq members;
  };

  class TAO_Export CORBA_Initializer_var
  {
  public:
    CORBA_Initializer_var (void); // default constructor
    CORBA_Initializer_var (CORBA_Initializer *);
    CORBA_Initializer_var (const CORBA_Initializer_var &); // copy constructor
    ~CORBA_Initializer_var (void); // destructor

    CORBA_Initializer_var &operator= (CORBA_Initializer *);
    CORBA_Initializer_var &operator= (const CORBA_Initializer_var &);
    CORBA_Initializer *operator-> (void);
    const CORBA_Initializer *operator-> (void) const;

    operator const CORBA_Initializer &() const;
    operator CORBA_Initializer &();
    operator CORBA_Initializer &() const;
    // in, inout, out, _retn
    const CORBA_Initializer &in (void) const;
    CORBA_Initializer &inout (void);
    CORBA_Initializer *&out (void);
    CORBA_Initializer *_retn (void);
    CORBA_Initializer *ptr (void) const;

  private:
    CORBA_Initializer *ptr_;
  };

  class TAO_Export CORBA_Initializer_out
  {
  public:
    CORBA_Initializer_out (CORBA_Initializer *&);
    CORBA_Initializer_out (CORBA_Initializer_var &);
    CORBA_Initializer_out (const CORBA_Initializer_out &);
    CORBA_Initializer_out &operator= (const CORBA_Initializer_out &);
    CORBA_Initializer_out &operator= (CORBA_Initializer *);
    operator CORBA_Initializer *&();
    CORBA_Initializer *&ptr (void);
    CORBA_Initializer *operator-> (void);

  private:
    CORBA_Initializer *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_Initializer_var &);
  };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_InitializerSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_Initializer *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (const _TAO_Unbounded_Sequence_CORBA_InitializerSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_InitializerSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_InitializerSeq (void); // Dtor.
      // = Accessors.
      CORBA_Initializer &operator[] (CORBA::ULong i);
      const CORBA_Initializer &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_Initializer *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_Initializer *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_Initializer *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_Initializer *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_Initializer *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_INITIALIZERSEQ_CH_)
#define _CORBA_INITIALIZERSEQ_CH_

  // *************************************************************
  // InitializerSeq
  // *************************************************************

  class TAO_Export CORBA_InitializerSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_InitializerSeq (void); // default ctor
    CORBA_InitializerSeq (CORBA::ULong max); // uses max size
    CORBA_InitializerSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_Initializer *buffer,
      CORBA::Boolean release=0
    );
    CORBA_InitializerSeq (const CORBA_InitializerSeq &); // copy ctor
    ~CORBA_InitializerSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_INITIALIZERSEQ___VAR_CH_)
#define _CORBA_INITIALIZERSEQ___VAR_CH_

// *************************************************************
  // class CORBA::InitializerSeq_var
  // *************************************************************

  class TAO_Export CORBA_InitializerSeq_var
  {
  public:
    CORBA_InitializerSeq_var (void); // default constructor
    CORBA_InitializerSeq_var (CORBA_InitializerSeq *);
    CORBA_InitializerSeq_var (const CORBA_InitializerSeq_var &); // copy constructor
    ~CORBA_InitializerSeq_var (void); // destructor

    CORBA_InitializerSeq_var &operator= (CORBA_InitializerSeq *);
    CORBA_InitializerSeq_var &operator= (const CORBA_InitializerSeq_var &);
    CORBA_InitializerSeq *operator-> (void);
    const CORBA_InitializerSeq *operator-> (void) const;

    operator const CORBA_InitializerSeq &() const;
    operator CORBA_InitializerSeq &();
    operator CORBA_InitializerSeq &() const;
    CORBA_Initializer &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_InitializerSeq &in (void) const;
    CORBA_InitializerSeq &inout (void);
    CORBA_InitializerSeq *&out (void);
    CORBA_InitializerSeq *_retn (void);
    CORBA_InitializerSeq *ptr (void) const;

  private:
    CORBA_InitializerSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_INITIALIZERSEQ___OUT_CH_)
#define _CORBA_INITIALIZERSEQ___OUT_CH_

  class TAO_Export CORBA_InitializerSeq_out
  {
  public:
    CORBA_InitializerSeq_out (CORBA_InitializerSeq *&);
    CORBA_InitializerSeq_out (CORBA_InitializerSeq_var &);
    CORBA_InitializerSeq_out (const CORBA_InitializerSeq_out &);
    CORBA_InitializerSeq_out &operator= (const CORBA_InitializerSeq_out &);
    CORBA_InitializerSeq_out &operator= (CORBA_InitializerSeq *);
    operator CORBA_InitializerSeq *&();
    CORBA_InitializerSeq *&ptr (void);
    CORBA_InitializerSeq *operator-> (void);
    CORBA_Initializer &operator[] (CORBA::ULong index);

  private:
    CORBA_InitializerSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_InitializerSeq_var &);
  };


#endif /* end #if !defined */

  struct  CORBA_UnionMember
  {
    TAO_String_Manager name;
    CORBA::Any label;
    CORBA::TypeCode_var type;
    TAO_Object_Field_T<CORBA_IDLType,CORBA_IDLType_var> type_def;
  };

  class TAO_Export CORBA_UnionMember_var
  {
  public:
    CORBA_UnionMember_var (void); // default constructor
    CORBA_UnionMember_var (CORBA_UnionMember *);
    CORBA_UnionMember_var (const CORBA_UnionMember_var &); // copy constructor
    ~CORBA_UnionMember_var (void); // destructor

    CORBA_UnionMember_var &operator= (CORBA_UnionMember *);
    CORBA_UnionMember_var &operator= (const CORBA_UnionMember_var &);
    CORBA_UnionMember *operator-> (void);
    const CORBA_UnionMember *operator-> (void) const;

    operator const CORBA_UnionMember &() const;
    operator CORBA_UnionMember &();
    operator CORBA_UnionMember &() const;
    // in, inout, out, _retn
    const CORBA_UnionMember &in (void) const;
    CORBA_UnionMember &inout (void);
    CORBA_UnionMember *&out (void);
    CORBA_UnionMember *_retn (void);
    CORBA_UnionMember *ptr (void) const;

  private:
    CORBA_UnionMember *ptr_;
  };

  class TAO_Export CORBA_UnionMember_out
  {
  public:
    CORBA_UnionMember_out (CORBA_UnionMember *&);
    CORBA_UnionMember_out (CORBA_UnionMember_var &);
    CORBA_UnionMember_out (const CORBA_UnionMember_out &);
    CORBA_UnionMember_out &operator= (const CORBA_UnionMember_out &);
    CORBA_UnionMember_out &operator= (CORBA_UnionMember *);
    operator CORBA_UnionMember *&();
    CORBA_UnionMember *&ptr (void);
    CORBA_UnionMember *operator-> (void);

  private:
    CORBA_UnionMember *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_UnionMember_var &);
  };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_UnionMember *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (const _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void); // Dtor.
      // = Accessors.
      CORBA_UnionMember &operator[] (CORBA::ULong i);
      const CORBA_UnionMember &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_UnionMember *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_UnionMember *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_UnionMember *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_UnionMember *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_UnionMember *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_UNIONMEMBERSEQ_CH_)
#define _CORBA_UNIONMEMBERSEQ_CH_

  // *************************************************************
  // UnionMemberSeq
  // *************************************************************

  class TAO_Export CORBA_UnionMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_UnionMemberSeq (void); // default ctor
    CORBA_UnionMemberSeq (CORBA::ULong max); // uses max size
    CORBA_UnionMemberSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_UnionMember *buffer,
      CORBA::Boolean release=0
    );
    CORBA_UnionMemberSeq (const CORBA_UnionMemberSeq &); // copy ctor
    ~CORBA_UnionMemberSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_UNIONMEMBERSEQ___VAR_CH_)
#define _CORBA_UNIONMEMBERSEQ___VAR_CH_

// *************************************************************
  // class CORBA::UnionMemberSeq_var
  // *************************************************************

  class TAO_Export CORBA_UnionMemberSeq_var
  {
  public:
    CORBA_UnionMemberSeq_var (void); // default constructor
    CORBA_UnionMemberSeq_var (CORBA_UnionMemberSeq *);
    CORBA_UnionMemberSeq_var (const CORBA_UnionMemberSeq_var &); // copy constructor
    ~CORBA_UnionMemberSeq_var (void); // destructor

    CORBA_UnionMemberSeq_var &operator= (CORBA_UnionMemberSeq *);
    CORBA_UnionMemberSeq_var &operator= (const CORBA_UnionMemberSeq_var &);
    CORBA_UnionMemberSeq *operator-> (void);
    const CORBA_UnionMemberSeq *operator-> (void) const;

    operator const CORBA_UnionMemberSeq &() const;
    operator CORBA_UnionMemberSeq &();
    operator CORBA_UnionMemberSeq &() const;
    CORBA_UnionMember &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_UnionMemberSeq &in (void) const;
    CORBA_UnionMemberSeq &inout (void);
    CORBA_UnionMemberSeq *&out (void);
    CORBA_UnionMemberSeq *_retn (void);
    CORBA_UnionMemberSeq *ptr (void) const;

  private:
    CORBA_UnionMemberSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONMEMBERSEQ___OUT_CH_)
#define _CORBA_UNIONMEMBERSEQ___OUT_CH_

  class TAO_Export CORBA_UnionMemberSeq_out
  {
  public:
    CORBA_UnionMemberSeq_out (CORBA_UnionMemberSeq *&);
    CORBA_UnionMemberSeq_out (CORBA_UnionMemberSeq_var &);
    CORBA_UnionMemberSeq_out (const CORBA_UnionMemberSeq_out &);
    CORBA_UnionMemberSeq_out &operator= (const CORBA_UnionMemberSeq_out &);
    CORBA_UnionMemberSeq_out &operator= (CORBA_UnionMemberSeq *);
    operator CORBA_UnionMemberSeq *&();
    CORBA_UnionMemberSeq *&ptr (void);
    CORBA_UnionMemberSeq *operator-> (void);
    CORBA_UnionMember &operator[] (CORBA::ULong index);

  private:
    CORBA_UnionMemberSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_UnionMemberSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ_CH_)
#define _CORBA_ENUMMEMBERSEQ_CH_

  // *************************************************************
  // EnumMemberSeq
  // *************************************************************

  class TAO_Export CORBA_EnumMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_EnumMemberSeq (void); // default ctor
    CORBA_EnumMemberSeq (CORBA::ULong max); // uses max size
    CORBA_EnumMemberSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      char * *buffer,
      CORBA::Boolean release=0
    );
    CORBA_EnumMemberSeq (const CORBA_EnumMemberSeq &); // copy ctor
    ~CORBA_EnumMemberSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ___VAR_CH_)
#define _CORBA_ENUMMEMBERSEQ___VAR_CH_

// *************************************************************
  // class CORBA::EnumMemberSeq_var
  // *************************************************************

  class TAO_Export CORBA_EnumMemberSeq_var
  {
  public:
    CORBA_EnumMemberSeq_var (void); // default constructor
    CORBA_EnumMemberSeq_var (CORBA_EnumMemberSeq *);
    CORBA_EnumMemberSeq_var (const CORBA_EnumMemberSeq_var &); // copy constructor
    ~CORBA_EnumMemberSeq_var (void); // destructor

    CORBA_EnumMemberSeq_var &operator= (CORBA_EnumMemberSeq *);
    CORBA_EnumMemberSeq_var &operator= (const CORBA_EnumMemberSeq_var &);
    CORBA_EnumMemberSeq *operator-> (void);
    const CORBA_EnumMemberSeq *operator-> (void) const;

    operator const CORBA_EnumMemberSeq &() const;
    operator CORBA_EnumMemberSeq &();
    operator CORBA_EnumMemberSeq &() const;
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_EnumMemberSeq &in (void) const;
    CORBA_EnumMemberSeq &inout (void);
    CORBA_EnumMemberSeq *&out (void);
    CORBA_EnumMemberSeq *_retn (void);
    CORBA_EnumMemberSeq *ptr (void) const;

  private:
    CORBA_EnumMemberSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ___OUT_CH_)
#define _CORBA_ENUMMEMBERSEQ___OUT_CH_

  class TAO_Export CORBA_EnumMemberSeq_out
  {
  public:
    CORBA_EnumMemberSeq_out (CORBA_EnumMemberSeq *&);
    CORBA_EnumMemberSeq_out (CORBA_EnumMemberSeq_var &);
    CORBA_EnumMemberSeq_out (const CORBA_EnumMemberSeq_out &);
    CORBA_EnumMemberSeq_out &operator= (const CORBA_EnumMemberSeq_out &);
    CORBA_EnumMemberSeq_out &operator= (CORBA_EnumMemberSeq *);
    operator CORBA_EnumMemberSeq *&();
    CORBA_EnumMemberSeq *&ptr (void);
    CORBA_EnumMemberSeq *operator-> (void);
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  private:
    CORBA_EnumMemberSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_EnumMemberSeq_var &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINER___VAR_CH_)
#define _CORBA_CONTAINER___VAR_CH_

  class TAO_Export CORBA_Container_var
  {
  public:
    CORBA_Container_var (void); // default constructor
    CORBA_Container_var (CORBA_Container_ptr);
    CORBA_Container_var (const CORBA_Container_var &); // copy constructor
    ~CORBA_Container_var (void); // destructor

    CORBA_Container_var &operator= (CORBA_Container_ptr);
    CORBA_Container_var &operator= (const CORBA_Container_var &);
    CORBA_Container_ptr operator-> (void) const;

    operator const CORBA_Container_ptr &() const;
    operator CORBA_Container_ptr &();
    // in, inout, out, _retn
    CORBA_Container_ptr in (void) const;
    CORBA_Container_ptr &inout (void);
    CORBA_Container_ptr &out (void);
    CORBA_Container_ptr _retn (void);
    CORBA_Container_ptr ptr (void) const;

  private:
    CORBA_Container_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER___OUT_CH_)
#define _CORBA_CONTAINER___OUT_CH_

  class TAO_Export CORBA_Container_out
  {
  public:
    CORBA_Container_out (CORBA_Container_ptr &);
    CORBA_Container_out (CORBA_Container_var &);
    CORBA_Container_out (const CORBA_Container_out &);
    CORBA_Container_out &operator= (const CORBA_Container_out &);
    CORBA_Container_out &operator= (const CORBA_Container_var &);
    CORBA_Container_out &operator= (CORBA_Container_ptr);
    operator CORBA_Container_ptr &();
    CORBA_Container_ptr &ptr (void);
    CORBA_Container_ptr operator-> (void);

  private:
    CORBA_Container_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER_CH_)
#define _CORBA_CONTAINER_CH_

class TAO_Export CORBA_Container: public virtual CORBA_IRObject
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_Container_ptr _ptr_type;
    typedef CORBA_Container_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_Container_ptr _duplicate (CORBA_Container_ptr obj);
    static CORBA_Container_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_Container_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_Container_ptr _nil (void)
      {
        return (CORBA::Container_ptr)0;
      }

    virtual CORBA_Contained_ptr lookup (
        const char * search_name,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ContainedSeq * contents (
        CORBA::DefinitionKind limit_type,
        CORBA::Boolean exclude_inherited,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ContainedSeq * lookup_name (
        const char * search_name,
        CORBA::Long levels_to_search,
        CORBA::DefinitionKind limit_type,
        CORBA::Boolean exclude_inherited,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    struct  Description
    {
      TAO_Object_Field_T<CORBA_Contained,CORBA_Contained_var> contained_object;
      CORBA::DefinitionKind kind;
      CORBA::Any value;
    };

    class  Description_var
    {
    public:
      Description_var (void); // default constructor
      Description_var (Description *);
      Description_var (const Description_var &); // copy constructor
      ~Description_var (void); // destructor

      Description_var &operator= (Description *);
      Description_var &operator= (const Description_var &);
      Description *operator-> (void);
      const Description *operator-> (void) const;

      operator const Description &() const;
      operator Description &();
      operator Description &() const;
      // in, inout, out, _retn
      const Description &in (void) const;
      Description &inout (void);
      Description *&out (void);
      Description *_retn (void);
      Description *ptr (void) const;

    private:
      Description *ptr_;
    };

    class  Description_out
    {
    public:
      Description_out (Description *&);
      Description_out (Description_var &);
      Description_out (const Description_out &);
      Description_out &operator= (const Description_out &);
      Description_out &operator= (Description *);
      operator Description *&();
      Description *&ptr (void);
      Description *operator-> (void);

    private:
      Description *&ptr_;
      // assignment from T_var not allowed
      void operator= (const Description_var &);
    };

    static CORBA::TypeCode_ptr _tc_Description;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CH_

      class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq : public TAO_Unbounded_Base_Sequence
      {
      public:
        // = Initialization and termination methods.

        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void); // Default constructor.
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (CORBA::ULong maximum);
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (CORBA::ULong maximum,
          CORBA::ULong length,
          Description *data,
          CORBA::Boolean release = 0);
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq &rhs);
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq &rhs);
        virtual ~_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void); // Dtor.
        // = Accessors.
        Description &operator[] (CORBA::ULong i);
        const Description &operator[] (CORBA::ULong i) const;
        // = Static operations.
        static Description *allocbuf (CORBA::ULong size);
        static void freebuf (Description *buffer);
        virtual void _allocate_buffer (CORBA::ULong length);
        virtual void _deallocate_buffer (void);
        // Implement the TAO_Base_Sequence methods (see Sequence.h)

        Description *get_buffer (CORBA::Boolean orphan = 0);
        const Description *get_buffer (void) const;
        void replace (CORBA::ULong max,
          CORBA::ULong length,
          Description *data,
          CORBA::Boolean release);
      };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ_CH_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ_CH_

    // *************************************************************
    // DescriptionSeq
    // *************************************************************

    class  DescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      DescriptionSeq (void); // default ctor
      DescriptionSeq (CORBA::ULong max); // uses max size
      DescriptionSeq (
        CORBA::ULong max,
        CORBA::ULong length,
        Description *buffer,
        CORBA::Boolean release=0
      );
      DescriptionSeq (const DescriptionSeq &); // copy ctor
      ~DescriptionSeq (void); // dtor
    };
    typedef DescriptionSeq *DescriptionSeq_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ___VAR_CH_

// *************************************************************
    // class CORBA::Container::DescriptionSeq_var
    // *************************************************************

    class  DescriptionSeq_var
    {
    public:
      DescriptionSeq_var (void); // default constructor
      DescriptionSeq_var (DescriptionSeq *);
      DescriptionSeq_var (const DescriptionSeq_var &); // copy constructor
      ~DescriptionSeq_var (void); // destructor

      DescriptionSeq_var &operator= (DescriptionSeq *);
      DescriptionSeq_var &operator= (const DescriptionSeq_var &);
      DescriptionSeq *operator-> (void);
      const DescriptionSeq *operator-> (void) const;

      operator const DescriptionSeq &() const;
      operator DescriptionSeq &();
      operator DescriptionSeq &() const;
      Description &operator[] (CORBA::ULong index);
      // in, inout, out, _retn
      const DescriptionSeq &in (void) const;
      DescriptionSeq &inout (void);
      DescriptionSeq *&out (void);
      DescriptionSeq *_retn (void);
      DescriptionSeq *ptr (void) const;

    private:
      DescriptionSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ___OUT_CH_

    class  DescriptionSeq_out
    {
    public:
      DescriptionSeq_out (DescriptionSeq *&);
      DescriptionSeq_out (DescriptionSeq_var &);
      DescriptionSeq_out (const DescriptionSeq_out &);
      DescriptionSeq_out &operator= (const DescriptionSeq_out &);
      DescriptionSeq_out &operator= (DescriptionSeq *);
      operator DescriptionSeq *&();
      DescriptionSeq *&ptr (void);
      DescriptionSeq *operator-> (void);
      Description &operator[] (CORBA::ULong index);

    private:
      DescriptionSeq *&ptr_;
      // assignment from T_var not allowed
      void operator= (const DescriptionSeq_var &);
    };


#endif /* end #if !defined */

    static CORBA::TypeCode_ptr _tc_DescriptionSeq;

    virtual DescriptionSeq * describe_contents (
        CORBA::DefinitionKind limit_type,
        CORBA::Boolean exclude_inherited,
        CORBA::Long max_returned_objs,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ModuleDef_ptr create_module (
        const char * id,
        const char * name,
        const char * version,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ConstantDef_ptr create_constant (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr type,
        const CORBA::Any & value,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_StructDef_ptr create_struct (
        const char * id,
        const char * name,
        const char * version,
        const CORBA_StructMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_UnionDef_ptr create_union (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr discriminator_type,
        const CORBA_UnionMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_EnumDef_ptr create_enum (
        const char * id,
        const char * name,
        const char * version,
        const CORBA_EnumMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_AliasDef_ptr create_alias (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr original_type,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_InterfaceDef_ptr create_interface (
        const char * id,
        const char * name,
        const char * version,
        const CORBA_InterfaceDefSeq & base_interfaces,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ValueDef_ptr create_value (
        const char * id,
        const char * name,
        const char * version,
        CORBA::Boolean is_custom,
        CORBA::Boolean is_abstract,
        CORBA_ValueDef_ptr base_value,
        CORBA::Boolean is_truncatable,
        const CORBA_ValueDefSeq & abstract_base_values,
        CORBA_InterfaceDef_ptr supported_interface,
        const CORBA_InitializerSeq & initializers,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ValueBoxDef_ptr create_value_box (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr original_type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ExceptionDef_ptr create_exception (
        const char * id,
        const char * name,
        const char * version,
        const CORBA_StructMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_Container (void);
    CORBA_Container (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_Container (void);
  private:
    CORBA_Container (const CORBA_Container &);
    void operator= (const CORBA_Container &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_IDLTYPE___VAR_CH_)
#define _CORBA_IDLTYPE___VAR_CH_

  class TAO_Export CORBA_IDLType_var
  {
  public:
    CORBA_IDLType_var (void); // default constructor
    CORBA_IDLType_var (CORBA_IDLType_ptr);
    CORBA_IDLType_var (const CORBA_IDLType_var &); // copy constructor
    ~CORBA_IDLType_var (void); // destructor

    CORBA_IDLType_var &operator= (CORBA_IDLType_ptr);
    CORBA_IDLType_var &operator= (const CORBA_IDLType_var &);
    CORBA_IDLType_ptr operator-> (void) const;

    operator const CORBA_IDLType_ptr &() const;
    operator CORBA_IDLType_ptr &();
    // in, inout, out, _retn
    CORBA_IDLType_ptr in (void) const;
    CORBA_IDLType_ptr &inout (void);
    CORBA_IDLType_ptr &out (void);
    CORBA_IDLType_ptr _retn (void);
    CORBA_IDLType_ptr ptr (void) const;

  private:
    CORBA_IDLType_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_IDLTYPE___OUT_CH_)
#define _CORBA_IDLTYPE___OUT_CH_

  class TAO_Export CORBA_IDLType_out
  {
  public:
    CORBA_IDLType_out (CORBA_IDLType_ptr &);
    CORBA_IDLType_out (CORBA_IDLType_var &);
    CORBA_IDLType_out (const CORBA_IDLType_out &);
    CORBA_IDLType_out &operator= (const CORBA_IDLType_out &);
    CORBA_IDLType_out &operator= (const CORBA_IDLType_var &);
    CORBA_IDLType_out &operator= (CORBA_IDLType_ptr);
    operator CORBA_IDLType_ptr &();
    CORBA_IDLType_ptr &ptr (void);
    CORBA_IDLType_ptr operator-> (void);

  private:
    CORBA_IDLType_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_IDLTYPE_CH_)
#define _CORBA_IDLTYPE_CH_

class TAO_Export CORBA_IDLType: public virtual CORBA_IRObject
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_IDLType_ptr _ptr_type;
    typedef CORBA_IDLType_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_IDLType_ptr _duplicate (CORBA_IDLType_ptr obj);
    static CORBA_IDLType_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_IDLType_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_IDLType_ptr _nil (void)
      {
        return (CORBA::IDLType_ptr)0;
      }

    virtual CORBA::TypeCode_ptr type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_IDLType (void);
    CORBA_IDLType (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_IDLType (void);
  private:
    CORBA_IDLType (const CORBA_IDLType &);
    void operator= (const CORBA_IDLType &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEDEF___VAR_CH_)
#define _CORBA_PRIMITIVEDEF___VAR_CH_

  class TAO_Export CORBA_PrimitiveDef_var
  {
  public:
    CORBA_PrimitiveDef_var (void); // default constructor
    CORBA_PrimitiveDef_var (CORBA_PrimitiveDef_ptr);
    CORBA_PrimitiveDef_var (const CORBA_PrimitiveDef_var &); // copy constructor
    ~CORBA_PrimitiveDef_var (void); // destructor

    CORBA_PrimitiveDef_var &operator= (CORBA_PrimitiveDef_ptr);
    CORBA_PrimitiveDef_var &operator= (const CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_ptr operator-> (void) const;

    operator const CORBA_PrimitiveDef_ptr &() const;
    operator CORBA_PrimitiveDef_ptr &();
    // in, inout, out, _retn
    CORBA_PrimitiveDef_ptr in (void) const;
    CORBA_PrimitiveDef_ptr &inout (void);
    CORBA_PrimitiveDef_ptr &out (void);
    CORBA_PrimitiveDef_ptr _retn (void);
    CORBA_PrimitiveDef_ptr ptr (void) const;

  private:
    CORBA_PrimitiveDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF___OUT_CH_)
#define _CORBA_PRIMITIVEDEF___OUT_CH_

  class TAO_Export CORBA_PrimitiveDef_out
  {
  public:
    CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_ptr &);
    CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_out (const CORBA_PrimitiveDef_out &);
    CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_out &);
    CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_out &operator= (CORBA_PrimitiveDef_ptr);
    operator CORBA_PrimitiveDef_ptr &();
    CORBA_PrimitiveDef_ptr &ptr (void);
    CORBA_PrimitiveDef_ptr operator-> (void);

  private:
    CORBA_PrimitiveDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_STRINGDEF___VAR_CH_)
#define _CORBA_STRINGDEF___VAR_CH_

  class TAO_Export CORBA_StringDef_var
  {
  public:
    CORBA_StringDef_var (void); // default constructor
    CORBA_StringDef_var (CORBA_StringDef_ptr);
    CORBA_StringDef_var (const CORBA_StringDef_var &); // copy constructor
    ~CORBA_StringDef_var (void); // destructor

    CORBA_StringDef_var &operator= (CORBA_StringDef_ptr);
    CORBA_StringDef_var &operator= (const CORBA_StringDef_var &);
    CORBA_StringDef_ptr operator-> (void) const;

    operator const CORBA_StringDef_ptr &() const;
    operator CORBA_StringDef_ptr &();
    // in, inout, out, _retn
    CORBA_StringDef_ptr in (void) const;
    CORBA_StringDef_ptr &inout (void);
    CORBA_StringDef_ptr &out (void);
    CORBA_StringDef_ptr _retn (void);
    CORBA_StringDef_ptr ptr (void) const;

  private:
    CORBA_StringDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___OUT_CH_)
#define _CORBA_STRINGDEF___OUT_CH_

  class TAO_Export CORBA_StringDef_out
  {
  public:
    CORBA_StringDef_out (CORBA_StringDef_ptr &);
    CORBA_StringDef_out (CORBA_StringDef_var &);
    CORBA_StringDef_out (const CORBA_StringDef_out &);
    CORBA_StringDef_out &operator= (const CORBA_StringDef_out &);
    CORBA_StringDef_out &operator= (const CORBA_StringDef_var &);
    CORBA_StringDef_out &operator= (CORBA_StringDef_ptr);
    operator CORBA_StringDef_ptr &();
    CORBA_StringDef_ptr &ptr (void);
    CORBA_StringDef_ptr operator-> (void);

  private:
    CORBA_StringDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCEDEF___VAR_CH_)
#define _CORBA_SEQUENCEDEF___VAR_CH_

  class TAO_Export CORBA_SequenceDef_var
  {
  public:
    CORBA_SequenceDef_var (void); // default constructor
    CORBA_SequenceDef_var (CORBA_SequenceDef_ptr);
    CORBA_SequenceDef_var (const CORBA_SequenceDef_var &); // copy constructor
    ~CORBA_SequenceDef_var (void); // destructor

    CORBA_SequenceDef_var &operator= (CORBA_SequenceDef_ptr);
    CORBA_SequenceDef_var &operator= (const CORBA_SequenceDef_var &);
    CORBA_SequenceDef_ptr operator-> (void) const;

    operator const CORBA_SequenceDef_ptr &() const;
    operator CORBA_SequenceDef_ptr &();
    // in, inout, out, _retn
    CORBA_SequenceDef_ptr in (void) const;
    CORBA_SequenceDef_ptr &inout (void);
    CORBA_SequenceDef_ptr &out (void);
    CORBA_SequenceDef_ptr _retn (void);
    CORBA_SequenceDef_ptr ptr (void) const;

  private:
    CORBA_SequenceDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF___OUT_CH_)
#define _CORBA_SEQUENCEDEF___OUT_CH_

  class TAO_Export CORBA_SequenceDef_out
  {
  public:
    CORBA_SequenceDef_out (CORBA_SequenceDef_ptr &);
    CORBA_SequenceDef_out (CORBA_SequenceDef_var &);
    CORBA_SequenceDef_out (const CORBA_SequenceDef_out &);
    CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_out &);
    CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_var &);
    CORBA_SequenceDef_out &operator= (CORBA_SequenceDef_ptr);
    operator CORBA_SequenceDef_ptr &();
    CORBA_SequenceDef_ptr &ptr (void);
    CORBA_SequenceDef_ptr operator-> (void);

  private:
    CORBA_SequenceDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_ARRAYDEF___VAR_CH_)
#define _CORBA_ARRAYDEF___VAR_CH_

  class TAO_Export CORBA_ArrayDef_var
  {
  public:
    CORBA_ArrayDef_var (void); // default constructor
    CORBA_ArrayDef_var (CORBA_ArrayDef_ptr);
    CORBA_ArrayDef_var (const CORBA_ArrayDef_var &); // copy constructor
    ~CORBA_ArrayDef_var (void); // destructor

    CORBA_ArrayDef_var &operator= (CORBA_ArrayDef_ptr);
    CORBA_ArrayDef_var &operator= (const CORBA_ArrayDef_var &);
    CORBA_ArrayDef_ptr operator-> (void) const;

    operator const CORBA_ArrayDef_ptr &() const;
    operator CORBA_ArrayDef_ptr &();
    // in, inout, out, _retn
    CORBA_ArrayDef_ptr in (void) const;
    CORBA_ArrayDef_ptr &inout (void);
    CORBA_ArrayDef_ptr &out (void);
    CORBA_ArrayDef_ptr _retn (void);
    CORBA_ArrayDef_ptr ptr (void) const;

  private:
    CORBA_ArrayDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___OUT_CH_)
#define _CORBA_ARRAYDEF___OUT_CH_

  class TAO_Export CORBA_ArrayDef_out
  {
  public:
    CORBA_ArrayDef_out (CORBA_ArrayDef_ptr &);
    CORBA_ArrayDef_out (CORBA_ArrayDef_var &);
    CORBA_ArrayDef_out (const CORBA_ArrayDef_out &);
    CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_out &);
    CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_var &);
    CORBA_ArrayDef_out &operator= (CORBA_ArrayDef_ptr);
    operator CORBA_ArrayDef_ptr &();
    CORBA_ArrayDef_ptr &ptr (void);
    CORBA_ArrayDef_ptr operator-> (void);

  private:
    CORBA_ArrayDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_WSTRINGDEF___VAR_CH_)
#define _CORBA_WSTRINGDEF___VAR_CH_

  class TAO_Export CORBA_WstringDef_var
  {
  public:
    CORBA_WstringDef_var (void); // default constructor
    CORBA_WstringDef_var (CORBA_WstringDef_ptr);
    CORBA_WstringDef_var (const CORBA_WstringDef_var &); // copy constructor
    ~CORBA_WstringDef_var (void); // destructor

    CORBA_WstringDef_var &operator= (CORBA_WstringDef_ptr);
    CORBA_WstringDef_var &operator= (const CORBA_WstringDef_var &);
    CORBA_WstringDef_ptr operator-> (void) const;

    operator const CORBA_WstringDef_ptr &() const;
    operator CORBA_WstringDef_ptr &();
    // in, inout, out, _retn
    CORBA_WstringDef_ptr in (void) const;
    CORBA_WstringDef_ptr &inout (void);
    CORBA_WstringDef_ptr &out (void);
    CORBA_WstringDef_ptr _retn (void);
    CORBA_WstringDef_ptr ptr (void) const;

  private:
    CORBA_WstringDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF___OUT_CH_)
#define _CORBA_WSTRINGDEF___OUT_CH_

  class TAO_Export CORBA_WstringDef_out
  {
  public:
    CORBA_WstringDef_out (CORBA_WstringDef_ptr &);
    CORBA_WstringDef_out (CORBA_WstringDef_var &);
    CORBA_WstringDef_out (const CORBA_WstringDef_out &);
    CORBA_WstringDef_out &operator= (const CORBA_WstringDef_out &);
    CORBA_WstringDef_out &operator= (const CORBA_WstringDef_var &);
    CORBA_WstringDef_out &operator= (CORBA_WstringDef_ptr);
    operator CORBA_WstringDef_ptr &();
    CORBA_WstringDef_ptr &ptr (void);
    CORBA_WstringDef_ptr operator-> (void);

  private:
    CORBA_WstringDef_ptr &ptr_;
  };


#endif /* end #if !defined */

#if !defined (_CORBA_FIXEDDEF___VAR_CH_)
#define _CORBA_FIXEDDEF___VAR_CH_

  class TAO_Export CORBA_FixedDef_var
  {
  public:
    CORBA_FixedDef_var (void); // default constructor
    CORBA_FixedDef_var (CORBA_FixedDef_ptr);
    CORBA_FixedDef_var (const CORBA_FixedDef_var &); // copy constructor
    ~CORBA_FixedDef_var (void); // destructor

    CORBA_FixedDef_var &operator= (CORBA_FixedDef_ptr);
    CORBA_FixedDef_var &operator= (const CORBA_FixedDef_var &);
    CORBA_FixedDef_ptr operator-> (void) const;

    operator const CORBA_FixedDef_ptr &() const;
    operator CORBA_FixedDef_ptr &();
    // in, inout, out, _retn
    CORBA_FixedDef_ptr in (void) const;
    CORBA_FixedDef_ptr &inout (void);
    CORBA_FixedDef_ptr &out (void);
    CORBA_FixedDef_ptr _retn (void);
    CORBA_FixedDef_ptr ptr (void) const;

  private:
    CORBA_FixedDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___OUT_CH_)
#define _CORBA_FIXEDDEF___OUT_CH_

  class TAO_Export CORBA_FixedDef_out
  {
  public:
    CORBA_FixedDef_out (CORBA_FixedDef_ptr &);
    CORBA_FixedDef_out (CORBA_FixedDef_var &);
    CORBA_FixedDef_out (const CORBA_FixedDef_out &);
    CORBA_FixedDef_out &operator= (const CORBA_FixedDef_out &);
    CORBA_FixedDef_out &operator= (const CORBA_FixedDef_var &);
    CORBA_FixedDef_out &operator= (CORBA_FixedDef_ptr);
    operator CORBA_FixedDef_ptr &();
    CORBA_FixedDef_ptr &ptr (void);
    CORBA_FixedDef_ptr operator-> (void);

  private:
    CORBA_FixedDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY___VAR_CH_)
#define _CORBA_REPOSITORY___VAR_CH_

  class TAO_Export CORBA_Repository_var
  {
  public:
    CORBA_Repository_var (void); // default constructor
    CORBA_Repository_var (CORBA_Repository_ptr);
    CORBA_Repository_var (const CORBA_Repository_var &); // copy constructor
    ~CORBA_Repository_var (void); // destructor

    CORBA_Repository_var &operator= (CORBA_Repository_ptr);
    CORBA_Repository_var &operator= (const CORBA_Repository_var &);
    CORBA_Repository_ptr operator-> (void) const;

    operator const CORBA_Repository_ptr &() const;
    operator CORBA_Repository_ptr &();
    // in, inout, out, _retn
    CORBA_Repository_ptr in (void) const;
    CORBA_Repository_ptr &inout (void);
    CORBA_Repository_ptr &out (void);
    CORBA_Repository_ptr _retn (void);
    CORBA_Repository_ptr ptr (void) const;

  private:
    CORBA_Repository_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY___OUT_CH_)
#define _CORBA_REPOSITORY___OUT_CH_

  class TAO_Export CORBA_Repository_out
  {
  public:
    CORBA_Repository_out (CORBA_Repository_ptr &);
    CORBA_Repository_out (CORBA_Repository_var &);
    CORBA_Repository_out (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_var &);
    CORBA_Repository_out &operator= (CORBA_Repository_ptr);
    operator CORBA_Repository_ptr &();
    CORBA_Repository_ptr &ptr (void);
    CORBA_Repository_ptr operator-> (void);

  private:
    CORBA_Repository_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY_CH_)
#define _CORBA_REPOSITORY_CH_

class TAO_Export CORBA_Repository: public virtual CORBA_Container
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_Repository_ptr _ptr_type;
    typedef CORBA_Repository_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_Repository_ptr _duplicate (CORBA_Repository_ptr obj);
    static CORBA_Repository_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_Repository_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_Repository_ptr _nil (void)
      {
        return (CORBA::Repository_ptr)0;
      }

    virtual CORBA_Contained_ptr lookup_id (
        const char * search_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_PrimitiveDef_ptr get_primitive (
        CORBA::PrimitiveKind kind,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_StringDef_ptr create_string (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_WstringDef_ptr create_wstring (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_SequenceDef_ptr create_sequence (
        CORBA::ULong bound,
        CORBA_IDLType_ptr element_type,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ArrayDef_ptr create_array (
        CORBA::ULong length,
        CORBA_IDLType_ptr element_type,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_FixedDef_ptr create_fixed (
        CORBA::UShort digits,
        CORBA::Short scale,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_Repository (void);
    CORBA_Repository (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_Repository (void);
  private:
    CORBA_Repository (const CORBA_Repository &);
    void operator= (const CORBA_Repository &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_MODULEDEF___VAR_CH_)
#define _CORBA_MODULEDEF___VAR_CH_

  class TAO_Export CORBA_ModuleDef_var
  {
  public:
    CORBA_ModuleDef_var (void); // default constructor
    CORBA_ModuleDef_var (CORBA_ModuleDef_ptr);
    CORBA_ModuleDef_var (const CORBA_ModuleDef_var &); // copy constructor
    ~CORBA_ModuleDef_var (void); // destructor

    CORBA_ModuleDef_var &operator= (CORBA_ModuleDef_ptr);
    CORBA_ModuleDef_var &operator= (const CORBA_ModuleDef_var &);
    CORBA_ModuleDef_ptr operator-> (void) const;

    operator const CORBA_ModuleDef_ptr &() const;
    operator CORBA_ModuleDef_ptr &();
    // in, inout, out, _retn
    CORBA_ModuleDef_ptr in (void) const;
    CORBA_ModuleDef_ptr &inout (void);
    CORBA_ModuleDef_ptr &out (void);
    CORBA_ModuleDef_ptr _retn (void);
    CORBA_ModuleDef_ptr ptr (void) const;

  private:
    CORBA_ModuleDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF___OUT_CH_)
#define _CORBA_MODULEDEF___OUT_CH_

  class TAO_Export CORBA_ModuleDef_out
  {
  public:
    CORBA_ModuleDef_out (CORBA_ModuleDef_ptr &);
    CORBA_ModuleDef_out (CORBA_ModuleDef_var &);
    CORBA_ModuleDef_out (const CORBA_ModuleDef_out &);
    CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_out &);
    CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_var &);
    CORBA_ModuleDef_out &operator= (CORBA_ModuleDef_ptr);
    operator CORBA_ModuleDef_ptr &();
    CORBA_ModuleDef_ptr &ptr (void);
    CORBA_ModuleDef_ptr operator-> (void);

  private:
    CORBA_ModuleDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF_CH_)
#define _CORBA_MODULEDEF_CH_

class TAO_Export CORBA_ModuleDef: public virtual CORBA_Container, public virtual CORBA_Contained
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ModuleDef_ptr _ptr_type;
    typedef CORBA_ModuleDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ModuleDef_ptr _duplicate (CORBA_ModuleDef_ptr obj);
    static CORBA_ModuleDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ModuleDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ModuleDef_ptr _nil (void)
      {
        return (CORBA::ModuleDef_ptr)0;
      }

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ModuleDef (void);
    CORBA_ModuleDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ModuleDef (void);
  private:
    CORBA_ModuleDef (const CORBA_ModuleDef &);
    void operator= (const CORBA_ModuleDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_ModuleDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
  };

  class TAO_Export CORBA_ModuleDescription_var
  {
  public:
    CORBA_ModuleDescription_var (void); // default constructor
    CORBA_ModuleDescription_var (CORBA_ModuleDescription *);
    CORBA_ModuleDescription_var (const CORBA_ModuleDescription_var &); // copy constructor
    ~CORBA_ModuleDescription_var (void); // destructor

    CORBA_ModuleDescription_var &operator= (CORBA_ModuleDescription *);
    CORBA_ModuleDescription_var &operator= (const CORBA_ModuleDescription_var &);
    CORBA_ModuleDescription *operator-> (void);
    const CORBA_ModuleDescription *operator-> (void) const;

    operator const CORBA_ModuleDescription &() const;
    operator CORBA_ModuleDescription &();
    operator CORBA_ModuleDescription &() const;
    // in, inout, out, _retn
    const CORBA_ModuleDescription &in (void) const;
    CORBA_ModuleDescription &inout (void);
    CORBA_ModuleDescription *&out (void);
    CORBA_ModuleDescription *_retn (void);
    CORBA_ModuleDescription *ptr (void) const;

  private:
    CORBA_ModuleDescription *ptr_;
  };

  class TAO_Export CORBA_ModuleDescription_out
  {
  public:
    CORBA_ModuleDescription_out (CORBA_ModuleDescription *&);
    CORBA_ModuleDescription_out (CORBA_ModuleDescription_var &);
    CORBA_ModuleDescription_out (const CORBA_ModuleDescription_out &);
    CORBA_ModuleDescription_out &operator= (const CORBA_ModuleDescription_out &);
    CORBA_ModuleDescription_out &operator= (CORBA_ModuleDescription *);
    operator CORBA_ModuleDescription *&();
    CORBA_ModuleDescription *&ptr (void);
    CORBA_ModuleDescription *operator-> (void);

  private:
    CORBA_ModuleDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ModuleDescription_var &);
  };



#if !defined (_CORBA_CONSTANTDEF___VAR_CH_)
#define _CORBA_CONSTANTDEF___VAR_CH_

  class TAO_Export CORBA_ConstantDef_var
  {
  public:
    CORBA_ConstantDef_var (void); // default constructor
    CORBA_ConstantDef_var (CORBA_ConstantDef_ptr);
    CORBA_ConstantDef_var (const CORBA_ConstantDef_var &); // copy constructor
    ~CORBA_ConstantDef_var (void); // destructor

    CORBA_ConstantDef_var &operator= (CORBA_ConstantDef_ptr);
    CORBA_ConstantDef_var &operator= (const CORBA_ConstantDef_var &);
    CORBA_ConstantDef_ptr operator-> (void) const;

    operator const CORBA_ConstantDef_ptr &() const;
    operator CORBA_ConstantDef_ptr &();
    // in, inout, out, _retn
    CORBA_ConstantDef_ptr in (void) const;
    CORBA_ConstantDef_ptr &inout (void);
    CORBA_ConstantDef_ptr &out (void);
    CORBA_ConstantDef_ptr _retn (void);
    CORBA_ConstantDef_ptr ptr (void) const;

  private:
    CORBA_ConstantDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF___OUT_CH_)
#define _CORBA_CONSTANTDEF___OUT_CH_

  class TAO_Export CORBA_ConstantDef_out
  {
  public:
    CORBA_ConstantDef_out (CORBA_ConstantDef_ptr &);
    CORBA_ConstantDef_out (CORBA_ConstantDef_var &);
    CORBA_ConstantDef_out (const CORBA_ConstantDef_out &);
    CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_out &);
    CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_var &);
    CORBA_ConstantDef_out &operator= (CORBA_ConstantDef_ptr);
    operator CORBA_ConstantDef_ptr &();
    CORBA_ConstantDef_ptr &ptr (void);
    CORBA_ConstantDef_ptr operator-> (void);

  private:
    CORBA_ConstantDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF_CH_)
#define _CORBA_CONSTANTDEF_CH_

class TAO_Export CORBA_ConstantDef: public virtual CORBA_Contained
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ConstantDef_ptr _ptr_type;
    typedef CORBA_ConstantDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ConstantDef_ptr _duplicate (CORBA_ConstantDef_ptr obj);
    static CORBA_ConstantDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ConstantDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ConstantDef_ptr _nil (void)
      {
        return (CORBA::ConstantDef_ptr)0;
      }

    virtual CORBA::TypeCode_ptr type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void type_def (
        CORBA_IDLType_ptr type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Any * value (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void value (
        const CORBA::Any & value,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ConstantDef (void);
    CORBA_ConstantDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ConstantDef (void);
  private:
    CORBA_ConstantDef (const CORBA_ConstantDef &);
    void operator= (const CORBA_ConstantDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_ConstantDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var type;
    CORBA::Any value;
  };

  class TAO_Export CORBA_ConstantDescription_var
  {
  public:
    CORBA_ConstantDescription_var (void); // default constructor
    CORBA_ConstantDescription_var (CORBA_ConstantDescription *);
    CORBA_ConstantDescription_var (const CORBA_ConstantDescription_var &); // copy constructor
    ~CORBA_ConstantDescription_var (void); // destructor

    CORBA_ConstantDescription_var &operator= (CORBA_ConstantDescription *);
    CORBA_ConstantDescription_var &operator= (const CORBA_ConstantDescription_var &);
    CORBA_ConstantDescription *operator-> (void);
    const CORBA_ConstantDescription *operator-> (void) const;

    operator const CORBA_ConstantDescription &() const;
    operator CORBA_ConstantDescription &();
    operator CORBA_ConstantDescription &() const;
    // in, inout, out, _retn
    const CORBA_ConstantDescription &in (void) const;
    CORBA_ConstantDescription &inout (void);
    CORBA_ConstantDescription *&out (void);
    CORBA_ConstantDescription *_retn (void);
    CORBA_ConstantDescription *ptr (void) const;

  private:
    CORBA_ConstantDescription *ptr_;
  };

  class TAO_Export CORBA_ConstantDescription_out
  {
  public:
    CORBA_ConstantDescription_out (CORBA_ConstantDescription *&);
    CORBA_ConstantDescription_out (CORBA_ConstantDescription_var &);
    CORBA_ConstantDescription_out (const CORBA_ConstantDescription_out &);
    CORBA_ConstantDescription_out &operator= (const CORBA_ConstantDescription_out &);
    CORBA_ConstantDescription_out &operator= (CORBA_ConstantDescription *);
    operator CORBA_ConstantDescription *&();
    CORBA_ConstantDescription *&ptr (void);
    CORBA_ConstantDescription *operator-> (void);

  private:
    CORBA_ConstantDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ConstantDescription_var &);
  };

#if !defined (_CORBA_TYPEDEFDEF___VAR_CH_)
#define _CORBA_TYPEDEFDEF___VAR_CH_

  class TAO_Export CORBA_TypedefDef_var
  {
  public:
    CORBA_TypedefDef_var (void); // default constructor
    CORBA_TypedefDef_var (CORBA_TypedefDef_ptr);
    CORBA_TypedefDef_var (const CORBA_TypedefDef_var &); // copy constructor
    ~CORBA_TypedefDef_var (void); // destructor

    CORBA_TypedefDef_var &operator= (CORBA_TypedefDef_ptr);
    CORBA_TypedefDef_var &operator= (const CORBA_TypedefDef_var &);
    CORBA_TypedefDef_ptr operator-> (void) const;

    operator const CORBA_TypedefDef_ptr &() const;
    operator CORBA_TypedefDef_ptr &();
    // in, inout, out, _retn
    CORBA_TypedefDef_ptr in (void) const;
    CORBA_TypedefDef_ptr &inout (void);
    CORBA_TypedefDef_ptr &out (void);
    CORBA_TypedefDef_ptr _retn (void);
    CORBA_TypedefDef_ptr ptr (void) const;

  private:
    CORBA_TypedefDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_TYPEDEFDEF___OUT_CH_)
#define _CORBA_TYPEDEFDEF___OUT_CH_

  class TAO_Export CORBA_TypedefDef_out
  {
  public:
    CORBA_TypedefDef_out (CORBA_TypedefDef_ptr &);
    CORBA_TypedefDef_out (CORBA_TypedefDef_var &);
    CORBA_TypedefDef_out (const CORBA_TypedefDef_out &);
    CORBA_TypedefDef_out &operator= (const CORBA_TypedefDef_out &);
    CORBA_TypedefDef_out &operator= (const CORBA_TypedefDef_var &);
    CORBA_TypedefDef_out &operator= (CORBA_TypedefDef_ptr);
    operator CORBA_TypedefDef_ptr &();
    CORBA_TypedefDef_ptr &ptr (void);
    CORBA_TypedefDef_ptr operator-> (void);

  private:
    CORBA_TypedefDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_TYPEDEFDEF_CH_)
#define _CORBA_TYPEDEFDEF_CH_

class TAO_Export CORBA_TypedefDef: public virtual CORBA_Contained, public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_TypedefDef_ptr _ptr_type;
    typedef CORBA_TypedefDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_TypedefDef_ptr _duplicate (CORBA_TypedefDef_ptr obj);
    static CORBA_TypedefDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_TypedefDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_TypedefDef_ptr _nil (void)
      {
        return (CORBA::TypedefDef_ptr)0;
      }

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_TypedefDef (void);
    CORBA_TypedefDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_TypedefDef (void);
  private:
    CORBA_TypedefDef (const CORBA_TypedefDef &);
    void operator= (const CORBA_TypedefDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_TypeDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var type;
  };

  class TAO_Export CORBA_TypeDescription_var
  {
  public:
    CORBA_TypeDescription_var (void); // default constructor
    CORBA_TypeDescription_var (CORBA_TypeDescription *);
    CORBA_TypeDescription_var (const CORBA_TypeDescription_var &); // copy constructor
    ~CORBA_TypeDescription_var (void); // destructor

    CORBA_TypeDescription_var &operator= (CORBA_TypeDescription *);
    CORBA_TypeDescription_var &operator= (const CORBA_TypeDescription_var &);
    CORBA_TypeDescription *operator-> (void);
    const CORBA_TypeDescription *operator-> (void) const;

    operator const CORBA_TypeDescription &() const;
    operator CORBA_TypeDescription &();
    operator CORBA_TypeDescription &() const;
    // in, inout, out, _retn
    const CORBA_TypeDescription &in (void) const;
    CORBA_TypeDescription &inout (void);
    CORBA_TypeDescription *&out (void);
    CORBA_TypeDescription *_retn (void);
    CORBA_TypeDescription *ptr (void) const;

  private:
    CORBA_TypeDescription *ptr_;
  };

  class TAO_Export CORBA_TypeDescription_out
  {
  public:
    CORBA_TypeDescription_out (CORBA_TypeDescription *&);
    CORBA_TypeDescription_out (CORBA_TypeDescription_var &);
    CORBA_TypeDescription_out (const CORBA_TypeDescription_out &);
    CORBA_TypeDescription_out &operator= (const CORBA_TypeDescription_out &);
    CORBA_TypeDescription_out &operator= (CORBA_TypeDescription *);
    operator CORBA_TypeDescription *&();
    CORBA_TypeDescription *&ptr (void);
    CORBA_TypeDescription *operator-> (void);

  private:
    CORBA_TypeDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_TypeDescription_var &);
  };

#if !defined (_CORBA_STRUCTDEF___VAR_CH_)
#define _CORBA_STRUCTDEF___VAR_CH_

  class TAO_Export CORBA_StructDef_var
  {
  public:
    CORBA_StructDef_var (void); // default constructor
    CORBA_StructDef_var (CORBA_StructDef_ptr);
    CORBA_StructDef_var (const CORBA_StructDef_var &); // copy constructor
    ~CORBA_StructDef_var (void); // destructor

    CORBA_StructDef_var &operator= (CORBA_StructDef_ptr);
    CORBA_StructDef_var &operator= (const CORBA_StructDef_var &);
    CORBA_StructDef_ptr operator-> (void) const;

    operator const CORBA_StructDef_ptr &() const;
    operator CORBA_StructDef_ptr &();
    // in, inout, out, _retn
    CORBA_StructDef_ptr in (void) const;
    CORBA_StructDef_ptr &inout (void);
    CORBA_StructDef_ptr &out (void);
    CORBA_StructDef_ptr _retn (void);
    CORBA_StructDef_ptr ptr (void) const;

  private:
    CORBA_StructDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF___OUT_CH_)
#define _CORBA_STRUCTDEF___OUT_CH_

  class TAO_Export CORBA_StructDef_out
  {
  public:
    CORBA_StructDef_out (CORBA_StructDef_ptr &);
    CORBA_StructDef_out (CORBA_StructDef_var &);
    CORBA_StructDef_out (const CORBA_StructDef_out &);
    CORBA_StructDef_out &operator= (const CORBA_StructDef_out &);
    CORBA_StructDef_out &operator= (const CORBA_StructDef_var &);
    CORBA_StructDef_out &operator= (CORBA_StructDef_ptr);
    operator CORBA_StructDef_ptr &();
    CORBA_StructDef_ptr &ptr (void);
    CORBA_StructDef_ptr operator-> (void);

  private:
    CORBA_StructDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF_CH_)
#define _CORBA_STRUCTDEF_CH_

class TAO_Export CORBA_StructDef: public virtual CORBA_TypedefDef, public virtual CORBA_Container
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_StructDef_ptr _ptr_type;
    typedef CORBA_StructDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_StructDef_ptr _duplicate (CORBA_StructDef_ptr obj);
    static CORBA_StructDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_StructDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_StructDef_ptr _nil (void)
      {
        return (CORBA::StructDef_ptr)0;
      }

    virtual CORBA_StructMemberSeq * members (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void members (
        const CORBA_StructMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_StructDef (void);
    CORBA_StructDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_StructDef (void);
  private:
    CORBA_StructDef (const CORBA_StructDef &);
    void operator= (const CORBA_StructDef &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___VAR_CH_)
#define _CORBA_UNIONDEF___VAR_CH_

  class TAO_Export CORBA_UnionDef_var
  {
  public:
    CORBA_UnionDef_var (void); // default constructor
    CORBA_UnionDef_var (CORBA_UnionDef_ptr);
    CORBA_UnionDef_var (const CORBA_UnionDef_var &); // copy constructor
    ~CORBA_UnionDef_var (void); // destructor

    CORBA_UnionDef_var &operator= (CORBA_UnionDef_ptr);
    CORBA_UnionDef_var &operator= (const CORBA_UnionDef_var &);
    CORBA_UnionDef_ptr operator-> (void) const;

    operator const CORBA_UnionDef_ptr &() const;
    operator CORBA_UnionDef_ptr &();
    // in, inout, out, _retn
    CORBA_UnionDef_ptr in (void) const;
    CORBA_UnionDef_ptr &inout (void);
    CORBA_UnionDef_ptr &out (void);
    CORBA_UnionDef_ptr _retn (void);
    CORBA_UnionDef_ptr ptr (void) const;

  private:
    CORBA_UnionDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___OUT_CH_)
#define _CORBA_UNIONDEF___OUT_CH_

  class TAO_Export CORBA_UnionDef_out
  {
  public:
    CORBA_UnionDef_out (CORBA_UnionDef_ptr &);
    CORBA_UnionDef_out (CORBA_UnionDef_var &);
    CORBA_UnionDef_out (const CORBA_UnionDef_out &);
    CORBA_UnionDef_out &operator= (const CORBA_UnionDef_out &);
    CORBA_UnionDef_out &operator= (const CORBA_UnionDef_var &);
    CORBA_UnionDef_out &operator= (CORBA_UnionDef_ptr);
    operator CORBA_UnionDef_ptr &();
    CORBA_UnionDef_ptr &ptr (void);
    CORBA_UnionDef_ptr operator-> (void);

  private:
    CORBA_UnionDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF_CH_)
#define _CORBA_UNIONDEF_CH_

class TAO_Export CORBA_UnionDef: public virtual CORBA_TypedefDef, public virtual CORBA_Container
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_UnionDef_ptr _ptr_type;
    typedef CORBA_UnionDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_UnionDef_ptr _duplicate (CORBA_UnionDef_ptr obj);
    static CORBA_UnionDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_UnionDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_UnionDef_ptr _nil (void)
      {
        return (CORBA::UnionDef_ptr)0;
      }

    virtual CORBA::TypeCode_ptr discriminator_type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr discriminator_type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void discriminator_type_def (
        CORBA_IDLType_ptr discriminator_type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_UnionMemberSeq * members (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void members (
        const CORBA_UnionMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_UnionDef (void);
    CORBA_UnionDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_UnionDef (void);
  private:
    CORBA_UnionDef (const CORBA_UnionDef &);
    void operator= (const CORBA_UnionDef &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_ENUMDEF___VAR_CH_)
#define _CORBA_ENUMDEF___VAR_CH_

  class TAO_Export CORBA_EnumDef_var
  {
  public:
    CORBA_EnumDef_var (void); // default constructor
    CORBA_EnumDef_var (CORBA_EnumDef_ptr);
    CORBA_EnumDef_var (const CORBA_EnumDef_var &); // copy constructor
    ~CORBA_EnumDef_var (void); // destructor

    CORBA_EnumDef_var &operator= (CORBA_EnumDef_ptr);
    CORBA_EnumDef_var &operator= (const CORBA_EnumDef_var &);
    CORBA_EnumDef_ptr operator-> (void) const;

    operator const CORBA_EnumDef_ptr &() const;
    operator CORBA_EnumDef_ptr &();
    // in, inout, out, _retn
    CORBA_EnumDef_ptr in (void) const;
    CORBA_EnumDef_ptr &inout (void);
    CORBA_EnumDef_ptr &out (void);
    CORBA_EnumDef_ptr _retn (void);
    CORBA_EnumDef_ptr ptr (void) const;

  private:
    CORBA_EnumDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF___OUT_CH_)
#define _CORBA_ENUMDEF___OUT_CH_

  class TAO_Export CORBA_EnumDef_out
  {
  public:
    CORBA_EnumDef_out (CORBA_EnumDef_ptr &);
    CORBA_EnumDef_out (CORBA_EnumDef_var &);
    CORBA_EnumDef_out (const CORBA_EnumDef_out &);
    CORBA_EnumDef_out &operator= (const CORBA_EnumDef_out &);
    CORBA_EnumDef_out &operator= (const CORBA_EnumDef_var &);
    CORBA_EnumDef_out &operator= (CORBA_EnumDef_ptr);
    operator CORBA_EnumDef_ptr &();
    CORBA_EnumDef_ptr &ptr (void);
    CORBA_EnumDef_ptr operator-> (void);

  private:
    CORBA_EnumDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF_CH_)
#define _CORBA_ENUMDEF_CH_

class TAO_Export CORBA_EnumDef: public virtual CORBA_TypedefDef
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_EnumDef_ptr _ptr_type;
    typedef CORBA_EnumDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_EnumDef_ptr _duplicate (CORBA_EnumDef_ptr obj);
    static CORBA_EnumDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_EnumDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_EnumDef_ptr _nil (void)
      {
        return (CORBA::EnumDef_ptr)0;
      }

    virtual CORBA_EnumMemberSeq * members (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void members (
        const CORBA_EnumMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_EnumDef (void);
    CORBA_EnumDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_EnumDef (void);
  private:
    CORBA_EnumDef (const CORBA_EnumDef &);
    void operator= (const CORBA_EnumDef &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_ALIASDEF___VAR_CH_)
#define _CORBA_ALIASDEF___VAR_CH_

  class TAO_Export CORBA_AliasDef_var
  {
  public:
    CORBA_AliasDef_var (void); // default constructor
    CORBA_AliasDef_var (CORBA_AliasDef_ptr);
    CORBA_AliasDef_var (const CORBA_AliasDef_var &); // copy constructor
    ~CORBA_AliasDef_var (void); // destructor

    CORBA_AliasDef_var &operator= (CORBA_AliasDef_ptr);
    CORBA_AliasDef_var &operator= (const CORBA_AliasDef_var &);
    CORBA_AliasDef_ptr operator-> (void) const;

    operator const CORBA_AliasDef_ptr &() const;
    operator CORBA_AliasDef_ptr &();
    // in, inout, out, _retn
    CORBA_AliasDef_ptr in (void) const;
    CORBA_AliasDef_ptr &inout (void);
    CORBA_AliasDef_ptr &out (void);
    CORBA_AliasDef_ptr _retn (void);
    CORBA_AliasDef_ptr ptr (void) const;

  private:
    CORBA_AliasDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF___OUT_CH_)
#define _CORBA_ALIASDEF___OUT_CH_

  class TAO_Export CORBA_AliasDef_out
  {
  public:
    CORBA_AliasDef_out (CORBA_AliasDef_ptr &);
    CORBA_AliasDef_out (CORBA_AliasDef_var &);
    CORBA_AliasDef_out (const CORBA_AliasDef_out &);
    CORBA_AliasDef_out &operator= (const CORBA_AliasDef_out &);
    CORBA_AliasDef_out &operator= (const CORBA_AliasDef_var &);
    CORBA_AliasDef_out &operator= (CORBA_AliasDef_ptr);
    operator CORBA_AliasDef_ptr &();
    CORBA_AliasDef_ptr &ptr (void);
    CORBA_AliasDef_ptr operator-> (void);

  private:
    CORBA_AliasDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF_CH_)
#define _CORBA_ALIASDEF_CH_

class TAO_Export CORBA_AliasDef: public virtual CORBA_TypedefDef
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_AliasDef_ptr _ptr_type;
    typedef CORBA_AliasDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_AliasDef_ptr _duplicate (CORBA_AliasDef_ptr obj);
    static CORBA_AliasDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_AliasDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_AliasDef_ptr _nil (void)
      {
        return (CORBA::AliasDef_ptr)0;
      }

    virtual CORBA_IDLType_ptr original_type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void original_type_def (
        CORBA_IDLType_ptr original_type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_AliasDef (void);
    CORBA_AliasDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_AliasDef (void);
  private:
    CORBA_AliasDef (const CORBA_AliasDef &);
    void operator= (const CORBA_AliasDef &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEDEF___VAR_CH_)
#define _CORBA_PRIMITIVEDEF___VAR_CH_

  class TAO_Export CORBA_PrimitiveDef_var
  {
  public:
    CORBA_PrimitiveDef_var (void); // default constructor
    CORBA_PrimitiveDef_var (CORBA_PrimitiveDef_ptr);
    CORBA_PrimitiveDef_var (const CORBA_PrimitiveDef_var &); // copy constructor
    ~CORBA_PrimitiveDef_var (void); // destructor

    CORBA_PrimitiveDef_var &operator= (CORBA_PrimitiveDef_ptr);
    CORBA_PrimitiveDef_var &operator= (const CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_ptr operator-> (void) const;

    operator const CORBA_PrimitiveDef_ptr &() const;
    operator CORBA_PrimitiveDef_ptr &();
    // in, inout, out, _retn
    CORBA_PrimitiveDef_ptr in (void) const;
    CORBA_PrimitiveDef_ptr &inout (void);
    CORBA_PrimitiveDef_ptr &out (void);
    CORBA_PrimitiveDef_ptr _retn (void);
    CORBA_PrimitiveDef_ptr ptr (void) const;

  private:
    CORBA_PrimitiveDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF___OUT_CH_)
#define _CORBA_PRIMITIVEDEF___OUT_CH_

  class TAO_Export CORBA_PrimitiveDef_out
  {
  public:
    CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_ptr &);
    CORBA_PrimitiveDef_out (CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_out (const CORBA_PrimitiveDef_out &);
    CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_out &);
    CORBA_PrimitiveDef_out &operator= (const CORBA_PrimitiveDef_var &);
    CORBA_PrimitiveDef_out &operator= (CORBA_PrimitiveDef_ptr);
    operator CORBA_PrimitiveDef_ptr &();
    CORBA_PrimitiveDef_ptr &ptr (void);
    CORBA_PrimitiveDef_ptr operator-> (void);

  private:
    CORBA_PrimitiveDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_PRIMITIVEDEF_CH_)
#define _CORBA_PRIMITIVEDEF_CH_

class TAO_Export CORBA_PrimitiveDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_PrimitiveDef_ptr _ptr_type;
    typedef CORBA_PrimitiveDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_PrimitiveDef_ptr _duplicate (CORBA_PrimitiveDef_ptr obj);
    static CORBA_PrimitiveDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_PrimitiveDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_PrimitiveDef_ptr _nil (void)
      {
        return (CORBA::PrimitiveDef_ptr)0;
      }

    virtual CORBA::PrimitiveKind kind (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_PrimitiveDef (void);
    CORBA_PrimitiveDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_PrimitiveDef (void);
  private:
    CORBA_PrimitiveDef (const CORBA_PrimitiveDef &);
    void operator= (const CORBA_PrimitiveDef &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___VAR_CH_)
#define _CORBA_STRINGDEF___VAR_CH_

  class TAO_Export CORBA_StringDef_var
  {
  public:
    CORBA_StringDef_var (void); // default constructor
    CORBA_StringDef_var (CORBA_StringDef_ptr);
    CORBA_StringDef_var (const CORBA_StringDef_var &); // copy constructor
    ~CORBA_StringDef_var (void); // destructor

    CORBA_StringDef_var &operator= (CORBA_StringDef_ptr);
    CORBA_StringDef_var &operator= (const CORBA_StringDef_var &);
    CORBA_StringDef_ptr operator-> (void) const;

    operator const CORBA_StringDef_ptr &() const;
    operator CORBA_StringDef_ptr &();
    // in, inout, out, _retn
    CORBA_StringDef_ptr in (void) const;
    CORBA_StringDef_ptr &inout (void);
    CORBA_StringDef_ptr &out (void);
    CORBA_StringDef_ptr _retn (void);
    CORBA_StringDef_ptr ptr (void) const;

  private:
    CORBA_StringDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF___OUT_CH_)
#define _CORBA_STRINGDEF___OUT_CH_

  class TAO_Export CORBA_StringDef_out
  {
  public:
    CORBA_StringDef_out (CORBA_StringDef_ptr &);
    CORBA_StringDef_out (CORBA_StringDef_var &);
    CORBA_StringDef_out (const CORBA_StringDef_out &);
    CORBA_StringDef_out &operator= (const CORBA_StringDef_out &);
    CORBA_StringDef_out &operator= (const CORBA_StringDef_var &);
    CORBA_StringDef_out &operator= (CORBA_StringDef_ptr);
    operator CORBA_StringDef_ptr &();
    CORBA_StringDef_ptr &ptr (void);
    CORBA_StringDef_ptr operator-> (void);

  private:
    CORBA_StringDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_STRINGDEF_CH_)
#define _CORBA_STRINGDEF_CH_

class TAO_Export CORBA_StringDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_StringDef_ptr _ptr_type;
    typedef CORBA_StringDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_StringDef_ptr _duplicate (CORBA_StringDef_ptr obj);
    static CORBA_StringDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_StringDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_StringDef_ptr _nil (void)
      {
        return (CORBA::StringDef_ptr)0;
      }

    virtual CORBA::ULong bound (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void bound (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_StringDef (void);
    CORBA_StringDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_StringDef (void);
  private:
    CORBA_StringDef (const CORBA_StringDef &);
    void operator= (const CORBA_StringDef &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_WSTRINGDEF___VAR_CH_)
#define _CORBA_WSTRINGDEF___VAR_CH_

  class TAO_Export CORBA_WstringDef_var
  {
  public:
    CORBA_WstringDef_var (void); // default constructor
    CORBA_WstringDef_var (CORBA_WstringDef_ptr);
    CORBA_WstringDef_var (const CORBA_WstringDef_var &); // copy constructor
    ~CORBA_WstringDef_var (void); // destructor

    CORBA_WstringDef_var &operator= (CORBA_WstringDef_ptr);
    CORBA_WstringDef_var &operator= (const CORBA_WstringDef_var &);
    CORBA_WstringDef_ptr operator-> (void) const;

    operator const CORBA_WstringDef_ptr &() const;
    operator CORBA_WstringDef_ptr &();
    // in, inout, out, _retn
    CORBA_WstringDef_ptr in (void) const;
    CORBA_WstringDef_ptr &inout (void);
    CORBA_WstringDef_ptr &out (void);
    CORBA_WstringDef_ptr _retn (void);
    CORBA_WstringDef_ptr ptr (void) const;

  private:
    CORBA_WstringDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF___OUT_CH_)
#define _CORBA_WSTRINGDEF___OUT_CH_

  class TAO_Export CORBA_WstringDef_out
  {
  public:
    CORBA_WstringDef_out (CORBA_WstringDef_ptr &);
    CORBA_WstringDef_out (CORBA_WstringDef_var &);
    CORBA_WstringDef_out (const CORBA_WstringDef_out &);
    CORBA_WstringDef_out &operator= (const CORBA_WstringDef_out &);
    CORBA_WstringDef_out &operator= (const CORBA_WstringDef_var &);
    CORBA_WstringDef_out &operator= (CORBA_WstringDef_ptr);
    operator CORBA_WstringDef_ptr &();
    CORBA_WstringDef_ptr &ptr (void);
    CORBA_WstringDef_ptr operator-> (void);

  private:
    CORBA_WstringDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_WSTRINGDEF_CH_)
#define _CORBA_WSTRINGDEF_CH_

class TAO_Export CORBA_WstringDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_WstringDef_ptr _ptr_type;
    typedef CORBA_WstringDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_WstringDef_ptr _duplicate (CORBA_WstringDef_ptr obj);
    static CORBA_WstringDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_WstringDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_WstringDef_ptr _nil (void)
      {
        return (CORBA::WstringDef_ptr)0;
      }

    virtual CORBA::ULong bound (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void bound (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_WstringDef (void);
    CORBA_WstringDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_WstringDef (void);
  private:
    CORBA_WstringDef (const CORBA_WstringDef &);
    void operator= (const CORBA_WstringDef &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___VAR_CH_)
#define _CORBA_FIXEDDEF___VAR_CH_

  class TAO_Export CORBA_FixedDef_var
  {
  public:
    CORBA_FixedDef_var (void); // default constructor
    CORBA_FixedDef_var (CORBA_FixedDef_ptr);
    CORBA_FixedDef_var (const CORBA_FixedDef_var &); // copy constructor
    ~CORBA_FixedDef_var (void); // destructor

    CORBA_FixedDef_var &operator= (CORBA_FixedDef_ptr);
    CORBA_FixedDef_var &operator= (const CORBA_FixedDef_var &);
    CORBA_FixedDef_ptr operator-> (void) const;

    operator const CORBA_FixedDef_ptr &() const;
    operator CORBA_FixedDef_ptr &();
    // in, inout, out, _retn
    CORBA_FixedDef_ptr in (void) const;
    CORBA_FixedDef_ptr &inout (void);
    CORBA_FixedDef_ptr &out (void);
    CORBA_FixedDef_ptr _retn (void);
    CORBA_FixedDef_ptr ptr (void) const;

  private:
    CORBA_FixedDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF___OUT_CH_)
#define _CORBA_FIXEDDEF___OUT_CH_

  class TAO_Export CORBA_FixedDef_out
  {
  public:
    CORBA_FixedDef_out (CORBA_FixedDef_ptr &);
    CORBA_FixedDef_out (CORBA_FixedDef_var &);
    CORBA_FixedDef_out (const CORBA_FixedDef_out &);
    CORBA_FixedDef_out &operator= (const CORBA_FixedDef_out &);
    CORBA_FixedDef_out &operator= (const CORBA_FixedDef_var &);
    CORBA_FixedDef_out &operator= (CORBA_FixedDef_ptr);
    operator CORBA_FixedDef_ptr &();
    CORBA_FixedDef_ptr &ptr (void);
    CORBA_FixedDef_ptr operator-> (void);

  private:
    CORBA_FixedDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_FIXEDDEF_CH_)
#define _CORBA_FIXEDDEF_CH_

class TAO_Export CORBA_FixedDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_FixedDef_ptr _ptr_type;
    typedef CORBA_FixedDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_FixedDef_ptr _duplicate (CORBA_FixedDef_ptr obj);
    static CORBA_FixedDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_FixedDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_FixedDef_ptr _nil (void)
      {
        return (CORBA::FixedDef_ptr)0;
      }

    virtual CORBA::UShort digits (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void digits (
        CORBA::UShort digits,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Short scale (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void scale (
        CORBA::Short scale,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_FixedDef (void);
    CORBA_FixedDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_FixedDef (void);
  private:
    CORBA_FixedDef (const CORBA_FixedDef &);
    void operator= (const CORBA_FixedDef &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCEDEF___VAR_CH_)
#define _CORBA_SEQUENCEDEF___VAR_CH_

  class TAO_Export CORBA_SequenceDef_var
  {
  public:
    CORBA_SequenceDef_var (void); // default constructor
    CORBA_SequenceDef_var (CORBA_SequenceDef_ptr);
    CORBA_SequenceDef_var (const CORBA_SequenceDef_var &); // copy constructor
    ~CORBA_SequenceDef_var (void); // destructor

    CORBA_SequenceDef_var &operator= (CORBA_SequenceDef_ptr);
    CORBA_SequenceDef_var &operator= (const CORBA_SequenceDef_var &);
    CORBA_SequenceDef_ptr operator-> (void) const;

    operator const CORBA_SequenceDef_ptr &() const;
    operator CORBA_SequenceDef_ptr &();
    // in, inout, out, _retn
    CORBA_SequenceDef_ptr in (void) const;
    CORBA_SequenceDef_ptr &inout (void);
    CORBA_SequenceDef_ptr &out (void);
    CORBA_SequenceDef_ptr _retn (void);
    CORBA_SequenceDef_ptr ptr (void) const;

  private:
    CORBA_SequenceDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF___OUT_CH_)
#define _CORBA_SEQUENCEDEF___OUT_CH_

  class TAO_Export CORBA_SequenceDef_out
  {
  public:
    CORBA_SequenceDef_out (CORBA_SequenceDef_ptr &);
    CORBA_SequenceDef_out (CORBA_SequenceDef_var &);
    CORBA_SequenceDef_out (const CORBA_SequenceDef_out &);
    CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_out &);
    CORBA_SequenceDef_out &operator= (const CORBA_SequenceDef_var &);
    CORBA_SequenceDef_out &operator= (CORBA_SequenceDef_ptr);
    operator CORBA_SequenceDef_ptr &();
    CORBA_SequenceDef_ptr &ptr (void);
    CORBA_SequenceDef_ptr operator-> (void);

  private:
    CORBA_SequenceDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_SEQUENCEDEF_CH_)
#define _CORBA_SEQUENCEDEF_CH_

class TAO_Export CORBA_SequenceDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_SequenceDef_ptr _ptr_type;
    typedef CORBA_SequenceDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_SequenceDef_ptr _duplicate (CORBA_SequenceDef_ptr obj);
    static CORBA_SequenceDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_SequenceDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_SequenceDef_ptr _nil (void)
      {
        return (CORBA::SequenceDef_ptr)0;
      }

    virtual CORBA::ULong bound (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void bound (
        CORBA::ULong bound,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::TypeCode_ptr element_type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr element_type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void element_type_def (
        CORBA_IDLType_ptr element_type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_SequenceDef (void);
    CORBA_SequenceDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_SequenceDef (void);
  private:
    CORBA_SequenceDef (const CORBA_SequenceDef &);
    void operator= (const CORBA_SequenceDef &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___VAR_CH_)
#define _CORBA_ARRAYDEF___VAR_CH_

  class TAO_Export CORBA_ArrayDef_var
  {
  public:
    CORBA_ArrayDef_var (void); // default constructor
    CORBA_ArrayDef_var (CORBA_ArrayDef_ptr);
    CORBA_ArrayDef_var (const CORBA_ArrayDef_var &); // copy constructor
    ~CORBA_ArrayDef_var (void); // destructor

    CORBA_ArrayDef_var &operator= (CORBA_ArrayDef_ptr);
    CORBA_ArrayDef_var &operator= (const CORBA_ArrayDef_var &);
    CORBA_ArrayDef_ptr operator-> (void) const;

    operator const CORBA_ArrayDef_ptr &() const;
    operator CORBA_ArrayDef_ptr &();
    // in, inout, out, _retn
    CORBA_ArrayDef_ptr in (void) const;
    CORBA_ArrayDef_ptr &inout (void);
    CORBA_ArrayDef_ptr &out (void);
    CORBA_ArrayDef_ptr _retn (void);
    CORBA_ArrayDef_ptr ptr (void) const;

  private:
    CORBA_ArrayDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF___OUT_CH_)
#define _CORBA_ARRAYDEF___OUT_CH_

  class TAO_Export CORBA_ArrayDef_out
  {
  public:
    CORBA_ArrayDef_out (CORBA_ArrayDef_ptr &);
    CORBA_ArrayDef_out (CORBA_ArrayDef_var &);
    CORBA_ArrayDef_out (const CORBA_ArrayDef_out &);
    CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_out &);
    CORBA_ArrayDef_out &operator= (const CORBA_ArrayDef_var &);
    CORBA_ArrayDef_out &operator= (CORBA_ArrayDef_ptr);
    operator CORBA_ArrayDef_ptr &();
    CORBA_ArrayDef_ptr &ptr (void);
    CORBA_ArrayDef_ptr operator-> (void);

  private:
    CORBA_ArrayDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ARRAYDEF_CH_)
#define _CORBA_ARRAYDEF_CH_

class TAO_Export CORBA_ArrayDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ArrayDef_ptr _ptr_type;
    typedef CORBA_ArrayDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ArrayDef_ptr _duplicate (CORBA_ArrayDef_ptr obj);
    static CORBA_ArrayDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ArrayDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ArrayDef_ptr _nil (void)
      {
        return (CORBA::ArrayDef_ptr)0;
      }

    virtual CORBA::ULong length (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void length (
        CORBA::ULong length,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::TypeCode_ptr element_type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr element_type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void element_type_def (
        CORBA_IDLType_ptr element_type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ArrayDef (void);
    CORBA_ArrayDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ArrayDef (void);
  private:
    CORBA_ArrayDef (const CORBA_ArrayDef &);
    void operator= (const CORBA_ArrayDef &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_EXCEPTIONDEF___VAR_CH_)
#define _CORBA_EXCEPTIONDEF___VAR_CH_

  class TAO_Export CORBA_ExceptionDef_var
  {
  public:
    CORBA_ExceptionDef_var (void); // default constructor
    CORBA_ExceptionDef_var (CORBA_ExceptionDef_ptr);
    CORBA_ExceptionDef_var (const CORBA_ExceptionDef_var &); // copy constructor
    ~CORBA_ExceptionDef_var (void); // destructor

    CORBA_ExceptionDef_var &operator= (CORBA_ExceptionDef_ptr);
    CORBA_ExceptionDef_var &operator= (const CORBA_ExceptionDef_var &);
    CORBA_ExceptionDef_ptr operator-> (void) const;

    operator const CORBA_ExceptionDef_ptr &() const;
    operator CORBA_ExceptionDef_ptr &();
    // in, inout, out, _retn
    CORBA_ExceptionDef_ptr in (void) const;
    CORBA_ExceptionDef_ptr &inout (void);
    CORBA_ExceptionDef_ptr &out (void);
    CORBA_ExceptionDef_ptr _retn (void);
    CORBA_ExceptionDef_ptr ptr (void) const;

  private:
    CORBA_ExceptionDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF___OUT_CH_)
#define _CORBA_EXCEPTIONDEF___OUT_CH_

  class TAO_Export CORBA_ExceptionDef_out
  {
  public:
    CORBA_ExceptionDef_out (CORBA_ExceptionDef_ptr &);
    CORBA_ExceptionDef_out (CORBA_ExceptionDef_var &);
    CORBA_ExceptionDef_out (const CORBA_ExceptionDef_out &);
    CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_out &);
    CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_var &);
    CORBA_ExceptionDef_out &operator= (CORBA_ExceptionDef_ptr);
    operator CORBA_ExceptionDef_ptr &();
    CORBA_ExceptionDef_ptr &ptr (void);
    CORBA_ExceptionDef_ptr operator-> (void);

  private:
    CORBA_ExceptionDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF_CH_)
#define _CORBA_EXCEPTIONDEF_CH_

class TAO_Export CORBA_ExceptionDef: public virtual CORBA_Contained, public virtual CORBA_Container
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ExceptionDef_ptr _ptr_type;
    typedef CORBA_ExceptionDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ExceptionDef_ptr _duplicate (CORBA_ExceptionDef_ptr obj);
    static CORBA_ExceptionDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ExceptionDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ExceptionDef_ptr _nil (void)
      {
        return (CORBA::ExceptionDef_ptr)0;
      }

    virtual CORBA::TypeCode_ptr type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_StructMemberSeq * members (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void members (
        const CORBA_StructMemberSeq & members,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ExceptionDef (void);
    CORBA_ExceptionDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ExceptionDef (void);
  private:
    CORBA_ExceptionDef (const CORBA_ExceptionDef &);
    void operator= (const CORBA_ExceptionDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_ExceptionDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var type;
  };

  class TAO_Export CORBA_ExceptionDescription_var
  {
  public:
    CORBA_ExceptionDescription_var (void); // default constructor
    CORBA_ExceptionDescription_var (CORBA_ExceptionDescription *);
    CORBA_ExceptionDescription_var (const CORBA_ExceptionDescription_var &); // copy constructor
    ~CORBA_ExceptionDescription_var (void); // destructor

    CORBA_ExceptionDescription_var &operator= (CORBA_ExceptionDescription *);
    CORBA_ExceptionDescription_var &operator= (const CORBA_ExceptionDescription_var &);
    CORBA_ExceptionDescription *operator-> (void);
    const CORBA_ExceptionDescription *operator-> (void) const;

    operator const CORBA_ExceptionDescription &() const;
    operator CORBA_ExceptionDescription &();
    operator CORBA_ExceptionDescription &() const;
    // in, inout, out, _retn
    const CORBA_ExceptionDescription &in (void) const;
    CORBA_ExceptionDescription &inout (void);
    CORBA_ExceptionDescription *&out (void);
    CORBA_ExceptionDescription *_retn (void);
    CORBA_ExceptionDescription *ptr (void) const;

  private:
    CORBA_ExceptionDescription *ptr_;
  };

  class TAO_Export CORBA_ExceptionDescription_out
  {
  public:
    CORBA_ExceptionDescription_out (CORBA_ExceptionDescription *&);
    CORBA_ExceptionDescription_out (CORBA_ExceptionDescription_var &);
    CORBA_ExceptionDescription_out (const CORBA_ExceptionDescription_out &);
    CORBA_ExceptionDescription_out &operator= (const CORBA_ExceptionDescription_out &);
    CORBA_ExceptionDescription_out &operator= (CORBA_ExceptionDescription *);
    operator CORBA_ExceptionDescription *&();
    CORBA_ExceptionDescription *&ptr (void);
    CORBA_ExceptionDescription *operator-> (void);

  private:
    CORBA_ExceptionDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ExceptionDescription_var &);
  };


#if !defined (_CORBA_ATTRIBUTEDEF___VAR_CH_)
#define _CORBA_ATTRIBUTEDEF___VAR_CH_

  class TAO_Export CORBA_AttributeDef_var
  {
  public:
    CORBA_AttributeDef_var (void); // default constructor
    CORBA_AttributeDef_var (CORBA_AttributeDef_ptr);
    CORBA_AttributeDef_var (const CORBA_AttributeDef_var &); // copy constructor
    ~CORBA_AttributeDef_var (void); // destructor

    CORBA_AttributeDef_var &operator= (CORBA_AttributeDef_ptr);
    CORBA_AttributeDef_var &operator= (const CORBA_AttributeDef_var &);
    CORBA_AttributeDef_ptr operator-> (void) const;

    operator const CORBA_AttributeDef_ptr &() const;
    operator CORBA_AttributeDef_ptr &();
    // in, inout, out, _retn
    CORBA_AttributeDef_ptr in (void) const;
    CORBA_AttributeDef_ptr &inout (void);
    CORBA_AttributeDef_ptr &out (void);
    CORBA_AttributeDef_ptr _retn (void);
    CORBA_AttributeDef_ptr ptr (void) const;

  private:
    CORBA_AttributeDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRIBUTEDEF___OUT_CH_)
#define _CORBA_ATTRIBUTEDEF___OUT_CH_

  class TAO_Export CORBA_AttributeDef_out
  {
  public:
    CORBA_AttributeDef_out (CORBA_AttributeDef_ptr &);
    CORBA_AttributeDef_out (CORBA_AttributeDef_var &);
    CORBA_AttributeDef_out (const CORBA_AttributeDef_out &);
    CORBA_AttributeDef_out &operator= (const CORBA_AttributeDef_out &);
    CORBA_AttributeDef_out &operator= (const CORBA_AttributeDef_var &);
    CORBA_AttributeDef_out &operator= (CORBA_AttributeDef_ptr);
    operator CORBA_AttributeDef_ptr &();
    CORBA_AttributeDef_ptr &ptr (void);
    CORBA_AttributeDef_ptr operator-> (void);

  private:
    CORBA_AttributeDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRIBUTEDEF_CH_)
#define _CORBA_ATTRIBUTEDEF_CH_

class TAO_Export CORBA_AttributeDef: public virtual CORBA_Contained
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_AttributeDef_ptr _ptr_type;
    typedef CORBA_AttributeDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_AttributeDef_ptr _duplicate (CORBA_AttributeDef_ptr obj);
    static CORBA_AttributeDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_AttributeDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_AttributeDef_ptr _nil (void)
      {
        return (CORBA::AttributeDef_ptr)0;
      }

    virtual CORBA::TypeCode_ptr type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void type_def (
        CORBA_IDLType_ptr type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::AttributeMode mode (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void mode (
        CORBA::AttributeMode mode,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_AttributeDef (void);
    CORBA_AttributeDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_AttributeDef (void);
  private:
    CORBA_AttributeDef (const CORBA_AttributeDef &);
    void operator= (const CORBA_AttributeDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_AttributeDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var type;
    CORBA::AttributeMode mode;
  };

  class TAO_Export CORBA_AttributeDescription_var
  {
  public:
    CORBA_AttributeDescription_var (void); // default constructor
    CORBA_AttributeDescription_var (CORBA_AttributeDescription *);
    CORBA_AttributeDescription_var (const CORBA_AttributeDescription_var &); // copy constructor
    ~CORBA_AttributeDescription_var (void); // destructor

    CORBA_AttributeDescription_var &operator= (CORBA_AttributeDescription *);
    CORBA_AttributeDescription_var &operator= (const CORBA_AttributeDescription_var &);
    CORBA_AttributeDescription *operator-> (void);
    const CORBA_AttributeDescription *operator-> (void) const;

    operator const CORBA_AttributeDescription &() const;
    operator CORBA_AttributeDescription &();
    operator CORBA_AttributeDescription &() const;
    // in, inout, out, _retn
    const CORBA_AttributeDescription &in (void) const;
    CORBA_AttributeDescription &inout (void);
    CORBA_AttributeDescription *&out (void);
    CORBA_AttributeDescription *_retn (void);
    CORBA_AttributeDescription *ptr (void) const;

  private:
    CORBA_AttributeDescription *ptr_;
  };

  class TAO_Export CORBA_AttributeDescription_out
  {
  public:
    CORBA_AttributeDescription_out (CORBA_AttributeDescription *&);
    CORBA_AttributeDescription_out (CORBA_AttributeDescription_var &);
    CORBA_AttributeDescription_out (const CORBA_AttributeDescription_out &);
    CORBA_AttributeDescription_out &operator= (const CORBA_AttributeDescription_out &);
    CORBA_AttributeDescription_out &operator= (CORBA_AttributeDescription *);
    operator CORBA_AttributeDescription *&();
    CORBA_AttributeDescription *&ptr (void);
    CORBA_AttributeDescription *operator-> (void);

  private:
    CORBA_AttributeDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_AttributeDescription_var &);
  };

  struct  CORBA_ParameterDescription
  {
    TAO_String_Manager name;
    CORBA::TypeCode_var type;
    TAO_Object_Field_T<CORBA_IDLType,CORBA_IDLType_var> type_def;
    CORBA::ParameterMode mode;
  };

  class TAO_Export CORBA_ParameterDescription_var
  {
  public:
    CORBA_ParameterDescription_var (void); // default constructor
    CORBA_ParameterDescription_var (CORBA_ParameterDescription *);
    CORBA_ParameterDescription_var (const CORBA_ParameterDescription_var &); // copy constructor
    ~CORBA_ParameterDescription_var (void); // destructor

    CORBA_ParameterDescription_var &operator= (CORBA_ParameterDescription *);
    CORBA_ParameterDescription_var &operator= (const CORBA_ParameterDescription_var &);
    CORBA_ParameterDescription *operator-> (void);
    const CORBA_ParameterDescription *operator-> (void) const;

    operator const CORBA_ParameterDescription &() const;
    operator CORBA_ParameterDescription &();
    operator CORBA_ParameterDescription &() const;
    // in, inout, out, _retn
    const CORBA_ParameterDescription &in (void) const;
    CORBA_ParameterDescription &inout (void);
    CORBA_ParameterDescription *&out (void);
    CORBA_ParameterDescription *_retn (void);
    CORBA_ParameterDescription *ptr (void) const;

  private:
    CORBA_ParameterDescription *ptr_;
  };

  class TAO_Export CORBA_ParameterDescription_out
  {
  public:
    CORBA_ParameterDescription_out (CORBA_ParameterDescription *&);
    CORBA_ParameterDescription_out (CORBA_ParameterDescription_var &);
    CORBA_ParameterDescription_out (const CORBA_ParameterDescription_out &);
    CORBA_ParameterDescription_out &operator= (const CORBA_ParameterDescription_out &);
    CORBA_ParameterDescription_out &operator= (CORBA_ParameterDescription *);
    operator CORBA_ParameterDescription *&();
    CORBA_ParameterDescription *&ptr (void);
    CORBA_ParameterDescription *operator-> (void);

  private:
    CORBA_ParameterDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ParameterDescription_var &);
  };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_ParameterDescription *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void); // Dtor.
      // = Accessors.
      CORBA_ParameterDescription &operator[] (CORBA::ULong i);
      const CORBA_ParameterDescription &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_ParameterDescription *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_ParameterDescription *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_ParameterDescription *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_ParameterDescription *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_ParameterDescription *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_PARDESCRIPTIONSEQ_CH_)
#define _CORBA_PARDESCRIPTIONSEQ_CH_

  // *************************************************************
  // ParDescriptionSeq
  // *************************************************************

  class TAO_Export CORBA_ParDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ParDescriptionSeq (void); // default ctor
    CORBA_ParDescriptionSeq (CORBA::ULong max); // uses max size
    CORBA_ParDescriptionSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ParameterDescription *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ParDescriptionSeq (const CORBA_ParDescriptionSeq &); // copy ctor
    ~CORBA_ParDescriptionSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_PARDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_PARDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ParDescriptionSeq_var
  // *************************************************************

  class TAO_Export CORBA_ParDescriptionSeq_var
  {
  public:
    CORBA_ParDescriptionSeq_var (void); // default constructor
    CORBA_ParDescriptionSeq_var (CORBA_ParDescriptionSeq *);
    CORBA_ParDescriptionSeq_var (const CORBA_ParDescriptionSeq_var &); // copy constructor
    ~CORBA_ParDescriptionSeq_var (void); // destructor

    CORBA_ParDescriptionSeq_var &operator= (CORBA_ParDescriptionSeq *);
    CORBA_ParDescriptionSeq_var &operator= (const CORBA_ParDescriptionSeq_var &);
    CORBA_ParDescriptionSeq *operator-> (void);
    const CORBA_ParDescriptionSeq *operator-> (void) const;

    operator const CORBA_ParDescriptionSeq &() const;
    operator CORBA_ParDescriptionSeq &();
    operator CORBA_ParDescriptionSeq &() const;
    CORBA_ParameterDescription &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ParDescriptionSeq &in (void) const;
    CORBA_ParDescriptionSeq &inout (void);
    CORBA_ParDescriptionSeq *&out (void);
    CORBA_ParDescriptionSeq *_retn (void);
    CORBA_ParDescriptionSeq *ptr (void) const;

  private:
    CORBA_ParDescriptionSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_PARDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_PARDESCRIPTIONSEQ___OUT_CH_

  class TAO_Export CORBA_ParDescriptionSeq_out
  {
  public:
    CORBA_ParDescriptionSeq_out (CORBA_ParDescriptionSeq *&);
    CORBA_ParDescriptionSeq_out (CORBA_ParDescriptionSeq_var &);
    CORBA_ParDescriptionSeq_out (const CORBA_ParDescriptionSeq_out &);
    CORBA_ParDescriptionSeq_out &operator= (const CORBA_ParDescriptionSeq_out &);
    CORBA_ParDescriptionSeq_out &operator= (CORBA_ParDescriptionSeq *);
    operator CORBA_ParDescriptionSeq *&();
    CORBA_ParDescriptionSeq *&ptr (void);
    CORBA_ParDescriptionSeq *operator-> (void);
    CORBA_ParameterDescription &operator[] (CORBA::ULong index);

  private:
    CORBA_ParDescriptionSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ParDescriptionSeq_var &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_CONTEXTIDSEQ_CH_)
#define _CORBA_CONTEXTIDSEQ_CH_

  // *************************************************************
  // ContextIdSeq
  // *************************************************************

  class TAO_Export CORBA_ContextIdSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ContextIdSeq (void); // default ctor
    CORBA_ContextIdSeq (CORBA::ULong max); // uses max size
    CORBA_ContextIdSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      char * *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ContextIdSeq (const CORBA_ContextIdSeq &); // copy ctor
    ~CORBA_ContextIdSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_CONTEXTIDSEQ___VAR_CH_)
#define _CORBA_CONTEXTIDSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ContextIdSeq_var
  // *************************************************************

  class TAO_Export CORBA_ContextIdSeq_var
  {
  public:
    CORBA_ContextIdSeq_var (void); // default constructor
    CORBA_ContextIdSeq_var (CORBA_ContextIdSeq *);
    CORBA_ContextIdSeq_var (const CORBA_ContextIdSeq_var &); // copy constructor
    ~CORBA_ContextIdSeq_var (void); // destructor

    CORBA_ContextIdSeq_var &operator= (CORBA_ContextIdSeq *);
    CORBA_ContextIdSeq_var &operator= (const CORBA_ContextIdSeq_var &);
    CORBA_ContextIdSeq *operator-> (void);
    const CORBA_ContextIdSeq *operator-> (void) const;

    operator const CORBA_ContextIdSeq &() const;
    operator CORBA_ContextIdSeq &();
    operator CORBA_ContextIdSeq &() const;
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ContextIdSeq &in (void) const;
    CORBA_ContextIdSeq &inout (void);
    CORBA_ContextIdSeq *&out (void);
    CORBA_ContextIdSeq *_retn (void);
    CORBA_ContextIdSeq *ptr (void) const;

  private:
    CORBA_ContextIdSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTEXTIDSEQ___OUT_CH_)
#define _CORBA_CONTEXTIDSEQ___OUT_CH_

  class TAO_Export CORBA_ContextIdSeq_out
  {
  public:
    CORBA_ContextIdSeq_out (CORBA_ContextIdSeq *&);
    CORBA_ContextIdSeq_out (CORBA_ContextIdSeq_var &);
    CORBA_ContextIdSeq_out (const CORBA_ContextIdSeq_out &);
    CORBA_ContextIdSeq_out &operator= (const CORBA_ContextIdSeq_out &);
    CORBA_ContextIdSeq_out &operator= (CORBA_ContextIdSeq *);
    operator CORBA_ContextIdSeq *&();
    CORBA_ContextIdSeq *&ptr (void);
    CORBA_ContextIdSeq *operator-> (void);
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  private:
    CORBA_ContextIdSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ContextIdSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CH_

    class _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_ExceptionDef* *value,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq(const _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq &rhs);
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq &rhs);
      TAO_Object_Manager<CORBA::ExceptionDef,CORBA::ExceptionDef_var> operator[] (CORBA::ULong index) const;
      static CORBA_ExceptionDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_ExceptionDef **buffer);
      // The Base_Sequence functions, please see tao/Sequence.h
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_ExceptionDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_ExceptionDef* *get_buffer (void) const;
      virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
      virtual void _downcast (
          void* target,
          CORBA_Object *src,
          CORBA_Environment &ACE_TRY_ENV =
            TAO_default_environment ()
        );
      virtual CORBA_Object* _upcast (void *src) const;

    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_EXCEPTIONDEFSEQ_CH_)
#define _CORBA_EXCEPTIONDEFSEQ_CH_

  // *************************************************************
  // ExceptionDefSeq
  // *************************************************************

  class TAO_Export CORBA_ExceptionDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ExceptionDefSeq (void); // default ctor
    CORBA_ExceptionDefSeq (CORBA::ULong max); // uses max size
    CORBA_ExceptionDefSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ExceptionDef_ptr *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ExceptionDefSeq (const CORBA_ExceptionDefSeq &); // copy ctor
    ~CORBA_ExceptionDefSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEFSEQ___VAR_CH_)
#define _CORBA_EXCEPTIONDEFSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ExceptionDefSeq_var
  // *************************************************************

  class TAO_Export CORBA_ExceptionDefSeq_var
  {
  public:
    CORBA_ExceptionDefSeq_var (void); // default constructor
    CORBA_ExceptionDefSeq_var (CORBA_ExceptionDefSeq *);
    CORBA_ExceptionDefSeq_var (const CORBA_ExceptionDefSeq_var &); // copy constructor
    ~CORBA_ExceptionDefSeq_var (void); // destructor

    CORBA_ExceptionDefSeq_var &operator= (CORBA_ExceptionDefSeq *);
    CORBA_ExceptionDefSeq_var &operator= (const CORBA_ExceptionDefSeq_var &);
    CORBA_ExceptionDefSeq *operator-> (void);
    const CORBA_ExceptionDefSeq *operator-> (void) const;

    operator const CORBA_ExceptionDefSeq &() const;
    operator CORBA_ExceptionDefSeq &();
    operator CORBA_ExceptionDefSeq &() const;
    TAO_Object_Manager<CORBA_ExceptionDef,CORBA_ExceptionDef_var> operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ExceptionDefSeq &in (void) const;
    CORBA_ExceptionDefSeq &inout (void);
    CORBA_ExceptionDefSeq *&out (void);
    CORBA_ExceptionDefSeq *_retn (void);
    CORBA_ExceptionDefSeq *ptr (void) const;

  private:
    CORBA_ExceptionDefSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEFSEQ___OUT_CH_)
#define _CORBA_EXCEPTIONDEFSEQ___OUT_CH_

  class TAO_Export CORBA_ExceptionDefSeq_out
  {
  public:
    CORBA_ExceptionDefSeq_out (CORBA_ExceptionDefSeq *&);
    CORBA_ExceptionDefSeq_out (CORBA_ExceptionDefSeq_var &);
    CORBA_ExceptionDefSeq_out (const CORBA_ExceptionDefSeq_out &);
    CORBA_ExceptionDefSeq_out &operator= (const CORBA_ExceptionDefSeq_out &);
    CORBA_ExceptionDefSeq_out &operator= (CORBA_ExceptionDefSeq *);
    operator CORBA_ExceptionDefSeq *&();
    CORBA_ExceptionDefSeq *&ptr (void);
    CORBA_ExceptionDefSeq *operator-> (void);
    TAO_Object_Manager<CORBA_ExceptionDef,CORBA_ExceptionDef_var> operator[] (CORBA::ULong index);

  private:
    CORBA_ExceptionDefSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ExceptionDefSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_ExceptionDescription *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void); // Dtor.
      // = Accessors.
      CORBA_ExceptionDescription &operator[] (CORBA::ULong i);
      const CORBA_ExceptionDescription &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_ExceptionDescription *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_ExceptionDescription *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_ExceptionDescription *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_ExceptionDescription *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_ExceptionDescription *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_EXCDESCRIPTIONSEQ_CH_)
#define _CORBA_EXCDESCRIPTIONSEQ_CH_

  // *************************************************************
  // ExcDescriptionSeq
  // *************************************************************

  class TAO_Export CORBA_ExcDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ExcDescriptionSeq (void); // default ctor
    CORBA_ExcDescriptionSeq (CORBA::ULong max); // uses max size
    CORBA_ExcDescriptionSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ExceptionDescription *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ExcDescriptionSeq (const CORBA_ExcDescriptionSeq &); // copy ctor
    ~CORBA_ExcDescriptionSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_EXCDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_EXCDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ExcDescriptionSeq_var
  // *************************************************************

  class TAO_Export CORBA_ExcDescriptionSeq_var
  {
  public:
    CORBA_ExcDescriptionSeq_var (void); // default constructor
    CORBA_ExcDescriptionSeq_var (CORBA_ExcDescriptionSeq *);
    CORBA_ExcDescriptionSeq_var (const CORBA_ExcDescriptionSeq_var &); // copy constructor
    ~CORBA_ExcDescriptionSeq_var (void); // destructor

    CORBA_ExcDescriptionSeq_var &operator= (CORBA_ExcDescriptionSeq *);
    CORBA_ExcDescriptionSeq_var &operator= (const CORBA_ExcDescriptionSeq_var &);
    CORBA_ExcDescriptionSeq *operator-> (void);
    const CORBA_ExcDescriptionSeq *operator-> (void) const;

    operator const CORBA_ExcDescriptionSeq &() const;
    operator CORBA_ExcDescriptionSeq &();
    operator CORBA_ExcDescriptionSeq &() const;
    CORBA_ExceptionDescription &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ExcDescriptionSeq &in (void) const;
    CORBA_ExcDescriptionSeq &inout (void);
    CORBA_ExcDescriptionSeq *&out (void);
    CORBA_ExcDescriptionSeq *_retn (void);
    CORBA_ExcDescriptionSeq *ptr (void) const;

  private:
    CORBA_ExcDescriptionSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_EXCDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_EXCDESCRIPTIONSEQ___OUT_CH_

  class TAO_Export CORBA_ExcDescriptionSeq_out
  {
  public:
    CORBA_ExcDescriptionSeq_out (CORBA_ExcDescriptionSeq *&);
    CORBA_ExcDescriptionSeq_out (CORBA_ExcDescriptionSeq_var &);
    CORBA_ExcDescriptionSeq_out (const CORBA_ExcDescriptionSeq_out &);
    CORBA_ExcDescriptionSeq_out &operator= (const CORBA_ExcDescriptionSeq_out &);
    CORBA_ExcDescriptionSeq_out &operator= (CORBA_ExcDescriptionSeq *);
    operator CORBA_ExcDescriptionSeq *&();
    CORBA_ExcDescriptionSeq *&ptr (void);
    CORBA_ExcDescriptionSeq *operator-> (void);
    CORBA_ExceptionDescription &operator[] (CORBA::ULong index);

  private:
    CORBA_ExcDescriptionSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ExcDescriptionSeq_var &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_OPERATIONDEF___VAR_CH_)
#define _CORBA_OPERATIONDEF___VAR_CH_

  class TAO_Export CORBA_OperationDef_var
  {
  public:
    CORBA_OperationDef_var (void); // default constructor
    CORBA_OperationDef_var (CORBA_OperationDef_ptr);
    CORBA_OperationDef_var (const CORBA_OperationDef_var &); // copy constructor
    ~CORBA_OperationDef_var (void); // destructor

    CORBA_OperationDef_var &operator= (CORBA_OperationDef_ptr);
    CORBA_OperationDef_var &operator= (const CORBA_OperationDef_var &);
    CORBA_OperationDef_ptr operator-> (void) const;

    operator const CORBA_OperationDef_ptr &() const;
    operator CORBA_OperationDef_ptr &();
    // in, inout, out, _retn
    CORBA_OperationDef_ptr in (void) const;
    CORBA_OperationDef_ptr &inout (void);
    CORBA_OperationDef_ptr &out (void);
    CORBA_OperationDef_ptr _retn (void);
    CORBA_OperationDef_ptr ptr (void) const;

  private:
    CORBA_OperationDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_OPERATIONDEF___OUT_CH_)
#define _CORBA_OPERATIONDEF___OUT_CH_

  class TAO_Export CORBA_OperationDef_out
  {
  public:
    CORBA_OperationDef_out (CORBA_OperationDef_ptr &);
    CORBA_OperationDef_out (CORBA_OperationDef_var &);
    CORBA_OperationDef_out (const CORBA_OperationDef_out &);
    CORBA_OperationDef_out &operator= (const CORBA_OperationDef_out &);
    CORBA_OperationDef_out &operator= (const CORBA_OperationDef_var &);
    CORBA_OperationDef_out &operator= (CORBA_OperationDef_ptr);
    operator CORBA_OperationDef_ptr &();
    CORBA_OperationDef_ptr &ptr (void);
    CORBA_OperationDef_ptr operator-> (void);

  private:
    CORBA_OperationDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_OPERATIONDEF_CH_)
#define _CORBA_OPERATIONDEF_CH_

class TAO_Export CORBA_OperationDef: public virtual CORBA_Contained
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_OperationDef_ptr _ptr_type;
    typedef CORBA_OperationDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_OperationDef_ptr _duplicate (CORBA_OperationDef_ptr obj);
    static CORBA_OperationDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_OperationDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_OperationDef_ptr _nil (void)
      {
        return (CORBA::OperationDef_ptr)0;
      }

    virtual CORBA::TypeCode_ptr result (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr result_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void result_def (
        CORBA_IDLType_ptr result_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ParDescriptionSeq * params (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void params (
        const CORBA_ParDescriptionSeq & params,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::OperationMode mode (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void mode (
        CORBA::OperationMode mode,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ContextIdSeq * contexts (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void contexts (
        const CORBA_ContextIdSeq & contexts,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ExceptionDefSeq * exceptions (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void exceptions (
        const CORBA_ExceptionDefSeq & exceptions,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_OperationDef (void);
    CORBA_OperationDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_OperationDef (void);
  private:
    CORBA_OperationDef (const CORBA_OperationDef &);
    void operator= (const CORBA_OperationDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_OperationDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var result;
    CORBA::OperationMode mode;
    CORBA_ContextIdSeq contexts;
    CORBA_ParDescriptionSeq parameters;
    CORBA_ExcDescriptionSeq exceptions;
  };

  class TAO_Export CORBA_OperationDescription_var
  {
  public:
    CORBA_OperationDescription_var (void); // default constructor
    CORBA_OperationDescription_var (CORBA_OperationDescription *);
    CORBA_OperationDescription_var (const CORBA_OperationDescription_var &); // copy constructor
    ~CORBA_OperationDescription_var (void); // destructor

    CORBA_OperationDescription_var &operator= (CORBA_OperationDescription *);
    CORBA_OperationDescription_var &operator= (const CORBA_OperationDescription_var &);
    CORBA_OperationDescription *operator-> (void);
    const CORBA_OperationDescription *operator-> (void) const;

    operator const CORBA_OperationDescription &() const;
    operator CORBA_OperationDescription &();
    operator CORBA_OperationDescription &() const;
    // in, inout, out, _retn
    const CORBA_OperationDescription &in (void) const;
    CORBA_OperationDescription &inout (void);
    CORBA_OperationDescription *&out (void);
    CORBA_OperationDescription *_retn (void);
    CORBA_OperationDescription *ptr (void) const;

  private:
    CORBA_OperationDescription *ptr_;
  };

  class TAO_Export CORBA_OperationDescription_out
  {
  public:
    CORBA_OperationDescription_out (CORBA_OperationDescription *&);
    CORBA_OperationDescription_out (CORBA_OperationDescription_var &);
    CORBA_OperationDescription_out (const CORBA_OperationDescription_out &);
    CORBA_OperationDescription_out &operator= (const CORBA_OperationDescription_out &);
    CORBA_OperationDescription_out &operator= (CORBA_OperationDescription *);
    operator CORBA_OperationDescription *&();
    CORBA_OperationDescription *&ptr (void);
    CORBA_OperationDescription *operator-> (void);

  private:
    CORBA_OperationDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_OperationDescription_var &);
  };


#if !defined (_CORBA_REPOSITORYIDSEQ_CH_)
#define _CORBA_REPOSITORYIDSEQ_CH_

  // *************************************************************
  // RepositoryIdSeq
  // *************************************************************

  class TAO_Export CORBA_RepositoryIdSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_RepositoryIdSeq (void); // default ctor
    CORBA_RepositoryIdSeq (CORBA::ULong max); // uses max size
    CORBA_RepositoryIdSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      char * *buffer,
      CORBA::Boolean release=0
    );
    CORBA_RepositoryIdSeq (const CORBA_RepositoryIdSeq &); // copy ctor
    ~CORBA_RepositoryIdSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORYIDSEQ___VAR_CH_)
#define _CORBA_REPOSITORYIDSEQ___VAR_CH_

// *************************************************************
  // class CORBA::RepositoryIdSeq_var
  // *************************************************************

  class TAO_Export CORBA_RepositoryIdSeq_var
  {
  public:
    CORBA_RepositoryIdSeq_var (void); // default constructor
    CORBA_RepositoryIdSeq_var (CORBA_RepositoryIdSeq *);
    CORBA_RepositoryIdSeq_var (const CORBA_RepositoryIdSeq_var &); // copy constructor
    ~CORBA_RepositoryIdSeq_var (void); // destructor

    CORBA_RepositoryIdSeq_var &operator= (CORBA_RepositoryIdSeq *);
    CORBA_RepositoryIdSeq_var &operator= (const CORBA_RepositoryIdSeq_var &);
    CORBA_RepositoryIdSeq *operator-> (void);
    const CORBA_RepositoryIdSeq *operator-> (void) const;

    operator const CORBA_RepositoryIdSeq &() const;
    operator CORBA_RepositoryIdSeq &();
    operator CORBA_RepositoryIdSeq &() const;
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_RepositoryIdSeq &in (void) const;
    CORBA_RepositoryIdSeq &inout (void);
    CORBA_RepositoryIdSeq *&out (void);
    CORBA_RepositoryIdSeq *_retn (void);
    CORBA_RepositoryIdSeq *ptr (void) const;

  private:
    CORBA_RepositoryIdSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORYIDSEQ___OUT_CH_)
#define _CORBA_REPOSITORYIDSEQ___OUT_CH_

  class TAO_Export CORBA_RepositoryIdSeq_out
  {
  public:
    CORBA_RepositoryIdSeq_out (CORBA_RepositoryIdSeq *&);
    CORBA_RepositoryIdSeq_out (CORBA_RepositoryIdSeq_var &);
    CORBA_RepositoryIdSeq_out (const CORBA_RepositoryIdSeq_out &);
    CORBA_RepositoryIdSeq_out &operator= (const CORBA_RepositoryIdSeq_out &);
    CORBA_RepositoryIdSeq_out &operator= (CORBA_RepositoryIdSeq *);
    operator CORBA_RepositoryIdSeq *&();
    CORBA_RepositoryIdSeq *&ptr (void);
    CORBA_RepositoryIdSeq *operator-> (void);
    TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  private:
    CORBA_RepositoryIdSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_RepositoryIdSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_OperationDescription *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void); // Dtor.
      // = Accessors.
      CORBA_OperationDescription &operator[] (CORBA::ULong i);
      const CORBA_OperationDescription &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_OperationDescription *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_OperationDescription *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_OperationDescription *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_OperationDescription *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_OperationDescription *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_OPDESCRIPTIONSEQ_CH_)
#define _CORBA_OPDESCRIPTIONSEQ_CH_

  // *************************************************************
  // OpDescriptionSeq
  // *************************************************************

  class TAO_Export CORBA_OpDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_OpDescriptionSeq (void); // default ctor
    CORBA_OpDescriptionSeq (CORBA::ULong max); // uses max size
    CORBA_OpDescriptionSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_OperationDescription *buffer,
      CORBA::Boolean release=0
    );
    CORBA_OpDescriptionSeq (const CORBA_OpDescriptionSeq &); // copy ctor
    ~CORBA_OpDescriptionSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_OPDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_OPDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
  // class CORBA::OpDescriptionSeq_var
  // *************************************************************

  class TAO_Export CORBA_OpDescriptionSeq_var
  {
  public:
    CORBA_OpDescriptionSeq_var (void); // default constructor
    CORBA_OpDescriptionSeq_var (CORBA_OpDescriptionSeq *);
    CORBA_OpDescriptionSeq_var (const CORBA_OpDescriptionSeq_var &); // copy constructor
    ~CORBA_OpDescriptionSeq_var (void); // destructor

    CORBA_OpDescriptionSeq_var &operator= (CORBA_OpDescriptionSeq *);
    CORBA_OpDescriptionSeq_var &operator= (const CORBA_OpDescriptionSeq_var &);
    CORBA_OpDescriptionSeq *operator-> (void);
    const CORBA_OpDescriptionSeq *operator-> (void) const;

    operator const CORBA_OpDescriptionSeq &() const;
    operator CORBA_OpDescriptionSeq &();
    operator CORBA_OpDescriptionSeq &() const;
    CORBA_OperationDescription &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_OpDescriptionSeq &in (void) const;
    CORBA_OpDescriptionSeq &inout (void);
    CORBA_OpDescriptionSeq *&out (void);
    CORBA_OpDescriptionSeq *_retn (void);
    CORBA_OpDescriptionSeq *ptr (void) const;

  private:
    CORBA_OpDescriptionSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_OPDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_OPDESCRIPTIONSEQ___OUT_CH_

  class TAO_Export CORBA_OpDescriptionSeq_out
  {
  public:
    CORBA_OpDescriptionSeq_out (CORBA_OpDescriptionSeq *&);
    CORBA_OpDescriptionSeq_out (CORBA_OpDescriptionSeq_var &);
    CORBA_OpDescriptionSeq_out (const CORBA_OpDescriptionSeq_out &);
    CORBA_OpDescriptionSeq_out &operator= (const CORBA_OpDescriptionSeq_out &);
    CORBA_OpDescriptionSeq_out &operator= (CORBA_OpDescriptionSeq *);
    operator CORBA_OpDescriptionSeq *&();
    CORBA_OpDescriptionSeq *&ptr (void);
    CORBA_OpDescriptionSeq *operator-> (void);
    CORBA_OperationDescription &operator[] (CORBA::ULong index);

  private:
    CORBA_OpDescriptionSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_OpDescriptionSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_AttributeDescription *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (const _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void); // Dtor.
      // = Accessors.
      CORBA_AttributeDescription &operator[] (CORBA::ULong i);
      const CORBA_AttributeDescription &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_AttributeDescription *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_AttributeDescription *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_AttributeDescription *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_AttributeDescription *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_AttributeDescription *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_ATTRDESCRIPTIONSEQ_CH_)
#define _CORBA_ATTRDESCRIPTIONSEQ_CH_

  // *************************************************************
  // AttrDescriptionSeq
  // *************************************************************

  class TAO_Export CORBA_AttrDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_AttrDescriptionSeq (void); // default ctor
    CORBA_AttrDescriptionSeq (CORBA::ULong max); // uses max size
    CORBA_AttrDescriptionSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_AttributeDescription *buffer,
      CORBA::Boolean release=0
    );
    CORBA_AttrDescriptionSeq (const CORBA_AttrDescriptionSeq &); // copy ctor
    ~CORBA_AttrDescriptionSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_ATTRDESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_ATTRDESCRIPTIONSEQ___VAR_CH_

// *************************************************************
  // class TAO_ExportCORBA::AttrDescriptionSeq_var
  // *************************************************************

  class TAO_Export CORBA_AttrDescriptionSeq_var
  {
  public:
    CORBA_AttrDescriptionSeq_var (void); // default constructor
    CORBA_AttrDescriptionSeq_var (CORBA_AttrDescriptionSeq *);
    CORBA_AttrDescriptionSeq_var (const CORBA_AttrDescriptionSeq_var &); // copy constructor
    ~CORBA_AttrDescriptionSeq_var (void); // destructor

    CORBA_AttrDescriptionSeq_var &operator= (CORBA_AttrDescriptionSeq *);
    CORBA_AttrDescriptionSeq_var &operator= (const CORBA_AttrDescriptionSeq_var &);
    CORBA_AttrDescriptionSeq *operator-> (void);
    const CORBA_AttrDescriptionSeq *operator-> (void) const;

    operator const CORBA_AttrDescriptionSeq &() const;
    operator CORBA_AttrDescriptionSeq &();
    operator CORBA_AttrDescriptionSeq &() const;
    CORBA_AttributeDescription &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_AttrDescriptionSeq &in (void) const;
    CORBA_AttrDescriptionSeq &inout (void);
    CORBA_AttrDescriptionSeq *&out (void);
    CORBA_AttrDescriptionSeq *_retn (void);
    CORBA_AttrDescriptionSeq *ptr (void) const;

  private:
    CORBA_AttrDescriptionSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_ATTRDESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_ATTRDESCRIPTIONSEQ___OUT_CH_

  class TAO_Export CORBA_AttrDescriptionSeq_out
  {
  public:
    CORBA_AttrDescriptionSeq_out (CORBA_AttrDescriptionSeq *&);
    CORBA_AttrDescriptionSeq_out (CORBA_AttrDescriptionSeq_var &);
    CORBA_AttrDescriptionSeq_out (const CORBA_AttrDescriptionSeq_out &);
    CORBA_AttrDescriptionSeq_out &operator= (const CORBA_AttrDescriptionSeq_out &);
    CORBA_AttrDescriptionSeq_out &operator= (CORBA_AttrDescriptionSeq *);
    operator CORBA_AttrDescriptionSeq *&();
    CORBA_AttrDescriptionSeq *&ptr (void);
    CORBA_AttrDescriptionSeq *operator-> (void);
    CORBA_AttributeDescription &operator[] (CORBA::ULong index);

  private:
    CORBA_AttrDescriptionSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_AttrDescriptionSeq_var &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___VAR_CH_)
#define _CORBA_INTERFACEDEF___VAR_CH_

  class TAO_Export CORBA_InterfaceDef_var
  {
  public:
    CORBA_InterfaceDef_var (void); // default constructor
    CORBA_InterfaceDef_var (CORBA_InterfaceDef_ptr);
    CORBA_InterfaceDef_var (const CORBA_InterfaceDef_var &); // copy constructor
    ~CORBA_InterfaceDef_var (void); // destructor

    CORBA_InterfaceDef_var &operator= (CORBA_InterfaceDef_ptr);
    CORBA_InterfaceDef_var &operator= (const CORBA_InterfaceDef_var &);
    CORBA_InterfaceDef_ptr operator-> (void) const;

    operator const CORBA_InterfaceDef_ptr &() const;
    operator CORBA_InterfaceDef_ptr &();
    // in, inout, out, _retn
    CORBA_InterfaceDef_ptr in (void) const;
    CORBA_InterfaceDef_ptr &inout (void);
    CORBA_InterfaceDef_ptr &out (void);
    CORBA_InterfaceDef_ptr _retn (void);
    CORBA_InterfaceDef_ptr ptr (void) const;

  private:
    CORBA_InterfaceDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___OUT_CH_)
#define _CORBA_INTERFACEDEF___OUT_CH_

  class TAO_Export CORBA_InterfaceDef_out
  {
  public:
    CORBA_InterfaceDef_out (CORBA_InterfaceDef_ptr &);
    CORBA_InterfaceDef_out (CORBA_InterfaceDef_var &);
    CORBA_InterfaceDef_out (const CORBA_InterfaceDef_out &);
    CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_out &);
    CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_var &);
    CORBA_InterfaceDef_out &operator= (CORBA_InterfaceDef_ptr);
    operator CORBA_InterfaceDef_ptr &();
    CORBA_InterfaceDef_ptr &ptr (void);
    CORBA_InterfaceDef_ptr operator-> (void);

  private:
    CORBA_InterfaceDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF_CH_)
#define _CORBA_INTERFACEDEF_CH_

class TAO_Export CORBA_InterfaceDef: public virtual CORBA_Container, public virtual CORBA_Contained, public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_InterfaceDef_ptr _ptr_type;
    typedef CORBA_InterfaceDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_InterfaceDef_ptr _duplicate (CORBA_InterfaceDef_ptr obj);
    static CORBA_InterfaceDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_InterfaceDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_InterfaceDef_ptr _nil (void)
      {
        return (CORBA::InterfaceDef_ptr)0;
      }

    virtual CORBA_InterfaceDefSeq * base_interfaces (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void base_interfaces (
        const CORBA_InterfaceDefSeq & base_interfaces,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean is_a (
        const char * interface_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    struct  FullInterfaceDescription
    {
      TAO_String_Manager name;
      TAO_String_Manager id;
      TAO_String_Manager defined_in;
      TAO_String_Manager version;
      CORBA_OpDescriptionSeq operations;
      CORBA_AttrDescriptionSeq attributes;
      CORBA_RepositoryIdSeq base_interfaces;
      CORBA::TypeCode_var type;
      CORBA::Boolean is_abstract;
    };

    class  FullInterfaceDescription_var
    {
    public:
      FullInterfaceDescription_var (void); // default constructor
      FullInterfaceDescription_var (FullInterfaceDescription *);
      FullInterfaceDescription_var (const FullInterfaceDescription_var &); // copy constructor
      ~FullInterfaceDescription_var (void); // destructor

      FullInterfaceDescription_var &operator= (FullInterfaceDescription *);
      FullInterfaceDescription_var &operator= (const FullInterfaceDescription_var &);
      FullInterfaceDescription *operator-> (void);
      const FullInterfaceDescription *operator-> (void) const;

      operator const FullInterfaceDescription &() const;
      operator FullInterfaceDescription &();
      operator FullInterfaceDescription &() const;
      // in, inout, out, _retn
      const FullInterfaceDescription &in (void) const;
      FullInterfaceDescription &inout (void);
      FullInterfaceDescription *&out (void);
      FullInterfaceDescription *_retn (void);
      FullInterfaceDescription *ptr (void) const;

    private:
      FullInterfaceDescription *ptr_;
    };

    class  FullInterfaceDescription_out
    {
    public:
      FullInterfaceDescription_out (FullInterfaceDescription *&);
      FullInterfaceDescription_out (FullInterfaceDescription_var &);
      FullInterfaceDescription_out (const FullInterfaceDescription_out &);
      FullInterfaceDescription_out &operator= (const FullInterfaceDescription_out &);
      FullInterfaceDescription_out &operator= (FullInterfaceDescription *);
      operator FullInterfaceDescription *&();
      FullInterfaceDescription *&ptr (void);
      FullInterfaceDescription *operator-> (void);

    private:
      FullInterfaceDescription *&ptr_;
      // assignment from T_var not allowed
      void operator= (const FullInterfaceDescription_var &);
    };

    static CORBA::TypeCode_ptr _tc_FullInterfaceDescription;

    virtual FullInterfaceDescription * describe_interface (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_AttributeDef_ptr create_attribute (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr type,
        CORBA::AttributeMode mode,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_OperationDef_ptr create_operation (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr result,
        CORBA::OperationMode mode,
        const CORBA_ParDescriptionSeq & params,
        const CORBA_ExceptionDefSeq & exceptions,
        const CORBA_ContextIdSeq & contexts,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_InterfaceDef (void);
    CORBA_InterfaceDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_InterfaceDef (void);
  private:
    CORBA_InterfaceDef (const CORBA_InterfaceDef &);
    void operator= (const CORBA_InterfaceDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_InterfaceDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA_RepositoryIdSeq base_interfaces;
    CORBA::Boolean is_abstract;
  };

  class TAO_Export CORBA_InterfaceDescription_var
  {
  public:
    CORBA_InterfaceDescription_var (void); // default constructor
    CORBA_InterfaceDescription_var (CORBA_InterfaceDescription *);
    CORBA_InterfaceDescription_var (const CORBA_InterfaceDescription_var &); // copy constructor
    ~CORBA_InterfaceDescription_var (void); // destructor

    CORBA_InterfaceDescription_var &operator= (CORBA_InterfaceDescription *);
    CORBA_InterfaceDescription_var &operator= (const CORBA_InterfaceDescription_var &);
    CORBA_InterfaceDescription *operator-> (void);
    const CORBA_InterfaceDescription *operator-> (void) const;

    operator const CORBA_InterfaceDescription &() const;
    operator CORBA_InterfaceDescription &();
    operator CORBA_InterfaceDescription &() const;
    // in, inout, out, _retn
    const CORBA_InterfaceDescription &in (void) const;
    CORBA_InterfaceDescription &inout (void);
    CORBA_InterfaceDescription *&out (void);
    CORBA_InterfaceDescription *_retn (void);
    CORBA_InterfaceDescription *ptr (void) const;

  private:
    CORBA_InterfaceDescription *ptr_;
  };

  class TAO_Export CORBA_InterfaceDescription_out
  {
  public:
    CORBA_InterfaceDescription_out (CORBA_InterfaceDescription *&);
    CORBA_InterfaceDescription_out (CORBA_InterfaceDescription_var &);
    CORBA_InterfaceDescription_out (const CORBA_InterfaceDescription_out &);
    CORBA_InterfaceDescription_out &operator= (const CORBA_InterfaceDescription_out &);
    CORBA_InterfaceDescription_out &operator= (CORBA_InterfaceDescription *);
    operator CORBA_InterfaceDescription *&();
    CORBA_InterfaceDescription *&ptr (void);
    CORBA_InterfaceDescription *operator-> (void);

  private:
    CORBA_InterfaceDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_InterfaceDescription_var &);
  };

  struct  CORBA_ValueMember
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    CORBA::TypeCode_var type;
    TAO_Object_Field_T<CORBA_IDLType,CORBA_IDLType_var> type_def;
    CORBA::Visibility access;
  };

  class TAO_Export CORBA_ValueMember_var
  {
  public:
    CORBA_ValueMember_var (void); // default constructor
    CORBA_ValueMember_var (CORBA_ValueMember *);
    CORBA_ValueMember_var (const CORBA_ValueMember_var &); // copy constructor
    ~CORBA_ValueMember_var (void); // destructor

    CORBA_ValueMember_var &operator= (CORBA_ValueMember *);
    CORBA_ValueMember_var &operator= (const CORBA_ValueMember_var &);
    CORBA_ValueMember *operator-> (void);
    const CORBA_ValueMember *operator-> (void) const;

    operator const CORBA_ValueMember &() const;
    operator CORBA_ValueMember &();
    operator CORBA_ValueMember &() const;
    // in, inout, out, _retn
    const CORBA_ValueMember &in (void) const;
    CORBA_ValueMember &inout (void);
    CORBA_ValueMember *&out (void);
    CORBA_ValueMember *_retn (void);
    CORBA_ValueMember *ptr (void) const;

  private:
    CORBA_ValueMember *ptr_;
  };

  class TAO_Export CORBA_ValueMember_out
  {
  public:
    CORBA_ValueMember_out (CORBA_ValueMember *&);
    CORBA_ValueMember_out (CORBA_ValueMember_var &);
    CORBA_ValueMember_out (const CORBA_ValueMember_out &);
    CORBA_ValueMember_out &operator= (const CORBA_ValueMember_out &);
    CORBA_ValueMember_out &operator= (CORBA_ValueMember *);
    operator CORBA_ValueMember *&();
    CORBA_ValueMember *&ptr (void);
    CORBA_ValueMember *operator-> (void);

  private:
    CORBA_ValueMember *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ValueMember_var &);
  };



#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        CORBA_ValueMember *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (const _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &rhs);
      _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &operator= (const _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void); // Dtor.
      // = Accessors.
      CORBA_ValueMember &operator[] (CORBA::ULong i);
      const CORBA_ValueMember &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static CORBA_ValueMember *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_ValueMember *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      CORBA_ValueMember *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_ValueMember *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        CORBA_ValueMember *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_VALUEMEMBERSEQ_CH_)
#define _CORBA_VALUEMEMBERSEQ_CH_

  // *************************************************************
  // ValueMemberSeq
  // *************************************************************

  class TAO_Export CORBA_ValueMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    CORBA_ValueMemberSeq (void); // default ctor
    CORBA_ValueMemberSeq (CORBA::ULong max); // uses max size
    CORBA_ValueMemberSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      CORBA_ValueMember *buffer,
      CORBA::Boolean release=0
    );
    CORBA_ValueMemberSeq (const CORBA_ValueMemberSeq &); // copy ctor
    ~CORBA_ValueMemberSeq (void); // dtor
  };

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERSEQ___VAR_CH_)
#define _CORBA_VALUEMEMBERSEQ___VAR_CH_

// *************************************************************
  // class CORBA::ValueMemberSeq_var
  // *************************************************************

  class TAO_Export CORBA_ValueMemberSeq_var
  {
  public:
    CORBA_ValueMemberSeq_var (void); // default constructor
    CORBA_ValueMemberSeq_var (CORBA_ValueMemberSeq *);
    CORBA_ValueMemberSeq_var (const CORBA_ValueMemberSeq_var &); // copy constructor
    ~CORBA_ValueMemberSeq_var (void); // destructor

    CORBA_ValueMemberSeq_var &operator= (CORBA_ValueMemberSeq *);
    CORBA_ValueMemberSeq_var &operator= (const CORBA_ValueMemberSeq_var &);
    CORBA_ValueMemberSeq *operator-> (void);
    const CORBA_ValueMemberSeq *operator-> (void) const;

    operator const CORBA_ValueMemberSeq &() const;
    operator CORBA_ValueMemberSeq &();
    operator CORBA_ValueMemberSeq &() const;
    CORBA_ValueMember &operator[] (CORBA::ULong index);
    // in, inout, out, _retn
    const CORBA_ValueMemberSeq &in (void) const;
    CORBA_ValueMemberSeq &inout (void);
    CORBA_ValueMemberSeq *&out (void);
    CORBA_ValueMemberSeq *_retn (void);
    CORBA_ValueMemberSeq *ptr (void) const;

  private:
    CORBA_ValueMemberSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERSEQ___OUT_CH_)
#define _CORBA_VALUEMEMBERSEQ___OUT_CH_

  class TAO_Export CORBA_ValueMemberSeq_out
  {
  public:
    CORBA_ValueMemberSeq_out (CORBA_ValueMemberSeq *&);
    CORBA_ValueMemberSeq_out (CORBA_ValueMemberSeq_var &);
    CORBA_ValueMemberSeq_out (const CORBA_ValueMemberSeq_out &);
    CORBA_ValueMemberSeq_out &operator= (const CORBA_ValueMemberSeq_out &);
    CORBA_ValueMemberSeq_out &operator= (CORBA_ValueMemberSeq *);
    operator CORBA_ValueMemberSeq *&();
    CORBA_ValueMemberSeq *&ptr (void);
    CORBA_ValueMemberSeq *operator-> (void);
    CORBA_ValueMember &operator[] (CORBA::ULong index);

  private:
    CORBA_ValueMemberSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ValueMemberSeq_var &);
  };


#endif /* end #if !defined */

#if !defined (_CORBA_VALUEMEMBERDEF___VAR_CH_)
#define _CORBA_VALUEMEMBERDEF___VAR_CH_

  class TAO_Export CORBA_ValueMemberDef_var
  {
  public:
    CORBA_ValueMemberDef_var (void); // default constructor
    CORBA_ValueMemberDef_var (CORBA_ValueMemberDef_ptr);
    CORBA_ValueMemberDef_var (const CORBA_ValueMemberDef_var &); // copy constructor
    ~CORBA_ValueMemberDef_var (void); // destructor

    CORBA_ValueMemberDef_var &operator= (CORBA_ValueMemberDef_ptr);
    CORBA_ValueMemberDef_var &operator= (const CORBA_ValueMemberDef_var &);
    CORBA_ValueMemberDef_ptr operator-> (void) const;

    operator const CORBA_ValueMemberDef_ptr &() const;
    operator CORBA_ValueMemberDef_ptr &();
    // in, inout, out, _retn
    CORBA_ValueMemberDef_ptr in (void) const;
    CORBA_ValueMemberDef_ptr &inout (void);
    CORBA_ValueMemberDef_ptr &out (void);
    CORBA_ValueMemberDef_ptr _retn (void);
    CORBA_ValueMemberDef_ptr ptr (void) const;

  private:
    CORBA_ValueMemberDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF___OUT_CH_)
#define _CORBA_VALUEMEMBERDEF___OUT_CH_

  class TAO_Export CORBA_ValueMemberDef_out
  {
  public:
    CORBA_ValueMemberDef_out (CORBA_ValueMemberDef_ptr &);
    CORBA_ValueMemberDef_out (CORBA_ValueMemberDef_var &);
    CORBA_ValueMemberDef_out (const CORBA_ValueMemberDef_out &);
    CORBA_ValueMemberDef_out &operator= (const CORBA_ValueMemberDef_out &);
    CORBA_ValueMemberDef_out &operator= (const CORBA_ValueMemberDef_var &);
    CORBA_ValueMemberDef_out &operator= (CORBA_ValueMemberDef_ptr);
    operator CORBA_ValueMemberDef_ptr &();
    CORBA_ValueMemberDef_ptr &ptr (void);
    CORBA_ValueMemberDef_ptr operator-> (void);

  private:
    CORBA_ValueMemberDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEMEMBERDEF_CH_)
#define _CORBA_VALUEMEMBERDEF_CH_

class TAO_Export CORBA_ValueMemberDef: public virtual CORBA_Contained
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ValueMemberDef_ptr _ptr_type;
    typedef CORBA_ValueMemberDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ValueMemberDef_ptr _duplicate (CORBA_ValueMemberDef_ptr obj);
    static CORBA_ValueMemberDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ValueMemberDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ValueMemberDef_ptr _nil (void)
      {
        return (CORBA::ValueMemberDef_ptr)0;
      }

    virtual CORBA::TypeCode_ptr type (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_IDLType_ptr type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void type_def (
        CORBA_IDLType_ptr type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Visibility access (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void access (
        CORBA::Visibility access,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ValueMemberDef (void);
    CORBA_ValueMemberDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ValueMemberDef (void);
  private:
    CORBA_ValueMemberDef (const CORBA_ValueMemberDef &);
    void operator= (const CORBA_ValueMemberDef &);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___VAR_CH_)
#define _CORBA_VALUEDEF___VAR_CH_

  class TAO_Export CORBA_ValueDef_var
  {
  public:
    CORBA_ValueDef_var (void); // default constructor
    CORBA_ValueDef_var (CORBA_ValueDef_ptr);
    CORBA_ValueDef_var (const CORBA_ValueDef_var &); // copy constructor
    ~CORBA_ValueDef_var (void); // destructor

    CORBA_ValueDef_var &operator= (CORBA_ValueDef_ptr);
    CORBA_ValueDef_var &operator= (const CORBA_ValueDef_var &);
    CORBA_ValueDef_ptr operator-> (void) const;

    operator const CORBA_ValueDef_ptr &() const;
    operator CORBA_ValueDef_ptr &();
    // in, inout, out, _retn
    CORBA_ValueDef_ptr in (void) const;
    CORBA_ValueDef_ptr &inout (void);
    CORBA_ValueDef_ptr &out (void);
    CORBA_ValueDef_ptr _retn (void);
    CORBA_ValueDef_ptr ptr (void) const;

  private:
    CORBA_ValueDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___OUT_CH_)
#define _CORBA_VALUEDEF___OUT_CH_

  class TAO_Export CORBA_ValueDef_out
  {
  public:
    CORBA_ValueDef_out (CORBA_ValueDef_ptr &);
    CORBA_ValueDef_out (CORBA_ValueDef_var &);
    CORBA_ValueDef_out (const CORBA_ValueDef_out &);
    CORBA_ValueDef_out &operator= (const CORBA_ValueDef_out &);
    CORBA_ValueDef_out &operator= (const CORBA_ValueDef_var &);
    CORBA_ValueDef_out &operator= (CORBA_ValueDef_ptr);
    operator CORBA_ValueDef_ptr &();
    CORBA_ValueDef_ptr &ptr (void);
    CORBA_ValueDef_ptr operator-> (void);

  private:
    CORBA_ValueDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF_CH_)
#define _CORBA_VALUEDEF_CH_

class TAO_Export CORBA_ValueDef: public virtual CORBA_Container, public virtual CORBA_Contained, public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ValueDef_ptr _ptr_type;
    typedef CORBA_ValueDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ValueDef_ptr _duplicate (CORBA_ValueDef_ptr obj);
    static CORBA_ValueDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ValueDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ValueDef_ptr _nil (void)
      {
        return (CORBA::ValueDef_ptr)0;
      }

    virtual CORBA_InterfaceDef_ptr supported_interface (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void supported_interface (
        CORBA_InterfaceDef_ptr supported_interface,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_InitializerSeq * initializers (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void initializers (
        const CORBA_InitializerSeq & initializers,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ValueDef_ptr base_value (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void base_value (
        CORBA_ValueDef_ptr base_value,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ValueDefSeq * abstract_base_values (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void abstract_base_values (
        const CORBA_ValueDefSeq & abstract_base_values,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean is_abstract (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void is_abstract (
        CORBA::Boolean is_abstract,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean is_custom (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void is_custom (
        CORBA::Boolean is_custom,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean is_truncatable (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void is_truncatable (
        CORBA::Boolean is_truncatable,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean is_a (
        const char * value_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    struct  FullValueDescription
    {
      TAO_String_Manager name;
      TAO_String_Manager id;
      CORBA::Boolean is_abstract;
      CORBA::Boolean is_custom;
      TAO_String_Manager defined_in;
      TAO_String_Manager version;
      CORBA_OpDescriptionSeq operations;
      CORBA_AttrDescriptionSeq attributes;
      CORBA_ValueMemberSeq members;
      CORBA_InitializerSeq initializers;
      CORBA_RepositoryIdSeq supported_interfaces;
      CORBA_RepositoryIdSeq abstract_base_values;
      CORBA::Boolean is_truncatable;
      TAO_String_Manager base_value;
      CORBA::TypeCode_var type;
    };

    class  FullValueDescription_var
    {
    public:
      FullValueDescription_var (void); // default constructor
      FullValueDescription_var (FullValueDescription *);
      FullValueDescription_var (const FullValueDescription_var &); // copy constructor
      ~FullValueDescription_var (void); // destructor

      FullValueDescription_var &operator= (FullValueDescription *);
      FullValueDescription_var &operator= (const FullValueDescription_var &);
      FullValueDescription *operator-> (void);
      const FullValueDescription *operator-> (void) const;

      operator const FullValueDescription &() const;
      operator FullValueDescription &();
      operator FullValueDescription &() const;
      // in, inout, out, _retn
      const FullValueDescription &in (void) const;
      FullValueDescription &inout (void);
      FullValueDescription *&out (void);
      FullValueDescription *_retn (void);
      FullValueDescription *ptr (void) const;

    private:
      FullValueDescription *ptr_;
    };

    class  FullValueDescription_out
    {
    public:
      FullValueDescription_out (FullValueDescription *&);
      FullValueDescription_out (FullValueDescription_var &);
      FullValueDescription_out (const FullValueDescription_out &);
      FullValueDescription_out &operator= (const FullValueDescription_out &);
      FullValueDescription_out &operator= (FullValueDescription *);
      operator FullValueDescription *&();
      FullValueDescription *&ptr (void);
      FullValueDescription *operator-> (void);

    private:
      FullValueDescription *&ptr_;
      // assignment from T_var not allowed
      void operator= (const FullValueDescription_var &);
    };

    static CORBA::TypeCode_ptr _tc_FullValueDescription;

    virtual FullValueDescription * describe_value (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_ValueMemberDef_ptr create_value_member (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr type,
        CORBA::Visibility access,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_AttributeDef_ptr create_attribute (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr type,
        CORBA::AttributeMode mode,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_OperationDef_ptr create_operation (
        const char * id,
        const char * name,
        const char * version,
        CORBA_IDLType_ptr result,
        CORBA::OperationMode mode,
        const CORBA_ParDescriptionSeq & params,
        const CORBA_ExceptionDefSeq & exceptions,
        const CORBA_ContextIdSeq & contexts,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ValueDef (void);
    CORBA_ValueDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ValueDef (void);
  private:
    CORBA_ValueDef (const CORBA_ValueDef &);
    void operator= (const CORBA_ValueDef &);
  };


#endif /* end #if !defined */

  struct  CORBA_ValueDescription
  {
    TAO_String_Manager name;
    TAO_String_Manager id;
    CORBA::Boolean is_abstract;
    CORBA::Boolean is_custom;
    TAO_String_Manager defined_in;
    TAO_String_Manager version;
    TAO_String_Manager supported_interface;
    CORBA_RepositoryIdSeq abstract_base_values;
    CORBA::Boolean is_truncatable;
    TAO_String_Manager base_value;
  };

  class TAO_Export CORBA_ValueDescription_var
  {
  public:
    CORBA_ValueDescription_var (void); // default constructor
    CORBA_ValueDescription_var (CORBA_ValueDescription *);
    CORBA_ValueDescription_var (const CORBA_ValueDescription_var &); // copy constructor
    ~CORBA_ValueDescription_var (void); // destructor

    CORBA_ValueDescription_var &operator= (CORBA_ValueDescription *);
    CORBA_ValueDescription_var &operator= (const CORBA_ValueDescription_var &);
    CORBA_ValueDescription *operator-> (void);
    const CORBA_ValueDescription *operator-> (void) const;

    operator const CORBA_ValueDescription &() const;
    operator CORBA_ValueDescription &();
    operator CORBA_ValueDescription &() const;
    // in, inout, out, _retn
    const CORBA_ValueDescription &in (void) const;
    CORBA_ValueDescription &inout (void);
    CORBA_ValueDescription *&out (void);
    CORBA_ValueDescription *_retn (void);
    CORBA_ValueDescription *ptr (void) const;

  private:
    CORBA_ValueDescription *ptr_;
  };

  class TAO_Export CORBA_ValueDescription_out
  {
  public:
    CORBA_ValueDescription_out (CORBA_ValueDescription *&);
    CORBA_ValueDescription_out (CORBA_ValueDescription_var &);
    CORBA_ValueDescription_out (const CORBA_ValueDescription_out &);
    CORBA_ValueDescription_out &operator= (const CORBA_ValueDescription_out &);
    CORBA_ValueDescription_out &operator= (CORBA_ValueDescription *);
    operator CORBA_ValueDescription *&();
    CORBA_ValueDescription *&ptr (void);
    CORBA_ValueDescription *operator-> (void);

  private:
    CORBA_ValueDescription *&ptr_;
    // assignment from T_var not allowed
    void operator= (const CORBA_ValueDescription_var &);
  };


#if !defined (_CORBA_VALUEBOXDEF___VAR_CH_)
#define _CORBA_VALUEBOXDEF___VAR_CH_

  class TAO_Export CORBA_ValueBoxDef_var
  {
  public:
    CORBA_ValueBoxDef_var (void); // default constructor
    CORBA_ValueBoxDef_var (CORBA_ValueBoxDef_ptr);
    CORBA_ValueBoxDef_var (const CORBA_ValueBoxDef_var &); // copy constructor
    ~CORBA_ValueBoxDef_var (void); // destructor

    CORBA_ValueBoxDef_var &operator= (CORBA_ValueBoxDef_ptr);
    CORBA_ValueBoxDef_var &operator= (const CORBA_ValueBoxDef_var &);
    CORBA_ValueBoxDef_ptr operator-> (void) const;

    operator const CORBA_ValueBoxDef_ptr &() const;
    operator CORBA_ValueBoxDef_ptr &();
    // in, inout, out, _retn
    CORBA_ValueBoxDef_ptr in (void) const;
    CORBA_ValueBoxDef_ptr &inout (void);
    CORBA_ValueBoxDef_ptr &out (void);
    CORBA_ValueBoxDef_ptr _retn (void);
    CORBA_ValueBoxDef_ptr ptr (void) const;

  private:
    CORBA_ValueBoxDef_ptr ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___OUT_CH_)
#define _CORBA_VALUEBOXDEF___OUT_CH_

  class TAO_Export CORBA_ValueBoxDef_out
  {
  public:
    CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_ptr &);
    CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_var &);
    CORBA_ValueBoxDef_out (const CORBA_ValueBoxDef_out &);
    CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_out &);
    CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_var &);
    CORBA_ValueBoxDef_out &operator= (CORBA_ValueBoxDef_ptr);
    operator CORBA_ValueBoxDef_ptr &();
    CORBA_ValueBoxDef_ptr &ptr (void);
    CORBA_ValueBoxDef_ptr operator-> (void);

  private:
    CORBA_ValueBoxDef_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF_CH_)
#define _CORBA_VALUEBOXDEF_CH_

class TAO_Export CORBA_ValueBoxDef: public virtual CORBA_IDLType
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef CORBA_ValueBoxDef_ptr _ptr_type;
    typedef CORBA_ValueBoxDef_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static CORBA_ValueBoxDef_ptr _duplicate (CORBA_ValueBoxDef_ptr obj);
    static CORBA_ValueBoxDef_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ValueBoxDef_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    static CORBA_ValueBoxDef_ptr _nil (void)
      {
        return (CORBA::ValueBoxDef_ptr)0;
      }

    virtual CORBA_IDLType_ptr original_type_def (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void original_type_def (
        CORBA_IDLType_ptr original_type_def,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &env =
          TAO_default_environment ()
      );
    virtual const char* _interface_repository_id (void) const;

  protected:
    CORBA_ValueBoxDef (void);
    CORBA_ValueBoxDef (TAO_Stub *objref,
        TAO_ServantBase *_tao_servant = 0,
        CORBA::Boolean _tao_collocated = 0
      );
    virtual ~CORBA_ValueBoxDef (void);
  private:
    CORBA_ValueBoxDef (const CORBA_ValueBoxDef &);
    void operator= (const CORBA_ValueBoxDef &);
  };


#endif /* end #if !defined */

TAO_Export void  operator<<= (CORBA::Any &, CORBA::DefinitionKind);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::DefinitionKind &);
extern TAO_Export CORBA::IRObject_ptr (*_TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::IRObject
TAO_Export void  operator<<= (CORBA::Any &, CORBA::IRObject_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::IRObject *&);
extern TAO_Export CORBA::Contained_ptr (*_TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::Contained
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Contained_ptr);
CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Contained *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::Contained::Description &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Contained::Description*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Contained::Description *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::InterfaceDefSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::InterfaceDefSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::InterfaceDefSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ValueDefSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueDefSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueDefSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ContainedSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ContainedSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ContainedSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::StructMember &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::StructMember*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::StructMember *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::StructMemberSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::StructMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::StructMemberSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::Initializer &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Initializer*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Initializer *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::InitializerSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::InitializerSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::InitializerSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::UnionMember &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::UnionMember*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::UnionMember *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::UnionMemberSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::UnionMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::UnionMemberSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::EnumMemberSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::EnumMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::EnumMemberSeq *&);
extern TAO_Export CORBA::Container_ptr (*_TAO_collocation_CORBA_Container_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::Container
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Container_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Container *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::Container::Description &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Container::Description*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Container::Description *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::Container::DescriptionSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Container::DescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Container::DescriptionSeq *&);
extern TAO_Export CORBA::IDLType_ptr (*_TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::IDLType
TAO_Export void  operator<<= (CORBA::Any &, CORBA::IDLType_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::IDLType *&);
TAO_Export void  operator<<= (CORBA::Any &, CORBA::PrimitiveKind);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::PrimitiveKind &);
extern TAO_Export CORBA::Repository_ptr (*_TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::Repository
TAO_Export void  operator<<= (CORBA::Any &, CORBA::Repository_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::Repository *&);
extern TAO_Export CORBA::ModuleDef_ptr (*_TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ModuleDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ModuleDef_ptr);
CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ModuleDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ModuleDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ModuleDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ModuleDescription *&);
extern TAO_Export CORBA::ConstantDef_ptr (*_TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ConstantDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ConstantDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ConstantDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ConstantDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ConstantDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ConstantDescription *&);
extern TAO_Export CORBA::TypedefDef_ptr (*_TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::TypedefDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::TypedefDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::TypedefDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::TypeDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::TypeDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::TypeDescription *&);
extern TAO_Export CORBA::StructDef_ptr (*_TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::StructDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::StructDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::StructDef *&);
extern TAO_Export CORBA::UnionDef_ptr (*_TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::UnionDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::UnionDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::UnionDef *&);
extern TAO_Export CORBA::EnumDef_ptr (*_TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::EnumDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::EnumDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::EnumDef *&);
extern TAO_Export CORBA::AliasDef_ptr (*_TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::AliasDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::AliasDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::AliasDef *&);
extern TAO_Export CORBA::PrimitiveDef_ptr (*_TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::PrimitiveDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::PrimitiveDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::PrimitiveDef *&);
extern TAO_Export CORBA::StringDef_ptr (*_TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::StringDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::StringDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::StringDef *&);
extern TAO_Export CORBA::WstringDef_ptr (*_TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::WstringDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::WstringDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::WstringDef *&);
extern TAO_Export CORBA::FixedDef_ptr (*_TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::FixedDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::FixedDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::FixedDef *&);
extern TAO_Export CORBA::SequenceDef_ptr (*_TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::SequenceDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::SequenceDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::SequenceDef *&);
extern TAO_Export CORBA::ArrayDef_ptr (*_TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ArrayDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ArrayDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ArrayDef *&);
extern TAO_Export CORBA::ExceptionDef_ptr (*_TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ExceptionDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ExceptionDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ExceptionDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ExceptionDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ExceptionDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ExceptionDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, CORBA::AttributeMode);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::AttributeMode &);
extern TAO_Export CORBA::AttributeDef_ptr (*_TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::AttributeDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::AttributeDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::AttributeDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::AttributeDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::AttributeDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::AttributeDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, CORBA::OperationMode);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::OperationMode &);
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ParameterMode);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ParameterMode &);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ParameterDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ParameterDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ParameterDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ParDescriptionSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ParDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ParDescriptionSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ContextIdSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ContextIdSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ContextIdSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ExceptionDefSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ExceptionDefSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ExceptionDefSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ExcDescriptionSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ExcDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ExcDescriptionSeq *&);
extern TAO_Export CORBA::OperationDef_ptr (*_TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::OperationDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::OperationDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::OperationDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::OperationDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::OperationDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::OperationDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::RepositoryIdSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::RepositoryIdSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::RepositoryIdSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::OpDescriptionSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::OpDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::OpDescriptionSeq *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::AttrDescriptionSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::AttrDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::AttrDescriptionSeq *&);
extern TAO_Export CORBA::InterfaceDef_ptr (*_TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::InterfaceDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::InterfaceDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::InterfaceDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::InterfaceDef::FullInterfaceDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::InterfaceDef::FullInterfaceDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::InterfaceDef::FullInterfaceDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::InterfaceDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::InterfaceDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::InterfaceDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ValueMember &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueMember*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueMember *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ValueMemberSeq &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueMemberSeq *&);
extern TAO_Export CORBA::ValueMemberDef_ptr (*_TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ValueMemberDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueMemberDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueMemberDef *&);
extern TAO_Export CORBA::ValueDef_ptr (*_TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ValueDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueDef *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ValueDef::FullValueDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueDef::FullValueDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueDef::FullValueDescription *&);
TAO_Export void  operator<<= (CORBA::Any &, const CORBA::ValueDescription &); // copying version
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueDescription*); // noncopying version
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueDescription *&);
extern TAO_Export CORBA::ValueBoxDef_ptr (*_TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA::ValueBoxDef
TAO_Export void  operator<<= (CORBA::Any &, CORBA::ValueBoxDef_ptr);
TAO_Export CORBA::Boolean  operator>>= (const CORBA::Any &, CORBA::ValueBoxDef *&);

#ifndef __ACE_INLINE__

TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::DefinitionKind &); //
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::DefinitionKind &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::IRObject_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::IRObject_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::Contained_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::Contained_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::Contained::Description &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::Contained::Description &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::InterfaceDefSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::InterfaceDefSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ValueDefSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ValueDefSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ContainedSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ContainedSeq &
  );

TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::StructMember &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::StructMember &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::StructMemberSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::StructMemberSeq &
  );

TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::Initializer &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::Initializer &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::InitializerSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::InitializerSeq &
  );

TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::UnionMember &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::UnionMember &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::UnionMemberSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::UnionMemberSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::EnumMemberSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::EnumMemberSeq &
  );

TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::Container_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::Container_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::Container::Description &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::Container::Description &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::Container::DescriptionSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::Container::DescriptionSeq &
  );

TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::IDLType_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::IDLType_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::PrimitiveKind &); //
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::PrimitiveKind &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::Repository_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::Repository_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ModuleDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ModuleDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ModuleDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ModuleDescription &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ConstantDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ConstantDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ConstantDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ConstantDescription &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::TypedefDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::TypedefDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::TypeDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::TypeDescription &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::StructDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::StructDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::UnionDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::UnionDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::EnumDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::EnumDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::AliasDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::AliasDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::PrimitiveDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::PrimitiveDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::StringDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::StringDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::WstringDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::WstringDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::FixedDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::FixedDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::SequenceDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::SequenceDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ArrayDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ArrayDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ExceptionDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ExceptionDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ExceptionDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ExceptionDescription &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::AttributeMode &); //
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::AttributeMode &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::AttributeDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::AttributeDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::AttributeDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::AttributeDescription &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::OperationMode &); //
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::OperationMode &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ParameterMode &); //
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ParameterMode &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ParameterDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ParameterDescription &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ParDescriptionSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ParDescriptionSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ContextIdSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ContextIdSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ExceptionDefSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ExceptionDefSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ExcDescriptionSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ExcDescriptionSeq &
  );

TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::OperationDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::OperationDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::OperationDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::OperationDescription &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::RepositoryIdSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::RepositoryIdSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::OpDescriptionSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::OpDescriptionSeq &
  );

TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::AttrDescriptionSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::AttrDescriptionSeq &
  );

TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::InterfaceDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::InterfaceDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::InterfaceDef::FullInterfaceDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::InterfaceDef::FullInterfaceDescription &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::InterfaceDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::InterfaceDescription &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ValueMember &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ValueMember &);
TAO_Export CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const CORBA::ValueMemberSeq &
  );
TAO_Export CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    CORBA::ValueMemberSeq &
  );

TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ValueMemberDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ValueMemberDef_ptr &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ValueDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ValueDef_ptr &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ValueDef::FullValueDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ValueDef::FullValueDescription &);
TAO_Export CORBA::Boolean  operator<< (TAO_OutputCDR &, const CORBA::ValueDescription &);
TAO_Export CORBA::Boolean  operator>> (TAO_InputCDR &, CORBA::ValueDescription &);
TAO_Export CORBA::Boolean
operator<< (TAO_OutputCDR &, const CORBA::ValueBoxDef_ptr );
TAO_Export CORBA::Boolean
operator>> (TAO_InputCDR &, CORBA::ValueBoxDef_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "tao/InterfaceC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */
#endif /* ifndef */
