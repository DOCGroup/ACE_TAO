//$Id$

#if !defined (DNC_DEPLOYMENT_IDL)
#define DNC_DEPLOYMENT_IDL

#include "DnC_Element.idl"

module Deployment {

  struct Connection {
    string name;
    Endpoints endpoint;
  };

  typedef sequence < Connection > Connections;

  exception InvalidConnection {
    string name;
    string reason;
  };

  exception StartError {
    string name;
    string reason;
  };

  interface Application {
    void finishLaunch (in Connections providedReference, in boolean start)
      raises (StartError, InvalidConnection);
    void start ()
      raises (StartError);
  };

  exception InvalidProperty {
    string name;
    string reason;
  };

  exception StopError {
    string name;
    string reason;
  };

  interface ApplicationManager {
    Application startLaunch (in Properties configProperty, out Connections providedReference, in boolean start)
      raises (ResourceNotAvailable, StartError, InvalidProperty);
    void destroyApplication (in Application app)
      raises (StopError);
  };

  typedef sequence < Application > Applications;

  interface DomainApplicationManager :
      ApplicationManager
  {
    Applications getApplications ();
    DeploymentPlan getPlan ();
  };

  typedef sequence < DomainApplicationManager > DomainApplicationManagers;

  interface ExecutionManager {
    DomainApplicationManager preparePlan (in DeploymentPlan plan, in boolean commitResources)
      raises (ResourceNotAvailable, PlanError, StartError);
    DomainApplicationManagers getManagers ();
    void destroyManager (in DomainApplicationManager manager)
      raises (StopError);
  };

  interface Logger {
  };

  interface NodeApplicationManager :
      ApplicationManager
  {
  };

  interface NodeManager {
    void joinDomain (in Domain domain, in TargetManager manager, in Logger log);
    void leaveDomain ();
    NodeApplicationManager preparePlan (in DeploymentPlan plan)
      raises (StartError, PlanError);
    void destroyManager (in NodeApplicationManager appManager)
      raises (StopError);
  };

  interface NodeApplication :
      Application
  {
  };

  interface DomainApplication :
      Application
  {
  };

  exception NameExists {
  };

  exception PackageError {
    string label;
    string reason;
  };

  exception NoSuchName {
  };

  exception LastConfiguration {
  };

  exception InvalidReference {
  };

  struct ComponentPackageDescription;

  typedef sequence < ComponentPackageDescription > ComponentPackageDescriptions;

  struct ComponentPackageReference {
    string requiredType;
  };

  typedef sequence < ComponentPackageReference > ComponentPackageReferences;

  struct SubcomponentInstantiationDescription {
    string name;
    ComponentPackageDescriptions package;
    Properties configProperty;
    Requirements selectRequirement;
    ComponentPackageReferences reference;
  };

  typedef sequence < SubcomponentInstantiationDescription > SubcomponentInstantiationDescriptions;

  struct SubcomponentPortEndpoint {
    string portName;
    unsigned long instanceRef;
  };

  typedef sequence < SubcomponentPortEndpoint > SubcomponentPortEndpoints;

  struct AssemblyConnectionDescription {
    string name;
    Requirements deployRequirement;
    ComponentExternalPortEndpoints externalEndpoint;
    SubcomponentPortEndpoints internalEndpoint;
    ExternalReferenceEndpoints externalReference;
  };

  typedef sequence < AssemblyConnectionDescription > AssemblyConnectionDescriptions;

  struct SubcomponentPropertyReference {
    string propertyName;
    unsigned long instanceRef;
  };

  typedef sequence < SubcomponentPropertyReference > SubcomponentPropertyReferences;

  struct AssemblyPropertyMapping {
    string name;
    string externalName;
    SubcomponentPropertyReferences delegatesTo;
  };

  typedef sequence < AssemblyPropertyMapping > AssemblyPropertyMappings;

  struct ComponentAssemblyDescription {
    SubcomponentInstantiationDescriptions instance;
    AssemblyConnectionDescriptions connection;
    AssemblyPropertyMappings externalProperty;
  };

  typedef sequence < ComponentAssemblyDescription > ComponentAssemblyDescriptions;

  struct NamedImplementationArtifact;

  typedef sequence < NamedImplementationArtifact > NamedImplementationArtifacts;

  struct ImplementationArtifactDescription {
    string label;
    string UUID;
    string location;
    Properties execParameter;
    Requirements deployRequirement;
    NamedImplementationArtifacts dependsOn;
  };

  struct NamedImplementationArtifact {
    string name;
    ImplementationArtifactDescription referencedArtifact;
  };

  struct MonolithicImplementationDescription {
    Properties execParameter;
    Requirements deployRequirement;
    NamedImplementationArtifacts primaryArtifact;
  };

  typedef sequence < MonolithicImplementationDescription > MonolithicImplementationDescriptions;

  struct Capability {
    string name;
    ::CORBA::StringSeq resourceType;
    SatisfierProperties property;
  };

  typedef sequence < Capability > Capabilities;

  struct ComponentImplementationDescription {
    string label;
    string UUID;
    ComponentInterfaceDescription implements;
    ComponentAssemblyDescriptions assemblyImpl;
    MonolithicImplementationDescriptions monolithicImpl;
    Properties configProperty;
    Capabilities capability;
    ImplementationDependencies dependsOn;
  };

  struct PackagedComponentImplementation {
    string name;
    ComponentImplementationDescription referencedImplementation;
  };

  typedef sequence < PackagedComponentImplementation > PackagedComponentImplementations;

  struct ComponentPackageDescription {
    string label;
    string UUID;
    ComponentInterfaceDescription realizes;
    Properties configProperty;
    PackagedComponentImplementations implementation;
  };

  struct PackageConfiguration {
    string name;
    string label;
    ::CORBA::ULongSeq specializedConfigRef;
    ComponentPackageDescriptions basePackage;
    Requirements selectRequirement;
    Properties configProperty;
  };

  interface RepositoryManager {
    void installPackage (in string name, in string label, in string location)
      raises (NameExists, PackageError);
    void createPackage (in string name, in string label, in ComponentPackageDescription package, in string baseLocation)
      raises (NameExists, PackageError);
    PackageConfiguration findConfigurationByName (in string label)
      raises (NoSuchName);
    ::CORBA::StringSeq getAllNames ();
    ::CORBA::StringSeq findNamesByType (in string type);
    ::CORBA::StringSeq getAllTypes ();
    void createConfiguration (in string nname, in string bname, in Properties cp, in Requirements sr)
      raises (NoSuchName, NameExists);
    void updateConfiguration (in string name, in Properties cp, in Requirements sr)
      raises (NoSuchName);
    void deleteConfiguration (in string name, in boolean deletePackage)
      raises (NoSuchName, LastConfiguration);
  };

  struct RequirementSatisfier {
    string name;
    ::CORBA::StringSeq resourceType;
    SatisfierProperties property;
  };

};
#endif /* DNC_DEPLOYMENT_IDL */
