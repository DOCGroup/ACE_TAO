--- Svc_Conf_l.cpp.save	Mon Mar 11 17:19:27 2002
+++ Svc_Conf_l.cpp	Mon Mar 11 17:47:24 2002
@@ -1,16 +1,14 @@
+#define ACE_YY_NO_UNPUT
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ * $Header: /project/cvs-repository/ACE_wrappers-repository/ace/Svc_Conf_l.cpp,v 4.59 2002/03/11 23:47:24 spark Exp $
  */
 
 #define FLEX_SCANNER
 #define ACE_YY_FLEX_MAJOR_VERSION 2
 #define ACE_YY_FLEX_MINOR_VERSION 5
 
-#include "ace/OS.h"
-
-
 /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
 #ifdef c_plusplus
 #ifndef __cplusplus
@@ -21,8 +19,8 @@
 
 #ifdef __cplusplus
 
-#include /**/ <stdlib.h>
 #include "ace/OS.h"
+#include "ace/Object_Manager.h"
 
 /* Use prototypes in function declarations. */
 #define ACE_YY_USE_PROTOS
@@ -132,7 +130,9 @@
 		} \
 	while ( 0 )
 
+#if 0
 #define unput(c) ace_yyunput( c, ace_yytext_ptr )
+#endif /* 0 */
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
@@ -145,8 +145,8 @@
 	{
 	FILE *ace_yy_input_file;
 
-	char *ace_yy_ch_buf;		/* input buffer */
-	char *ace_yy_buf_pos;		/* current position in input buffer */
+	ACE_TCHAR *ace_yy_ch_buf;	/* input buffer */
+	ACE_TCHAR *ace_yy_buf_pos;	/* current position in input buffer */
 
 	/* Size of input buffer in bytes, not including room for EOB
 	 * characters.
@@ -208,7 +208,7 @@
 
 
 /* ace_yy_hold_char holds the character lost when ace_yytext is formed. */
-static char ace_yy_hold_char;
+static ACE_TCHAR ace_yy_hold_char;
 
 static int ace_yy_n_chars;		/* number of characters read into ace_yy_ch_buf */
 
@@ -216,7 +216,7 @@
 int ace_yyleng;
 
 /* Points to current character in buffer. */
-static char *ace_yy_c_buf_p = (char *) 0;
+static ACE_TCHAR *ace_yy_c_buf_p = (ACE_TCHAR *) 0;
 static int ace_yy_init = 1;		/* whether we need to initialize */
 static int ace_yy_start = 0;	/* start state number */
 
@@ -235,9 +235,9 @@
 void ace_yy_flush_buffer ACE_YY_PROTO(( ACE_YY_BUFFER_STATE b ));
 #define ACE_YY_FLUSH_BUFFER ace_yy_flush_buffer( ace_yy_current_buffer )
 
-ACE_YY_BUFFER_STATE ace_yy_scan_buffer ACE_YY_PROTO(( char *base, ace_yy_size_t size ));
-ACE_YY_BUFFER_STATE ace_yy_scan_string ACE_YY_PROTO(( ace_yyconst char *ace_yy_str ));
-ACE_YY_BUFFER_STATE ace_yy_scan_bytes ACE_YY_PROTO(( ace_yyconst char *bytes, int len ));
+ACE_YY_BUFFER_STATE ace_yy_scan_buffer ACE_YY_PROTO(( ACE_TCHAR *base, ace_yy_size_t size ));
+ACE_YY_BUFFER_STATE ace_yy_scan_string ACE_YY_PROTO(( ace_yyconst ACE_TCHAR *ace_yy_str ));
+ACE_YY_BUFFER_STATE ace_yy_scan_bytes ACE_YY_PROTO(( ace_yyconst ACE_TCHAR *bytes, int len ));
 
 static void *ace_yy_flex_alloc ACE_YY_PROTO(( ace_yy_size_t ));
 static void *ace_yy_flex_realloc ACE_YY_PROTO(( void *, ace_yy_size_t ));
@@ -261,16 +261,16 @@
 
 #define ACE_YY_AT_BOL() (ace_yy_current_buffer->ace_yy_at_bol)
 
-typedef unsigned char ACE_YY_CHAR;
+typedef ACE_TCHAR ACE_YY_CHAR;
 FILE *ace_yyin = (FILE *) 0, *ace_yyout = (FILE *) 0;
 typedef int ace_yy_state_type;
-extern char *ace_yytext;
+extern ACE_TCHAR *ace_yytext;
 #define ace_yytext_ptr ace_yytext
 
 static ace_yy_state_type ace_yy_get_previous_state ACE_YY_PROTO(( void ));
 static ace_yy_state_type ace_yy_try_NUL_trans ACE_YY_PROTO(( ace_yy_state_type current_state ));
 static int ace_yy_get_next_buffer ACE_YY_PROTO(( void ));
-static void ace_yy_fatal_error ACE_YY_PROTO(( ace_yyconst char msg[] ));
+static void ace_yy_fatal_error ACE_YY_PROTO(( ace_yyconst ACE_TCHAR msg[] ));
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up ace_yytext.
@@ -490,7 +490,7 @@
     } ;
 
 static ace_yy_state_type ace_yy_last_accepting_state;
-static char *ace_yy_last_accepting_cpos;
+static ACE_TCHAR *ace_yy_last_accepting_cpos;
 
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
@@ -499,9 +499,9 @@
 #define ace_yymore() ace_yymore_used_but_not_detected
 #define ACE_YY_MORE_ADJ 0
 #define ACE_YY_RESTORE_ACE_YY_MORE_OFFSET
-char *ace_yytext;
+ACE_TCHAR *ace_yytext;
 #define INITIAL 0
-// $Id: Svc_Conf.l,v 4.18 2002/03/08 23:15:25 spark Exp $
+// $Id: Svc_Conf_l.cpp,v 4.59 2002/03/11 23:47:24 spark Exp $
 // Sample lexical analysis for regular expression subset.  Must be
 // compiled with FLEX and an ANSI C++ compiler.
 
@@ -512,7 +512,7 @@
 
 ACE_RCSID (ace,
 	   Svc_Conf_l,
-	   "$Id: Svc_Conf.l,v 4.18 2002/03/08 23:15:25 spark Exp $")
+	   "$Id: Svc_Conf_l.cpp,v 4.59 2002/03/11 23:47:24 spark Exp $")
 
 // Keeps track of the current line for debugging output.
 int ace_yylineno = 1;
@@ -536,15 +536,15 @@
 #endif
 
 #ifndef ACE_YY_NO_UNPUT
-static void ace_yyunput ACE_YY_PROTO(( int c, char *buf_ptr ));
+static void ace_yyunput ACE_YY_PROTO(( int c, ACE_TCHAR *buf_ptr ));
 #endif
 
 #ifndef ace_yytext_ptr
-static void ace_yy_flex_strncpy ACE_YY_PROTO(( char *, ace_yyconst char *, int ));
+static void ace_yy_flex_strncpy ACE_YY_PROTO(( ACE_TCHAR *, ace_yyconst ACE_TCHAR *, int ));
 #endif
 
 #ifdef ACE_YY_NEED_STRLEN
-static int ace_yy_flex_strlen ACE_YY_PROTO(( ace_yyconst char * ));
+static int ace_yy_flex_strlen ACE_YY_PROTO(( ace_yyconst ACE_TCHAR * ));
 #endif
 
 #ifndef ACE_YY_NO_INPUT
@@ -614,16 +614,16 @@
 		int c = '*', n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( ace_yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
+			buf[n] = (ACE_TCHAR) c; \
 		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
+			buf[n++] = (ACE_TCHAR) c; \
 		if ( c == EOF && ferror( ace_yyin ) ) \
-			ACE_YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "input in flex scanner failed") ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, ace_yyin )) == 0) \
+	else if ( ((result = fread( buf, sizeof (ACE_TCHAR), max_size, ace_yyin )) == 0) \
 		  && ferror( ace_yyin ) ) \
-		ACE_YY_FATAL_ERROR( "input in flex scanner failed" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT("input in flex scanner failed") );
 #endif
 
 /* No semi-colon after return; correct usage is to write "ace_yyterminate();" -
@@ -671,8 +671,15 @@
 
 ACE_YY_DECL
 	{
+          ACE_MT (ACE_GUARD_RETURN (ACE_SYNCH_RECURSIVE_MUTEX,
+                                    ace_mon,
+                                    *ACE_Static_Object_Lock::instance (),
+                                    -1));
+
+          ACE_Svc_Conf_Lexer_Guard ace_lexer_guard (ACE_SVC_CONF_PARAM);
+
 	register ace_yy_state_type ace_yy_current_state;
-	register char *ace_yy_cp, *ace_yy_bp;
+	register ACE_TCHAR *ace_yy_cp=0, *ace_yy_bp=0;
 	register int ace_yy_act;
 
 
@@ -770,71 +777,71 @@
 case 2:
 ACE_YY_RULE_SETUP
 { return token (ACE_DYNAMIC); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 3:
 ACE_YY_RULE_SETUP
 { return token (ACE_STATIC); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 4:
 ACE_YY_RULE_SETUP
 { return token (ACE_SUSPEND); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 5:
 ACE_YY_RULE_SETUP
 { return token (ACE_RESUME); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 6:
 ACE_YY_RULE_SETUP
 { return token (ACE_REMOVE); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 7:
 ACE_YY_RULE_SETUP
 { return token (ACE_USTREAM); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 8:
 ACE_YY_RULE_SETUP
 { return token (ACE_MODULE_T); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 9:
 ACE_YY_RULE_SETUP
 { return token (ACE_SVC_OBJ_T); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 10:
 ACE_YY_RULE_SETUP
 { return token (ACE_STREAM_T); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 11:
 ACE_YY_RULE_SETUP
 { return token (ACE_ACTIVE); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 12:
 ACE_YY_RULE_SETUP
 { return token (ACE_INACTIVE); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 13:
 ACE_YY_RULE_SETUP
 { return token (':'); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 14:
 ACE_YY_RULE_SETUP
 { return token ('*'); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 15:
 ACE_YY_RULE_SETUP
 { return token ('('); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 16:
 ACE_YY_RULE_SETUP
 { return token (')'); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 17:
 ACE_YY_RULE_SETUP
 { return token ('{'); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 18:
 ACE_YY_RULE_SETUP
 { return token ('}'); }
-	ACE_YY_BREAK
+	//      ACE_YY_BREAK
 case 19:
 ACE_YY_RULE_SETUP
 {
@@ -853,21 +860,21 @@
 			ace_yyleng -= 1;
                         ace_yylval->ident_ = ACE_SVC_CONF_PARAM->obstack.copy (ace_yytext + 1, ace_yyleng);
 			return token (ACE_STRING); }
-	ACE_YY_BREAK
+//	ACE_YY_BREAK
 case 20:
 ACE_YY_RULE_SETUP
 {
 		        ace_yylval->ident_ = ACE_SVC_CONF_PARAM->obstack.copy (ace_yytext, ace_yyleng);
 			return token (ACE_IDENT);
 		      }
-	ACE_YY_BREAK
+//	ACE_YY_BREAK
 case 21:
 ACE_YY_RULE_SETUP
 {
 		        ace_yylval->ident_ = ACE_SVC_CONF_PARAM->obstack.copy (ace_yytext, ace_yyleng);
 			return token (ACE_PATHNAME);
 		      }
-	ACE_YY_BREAK
+//	ACE_YY_BREAK
 case 22:
 ACE_YY_RULE_SETUP
 ; /* EMPTY */
@@ -878,7 +885,7 @@
 	ACE_YY_BREAK
 case 24:
 ACE_YY_RULE_SETUP
-{ ACE_SVC_CONF_PARAM->ace_yylineno++; ace_ace_yylineno++; }
+{ ACE_SVC_CONF_PARAM->yylineno++; ace_yylineno++; }
 	ACE_YY_BREAK
 case 25:
 ACE_YY_RULE_SETUP
@@ -895,7 +902,7 @@
 case ACE_YY_STATE_EOF(PARAMETERS):
 case ACE_YY_STATE_EOF(NORMAL):
 { ace_yyterminate(); }
-	ACE_YY_BREAK
+//	ACE_YY_BREAK
 case 26:
 ACE_YY_RULE_SETUP
 ACE_SVC_CONF_ECHO;
@@ -903,7 +910,7 @@
 
 	case ACE_YY_END_OF_BUFFER:
 		{
-		/* Amount of text matched not including the EOB char. */
+		/* Amount of text matched not including the EOB ACE_TCHAR. */
 		int ace_yy_amount_of_matched_text = (int) (ace_yy_cp - ace_yytext_ptr) - 1;
 
 		/* Undo the effects of ACE_YY_DO_BEFORE_ACTION. */
@@ -1025,7 +1032,7 @@
 
 	default:
 		ACE_YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
+			ACE_LIB_TEXT("fatal flex scanner internal error--no action found") );
 	} /* end of action switch */
 		} /* end of scanning one token */
 	} /* end of ace_yylex */
@@ -1041,14 +1048,14 @@
 
 static int ace_yy_get_next_buffer()
 	{
-	register char *dest = ace_yy_current_buffer->ace_yy_ch_buf;
-	register char *source = ace_yytext_ptr;
+	register ACE_TCHAR *dest = ace_yy_current_buffer->ace_yy_ch_buf;
+	register ACE_TCHAR *source = ace_yytext_ptr;
 	register int number_to_move, i;
 	int ret_val;
 
 	if ( ace_yy_c_buf_p > &ace_yy_current_buffer->ace_yy_ch_buf[ace_yy_n_chars + 1] )
 		ACE_YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
+		ACE_LIB_TEXT("fatal flex scanner internal error--end of buffer missed") );
 
 	if ( ace_yy_current_buffer->ace_yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
@@ -1091,8 +1098,8 @@
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
 #ifdef ACE_YY_USES_REJECT
-			ACE_YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+                          ACE_YY_FATAL_ERROR(ACE_LIB_TEXT(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT") );
 #else
 
 			/* just a shorter name for the current buffer */
@@ -1110,18 +1117,18 @@
 				else
 					b->ace_yy_buf_size *= 2;
 
-				b->ace_yy_ch_buf = (char *)
+				b->ace_yy_ch_buf = (ACE_TCHAR *)
 					/* Include room in for 2 EOB chars. */
 					ace_yy_flex_realloc( (void *) b->ace_yy_ch_buf,
-							 b->ace_yy_buf_size + 2 );
+                                                      (b->ace_yy_buf_size + 2)*sizeof(ACE_TCHAR));
 				}
 			else
 				/* Can't grow it, we don't own it. */
 				b->ace_yy_ch_buf = 0;
 
 			if ( ! b->ace_yy_ch_buf )
-				ACE_YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
+                          ACE_YY_FATAL_ERROR(ACE_LIB_TEXT(
+				"fatal error - scanner input buffer overflow") );
 
 			ace_yy_c_buf_p = &b->ace_yy_ch_buf[ace_yy_c_buf_p_offset];
 
@@ -1130,8 +1137,8 @@
 #endif
 			}
 
-		if ( num_to_read > ACE_YY_READ_BUF_SIZE )
-			num_to_read = ACE_YY_READ_BUF_SIZE;
+		if ( num_to_read * sizeof (ACE_TCHAR) > ACE_YY_READ_BUF_SIZE )
+			num_to_read = ACE_YY_READ_BUF_SIZE/sizeof (ACE_TCHAR);
 
 		/* Read in more data. */
 		ACE_YY_INPUT( (&ace_yy_current_buffer->ace_yy_ch_buf[number_to_move]),
@@ -1169,12 +1176,12 @@
 	}
 
 
-/* ace_yy_get_previous_state - get the state just before the EOB char was reached */
+/* ace_yy_get_previous_state - get the state just before the EOB ACE_TCHAR was reached */
 
 static ace_yy_state_type ace_yy_get_previous_state()
 	{
 	register ace_yy_state_type ace_yy_current_state;
-	register char *ace_yy_cp;
+	register ACE_TCHAR *ace_yy_cp;
 
 	ace_yy_current_state = ace_yy_start;
 	ace_yy_current_state += ACE_YY_AT_BOL();
@@ -1214,7 +1221,7 @@
 #endif
 	{
 	register int ace_yy_is_jam;
-	register char *ace_yy_cp = ace_yy_c_buf_p;
+	register ACE_TCHAR *ace_yy_cp = ace_yy_c_buf_p;
 
 	register ACE_YY_CHAR ace_yy_c = 1;
 	if ( ace_yy_accept[ace_yy_current_state] )
@@ -1237,14 +1244,14 @@
 
 #ifndef ACE_YY_NO_UNPUT
 #ifdef ACE_YY_USE_PROTOS
-static void ace_yyunput( int c, register char *ace_yy_bp )
+static void ace_yyunput( int c, register ACE_TCHAR *ace_yy_bp )
 #else
 static void ace_yyunput( c, ace_yy_bp )
 int c;
-register char *ace_yy_bp;
+register ACE_TCHAR *ace_yy_bp;
 #endif
 	{
-	register char *ace_yy_cp = ace_yy_c_buf_p;
+	register ACE_TCHAR *ace_yy_cp = ace_yy_c_buf_p;
 
 	/* undo effects of setting up ace_yytext */
 	*ace_yy_cp = ace_yy_hold_char;
@@ -1253,9 +1260,9 @@
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
 		register int number_to_move = ace_yy_n_chars + 2;
-		register char *dest = &ace_yy_current_buffer->ace_yy_ch_buf[
+		register ACE_TCHAR *dest = &ace_yy_current_buffer->ace_yy_ch_buf[
 					ace_yy_current_buffer->ace_yy_buf_size + 2];
-		register char *source =
+		register ACE_TCHAR *source =
 				&ace_yy_current_buffer->ace_yy_ch_buf[number_to_move];
 
 		while ( source > ace_yy_current_buffer->ace_yy_ch_buf )
@@ -1267,10 +1274,10 @@
 			ace_yy_n_chars = ace_yy_current_buffer->ace_yy_buf_size;
 
 		if ( ace_yy_cp < ace_yy_current_buffer->ace_yy_ch_buf + 2 )
-			ACE_YY_FATAL_ERROR( "flex scanner push-back overflow" );
+			ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "flex scanner push-back overflow") );
 		}
 
-	*--ace_yy_cp = (char) c;
+	*--ace_yy_cp = (ACE_TCHAR) c;
 
 
 	ace_yytext_ptr = ace_yy_bp;
@@ -1424,16 +1431,16 @@
 
 	b = (ACE_YY_BUFFER_STATE) ace_yy_flex_alloc( sizeof( struct ace_yy_buffer_state ) );
 	if ( ! b )
-		ACE_YY_FATAL_ERROR( "out of dynamic memory in ace_yy_create_buffer()" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "out of dynamic memory in ace_yy_create_buffer()") );
 
 	b->ace_yy_buf_size = size;
 
 	/* ace_yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->ace_yy_ch_buf = (char *) ace_yy_flex_alloc( b->ace_yy_buf_size + 2 );
+	b->ace_yy_ch_buf = (ACE_TCHAR *) ace_yy_flex_alloc( (b->ace_yy_buf_size + 2 ) * sizeof (ACE_TCHAR));
 	if ( ! b->ace_yy_ch_buf )
-		ACE_YY_FATAL_ERROR( "out of dynamic memory in ace_yy_create_buffer()" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "out of dynamic memory in ace_yy_create_buffer()") );
 
 	b->ace_yy_is_our_buffer = 1;
 
@@ -1462,6 +1469,11 @@
 	ace_yy_flex_free( (void *) b );
 	}
 
+#ifndef ACE_YY_ALWAYS_INTERACTIVE
+#ifndef ACE_YY_NEVER_INTERACTIVE
+extern int nop_isatty ACE_YY_PROTO(( int ));
+#endif
+#endif
 
 #ifndef ACE_YY_ALWAYS_INTERACTIVE
 #ifndef ACE_YY_NEVER_INTERACTIVE
@@ -1528,10 +1540,10 @@
 
 #ifndef ACE_YY_NO_SCAN_BUFFER
 #ifdef ACE_YY_USE_PROTOS
-ACE_YY_BUFFER_STATE ace_yy_scan_buffer( char *base, ace_yy_size_t size )
+ACE_YY_BUFFER_STATE ace_yy_scan_buffer( ACE_TCHAR *base, ace_yy_size_t size )
 #else
 ACE_YY_BUFFER_STATE ace_yy_scan_buffer( base, size )
-char *base;
+ACE_TCHAR *base;
 ace_yy_size_t size;
 #endif
 	{
@@ -1545,7 +1557,7 @@
 
 	b = (ACE_YY_BUFFER_STATE) ace_yy_flex_alloc( sizeof( struct ace_yy_buffer_state ) );
 	if ( ! b )
-		ACE_YY_FATAL_ERROR( "out of dynamic memory in ace_yy_scan_buffer()" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "out of dynamic memory in ace_yy_scan_buffer()" ));
 
 	b->ace_yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
 	b->ace_yy_buf_pos = b->ace_yy_ch_buf = base;
@@ -1566,10 +1578,10 @@
 
 #ifndef ACE_YY_NO_SCAN_STRING
 #ifdef ACE_YY_USE_PROTOS
-ACE_YY_BUFFER_STATE ace_yy_scan_string( ace_yyconst char *ace_yy_str )
+ACE_YY_BUFFER_STATE ace_yy_scan_string( ace_yyconst ACE_TCHAR *ace_yy_str )
 #else
 ACE_YY_BUFFER_STATE ace_yy_scan_string( ace_yy_str )
-ace_yyconst char *ace_yy_str;
+ace_yyconst ACE_TCHAR *ace_yy_str;
 #endif
 	{
 	int len;
@@ -1583,23 +1595,23 @@
 
 #ifndef ACE_YY_NO_SCAN_BYTES
 #ifdef ACE_YY_USE_PROTOS
-ACE_YY_BUFFER_STATE ace_yy_scan_bytes( ace_yyconst char *bytes, int len )
+ACE_YY_BUFFER_STATE ace_yy_scan_bytes( ace_yyconst ACE_TCHAR *bytes, int len )
 #else
 ACE_YY_BUFFER_STATE ace_yy_scan_bytes( bytes, len )
-ace_yyconst char *bytes;
+ace_yyconst ACE_TCHAR *bytes;
 int len;
 #endif
 	{
 	ACE_YY_BUFFER_STATE b;
-	char *buf;
+	ACE_TCHAR *buf;
 	ace_yy_size_t n;
 	int i;
 
 	/* Get memory for full buffer, including space for trailing EOB's. */
 	n = len + 2;
-	buf = (char *) ace_yy_flex_alloc( n );
+	buf = (ACE_TCHAR *) ace_yy_flex_alloc( n * sizeof (ACE_TCHAR));
 	if ( ! buf )
-		ACE_YY_FATAL_ERROR( "out of dynamic memory in ace_yy_scan_bytes()" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "out of dynamic memory in ace_yy_scan_bytes()" ));
 
 	for ( i = 0; i < len; ++i )
 		buf[i] = bytes[i];
@@ -1608,7 +1620,7 @@
 
 	b = ace_yy_scan_buffer( buf, n );
 	if ( ! b )
-		ACE_YY_FATAL_ERROR( "bad buffer in ace_yy_scan_bytes()" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "bad buffer in ace_yy_scan_bytes()") );
 
 	/* It's okay to grow etc. this buffer, and we should throw it
 	 * away when we're done.
@@ -1643,8 +1655,8 @@
 					(void *) ace_yy_start_stack, new_size );
 
 		if ( ! ace_yy_start_stack )
-			ACE_YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
+                  ACE_YY_FATAL_ERROR(ACE_LIB_TEXT(
+			"out of memory expanding start-condition stack" ));
 		}
 
 	ace_yy_start_stack[ace_yy_start_stack_ptr++] = ACE_YY_START;
@@ -1658,7 +1670,7 @@
 static void ace_yy_pop_state()
 	{
 	if ( --ace_yy_start_stack_ptr < 0 )
-		ACE_YY_FATAL_ERROR( "start-condition stack underflow" );
+		ACE_YY_FATAL_ERROR(ACE_LIB_TEXT( "start-condition stack underflow" ));
 
 	BEGIN(ace_yy_start_stack[ace_yy_start_stack_ptr]);
 	}
@@ -1677,13 +1689,13 @@
 #endif
 
 #ifdef ACE_YY_USE_PROTOS
-static void ace_yy_fatal_error( ace_yyconst char msg[] )
+static void ace_yy_fatal_error( ace_yyconst ACE_TCHAR msg[] )
 #else
 static void ace_yy_fatal_error( msg )
-char msg[];
+ACE_TCHAR msg[];
 #endif
 	{
-	(void) fprintf( stderr, "%s\n", msg );
+	(void) ACE_OS::fprintf( stderr, ACE_LIB_TEXT("%s\n"), msg );
 	exit( ACE_YY_EXIT_FAILURE );
 	}
 
@@ -1709,11 +1721,11 @@
 
 #ifndef ace_yytext_ptr
 #ifdef ACE_YY_USE_PROTOS
-static void ace_yy_flex_strncpy( char *s1, ace_yyconst char *s2, int n )
+static void ace_yy_flex_strncpy( ACE_TCHAR *s1, ace_yyconst ACE_TCHAR *s2, int n )
 #else
 static void ace_yy_flex_strncpy( s1, s2, n )
-char *s1;
-ace_yyconst char *s2;
+ACE_TCHAR *s1;
+ace_yyconst ACE_TCHAR *s2;
 int n;
 #endif
 	{
@@ -1725,10 +1737,10 @@
 
 #ifdef ACE_YY_NEED_STRLEN
 #ifdef ACE_YY_USE_PROTOS
-static int ace_yy_flex_strlen( ace_yyconst char *s )
+static int ace_yy_flex_strlen( ace_yyconst ACE_TCHAR *s )
 #else
 static int ace_yy_flex_strlen( s )
-ace_yyconst char *s;
+ace_yyconst ACE_TCHAR *s;
 #endif
 	{
 	register int n;
