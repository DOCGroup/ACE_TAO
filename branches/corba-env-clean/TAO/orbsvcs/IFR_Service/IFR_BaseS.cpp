// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_BASES_CPP_
#define _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_BASES_CPP_

#include "IFR_BaseS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#include "tao/PortableServer/ServerInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BaseS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:18:35 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_IRObject::_is_a_skel},
      {"",0},
      {"destroy",       &POA_CORBA_IRObject::destroy_skel},
      {"",0},{"",0},
      {"_interface",  &POA_CORBA_IRObject::_interface_skel},
      {"",0},{"",0},
      {"_get_def_kind",         &POA_CORBA_IRObject::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA_IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:18:35 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_IRObject *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::DefinitionKind result);

private:
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (const TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get &);

private:
  POA_CORBA_IRObject *_tao_impl;
  CORBA::DefinitionKind _result;
};

TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_IRObject *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::DefinitionKind result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_IRObject_destroy : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_IRObject *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_IRObject_destroy (const TAO_ServerRequestInfo_CORBA_IRObject_destroy &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IRObject_destroy &);

private:
  POA_CORBA_IRObject *_tao_impl;

};

TAO_ServerRequestInfo_CORBA_IRObject_destroy::TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_IRObject *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_IRObject_Strategized_Proxy_Broker *_TAO_CORBA_IRObject_Strategized_Proxy_Broker::the_TAO_CORBA_IRObject_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_IRObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_IRObject_Strategized_Proxy_Broker::_TAO_CORBA_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_IRObject_Strategized_Proxy_Broker::~_TAO_CORBA_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_IRObject_Proxy_Impl&
_TAO_CORBA_IRObject_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_IRObject *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_IRObject_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_IRObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_IRObject_Proxy_Broker *
_TAO_CORBA_IRObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_IRObject_Strategized_Proxy_Broker::the_TAO_CORBA_IRObject_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_IRObject_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_IRObject_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_IRObject_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_IRObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_IRObject_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_IRObject_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_IRObject_ThruPOA_Proxy_Impl::_TAO_CORBA_IRObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::DefinitionKind _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "def_kind",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->def_kind (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->destroy (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_IRObject::POA_CORBA_IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA_IRObject::POA_CORBA_IRObject (const POA_CORBA_IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_IRObject::~POA_CORBA_IRObject (void)
{
}

void POA_CORBA_IRObject::_get_def_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IRObject *_tao_impl =
    ACE_static_cast (POA_CORBA_IRObject *, _tao_object_reference);

    CORBA::DefinitionKind _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->def_kind (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::DefinitionKind _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_IRObject::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IRObject *_tao_impl =
    ACE_static_cast (POA_CORBA_IRObject *, _tao_object_reference);

  _tao_server_request.argument_flag (0);

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_IRObject_destroy ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->destroy (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_IRObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IRObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IRObject::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_IRObject::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_IRObject::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_IRObject::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA_IRObject*
POA_CORBA_IRObject::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_IRObject::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:18:36 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 20
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_Contained::move_skel},
      {"_is_a",  &POA_CORBA_Contained::_is_a_skel},
      {"_get_id",       &POA_CORBA_Contained::_get_id_skel},
      {"_set_id",       &POA_CORBA_Contained::_set_id_skel},
      {"describe",      &POA_CORBA_Contained::describe_skel},
      {"_get_name",     &POA_CORBA_Contained::_get_name_skel},
      {"_set_name",     &POA_CORBA_Contained::_set_name_skel},
      {"_interface",  &POA_CORBA_Contained::_interface_skel},
      {"_get_version",  &POA_CORBA_Contained::_get_version_skel},
      {"_set_version",  &POA_CORBA_Contained::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_Contained::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_Contained::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_Contained::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA_Contained::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  48,   8, -45,  11,  -1, -46,  14,
       -1,  15,  -1,  16,  17,  -6,  -2,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:18:36 */
static TAO_CORBA_Contained_Perfect_Hash_OpTable tao_CORBA_Contained_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Contained_id_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_id_get (const TAO_ServerRequestInfo_CORBA_Contained_id_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_id_get &);

private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_id_get::TAO_ServerRequestInfo_CORBA_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_id_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_id_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_id_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_id_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_id_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_id_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_id_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl
    ,
    const char * id
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_Contained_id_set (const TAO_ServerRequestInfo_CORBA_Contained_id_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_id_set &);

private:
  POA_CORBA_Contained *_tao_impl;
  const char * id_;

};

TAO_ServerRequestInfo_CORBA_Contained_id_set::TAO_ServerRequestInfo_CORBA_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl,
    const char * id
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_id_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_id_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_id_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_id_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_id_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_Contained_name_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_name_get (const TAO_ServerRequestInfo_CORBA_Contained_name_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_name_get &);

private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_name_get::TAO_ServerRequestInfo_CORBA_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_name_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_name_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_name_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_name_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_name_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_name_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl
    ,
    const char * name
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_Contained_name_set (const TAO_ServerRequestInfo_CORBA_Contained_name_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_name_set &);

private:
  POA_CORBA_Contained *_tao_impl;
  const char * name_;

};

TAO_ServerRequestInfo_CORBA_Contained_name_set::TAO_ServerRequestInfo_CORBA_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl,
    const char * name
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_name_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_name_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_name_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_name_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_name_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_Contained_version_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_version_get (const TAO_ServerRequestInfo_CORBA_Contained_version_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_version_get &);

private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_version_get::TAO_ServerRequestInfo_CORBA_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_version_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_version_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_version_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_version_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_version_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_version_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_version_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl
    ,
    const char * version
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_Contained_version_set (const TAO_ServerRequestInfo_CORBA_Contained_version_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_version_set &);

private:
  POA_CORBA_Contained *_tao_impl;
  const char * version_;

};

TAO_ServerRequestInfo_CORBA_Contained_version_set::TAO_ServerRequestInfo_CORBA_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl,
    const char * version
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_version_set::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_version_set::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_version_set::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_version_set::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_version_set::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_CORBA_Contained_defined_in_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Container_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (const TAO_ServerRequestInfo_CORBA_Contained_defined_in_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_defined_in_get &);

private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Container_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::result (CORBA_Container_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (const TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get &);

private:
  POA_CORBA_Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Repository_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (const TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get &);

private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Repository_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::result (CORBA_Repository_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_describe : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Contained::Description * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_describe (const TAO_ServerRequestInfo_CORBA_Contained_describe &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_describe &);

private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Contained::Description * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_describe::TAO_ServerRequestInfo_CORBA_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_describe::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_describe::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_describe::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_describe::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_describe::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Contained_describe::result (CORBA_Contained::Description * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_move : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Contained *tao_impl
    ,
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));


private:
  TAO_ServerRequestInfo_CORBA_Contained_move (const TAO_ServerRequestInfo_CORBA_Contained_move &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_move &);

private:
  POA_CORBA_Contained *_tao_impl;
  CORBA_Container_ptr new_container_;
  const char * new_name_;
  const char * new_version_;

};

TAO_ServerRequestInfo_CORBA_Contained_move::TAO_ServerRequestInfo_CORBA_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Contained *tao_impl,
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    new_container_ (new_container),
    new_name_ (new_name),
    new_version_ (new_version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_move::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (3);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->new_container_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= new_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= new_version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_move::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Contained_move::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_move::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_move::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_Contained_Strategized_Proxy_Broker *_TAO_CORBA_Contained_Strategized_Proxy_Broker::the_TAO_CORBA_Contained_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_Contained_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_Contained_Strategized_Proxy_Broker::_TAO_CORBA_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_Contained_Strategized_Proxy_Broker::~_TAO_CORBA_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_Contained_Proxy_Impl&
_TAO_CORBA_Contained_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_Contained *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_Contained_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_Contained_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_Contained_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_Contained_Proxy_Broker *
_TAO_CORBA_Contained_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_Contained_Strategized_Proxy_Broker::the_TAO_CORBA_Contained_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_Contained_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_Contained_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_Contained_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_Contained_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_Contained_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_Contained_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_Contained_ThruPOA_Proxy_Impl::_TAO_CORBA_Contained_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->id (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->id (
        id
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->name (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->name (
        name
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->version (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->version (
        version
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

CORBA_Container_ptr _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "defined_in",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->defined_in (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

char * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "absolute_name",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->absolute_name (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_Repository_ptr _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::containing_repository (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "containing_repository",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->containing_repository (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

CORBA_Contained::Description * _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->describe (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

void _TAO_CORBA_Contained_ThruPOA_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "move",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->move (
        new_container,
        new_name,
        new_version
        TAO_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_Contained::POA_CORBA_Contained (void)
{
  this->optable_ = &tao_CORBA_Contained_optable;
}

// copy ctor
POA_CORBA_Contained::POA_CORBA_Contained (const POA_CORBA_Contained& rhs)
  :   POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_Contained::~POA_CORBA_Contained (void)
{
}

void POA_CORBA_Contained::_get_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_id_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->id (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_set_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_id_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->id (
          id.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_get_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_name_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->name (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_set_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_name_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      name.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->name (
          name.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_get_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_version_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->version (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_set_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_version_set ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      version.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->version (
          version.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_get_defined_in_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA_Container_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->defined_in (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Container_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_get_absolute_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->absolute_name (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_get_containing_repository_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA_Repository_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->containing_repository (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Repository_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::describe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

    CORBA_Contained::Description_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_describe ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->describe (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Contained::Description * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::move_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl =
    ACE_static_cast (POA_CORBA_Contained *, _tao_object_reference);

  _tao_server_request.argument_flag (0);
    CORBA_Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Contained_move ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      new_container.in (),
      new_name.in (),
      new_version.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->move (
          new_container.in (),
          new_name.in (),
          new_version.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Contained::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Contained::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Contained::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Contained *_tao_impl = (POA_CORBA_Contained *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_Contained::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_Contained::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_Contained::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

CORBA_Contained*
POA_CORBA_Contained::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_Contained::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:18:38 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 20,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 10,
     39,  0,  0,  0, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39,  0, 20,  5,
     39,  0, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 15,  5, 39, 39, 39, 10,  0, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 20, 39, 10, 39,  0,
      0,  0, 39, 39, 39, 39, 39, 39,  0, 20,
      5, 39,  0, 39, 39, 15,  5, 39, 39, 39,
     10,  0, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 22,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 2,
      WORDLIST_SIZE = 28
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_CORBA_Container::lookup_skel},
      {"destroy",       &POA_CORBA_Container::destroy_skel},
      {"lookup_name",   &POA_CORBA_Container::lookup_name_skel},
      {"create_value",  &POA_CORBA_Container::create_value_skel},
      {"create_module",         &POA_CORBA_Container::create_module_skel},
      {"create_native",         &POA_CORBA_Container::create_native_skel},
      {"create_interface",      &POA_CORBA_Container::create_interface_skel},
      {"create_union",  &POA_CORBA_Container::create_union_skel},
      {"create_struct",         &POA_CORBA_Container::create_struct_skel},
      {"create_constant",       &POA_CORBA_Container::create_constant_skel},
      {"create_exception",      &POA_CORBA_Container::create_exception_skel},
      {"create_local_interface",        &POA_CORBA_Container::create_local_interface_skel},
      {"contents",      &POA_CORBA_Container::contents_skel},
      {"create_abstract_interface",     &POA_CORBA_Container::create_abstract_interface_skel},
      {"create_value_box",      &POA_CORBA_Container::create_value_box_skel},
      {"create_alias",  &POA_CORBA_Container::create_alias_skel},
      {"_interface",  &POA_CORBA_Container::_interface_skel},
      {"create_enum",   &POA_CORBA_Container::create_enum_skel},
      {"describe_contents",     &POA_CORBA_Container::describe_contents_skel},
      {"_get_def_kind",         &POA_CORBA_Container::_get_def_kind_skel},
      {"_is_a",  &POA_CORBA_Container::_is_a_skel},
      {"_non_existent",  &POA_CORBA_Container::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -42,
       -1,  -1,  12,  13,  14,  -1,  15,  16,  17,  18,  -1,  19,  20,  21,
       -1,  -1,  22,  23,  24,  25,  -1,  26,  -1,  -1,  27,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:18:38 */
static TAO_CORBA_Container_Perfect_Hash_OpTable tao_CORBA_Container_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Container_lookup : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * search_name
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Contained_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_lookup (const TAO_ServerRequestInfo_CORBA_Container_lookup &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_lookup &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * search_name_;
  CORBA_Contained_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_lookup::TAO_ServerRequestInfo_CORBA_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * search_name
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    search_name_ (search_name)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_lookup::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (1);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= search_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_lookup::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_lookup::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_lookup::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_lookup::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_lookup::result (CORBA_Contained_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_contents : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ContainedSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_contents (const TAO_ServerRequestInfo_CORBA_Container_contents &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_contents &);

private:
  POA_CORBA_Container *_tao_impl;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA_ContainedSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_contents::TAO_ServerRequestInfo_CORBA_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_contents::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (2);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->limit_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_contents::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_contents::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_contents::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_contents::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_contents::result (CORBA_ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_lookup_name : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ContainedSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_lookup_name (const TAO_ServerRequestInfo_CORBA_Container_lookup_name &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_lookup_name &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * search_name_;
  const CORBA::Long & levels_to_search_;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA_ContainedSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_lookup_name::TAO_ServerRequestInfo_CORBA_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    search_name_ (search_name),
    levels_to_search_ (levels_to_search),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= search_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= levels_to_search_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->limit_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_lookup_name::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_lookup_name::result (CORBA_ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_describe_contents : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_Container::DescriptionSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_describe_contents (const TAO_ServerRequestInfo_CORBA_Container_describe_contents &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_describe_contents &);

private:
  POA_CORBA_Container *_tao_impl;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  const CORBA::Long & max_returned_objs_;
  CORBA_Container::DescriptionSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_describe_contents::TAO_ServerRequestInfo_CORBA_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited),
    max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (3);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<=  this->limit_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= max_returned_objs_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_describe_contents::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_describe_contents::result (CORBA_Container::DescriptionSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_module : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ModuleDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_module (const TAO_ServerRequestInfo_CORBA_Container_create_module &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_module &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ModuleDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_module::TAO_ServerRequestInfo_CORBA_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_module::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (3);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_module::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_module::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_module::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_module::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_module::result (CORBA_ModuleDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_constant : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA::Any & value
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ConstantDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_constant (const TAO_ServerRequestInfo_CORBA_Container_create_constant &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_constant &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr type_;
  const CORBA::Any & value_;
  CORBA_ConstantDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_constant::TAO_ServerRequestInfo_CORBA_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA::Any & value
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_constant::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_constant::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_constant::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_constant::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_constant::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_constant::result (CORBA_ConstantDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_struct : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_StructDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_struct (const TAO_ServerRequestInfo_CORBA_Container_create_struct &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_struct &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_StructMemberSeq & members_;
  CORBA_StructDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_struct::TAO_ServerRequestInfo_CORBA_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_struct::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_struct::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_struct::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_struct::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_struct::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_struct::result (CORBA_StructDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_union : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_UnionDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_union (const TAO_ServerRequestInfo_CORBA_Container_create_union &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_union &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr discriminator_type_;
  const CORBA_UnionMemberSeq & members_;
  CORBA_UnionDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_union::TAO_ServerRequestInfo_CORBA_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    discriminator_type_ (discriminator_type),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_union::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (5);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->discriminator_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_union::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_union::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_union::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_union::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_union::result (CORBA_UnionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_enum : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_EnumDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_enum (const TAO_ServerRequestInfo_CORBA_Container_create_enum &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_enum &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_EnumMemberSeq & members_;
  CORBA_EnumDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_enum::TAO_ServerRequestInfo_CORBA_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_enum::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_enum::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_enum::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_enum::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_enum::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_enum::result (CORBA_EnumDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_alias : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_AliasDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_alias (const TAO_ServerRequestInfo_CORBA_Container_create_alias &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_alias &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr original_type_;
  CORBA_AliasDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_alias::TAO_ServerRequestInfo_CORBA_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_ (original_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_alias::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->original_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_alias::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_alias::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_alias::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_alias::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_alias::result (CORBA_AliasDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_interface (const TAO_ServerRequestInfo_CORBA_Container_create_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_interface &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_InterfaceDefSeq & base_interfaces_;
  CORBA_InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_interface::TAO_ServerRequestInfo_CORBA_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_interface::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_interface::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_interface::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_interface::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_interface::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_interface::result (CORBA_InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_value : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA_ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    const CORBA_InitializerSeq & initializers
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_value (const TAO_ServerRequestInfo_CORBA_Container_create_value &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_value &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::Boolean & is_custom_;
  const CORBA::Boolean & is_abstract_;
  CORBA_ValueDef_ptr base_value_;
  const CORBA::Boolean & is_truncatable_;
  const CORBA_ValueDefSeq & abstract_base_values_;
  const CORBA_InterfaceDefSeq & supported_interfaces_;
  const CORBA_InitializerSeq & initializers_;
  CORBA_ValueDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_value::TAO_ServerRequestInfo_CORBA_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA_ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    const CORBA_InitializerSeq & initializers
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    is_custom_ (is_custom),
    is_abstract_ (is_abstract),
    base_value_ (base_value),
    is_truncatable_ (is_truncatable),
    abstract_base_values_ (abstract_base_values),
    supported_interfaces_ (supported_interfaces),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_value::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (10);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->abstract_base_values_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->initializers_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_value::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_value::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_value::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_value::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_value::result (CORBA_ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_value_box : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueBoxDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_value_box (const TAO_ServerRequestInfo_CORBA_Container_create_value_box &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_value_box &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_IDLType_ptr original_type_def_;
  CORBA_ValueBoxDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_value_box::TAO_ServerRequestInfo_CORBA_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->original_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_value_box::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_value_box::result (CORBA_ValueBoxDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_exception : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ExceptionDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_exception (const TAO_ServerRequestInfo_CORBA_Container_create_exception &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_exception &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_StructMemberSeq & members_;
  CORBA_ExceptionDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_exception::TAO_ServerRequestInfo_CORBA_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_exception::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->members_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_exception::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_exception::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_exception::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_exception::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_exception::result (CORBA_ExceptionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_native : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_NativeDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_native (const TAO_ServerRequestInfo_CORBA_Container_create_native &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_native &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_NativeDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_native::TAO_ServerRequestInfo_CORBA_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_native::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (3);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_native::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_native::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_native::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_native::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_native::result (CORBA_NativeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_AbstractInterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_AbstractInterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (const TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_AbstractInterfaceDefSeq & base_interfaces_;
  CORBA_AbstractInterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_AbstractInterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::result (CORBA_AbstractInterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_local_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_Container *tao_impl
    ,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_LocalInterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface (const TAO_ServerRequestInfo_CORBA_Container_create_local_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_local_interface &);

private:
  POA_CORBA_Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_InterfaceDefSeq & base_interfaces_;
  CORBA_LocalInterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_local_interface::TAO_ServerRequestInfo_CORBA_Container_create_local_interface (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  parameter_list->length (4);
  CORBA::ULong len = 0;

    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->base_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::result (CORBA_LocalInterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_Container_Strategized_Proxy_Broker *_TAO_CORBA_Container_Strategized_Proxy_Broker::the_TAO_CORBA_Container_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_Container_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_Container_Strategized_Proxy_Broker::_TAO_CORBA_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_Container_Strategized_Proxy_Broker::~_TAO_CORBA_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_Container_Proxy_Impl&
_TAO_CORBA_Container_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_Container *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_Container_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_Container_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_Container_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_Container_Proxy_Broker *
_TAO_CORBA_Container_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_Container_Strategized_Proxy_Broker::the_TAO_CORBA_Container_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_Container_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_Container_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_Container_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_Container_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_Container_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_Container_ThruPOA_Proxy_Impl::_TAO_CORBA_Container_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_Contained_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->lookup (
        search_name
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ContainedSeq * _TAO_CORBA_Container_ThruPOA_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contents",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->contents (
        limit_type,
        exclude_inherited
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ContainedSeq * _TAO_CORBA_Container_ThruPOA_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_name",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->lookup_name (
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_Container::DescriptionSeq * _TAO_CORBA_Container_ThruPOA_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_contents",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->describe_contents (
        limit_type,
        exclude_inherited,
        max_returned_objs
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ModuleDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_module (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_module",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_module (
        id,
        name,
        version
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ConstantDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_constant (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA::Any & value
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_constant",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_constant (
        id,
        name,
        version,
        type,
        value
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_StructDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_struct (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_struct",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_struct (
        id,
        name,
        version,
        members
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_UnionDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_union (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_union",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_union (
        id,
        name,
        version,
        discriminator_type,
        members
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_EnumDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_enum (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_enum",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_enum (
        id,
        name,
        version,
        members
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_AliasDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_alias (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_alias",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_alias (
        id,
        name,
        version,
        original_type
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_InterfaceDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_interface",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_interface (
        id,
        name,
        version,
        base_interfaces
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ValueDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_value (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    const CORBA_InitializerSeq & initializers
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_value (
        id,
        name,
        version,
        is_custom,
        is_abstract,
        base_value,
        is_truncatable,
        abstract_base_values,
        supported_interfaces,
        initializers
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ValueBoxDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_value_box (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_box",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_value_box (
        id,
        name,
        version,
        original_type_def
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_ExceptionDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_exception (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_exception",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_exception (
        id,
        name,
        version,
        members
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_NativeDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_native (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_NativeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_native",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_native (
        id,
        name,
        version
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_AbstractInterfaceDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_abstract_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_AbstractInterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_AbstractInterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_abstract_interface",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_abstract_interface (
        id,
        name,
        version,
        base_interfaces
        TAO_ENV_ARG_PARAMETER
      );
}

CORBA_LocalInterfaceDef_ptr _TAO_CORBA_Container_ThruPOA_Proxy_Impl::create_local_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_LocalInterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_local_interface",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_local_interface (
        id,
        name,
        version,
        base_interfaces
        TAO_ENV_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_Container::POA_CORBA_Container (void)
{
  this->optable_ = &tao_CORBA_Container_optable;
}

// copy ctor
POA_CORBA_Container::POA_CORBA_Container (const POA_CORBA_Container& rhs)
  :   POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_Container::~POA_CORBA_Container (void)
{
}

void POA_CORBA_Container::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_lookup ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      search_name.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->lookup (
          search_name.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Contained_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ContainedSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_contents ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      limit_type,
      exclude_inherited
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->contents (
          limit_type,
          exclude_inherited
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::lookup_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_lookup_name ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      search_name.in (),
      levels_to_search,
      limit_type,
      exclude_inherited
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->lookup_name (
          search_name.in (),
          levels_to_search,
          limit_type,
          exclude_inherited
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::describe_contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_Container::DescriptionSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_describe_contents ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      limit_type,
      exclude_inherited,
      max_returned_objs
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->describe_contents (
          limit_type,
          exclude_inherited,
          max_returned_objs
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_Container::DescriptionSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_module_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_module ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_module (
          id.in (),
          name.in (),
          version.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ModuleDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_constant_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_constant ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      value
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_constant (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          value
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ConstantDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_struct_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_struct ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_struct (
          id.in (),
          name.in (),
          version.in (),
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_StructDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_union_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var discriminator_type;
  CORBA_UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_union ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      discriminator_type.in (),
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_union (
          id.in (),
          name.in (),
          version.in (),
          discriminator_type.in (),
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_UnionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_enum_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_enum ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_enum (
          id.in (),
          name.in (),
          version.in (),
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_EnumDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_alias_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_alias ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_alias (
          id.in (),
          name.in (),
          version.in (),
          original_type.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_AliasDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_interface ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  CORBA_ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  CORBA_ValueDefSeq abstract_base_values;
  CORBA_InterfaceDefSeq supported_interfaces;
  CORBA_InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interfaces) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_value ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      is_custom,
      is_abstract,
      base_value.in (),
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_value (
          id.in (),
          name.in (),
          version.in (),
          is_custom,
          is_abstract,
          base_value.in (),
          is_truncatable,
          abstract_base_values,
          supported_interfaces,
          initializers
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_value_box_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_value_box ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type_def.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_value_box (
          id.in (),
          name.in (),
          version.in (),
          original_type_def.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueBoxDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_exception_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_exception ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_exception (
          id.in (),
          name.in (),
          version.in (),
          members
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ExceptionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_native_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_NativeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_native ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in ()
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_native (
          id.in (),
          name.in (),
          version.in ()
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_NativeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_abstract_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_AbstractInterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_AbstractInterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_abstract_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_AbstractInterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::create_local_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl =
    ACE_static_cast (POA_CORBA_Container *, _tao_object_reference);

    CORBA_LocalInterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_Container_create_local_interface ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_local_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces
          TAO_ENV_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_LocalInterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_Container::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_Container *_tao_impl = (POA_CORBA_Container *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_Container::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_Container::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_Container::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

CORBA_Container*
POA_CORBA_Container::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_Container::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:18:41 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_IDLType::_is_a_skel},
      {"",0},
      {"destroy",       &POA_CORBA_IDLType::destroy_skel},
      {"",0},
      {"_get_type",     &POA_CORBA_IDLType::_get_type_skel},
      {"_interface",  &POA_CORBA_IDLType::_interface_skel},
      {"",0},{"",0},
      {"_get_def_kind",         &POA_CORBA_IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA_IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:18:41 */
static TAO_CORBA_IDLType_Perfect_Hash_OpTable tao_CORBA_IDLType_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_IDLType_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_CORBA_IDLType *tao_impl

    TAO_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual Dynamic::ParameterList * arguments (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual Dynamic::ExceptionList * exceptions (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Any * result (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual char * target_most_derived_interface (
      TAO_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  virtual CORBA::Boolean target_is_a (
      const char * id
      TAO_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_IDLType_type_get (const TAO_ServerRequestInfo_CORBA_IDLType_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IDLType_type_get &);

private:
  POA_CORBA_IDLType *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_IDLType_type_get::TAO_ServerRequestInfo_CORBA_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_CORBA_IDLType *tao_impl
    TAO_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::arguments (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::exceptions (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::result (TAO_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::target_most_derived_interface (
    TAO_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IDLType_type_get::target_is_a (
    const char * id
    TAO_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id TAO_ENV_ARG_PARAMETER);
}

void
TAO_ServerRequestInfo_CORBA_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_IDLType_Strategized_Proxy_Broker *_TAO_CORBA_IDLType_Strategized_Proxy_Broker::the_TAO_CORBA_IDLType_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_IDLType_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_IDLType_Strategized_Proxy_Broker::_TAO_CORBA_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_IDLType_Strategized_Proxy_Broker::~_TAO_CORBA_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_IDLType_Proxy_Impl&
_TAO_CORBA_IDLType_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_IDLType *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_IDLType_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_IDLType_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_IDLType_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_IDLType_Proxy_Broker *
_TAO_CORBA_IDLType_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_IDLType_Strategized_Proxy_Broker::the_TAO_CORBA_IDLType_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_IDLType_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_IDLType_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_IDLType_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_IDLType_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_IDLType_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_IDLType_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_IDLType_ThruPOA_Proxy_Impl::_TAO_CORBA_IDLType_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_CORBA_IDLType_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    TAO_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out ()
      TAO_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA_IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IDLType:1.0"
        )
    )->type (
        TAO_ENV_SINGLE_ARG_PARAMETER
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_IDLType::POA_CORBA_IDLType (void)
{
  this->optable_ = &tao_CORBA_IDLType_optable;
}

// copy ctor
POA_CORBA_IDLType::POA_CORBA_IDLType (const POA_CORBA_IDLType& rhs)
  :   POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_IDLType::~POA_CORBA_IDLType (void)
{
}

void POA_CORBA_IDLType::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IDLType *_tao_impl =
    ACE_static_cast (POA_CORBA_IDLType *, _tao_object_reference);

    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);

  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  TAO_ServerRequestInfo_CORBA_IDLType_type_get ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl
      TAO_ENV_ARG_PARAMETER
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          TAO_ENV_SINGLE_ARG_PARAMETER
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri TAO_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri
          TAO_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;

      PortableInterceptor::ReplyStatus _tao_status =
        ri.reply_status (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
}

void POA_CORBA_IDLType::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IDLType::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IDLType::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_IDLType *_tao_impl = (POA_CORBA_IDLType *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_IDLType::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_IDLType::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_IDLType::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

CORBA_IDLType*
POA_CORBA_IDLType::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_IDLType::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:18:42 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_CORBA_TypedefDef::move_skel},
      {"_is_a",  &POA_CORBA_TypedefDef::_is_a_skel},
      {"_get_id",       &POA_CORBA_TypedefDef::_get_id_skel},
      {"_set_id",       &POA_CORBA_TypedefDef::_set_id_skel},
      {"describe",      &POA_CORBA_TypedefDef::describe_skel},
      {"_get_name",     &POA_CORBA_TypedefDef::_get_name_skel},
      {"_get_type",     &POA_CORBA_TypedefDef::_get_type_skel},
      {"_set_name",     &POA_CORBA_TypedefDef::_set_name_skel},
      {"_interface",  &POA_CORBA_TypedefDef::_interface_skel},
      {"_get_version",  &POA_CORBA_TypedefDef::_get_version_skel},
      {"_set_version",  &POA_CORBA_TypedefDef::_set_version_skel},
      {"_get_def_kind",         &POA_CORBA_TypedefDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_CORBA_TypedefDef::_get_defined_in_skel},
      {"destroy",       &POA_CORBA_TypedefDef::destroy_skel},
      {"_get_absolute_name",    &POA_CORBA_TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA_TypedefDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_CORBA_TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  48,   8, -45,  12,  -1, -46,  15,
       -1,  16,  -1,  17,  18,  -6,  -2,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:18:42 */
static TAO_CORBA_TypedefDef_Perfect_Hash_OpTable tao_CORBA_TypedefDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker *_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::the_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker (void)
{
  static _TAO_CORBA_TypedefDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::~_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_CORBA_TypedefDef_Proxy_Impl&
_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA_TypedefDef *object
    TAO_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy TAO_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::create_proxy (
    int strategy
    TAO_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_CORBA_TypedefDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_CORBA_TypedefDef_Proxy_Broker *
_TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker::the_TAO_CORBA_TypedefDef_Strategized_Proxy_Broker();
}

int
_TAO_CORBA_TypedefDef_Proxy_Broker_Factory_Initializer (long)
{
  _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function_pointer =
    _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_CORBA_TypedefDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_CORBA_TypedefDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl::_TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_TypedefDef::POA_CORBA_TypedefDef (void)
{
  this->optable_ = &tao_CORBA_TypedefDef_optable;
}

// copy ctor
POA_CORBA_TypedefDef::POA_CORBA_TypedefDef (const POA_CORBA_TypedefDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_TypedefDef::~POA_CORBA_TypedefDef (void)
{
}

void POA_CORBA_TypedefDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_TypedefDef *_tao_impl = (POA_CORBA_TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in () TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_TypedefDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_TypedefDef *_tao_impl = (POA_CORBA_TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_TypedefDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    TAO_ENV_ARG_DECL
  )
{
  POA_CORBA_TypedefDef *_tao_impl = (POA_CORBA_TypedefDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;

  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }

  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (TAO_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;

      _tao_server_request.init_reply ();

      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;

  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_CORBA_TypedefDef::_is_a (
    const char* value
    TAO_ENV_ARG_DECL
  )
{
  const char *base_id = CORBA::_tc_Object->id (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA_TypedefDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_TypedefDef::_dispatch (TAO_ServerRequest &req, void *servant_upcall TAO_ENV_ARG_DECL)
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     TAO_ENV_ARG_PARAMETER);
}


const char* POA_CORBA_TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

CORBA_TypedefDef*
POA_CORBA_TypedefDef::_this (TAO_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (TAO_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);

  TAO_Stub_Auto_Ptr safe_stub (stub);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;

  (void) safe_stub.release ();

  return ::CORBA_TypedefDef::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
